
## 《Qcon2019/基于 C++ 构建微信客户端跨平台开发框架》学习

## 微信支付的跨平台架构详解 学习

### 建立 C++ 与原生系统框架进行互相通讯的机制

#### 上下层对象转换机制
隐藏语言通讯的细节。让开发者只和当前语言打交道，**核心：对象转换流程**

对象转换流程的关键：
- 维护对象的唯一性
- 维护对象的继承关系

#### 代码生成器
设计 IDL(Interface Definition Language 接口描述语言)
- 定义一个对象
- 区分对象的类型 
- 支持在对象里定义方法
- 支持基本的数据类型
- 支持描述继承关系


### 建立 C++  控制 iOS 和 安卓 UI 布局渲染的机制
- 布局语法：Flexbox
- 布局引擎：Yoga
- 渲染机制：系统能力

#### yoga简介
yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局系统，它实现了Flexbox规范（https://facebook.github.io/yoga/docs/flex-direction/）

yoga有如下特性：
- 完全兼容Flexbox布局，遵守W3C的规范。
- 支持Java、C#、Objective-C、C四种语言。
- 底层代码使用C语言编写，性能不是问题，并且可以更容易跟其他平台集成。
- 支持流行框架如React Native。




### 基于 C++ 编写业务框架，搭建工具链


### 问题1
ViewController 自己负责和不同的 ViewController 通讯。那么 ViewController 得不到复用，更致命的是业务流程的代码非常不清晰，业务流程的代码都被分散到各个 Controller 中， 而一个 Controller 又可能耦合了多个业务的代码。

解决：架构抽象的第一步就是将业务流程抽象为一个独立的角色 UseCase。同时, 把界面抽象为 UIPage。 一个大的业务流程可以分解为一个个小的业务流程。

和刚才基于 MVC 混乱的架构相比：
- 业务流程的代码能够聚合到 UseCase 中，而不是分散到原来 iOS, 安卓的各个 ViewController，Activity 中。
- 业务流程和界面得到了复用。
- 契合微信支付多流程，界面跳转复杂的业务特点。

### 问题2
比如我们要给一个朋友转账，输入金额，确认支付，触发 Cgi 后。下一个流程是多变的。有可能用户需要去实名，有可能用户要进入一个安全拦截的 WebView，或者是正常拉起收银台。
`本文中的名词 CGI 可以理解为一个网络请求，类似HTTP请求。`
那么以往在 iOS, 安卓分开实现时，都没有一个统一的处理机制。要么就是通过网络回包的某个字段来判断，要么就是本地维护一些状态来决定下一步走什么流程等等，非常繁琐，易错。

### 问题3
支付业务流程还有个特殊的地方，那就是在正常流程的中间，往往很多时候要需要插入一些特殊流程。比如有些地方要跳转 Webview, 有些地方要跳转小程序，有些地方要弹窗告知用户风险，或者终止当前流程，等等。我们经常需要在业务代码里面不断重复增加这样的处理。

解决：
微信支付需要一个路由机制。路由机制的核心思想，就是通过向路由传递数据，然后路由解析数据，并响应。
结合微信支付和网络密切相关的特点。创新地将支付领域模型作为传递的数据。

> 那么怎么建立这个支付领域模型的呢？建模，就是建立映射。领域知识 + 建模方法 = 领域建模。那么这里的领域知识，就是对支付业务流程的理解。建模方法，我采用了 UML 建模。最终会落地为 Proto 协议供客户端和后台一起使用。

首先，微信支付业务特点就是和网络密切相关，流程和页面往往是由 Cgi 串联起来。因此建立模型时，最外层便是网络回包。对于路由机制，这里我们只关心路由数据模型。

路由数据模型由 路由类型，还有各个路由类型所需要的信息组合成。

路由类型清晰的定义了要触发的行为。究竟是要开启一个 UseCase，还是要打开一个界面，或者 网页，小程序，弹窗等等。

然后就是这些行为所需要的数据。比如打开小程序所需要的参数，弹窗所需要的参数等。

### 问题4
CGI 一对多通讯问题。

解决：
将 Cgi 抽象为独立对象

在架构设计上来说，旧架构是通过单例模式实现的集约型 API，而我们新的架构则是通过命令模式实现的离散型 API。

关于 Cgi 由谁发起，之前安卓和 iOS 都没有一个统一的做法。有些人会放到 Activity，ViewController，和 UI 代码耦合起来。

因此，在跨平台软件架构中，我们统一由业务流程 UseCase 进行发起。并且生命周期是一对一的，一个 Cgi 只会有一个 UseCase 处理， UseCase 销毁后，Cgi 也随之销毁。
对比旧架构：
- 杜绝了一对多通信造成的 Bug
- 生命周期和业务逻辑绑定，不会出现业务结束，Cgi 回来后再触发动作。
- 高内聚，低耦合。将 Cgi 相关的数据，能力集中处理，业务侧无需感知。
- 提供统一的缓存，加密能力。



RecyclerView item的根布局在Recyclerview布局方向上的宽或高必须是match_parent或固定尺寸，否则在一些设备设备上（4.4.0）alignParentRight属性失效
### 资料

下载地址：
https://github.com/100mango/zen/blob/master/Qcon2019/%E5%9F%BA%E4%BA%8E%20C%2B%2B%20%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6.key