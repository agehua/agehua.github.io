{"meta":{"title":"Agehua","subtitle":null,"description":"","author":"Jixin Li","url":"http://agehua.github.io"},"pages":[{"title":"人不逍遥，名逍遥","date":"2017-03-13T07:25:42.000Z","updated":"2017-03-13T07:25:42.000Z","comments":true,"path":"about/index.html","permalink":"http://agehua.github.io/about/index.html","excerpt":"","text":"本文链接：http://agehua.github.io/about/index.html","raw":null,"content":null},{"title":"Categories","date":"2016-12-26T10:41:15.000Z","updated":"2016-12-26T10:41:15.000Z","comments":true,"path":"categories/index.html","permalink":"http://agehua.github.io/categories/index.html","excerpt":"","text":"本文链接：http://agehua.github.io/categories/index.html","raw":null,"content":null},{"title":"Tags","date":"2017-07-18T07:35:27.000Z","updated":"2017-07-18T07:35:27.000Z","comments":true,"path":"tags/index.html","permalink":"http://agehua.github.io/tags/index.html","excerpt":"","text":"本文链接：http://agehua.github.io/tags/index.html","raw":null,"content":null}],"posts":[{"title":"PBOC知识收集（干货）","slug":"PBOCKonwledgeCode","date":"2017-09-20T16:00:00.000Z","updated":"2017-11-23T06:47:56.000Z","comments":true,"path":"2017/09/21/PBOCKonwledgeCode/","link":"","permalink":"http://agehua.github.io/2017/09/21/PBOCKonwledgeCode/","excerpt":"PBOC规范基础知识（干货）摘自：《中国集成电路（IC）卡规范第2部分：电子钱包电子存折应用规范》\n消费交易消费交易允许持卡人使用电子存折或电子钱包的余额进行购物或获取服务。此交易可以在销售点终端(POS)上脱机进行。使用电子存折进行的消费交易必须提交个人识别码(PIN)，使用电子钱包则不需要。\n发出初始化消费(INITIALIZE FOR PURCHASE)命令指令字节：      命令                         CLA  INS   P1   P2消费初始化(INITIALIZE FOR PURCHASE) ‘80’ ‘50’ ‘01’ ‘0X’\n\n上面的指令字节，其实就是APDU（Application Protocol data unit), 是智能卡与智能卡读卡器之间传送的信息单元\n","text":"PBOC规范基础知识（干货）摘自：《中国集成电路（IC）卡规范第2部分：电子钱包电子存折应用规范》 消费交易消费交易允许持卡人使用电子存折或电子钱包的余额进行购物或获取服务。此交易可以在销售点终端(POS)上脱机进行。使用电子存折进行的消费交易必须提交个人识别码(PIN)，使用电子钱包则不需要。 发出初始化消费(INITIALIZE FOR PURCHASE)命令指令字节： 命令 CLA INS P1 P2消费初始化(INITIALIZE FOR PURCHASE) ‘80’ ‘50’ ‘01’ ‘0X’ 上面的指令字节，其实就是APDU（Application Protocol data unit), 是智能卡与智能卡读卡器之间传送的信息单元 APDU的格式为：CLA INS P1 P2 Lc Data Le其中CLA为指令类别；INS为指令码；P1、P2为参数；Lc为Data的长度；Le为希望响应时回答的数据字节数，0表最大可能长度。 COS命令由具体应用分为4种命令报文结构如下：① 情形1：CLA INS P1 P2 00② 情形2：CLA INS P1 P2 Le③ 情形3：CLA INS P1 P2 Lc Data④ 情形4：CLA INS P1 P2 Lc Data Le 而消费交易初始化的具体命令如下： 响应报文结构：响应数据 响应状态码Data SW1 SW1 DATA： 返回给用户的数据，即命令的执行结果。SW1、SW2： 返回命令处理的状态。 如果命令执行不成功，则只在响应报文中回送SW1和SW2。命令执行成功的状态字一般是“9000”，但个别卡商在执行成功后，返回61 xx，这里表示还有xx字节需要返回，需要再使用卡商提供的GET REPONSE命令接收从IC卡中传递向读卡设备的数据。 消费交易初始化执行成功，返回的响应报文，总长度是（Le 0F）15个字节： 一个字节是8bit，4个bit用一个16进制表示（0-9 A-F）。所以一个字节可以由两个16进制表示 VERIFY 命令定义和范围VERIFY命令用于校验命令数据域中的个人识别码的正确性。如PIN文件位于某一应用下，当此应用被锁定时，禁止校验PIN;如PIN文件位于MF下，当应用被锁 定后可以执行校验PIN命令。 命令报文 代码 值 CLA ‘00’ INS ‘20’ P1 ‘00’ P2 ‘00’ Lc 可变 Data 外部输入的个人识别码 Le 不存在 P2=’00’表示无特殊限定符被使用。在IC卡上，VERIFY命令在处理过程中应明确知道如何去寻找个人识别码。 这里外部输入的PIN码长度是，4到12位（2-6字节），响应报文数据域不存在。 此命令执行成功的状态字是“9000”。当前的应用选择中，命令数据域中外部输入的个人识别码与卡中存放的个人识别码校验失败时，IC 卡将回送SW2=’Cx’，其中’x’表示个人识别码允许重试的次数;当卡回送’C0’时，表示不能重试个人识别 码。此时再使用VERIFY命令时，将回送失败状态字SW1 SW2=“6983”。 IC卡可能回送的警告状态字见表48。 下面贴一些转换工具代码：/** * 把16进制字符串转换成字节数组 * * @param hex * @return */public static byte[] hexStringToByte(String hex) &#123; int len = (hex.length() / 2); byte[] result = new byte[len]; char[] achar = hex.toCharArray(); for (int i = 0; i &lt; len; i++) &#123; int pos = i * 2; result[i] = (byte) (toByte(achar[pos]) &lt;&lt; 4 | toByte(achar[pos + 1])); &#125; return result;&#125;private static byte toByte(char c) &#123; byte b = (byte) \"0123456789ABCDEF\".indexOf(c); return b;&#125;/** * 把字节数组转换成16进制字符串 * * @param bArray * @return */public static final String bytesToHexString(byte[] bArray) &#123; if(bArray == null ) &#123; return \"\"; &#125; StringBuffer sb = new StringBuffer(bArray.length); String sTemp; for (int i = 0; i &lt; bArray.length; i++) &#123; sTemp = Integer.toHexString(0xFF &amp; bArray[i]); if (sTemp.length() &lt; 2) sb.append(0); sb.append(sTemp.toUpperCase()); &#125; return sb.toString();&#125; IC卡交易金额转换（以分为单位，输出byte[]）public static String IntToHex(int n)&#123; char[] ch = new char[20]; int nIndex = 0; while ( true )&#123; int m = n/16; int k = n%16; if ( k == 15 ) ch[nIndex] = 'F'; else if ( k == 14 ) ch[nIndex] = 'E'; else if ( k == 13 ) ch[nIndex] = 'D'; else if ( k == 12 ) ch[nIndex] = 'C'; else if ( k == 11 ) ch[nIndex] = 'B'; else if ( k == 10 ) ch[nIndex] = 'A'; else ch[nIndex] = (char)('0' + k); nIndex++; if ( m == 0 ) break; n = m; &#125; StringBuffer sb = new StringBuffer(); sb.append(ch, 0, nIndex); sb.reverse(); String strHex = new String(\"\"); strHex += sb.toString(); return strHex;&#125;public static byte[] hexStringToByteArray(String s) &#123; if (TextUtils.isEmpty(s)) return null; int len = s.length(); String append= \"\"; switch (len)&#123; case 1: s = \"0000000\"+s; break; case 2: s = \"000000\"+s; break; case 3: s = \"00000\"+s; break; case 4: s = \"0000\"+s; break; case 5: s = \"000\"+s; break; case 6: s = \"00\"+s; break; case 7: s = \"0\"+s; break; case 8: break; &#125; len = s.length(); byte[] b = new byte[len / 2]; for (int i = 0; i &lt; len; i += 2) &#123; // 两位一组，表示一个字节,把这样表示的16进制字符串，还原成一个字节 b[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character .digit(s.charAt(i + 1), 16)); &#125; return b;&#125;/** * 交易金额转换 */public static byte[] intTo4HexByte(int num)&#123; return hexStringToByteArray(IntToHex(num));&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/09/21/PBOCKonwledgeCode/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"PBOC","slug":"pboc","permalink":"http://agehua.github.io/tags/pboc/"},{"name":"PBOC 2.0","slug":"pboc-2-0","permalink":"http://agehua.github.io/tags/pboc-2-0/"}]},{"title":"PBOC知识收集","slug":"PBOCKonwledge","date":"2017-09-11T16:00:00.000Z","updated":"2017-11-23T06:49:46.000Z","comments":true,"path":"2017/09/12/PBOCKonwledge/","link":"","permalink":"http://agehua.github.io/2017/09/12/PBOCKonwledge/","excerpt":"PBOC规范基础知识术语和定义\n集成电路 integrated circuit (IC) 具有处理和/或存储功能的电子器件。\n集成电路卡(IC 卡) integrated circuit(s) card (ICC) 内部封装一个或多个集成电路用于执行处理和存储功能的卡片。\n电子存折 electronic deposit 一种为持卡人进行消费、取现等交易而设计的支持个人识别码(PIN)保护的金融IC卡应用。它支持圈存、圈提、消费和取现等交易。\n电子钱包 electronic purse 一种为方便持卡人小额消费而设计的金融IC卡应用。它支持圈存、消费等交易。消费不支持个人识别码(PIN)保护。\n圈存 load持卡人将其在银行相应账户上的资金划转到电子存折或电子钱包中。圈存交易必须在金融终端上联机进行。一般情况下，圈存到电子存折中的资金仍计付活期利息，圈存到电子钱包中的资金不计付利息。但 具体作法由发卡方自行决定。\n圈提 unload持卡人将电子存折中的部分或全部资金划回到其在银行的相应账户上。圈提交易必须在金融终端上 联机进行2。","text":"PBOC规范基础知识术语和定义 集成电路 integrated circuit (IC) 具有处理和/或存储功能的电子器件。 集成电路卡(IC 卡) integrated circuit(s) card (ICC) 内部封装一个或多个集成电路用于执行处理和存储功能的卡片。 电子存折 electronic deposit 一种为持卡人进行消费、取现等交易而设计的支持个人识别码(PIN)保护的金融IC卡应用。它支持圈存、圈提、消费和取现等交易。 电子钱包 electronic purse 一种为方便持卡人小额消费而设计的金融IC卡应用。它支持圈存、消费等交易。消费不支持个人识别码(PIN)保护。 圈存 load持卡人将其在银行相应账户上的资金划转到电子存折或电子钱包中。圈存交易必须在金融终端上联机进行。一般情况下，圈存到电子存折中的资金仍计付活期利息，圈存到电子钱包中的资金不计付利息。但 具体作法由发卡方自行决定。 圈提 unload持卡人将电子存折中的部分或全部资金划回到其在银行的相应账户上。圈提交易必须在金融终端上 联机进行2。 符号和缩略语下列符号和缩略语适用于 JR/T 0025 的本部分。 AID 应用标识符(Application Identifier) an 字母数字型(Alphanumeric) ans 字母数字及特殊字符型(Alphanumeric Special) ATI 应用类型标识(Application Type Identifier)，卡上有两种应用时，用来区分是电子存折和电子钱包 b 二进制(Binary) CLA 命令报文的类别字节(Class Byte of the Command Message) cn 压缩数字型(Compressed Numeric) DEA 数据加密算法(Data Encryption Algorithm) DF 专用文件(Dedicated File) ED 电子存折(Electronic Deposit) EF 基本文件(Elementary File) EP 电子钱包(Electronic Purse) FCI 文件控制信息(File Control Information) INS 命令报文的指令字节(Instruction Byte of Command Message) ISO 国际标准化组织(International Organization for Standardization) Lc 终端发出的命令数据的实际长度(Exact Length of Data Sent) Le 响应数据中的最大期望长度(Maximum Length of Data Expected) MAC 报文鉴别码(Message Authentication Code) MF 主文件(Master File) n 数字型(Numeric) P1 参数 1(Parameter 1) P2 参数 2(Parameter 2) PIN 个人识别码(Personal Identification Number) POS 销售点终端(Point of Service) PSAM 销售点终端安全存取模块(Purchase Secure Access Module) PSE 支付系统环境(Payment System Environment) PVN PIN 校验值(PIN Verification Number) SFI 短文件标识符(Short File Identifier) SW1 状态字 1(Status Word One) SW2 状态字 2(Status Word Two) TAC 交易验证码(Transaction Authorization Crypogram) TTI 交易类型标识(Transaction Type Identifier) YYYYMMDD 年、月、日(Year, Month, Day) 智能卡又称为IC卡(Integrated circuit Card),即集成电路卡。根据卡中使用的集成电路的不同可以分为存储器卡、逻辑加密卡和CPU卡。由于CPU卡中集成了中央处理器CPU、存储器和芯片操作系统(Chip Operating System, COS) ,构成一个完整的计算机系统, 具有独立的数据处理能力, 因此安全性大大增强,从而得到了广泛的应用,成为IC卡中的主流产品。 文件操作2.1 基本文件结构文件系统是COS的基础模块,它负责组织、管理、维护IC卡内存储的所有数据。根据ISO7816-4,COS 支持的文件类型为: 主文件(Master File, MF) 、目录文件(Dedicated File, DF)和基本文件(Elementary File,EF) 。主文件MF为文件系统的根，下面可以有多个目录文件DF和基本文件EF。目录文件DF分为DDF和ADF两种。DDF可以含有下级目录ADF, 而ADF不能含有下级目录文件。 主文件MF在IC卡中唯一且必须存在。DDF是指包含多个应用的DF, 一个ADF则代表一个应用, 任何一个DF在物理上和逻辑上都保持独立。基本文件EF用于存放密钥或用户数据, 分为密钥文件和工作基本文件。 三种专用文件(DF)类型:MF: 根目录，是整个文件系统的根，同属应用环境类。MF 下可以有 EF(基本文件)、SF (安全文件)、DDF(目录文件)、ADF(应用文件);DDF: 目录文件，用于定义一个应用环境，它是应用的集合。DDF下可以有ADF、子DDF、 EF和SF等结构。ADF: 应用文件，用于定义具体应用。ADF下可以有EF和SF。 2.2 文件的访问控制文件的访问控制可采取鉴别寄存器方式和状态机方式,这里以鉴别寄存器方式为例。用两个四位寄存器来表示安全状态: 一个寄存器称为MF的安全状态寄存器,另一个寄存器为当前DF的安全状态寄存器。每个寄存器的初始值是0,取值安全状态员安全状态圆执行命令符合命令要求的安全属性钥命令拒绝安全机制再晕图员智能卡安全体系范围是0～F之间的某一个值。文件有两种不同的访问控制权限AC0,AC1。AC0 是使用权限,AC1 是修改权限,分别用一个字节表示。当前安全状态寄存器的值大于AC字节的低半字节小于其高半字节时, 该文件的相应读、写权限在该安全状态下被满足,则能进行相关操作。COS在建立文件时指定其AC0和AC1的值来对文件的访问权限进行设定,通过口令校验和外部认证两条命令可以改变安全状态寄存器的值,从而利用安全机制实现对文件的访问控制。 命令的类别字节和指令字节 命令 CLA INS P1 P2 修改个人识别码(CHANGE PIN) ‘80’ ‘5E’ ‘01’ ‘00’ 圈存(CREDIT FOR LOAD) ‘80’ ‘52’ ‘00’ ‘00’ 消费/取现(DEBIT FOR PURCHASE/CASH WITHDRAW) ‘80’ ‘54’ ‘01’ ‘00’ 圈提(DEBIT FOR UNLOAD) ‘80’ ‘54’ ‘03’ ‘00’ 读余额(GET BALANCE) ‘80’ ‘5C’ ‘00’ ‘0X’ 取交易认证(GET TRANSACTION PROVE) ‘80’ ‘5A’ ‘00’ ‘XX’ 取现初始化(INITIALIZE FOR CASH WITHDRAW) ‘80’ ‘50’ ‘02’ ‘01’ 圈存初始化(INITIALIZE FOR LOAD) ‘80 ‘50’ ‘00’ ‘0X’ 消费初始化(INITIALIZE FOR PURCHASE) ‘80’ ‘50’ ‘01’ ‘0X’ 圈提初始化(INITIALIZE FOR UNLOAD) ‘80’ ‘50’ ‘05’ ‘01’ 修改初始化(INITIALIZE FOR UPDATE) ‘80’ ‘50’ ‘04’ ‘01’ 重装个人识别码(RELOAD PIN) ‘80’ ‘5E’ ‘00’ ‘00’ 修改透支限额(UPDATE OVERDRAW LIMIT) ‘80’ ‘58’ ‘00’ ‘00’ IC卡、M1卡、CPU卡、SAM卡、PSAM卡的联系与区别 一、 技术方面（非接触式IC卡） 1、 逻辑加密卡又叫存储卡，卡内的集成电路具有加密逻辑和EEPROM（电可擦除可编程只读存储器）。 2、 CPU卡又叫智能卡，卡内的集成电路包括中央处理器（CPU）、EEPROM、随机存储器(ROM)、以及固化在只读存储器（ROM）中的片内操作系统(COS)，有的卡内芯片还集成了加密运算协处理器以提高安全性和工作速度，使其技术指标远远高于逻辑加密卡。 3、 CPU卡由于具有微处理功能，使得在交易速度以及数据干扰方面远远高于逻辑加密卡，且允许多张卡片同时操作，具有防冲突机制。 4、 两者在技术方面的最大区别在于：CPU卡是一种具有微处理芯片的IC卡，可执行加密运算和其它操作，存储容量较大，能应用于不同的系统；逻辑加密卡是一种单一的存储卡，主要特点是内部有只读存储器，但存储容量较CPU卡小，使其在用途方面没有扩展性。 二、 保密方面（非接触式IC卡） 1、 逻辑加密卡具有防止对卡中信息随意改写功能的存储IC卡，当对加密卡进行操作时必须首先核对卡中密码，只有核对正确，卡中送出一串正确的应答信号时，才能对卡进行正确的操作，但由于只进行一次认证，且无其它的安全保护措施，容易导致密码的泄露和伪卡的产生，其安全性能很低。 2、 由于CPU卡中有微处理机和IC卡操作系统（COS），当CPU卡进行操作时，可进行加密和解密算法（算法和密码都不易破解），用户和IC卡系统之间需要进行多次的相互密码认证（且速度极快），提高了系统的安全性能，对于防止伪卡的产生有很好的效果。 综上所述，对于逻辑加密卡和CPU卡来说，CPU卡不仅具有逻辑加密卡的所有功能，更具有逻辑加密卡所不具备的高安全性、灵活性以及支持与应用扩展等优良性能，也是今后IC卡发展的主要趋势和方向。 CPU卡安全系统与逻辑加密系统的比较 众所周知，密钥管理系统（Key Management System），也简称KMS，是IC项目安全的核心。如何进行密钥的安全管理，贯穿着IC卡应用的整个生命周期。 1、 非接触逻辑加密卡的安全认证，依赖于每个扇区独立的KEYA和KEYB的校验，可以通过扇区控制字对KEYA和KEYB的不同安全组合，实现扇区数据的读写安全控制。非接触逻辑加密卡的个人化也比较简单，主要包括数据和各扇区KEYA、KEYB的更新，在期间所有敏感数据包括KEYA和KEYB都是直接以明文的形式更新。由于KEYA和KEYB的校验机制，只能解决卡片对终端的认证，而无法解决终端对卡片的认证，即我们俗称的“伪卡”的风险。接触逻辑加密卡，即密钥就是一个预先设定的确定数，无论用什么方法计算密钥，最后就一定要和原先写入的数一致，就可以对被保护的数据进行读写操作。因此无论是一卡一密的系统还是统一密码的系统，经过破解就可以实现对非接触逻辑加密卡的解密。很多人认为只要是采用了一卡一密、实时在线系统或非接触逻辑加密卡的ID号就能避免密钥被解密，其实，非接触逻辑加密卡被解密就意味着M1卡可以被复制，使用在线系统尽可以避免被非法充值，但是不能保证非法消费，即复制一张一样ID号的M1卡，就可以进行非法消费。现在的技术使用FPGA就可以完全复制。基于这个原理，M1的门禁卡也是不安全的。目前国内80%的门禁产品均是采用原始IC卡的ID号或ID卡的ID号去做门禁卡，根本没有去进行加密认证或开发专用的密钥，其安全隐患远远比Mifare卡的破解更危险，非法破解的人士只需采用的是专业的技术手段就可以完成破解过程，导致目前国内大多数门禁产品都不具备安全性原因之一，是因为早期门禁产品的设计理论是从国外引进过来的，国内大部分厂家长期以来延用国外做法，采用ID和IC卡的只读特性进行身份识别使用，很少关注卡与机具间的加密认证，缺少钥匙体系的设计；而ID卡是很容易可复制的载体，导致所有的门禁很容易几乎可以在瞬间被破解复制；这才是我们国内安防市场最大的灾难。 2、 非接触CPU卡智能卡与非接触逻辑加密卡相比，拥有独立的CPU处理器和芯片操作系统，所以可以更灵活的支持各种不同的应用需求，更安全的设计交易流程。但同时，与非接触逻辑加密卡系统相比，非接触CPU卡智能卡的系统显得更为复杂，需要进行更多的系统改造，比如密钥管理、交易流程、PSAM卡以及卡片个人化等。密钥通常分为充值密钥（ISAM卡），减值密钥（PSAM卡），外部认证密钥（SAM卡）和全能密钥（ASAM卡）。非接触CPU卡智能卡可以通过内外部认证的机制，例如像建设部定义的电子钱包的交易流程，高可靠的满足不同的业务流程对安全和密钥管理的需求。对电子钱包圈存可以使用圈存密钥，消费可以使用消费密钥，清算可以使用TAC密钥，更新数据可以使用卡片应用维护密钥，卡片个人化过程中可以使用卡片传输密钥、卡片主控密钥、应用主控密钥等，真正做到一钥一用。 SAM(Secure Access Module)安全存取模块介绍为什么要用SAM？究竟谁最开始使用SAM这个词，已经无从考证，能够确认的是：这个世界上先有了PSAM，然后才有了SAM。由于网络状况的原因，或者是应用环境的要求，使用IC卡作为支付介质的系统里面，消费环境不能在每次交易的时候，都做到实时与后台相连接认证IC卡的合法性以及交易完全性。因此，一种我们目前已经认可的交易模式——“电子钱包脱机消费”产生了。即便目前通讯技术发展到已经不存在技术障碍，在权衡风险、代价、方便性等等，我们还是要继续使用并发扬光大脱机消费这样一个模式。由此，就需要对发生交易的终端有所要求，一是能够鉴别IC卡的真伪，再者需要能够保证交易的合法性与安全性，本着不把终端制造商拉下水的目的，于是，坚持一个原则：终端设备与系统安全机制分离，即所有有关安全性的因素，都放置到一个叫PSAM卡里面，由系统发行方来发行管理。没有 PSAM卡的消费终端，相当于没有SIM卡的手机，安装PSAM卡以后，该消费终端就获得了系统运营商的许可，有权鉴别卡片的真伪，有权从卡上的钱包扣款。因此，PSAM的解释为：销售点终端安全存取模块（Purchase Secure Access Module）。 上述最初起源自金融领域 IC卡电子钱包支付系统中的消费应用。在迅猛发展，并极具想象力的IC卡行业，PSAM的应用模式很快得到了延伸，去掉了P（Purchase）的限制之后的SAM（Secure Access Module），被用于很多模式中，变成了“各种终端内嵌入的、认证及存储所有安全数据与敏感信息的设备”。SAM是一个统称，SAM可以是一张标准尺寸的IC卡大小，更多的时候还是符合ISO/IEC 7810里面ID-000标准的小卡形状，也可以是一个DIP8或者SOP8/16封装的IC集成电路形状。如同印章一样，放一个SAM到一个通用的设备里面，表明运营商获得这个设备的控制权和所有权，才能完成该终端赋予的各种功能。 CPU卡加密算法和随机数发生器与安装在读写设备中的密钥认证卡(SAM卡)相互发送认证的随机数，可以实现以下功能： 1）通过终端设备上SAM卡实现对卡的认证 2）CPU卡与终端设备上的SAM卡的相互认证，实现对卡终端的认证 3）通过ISAM卡对CPU卡进行充值操作，实现安全的储值 4）通过PSAM卡对CPU卡进行减值操作，实现安全的扣款 5）在终端设备与CPU卡中传输的数据是加密传输 6）通过对CPU卡发送给SAM卡的MAC1，SAM卡发送给CPU的MAC2和由CPU卡返回的TAC，可以实现数据传输验证的计算。而MAC1、MAC2和TAC就是同一张CPU卡每次传输的过程中都是不同的，因此无法使用空中接收的办法来破解CPU卡的密钥。 有几种SAM？ PSAM：放在脱机消费终端内，用来控制电子钱包脱机消费交易的SAM卡，通常是铳成ID-000的小卡形状，存放消费主密钥，能够验证用户卡上消费子密钥是否符合约定的对应关系，并且保证扣款过程的安全性。 ISAM：ISAM的出现并不具有典型意义，其中的I，可解释为Input，也可解释为Increase，放置在充值终端设备内，脱机充值交易中控制充值交易安全。说它不具有典型意义的原因是，脱机充值的模式是小额支付系统早期的模式，基于安全、风险、政策、技术发展等考虑，脱机充值应用在未来不会有生命力，因此， ISAM作为一个过渡产品，慢慢会成为历史。 ESAM，ESAM属于企业创造的新名词，其中的“E”代表一种形态，特指采用SOP或者DIP封装形式的SAM，作为设备原始设计的一部分，生产的时候焊接在设备的电路板上，不像是其他的SAM是在卡座内，可以灵活拆卸。ESAM的名字与功能无关，比如ESAM形式的PSAM或者ISAM，比如ESAM形式的电子钱包应用。都是符合逻辑的说法。ESAM有几种典型的应用：作为电子计数文件，在预付费表具内控制表具的运行。作为安全数据的存储与认证，实现硬件设备的版权保护与安全使用。 USAM： 是一个新产品，是基于已有SAM概念的基础上，进行的10%左右的创新而来，其中的“U”，大家一定比较容易猜到，即“USB”，是一个采用USB接口和通讯方式的SAM，在这里补充一下，前面所说的各种SAM的通讯方式都是符合ISO/IEC 7816中规定的接口和通讯协议。USAM是两种成熟技术结合，一种全新形态的产品。能大幅度提高SAM的效率与性能，减少设备开发工作量，使SAM的应用趋于标准化、开放性，也扩展了SAM的应用领域。 SAM的技术要求SAM是与终端设备配套使用的安全设备，它具备这样的几个基本要求： 1、是带有COS的CPU卡（模块）； 2、密钥安全的存储在卡内，在某种认可的权限下，能被用于运算，但是不能被直接读出； 3、高安全等级芯片，低功耗、宽电压、宽温度范围； 4、SAM最核心的要求是安全性； 5、SAM最重要的两个参数是运算速度和通讯速率； 对IC卡操作时，耗费时间最多的环节是通讯所占用的时间，而在IC卡应用系统中，尤其是非接触式的应用中，每一个毫秒的时间都是非常宝贵的，都会极大地影响用户感受，在高速公路不停车收费系统中，每增加一个毫秒，都意味着通行速度的大幅降低。 而采用USAM的最大特点在于：1、减少数据流通环节；2、提高数据通讯速度。 USAM直接插入标准USB接口即可使用，不用外接IC卡读写器或者需要SAM卡座；便于安装、使用； USAM比较适合用于：城市通卡、高速公路收费、金融领域、加油领域、预付费水电气表。 参考资料PSAM SAM：https://www.bbsmax.com/A/lk5aGpwPz1/ IC卡、M1卡、CPU卡、SAM卡、PSAM卡的联系与区别:https://www.bbsmax.com/A/8Bz8BRpx5x/ 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/09/12/PBOCKonwledge/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"PBOC","slug":"pboc","permalink":"http://agehua.github.io/tags/pboc/"},{"name":"PBOC 2.0","slug":"pboc-2-0","permalink":"http://agehua.github.io/tags/pboc-2-0/"}]},{"title":"Android面试题积累","slug":"IntervieweeQuestions","date":"2017-08-16T16:00:00.000Z","updated":"2017-11-23T07:25:53.000Z","comments":true,"path":"2017/08/17/IntervieweeQuestions/","link":"","permalink":"http://agehua.github.io/2017/08/17/IntervieweeQuestions/","excerpt":"1Activity面试题1、Activity是什么Activity是四大组件之一，它提供一个界面让用户点击和各种滑动操作，这就是Activity\n2、Activity四种状态runingpausedstoppedkilled\n3、Activity生命周期onCreate()onStart()onResume()onPause()onStop()onDestroy()onRestart()\n4、进程的优先级空进程后台进程服务进程可见进程前台进程\n5、Activity任务栈先进后出","text":"1Activity面试题1、Activity是什么Activity是四大组件之一，它提供一个界面让用户点击和各种滑动操作，这就是Activity 2、Activity四种状态runingpausedstoppedkilled 3、Activity生命周期onCreate()onStart()onResume()onPause()onStop()onDestroy()onRestart() 4、进程的优先级空进程后台进程服务进程可见进程前台进程 5、Activity任务栈先进后出6、Activity启动模式standardsingletopsingletask: 能够保证Activity A在栈中只有一个实例，这个栈也允许存在其他的实例. 特别需要注意的是使用startActivityForResult方法的时候，根据startActivityForResult的api说明: if the activity you are launching uses the singleTask launch mode, it will not run in your task and thus you will immediately receive a cancel result意思就是使用startActivityForResult方法启动一个singleTask的Activity，该Activity不会启动，会收到一个RESULT_CANCELED结果 singleinstance: singleInstance要求activity的实例不仅只有一个，并且整个task中只有一个activity实例，而singleTask所在的栈中允许存在其他activity的实例。 singleInstance的activity也具有上面的特性，此外，activity设置了singleInstance，那么无论被启动的activity有没有设置singleInstance，都无法获取返回值 7、scheme跳转协议Android中的scheme是一种页面内跳转协议，通过定义自己的scheme协议，可以跳转到app中的各个页面服务器可以定制化告诉app跳转哪个页面App可以通过跳转到另一个App页面可以通过H5页面跳转页面（DeepLink）：&lt;a href=&quot;[scheme]://[host]/[path]?[query]&quot;&gt;启动应用程序&lt;/a&gt; &lt;intent-filter&gt; &lt;data android:scheme=\"http\" /&gt; &lt;!-- or you can use deep linking like --&gt; &lt;data android:scheme=\"http\" android:host=\"xyz.abc.com\"/&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;&lt;/intent-filter&gt; 2Fragment面试题1、Fragment为什么被称为第五大组件Fragment比Activity更节省内存，其切换模式也更加舒适，使用频率不低于四大组件，且有自己的生命周期，而且必须依附于Activity 2、Activity创建Fragment的方式静态创建：在activity布局文件里声明fragment，activity_main.xml中声明： 动态创建：通过java代码将fragment添加到已存的ViewGroup中fragment = new MyFragment();fragmentStack.push(fragment);transaction = manager.beginTransaction();transaction.add(R.id.fragments, fragment);transaction.commit(); 3、FragmentPageAdapter和FragmentPageStateAdapter的区别FragmentPageAdapter在每次切换页面的的时候，是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响FragmentPageStateAdapter在每次切换页面的时候，是将Fragment进行回收，适合页面较多的Fragment使用，这样就不会消耗更多的内存 4、Fragment生命周期onAttach()onCreate()onCreateView()onActivityCreated()onStart()onResume()onPause()onStop()onDestroyView()onDestroy()onDetach() 5、Fragment的通信Fragment调用Activity中的方法：getActivityActivity调用Fragment中的方法：接口回调Fragment调用Fragment中的方法：FragmentManager.findFragmentById 6、Fragment的replace、add、remove方法replace：替代Fragment的栈顶页面add：添加Fragment到栈顶页面remove：移除Fragment栈顶页面 3Service面试题1、Service是什么Service是四大组件之一，它可以在后台执行长时间运行操作而没有用户界面的应用组件 2、Service和Thread的区别Service是安卓中系统的组件，它运行在独立进程的主线程中，不可以执行耗时操作，超时会有ANR异常。Thread是程序执行的最小单元，分配CPU的基本单位，可以开启子线程执行耗时操作Service在不同Activity中可以获取自身实例，可以方便的对Service进行操作。Thread在不同的Activity中难以获取自身实例，如果Activity被销毁，Thread实例就很难再获取得到 3、Service启动方式startServicebindService 4、Service生命周期startServiceonCreate()onStartCommand()onDestroy()bindServiceonCreate()onBind()onUnbind()onDestroy() 4Broadcast Receiver面试题1、Broadcast Receiver是什么Broadcast是四大组件之一，是一种广泛运用在应用程序之间传输信息的机制，通过发送Intent来传送我们的数据 2、Broadcast Receiver的使用场景同一App具有多个进程的不同组件之间的消息通信不同App之间的组件之间的消息通信 3、Broadcast Receiver的种类普通广播有序广播 Context.sendOrderedBroadcast本地广播 LocalBroadcastManager.getInstance(context).sendBroadcast(intent) 除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。Sticky广播 的sendStickyBroadcast(Intent)接口发送，需要添加权限也可以通过Context的removeStickyBroadcast(Intent intent)接口移除缓存的粘性广播。sticky有序广播 StickyOrderedBroadcast 4、Broadcast Receiver的实现静态注册：注册后一直运行，尽管Activity、进程、App被杀死还是可以接收到广播动态注册：跟随Activity的生命周期 5、Broadcast Receiver实现机制自定义广播类继承BroadcastReceiver，复写onReceiver()通过Binder机制向AMS进行注册广播广播发送者通过Binder机制向AMS发送广播AMS查找符合相应条件的广播发送到BroadcastReceiver相应的循环队列中消息队列执行拿到广播，回调BroadcastReceiver的onReceiver() 6、LocalBroadcastManager特点本地广播只能在自身App内传播，不必担心泄漏隐私数据本地广播不允许其他App对你的App发送该广播，不必担心安全漏洞被利用本地广播比全局广播更高效以上三点都是源于其内部是用Handler实现的 5 WebView面试题1、WebView安全漏洞API16之前存在远程代码执行安全漏洞，该漏洞源于程序没有正确限制使用WebView.addJavascriptInterface方法，远程攻击者可通过使用Java反射机制利用该漏洞执行任意Java对象的方法 2、WebView销毁步骤WebView在其他容器上时（如：LinearLayout），当销毁Activity时，需要在onDestroy()中先移除容器上的WebView，然后再将WebView.destroy()，这样就不会导致内存泄漏 3、WebView的jsbridge客户端和服务端之间可以通过Javascript来互相调用各自的方法 4、WebViewClient的onPageFinishedWebViewClient的onPageFinished在每次完成页面的时候调用，但是遇到未加载完成的页面跳转其他页面时，就会一直调用，使用WebChromeClient.onProgressChanged可以替代 5、WebView后台耗电在WebView加载页面的时候，会自动开启线程去加载，如果不很好的关闭这些线程，就会导致电量消耗加大，可以采用暴力的方法，直接在onDestroy方法中System.exit(0)结束当前正在运行中的java虚拟机 6、WebView硬件加速Android3.0引入硬件加速，默认会开启，WebView在硬件加速的情况下滑动更加平滑，性能更加好，但是会出现白块或者页面闪烁的副作用，建议WebView暂时关闭硬件加速 7、WebView内存泄漏由于WebView是依附于Activity的，Activity的生命周期和WebView启动的线程的生命周期是不一致的，这会导致WebView一直持有对这个Activity的引用而无法释放，解决方案如下独立进程，简单暴力，不过可能涉及到进程间通信（推荐）动态添加WebView，对传入WebView中使用的Context使用弱引用 6Binder面试题1、Linux内核的基本知识 进程隔离/虚拟地址空间：进程间是不可以共享数据的，相当于被隔离，每个进程被分配到不同的虚拟地址中系统调用：Linux内核对应用有访问权限，用户只能在应用层通过系统调用，调用内核的某些程序binder驱动：它负责各个用户的进程，通过binder通信内核来进行交互的模块 而Binder，就是充当 连接 两个进程（内核空间）的通道。 2、为什么使用Binder性能上，相比传统的Socket更加高效安全性高，支持协议双方互相校验 3、Binder通信模型 虚线表示并非直接交互 说明1：Client进程、Server进程 &amp; Service Manager 进程之间的交互都必须通过Binder驱动（使用 open 和 ioctl文件操作函数），而非直接交互 原因： Client进程、Server进程 &amp; Service Manager进程属于进程空间的用户空间，不可进行进程间交互 Binder驱动 属于 进程空间的 内核空间，可进行进程间 &amp; 进程内交互 说明2： Binder驱动 &amp; Service Manager进程 属于 Android基础架构（即系统已经实现好了）；而Client 进程 和 Server 进程 属于Android应用层（需要开发者自己实现） 所以，在进行跨进程通信时，开发者只需自定义Client &amp; Server 进程 并 显式使用上述3个步骤，最终借助 Android的基本架构功能就可完成进程间通信 详细参考这篇博客：图文详解 Android Binder 跨进程通信机制原理 对比 Linux （Android基于linux）上的其他进程通信方式（管道/消息队列/共享内存/信号量/Socket），Binder 机制的优点有： 高效Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次通过驱动在内核空间拷贝数据，不需要额外的同步处理 安全性高Binder 机制为每个进程分配了 UID/PID 来作为鉴别身份的标示，并且在 Binder 通信时会根据 UID/PID 进行有效性检测传统的进程通信方式对于通信双方的身份并没有做出严格的验证如，Socket通信 ip地址是客户端手动填入，容易出现伪造 使用简单采用Client/Server 架构实现 面向对象 的调用方式，即在使用Binder时就和调用一个本地对象实例一样 4、AIDL客户端通过aidl文件的Stub.asInterface()方法，拿到Proxy代理类通过调用Proxy代理类的方法，将参数进行封包后，调用底层的transact()方法transact()方法会回调onTransact()方法，进行参数的解封在onTransact()方法中调用服务端对应的方法，并将结果返回 7Handler面试题1、Handler是什么Handler通过发送和处理Message和Runnable对象来关联相对应线程的MessageQueue 2、Handler使用方法post(runnable)sendMessage(message) 3、Handler工作原理Android进阶——Android消息机制之Looper、Handler、MessageQueen 4、Handler引起的内存泄漏原因：非静态内部类持有外部类的匿名引用，导致Activity无法释放解决：Handler内部持有外部Activity的弱引用Handler改为静态内部类Handler.removeCallback() 8AsyncTask面试题1、AsyncTask是什么它本质上就是一个封装了线程池和Handler的异步框架 2、AsyncTask使用方法三个参数Params：表示后台任务执行时的参数类型，该参数会传给AysncTask的 doInBackground() 方法Progress：表示后台任务的执行进度的参数类型，该参数会作为 onProgressUpdate() 方法的参数Result：表示后台任务的返回结果的参数类型，该参数会作为 onPostExecute() 方法的参数五个方法onPreExecute()：异步任务开启之前回调，在主线程中执行doInBackground()：执行异步任务，在线程池中执行onProgressUpdate()：当doInBackground中调用publishProgress时回调，在主线程中执行onPostExecute()：在异步任务执行之后回调，在主线程中执行onCancelled()：在异步任务被取消时回调 3、AsyncTask工作原理Android进阶——多线程系列之异步任务AsyncTask的使用与源码分析http://blog.csdn.net/qq_30379689/article/details/53203556 4、AsyncTask引起的内存泄漏原因：非静态内部类持有外部类的匿名引用，导致Activity无法释放解决：AsyncTask内部持有外部Activity的弱引用AsyncTask改为静态内部类AsyncTask.cancel() 5、AsyncTask生命周期在Activity销毁之前，取消AsyncTask的运行，以此来保证程序的稳定 6、AsyncTask结果丢失由于屏幕旋转、Activity在内存紧张时被回收等情况下，Activity会被重新创建，此时，旧的AsyncTask持有旧的Activity引用，这个时候会导致AsyncTask的 onPostExecute()对UI更新无效 7、AsyncTask并行or串行AsyncTask在Android 2.3之前默认采用并行执行任务，AsyncTask在Android 2.3之后默认采用串行执行任务如果需要在Android 2.3之后采用并行执行任务，可以调用AsyncTask的executeOnExecutor() 9HandlerThread面试题1、HandlerThread产生背景当系统有多个耗时任务需要执行时，每个任务都会开启一个新线程去执行耗时任务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题，Google提供了HandlerThread，HandlerThread是在线程中创建一个Looper循环器，让Looper轮询消息队列，当有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即可，否则线程阻塞 2、HanlderThread的特点、HandlerThread本质上是一个线程，继承自ThreadHandlerThread有自己的Looper对象，可以进行Looper循环，可以创建HandlerHandlerThread可以在Handler的handlerMessage中执行异步方法HandlerThread优点是异步不会堵塞，减少对性能的消耗HandlerThread缺点是不能同时继续进行多任务处理，需要等待进行处理，处理效率较低HandlerThread与线程池不同，HandlerThread是一个串行队列，背后只有一个线程。 10IntentService面试题1、IntentService是什么IntentService是继承自Service并处理异步请求的一个类，其内部采用HandlerThread和Handler实现的，在IntentService内有一个工作线程来处理耗时操作，其优先级比普通Service高。当任务完成后，IntentService会自动停止，而不需要手动调用stopSelf()。另外，可以多次启动IntentService，每个耗时操作都会以工作队列的方式在IntentService中 onHandlerIntent() 回调方法中执行，并且每次只会执行一个工作线程 2、IntentService使用方法创建Service继承自IntentService覆写构造方法和onHandlerIntent()方法在onHandlerIntent()中执行耗时操作 11视图工作机制面试题Android进阶——Android视图工作机制之measure、layout、draw Android事件分发机制之dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent 12ListView面试题1、ListView是什么ListView是能将一个数据集合以动态滚动的方式展示到用户界面上的View 2、ListView的RecycleBin机制 3、ListView的优化重用convertView使用ViewHolder图片三级缓存监听滑动事件少用透明View开启硬件加速 13Android项目构建面试题1、android构建流程 2、jenkins持续集成构建这里可参考蒲公英文档 3、Git常用命令git init：仓库的初始化git status：查看当前仓库的状态git diff：查看仓库与上次修改的内容git add：将文件放进暂存区git commit：提交代码git clone：克隆代码git bransh：查看当前分支git checkout：切换当前分支 4、git工作流fork/clone（主流）fork：将别人的仓库代码fork到自己的仓库上clone：克隆下自己仓库的代码update、commit：修改代码并提交到自己的仓库push：提交到自己的仓库pull request：请求添加到别人的仓库clone 5、proguard是什么ProGuard工具是用于压缩、优化和混淆我们的代码，其主作用是移除或混淆代码中无用类、字段、方法和属性 6、proguard技术功能压缩优化混淆预检测 7、proguard工作原理将无用的字段或方法存入到EntryPoint中，将非EntryPoint的字段和方法进行替换 8、为什么要混淆由于Java是一门跨平台的解释性语言，其源代码被编译成class字节码来适应其他平台，而class文件包含了Java源代码信息，很容易被反编译 14ANR面试题1、什么是ANRApplication Not Responding，页面无响应的对话框 2、发生ANR的条件应用程序的响应性是由ActivityManager和WindowManager系统服务监视的，当ANR发生条件满足时，就会弹出ANR的对话框Activity超过5秒无响应BroadcastReceiver超过10秒无响应Service超过20秒无响应 3、造成ANR的主要原因主线程被IO操作阻塞Activity的所有生命周期回调都是执行在主线程的Service默认执行在主线程中BoardcastReceiver的回调onReceive()执行在主线程中AsyncTask的回调除了doInBackground，其他都是在主线程中没有使用子线程Looper的Handler的handlerMessage，post(Runnable)都是执行在主线程中 4、如何解决ANR使用AsyncTask处理耗时IO操作使用Thread或HandlerThread提供优先级使用Handler处理工作线程的耗时操作Activity的onCreate和onResume回调尽量避免耗时操作 15 OOM面试题1、什么是OOMOOM指Out of memory（内存溢出），当前占用内存加上我们申请的内存资源超过了Dalvik虚拟机的最大内存限制就会抛出Out of memory异常 2、OOM相关概念内存溢出：指程序在申请内存时，没有足够的空间供其使用内存泄漏：指程序分配出去的内存不再使用，无法进行回收内存抖动：指程序短时间内大量创建对象，然后回收的现象 3、解决OOMBitmap相关图片压缩加载缩略图在滚动时不加载图片回收Bitmap使用inBitmap属性捕获异常其他相关listview重用convertView、使用LruCache避免onDraw方法执行对象的创建谨慎使用多进程 16 Bitmap面试题1、recycle在安卓3.0以前Bitmap是存放在堆中的，我们只要回收堆内存即可在安卓3.0以后Bitmap是存放在内存中的，我们需要回收native层和Java层的内存官方建议我们3.0以后使用recycle方法进行回收，该方法也可以不主动调用，因为垃圾回收器会自动收集不可用的Bitmap对象进行回收recycle方法会判断Bitmap在不可用的情况下，将发送指令到垃圾回收器，让其回收native层和Java层的内存，则Bitmap进入dead状态recycle方法是不可逆的，如果再次调用getPixels()等方法，则获取不到想要的结果 2、LruCache原理LruCache是个泛型类，内部采用LinkedHashMap来实现缓存机制，它提供get方法和put方法来获取缓存和添加缓存，其最重要的方法trimToSize是用来移除最少使用的缓存和使用最久的缓存，并添加最新的缓存到队列中 3、计算inSampleSizepublic static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; if (width &gt; height) &#123; inSampleSize = Math.round((float)height / (float)reqHeight); &#125; else &#123; inSampleSize = Math.round((float)width / (float)reqWidth); &#125; &#125; return inSampleSize;&#125; 4、缩略图public static Bitmap thumbnail(String path,int maxWidth, int maxHeight, boolean autoRotate) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; Bitmap bitmap = BitmapFactory.decodeFile(path, options); options.inJustDecodeBounds = false; int sampleSize = calculateInSampleSize(options, maxWidth, maxHeight); options.inSampleSize = sampleSize; options.inPreferredConfig = Bitmap.Config.RGB_565; options.inPurgeable = true; options.inInputShareable = true; if (bitmap != null &amp;&amp; !bitmap.isRecycled()) &#123; bitmap.recycle(); &#125; bitmap = BitmapFactory.decodeFile(path, options); return bitmap;&#125; 5、保存Bitmappublic static String save(Bitmap bitmap,Bitmap.CompressFormat format, int quality, File destFile) &#123; try &#123; FileOutputStream out = new FileOutputStream(destFile); if (bitmap.compress(format, quality, out)) &#123; out.flush(); out.close(); &#125; if (bitmap != null &amp;&amp; !bitmap.isRecycled()) &#123; bitmap.recycle(); &#125; return destFile.getAbsolutePath(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null;&#125; 6、保存到SD卡 public static String save(Bitmap bitmap,Bitmap.CompressFormat format, int quality, Context context) &#123; if (!Environment.getExternalStorageState() .equals(Environment.MEDIA_MOUNTED)) &#123; return null; &#125; File dir = new File(Environment.getExternalStorageDirectory() + \"/\" + context.getPackageName() + \"/save/\"); if (!dir.exists()) &#123; dir.mkdirs(); &#125; File destFile = new File(dir, UUID.randomUUID().toString()); return save(bitmap, format, quality, destFile);&#125; 7、三级缓存网络缓存本地缓存内存缓存 17UI卡顿面试题1、UI卡顿原理View的绘制帧数保持60fps是最佳，这要求每帧的绘制时间不超过16ms（1000/60），如果安卓不能在16ms内完成界面的渲染，那么就会出现卡顿现象 2、UI卡顿的原因分析在UI线程中做轻微的耗时操作，导致UI线程卡顿布局Layout过于复杂，无法在16ms内完成渲染同一时间动画执行的次数过多，导致CPU和GPU负载过重overDraw，导致像素在同一帧的时间内被绘制多次，使CPU和GPU负载过重View频繁的触发measure、layout，导致measure、layout累计耗时过多和整个View频繁的重新渲染频繁的触发GC操作导致线程暂停，会使得安卓系统在16ms内无法完成绘制冗余资源及逻辑等导致加载和执行缓慢ANR 3、UI卡顿的优化布局优化使用include、ViewStub、merge不要出现过于嵌套和冗余的布局使用自定义View取代复杂的ViewListView优化复用convertView滑动不加载背景和图片优化缩略图图片压缩避免ANR不要在UI线程中做耗时操作 18 内存泄漏面试题1、Java内存泄漏引起的主要原因长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏 2、Java内存分配策略静态存储区：又称方法区，主要存储全局变量和静态变量，在整个程序运行期间都存在栈区：方法体的局部变量会在栈区创建空间，并在方法执行结束后会自动释放变量的空间和内存堆区：保存动态产生的数据，如：new出来的对象和数组，在不使用的时候由Java回收器自动回收 3、Android解决内存泄漏的例子单例造成的内存泄漏：在单例中，使用context.getApplicationContext()作为单例的context匿名内部类造成的内存泄漏：由于非静态内部类持有匿名外部类的引用，必须将内部类设置为staticHandler造成的内存泄漏：使用static的Handler内部类，同时在实现内部类中持有Context的弱引用避免使用static变量：由于static变量会跟Activity生命周期一致，当Activity退出后台被后台回收时，static变量是不安全，所以也要管理好static变量的生命周期资源未关闭造成的内存泄漏：比如Socket、Broadcast、Cursor、Bitmap、ListView等，使用完后要关闭AsyncTask造成的内存泄漏：由于非静态内部类持有匿名内部类的引用而造成内存泄漏，可以通过AsyncTask内部持有外部Activity的弱引用同时改为静态内部类或在onDestroy()中执行AsyncTask.cancel()进行修复 19 内存管理面试题1、Android内存管理机制分配机制管理机制 2、内存管理机制的特点更少的占用内存在合适的时候，合理的释放系统资源在系统内存紧张的时候，能释放掉大部分不重要的资源能合理的在特殊生命周期中，保存或还原重要数据 3、内存优化方法Service完成任务后应停止它，或用IntentService（因为可以自动停止服务）代替Service在UI不可见的时候，释放其UI资源在系统内存紧张的时候，尽可能多的释放非重要资源避免滥用Bitmap导致内存浪费避免使用依赖注入框架使用针对内存优化过的数据容器使用ZIP对齐的APK使用多进程 20 冷启动和热启动面试题1、什么是冷启动和热启动冷启动：在启动应用前，系统中没有该应用的任何进程信息热启动：在启动应用时，在已有的进程上启动应用（用户使用返回键退出应用，然后马上又重新启动应用） 2、冷启动和热启动的区别冷启动：创建Application后再创建和初始化MainActivity热启动：创建和初始化MainActivity即可 3、冷启动时间的计算这个时间值从应用启动（创建进程）开始计算，到完成视图的第一次绘制为止 4、冷启动流程Zygote进程中fork创建出一个新的进程创建和初始化Application类、创建MainActivityinflate布局、当onCreate/onStart/onResume方法都走完contentView的measure/layout/draw显示在界面上总结：Application构造方法-&gt;attachBaseContext()-&gt;onCreate()-&gt;Activity构造方法-&gt;onCreate()-&gt;配置主题中背景等属性-&gt;onStart()-&gt;onResume()-&gt;测量布局绘制显示在界面上 5、冷启动优化减少第一个界面onCreate()方法的工作量不要让Application参与业务的操作不要在Application进行耗时操作不要以静态变量的方式在Application中保存数据减少布局的复杂性和深度不要在mainThread中加载资源通过懒加载方式初始化第三方SDK 21其他优化面试题1、Android不用静态变量存储数据静态变量等数据由于进程已经被杀死而被初始化使用其他数据传输方式：文件/sp/contentProvider 2、SharePreference安全问题不能跨进程同步文件不宜过大 3、内存对象序列化Serializeble：是java的序列化方式，Serializeble在序列化的时候会产生大量的临时对象，从而引起频繁的GCParcelable：是Android的序列化方式，且性能比Serializeble高，Parcelable不能使用在要将数据存储在硬盘上的情况 4、避免在UI线程中做繁重的操作 22架构模式面试题Android基础——框架模式MVC在安卓中的实践http://blog.csdn.net/qq_30379689/article/details/52909656Android基础——框架模式MVP在安卓中的实践http://blog.csdn.net/qq_30379689/article/details/52910567Android基础——框架模式MVVM之DataBinding的实践http://blog.csdn.net/qq_30379689/article/details/53037430 23 插件化面试题1、插件化解决的问题动态加载APK（反射、类加载器）资源加载（反射、AssetManager、独立资源、分段资源）代码加载（反射获取生命周期） 2、类加载器（Java中字节码添加到虚拟机中）DexClassLoader：能够加载未安装的jar/apk/dex，主要用于动态加载和代码热更新PathClassLoader：只能加载系统中已经安装过的apk 24 热更新面试题1、热更新主要流程线上检查到Crash拉出Bugfix分支修复Crash问题jenkins构建和补丁生成app通过推送或主动拉取补丁文件将Bugfix代码合到master上 2、热更新主流框架DexposedAndFixNuwaTinker 3、热更新的原理在ClassLoader创建一个dexElements数组将修复好的dex文件存放在dexElements数组的最前面ClassLoader会遍历dexElements数组，找到最前面的dex文件优先加载 25 进程保活面试题1、进程的优先级空进程后台进程服务进程可见进程前台进程 2、Android进程回收策略Low memory Killer（定时执行）：通过一些比较复杂的评分机制，对进程进行打分，然后将分数高的进程判定为bad进程，杀死并释放内存OOM_ODJ：判别进程的优先级 3、Android保活方案利用系统广播拉活利用系统Service机制拉活利用Native进程拉活利用JobScheduler机制拉活利用账号同步机制拉活 26 Lint面试题1、什么是Android LintAndroid Lint是一个静态代码分析工具，它能够对你的Android项目中潜在的Bug、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查 2、Lint工作流程 3、配置Lint创建Lint.xml到根目录下，自定义Lint安全等级等在Java文件中可以使用@suppressLint(“NewApi”)来忽视Lint的报错在xml文件中可以使用tool:ignore(“UnusedResources”)来忽视Lint的报错自定义Lint检查，可以创建类，继承Detector和实现JavaPsiScanner 27 Kotlin面试题1、什么是KotlinKotlin是一种基于JVM的编程语言对Java的一种拓展，比Java更简洁Kotlin支持函数式编程Kotlin类和Java类可以相互调用 2、Kotlin环境搭建直接在Plugin中下载Kotlin插件即可系统会自动配置到Kotlin环境 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/08/17/IntervieweeQuestions/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"Interview Knowledge","slug":"interview-knowledge","permalink":"http://agehua.github.io/tags/interview-knowledge/"}]},{"title":"Activity启动流程分析","slug":"activity-start-process","date":"2017-08-01T16:00:00.000Z","updated":"2017-11-23T07:20:01.000Z","comments":true,"path":"2017/08/02/activity-start-process/","link":"","permalink":"http://agehua.github.io/2017/08/02/activity-start-process/","excerpt":"Activity启动流程分析本文主要介绍Activity的启动过程和过程中主要涉及的类。如果你跟随上一篇文章，成功编译了Android源码，可以动手跟本篇文章一步一步调试分析整个启动过程。没有编译源码，也可以看看android.googlesource，这里也有源码。\n主要对象功能介绍zygote进程和SystemServer进程android是基于Linux系统的，而在linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote 进程也不例外。\n\n每一个App其实都是\n\n一个单独的dalvik虚拟机\n一个单独的进程\n\n\nAndroid系统开启新进程的方式，是通过fork第一个zygote 进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程。","text":"Activity启动流程分析本文主要介绍Activity的启动过程和过程中主要涉及的类。如果你跟随上一篇文章，成功编译了Android源码，可以动手跟本篇文章一步一步调试分析整个启动过程。没有编译源码，也可以看看android.googlesource，这里也有源码。 主要对象功能介绍zygote进程和SystemServer进程android是基于Linux系统的，而在linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote 进程也不例外。 每一个App其实都是 一个单独的dalvik虚拟机 一个单独的进程 Android系统开启新进程的方式，是通过fork第一个zygote 进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程。 SystemServer 也是一个进程，而且是由zygote进程fork出来的。为什么说SystemServer非常重要呢？因为系统里面重要的服务都是在这个进程里面开启的，比如ActivityManagerService、PackageManagerService、WindowManagerService等等。 我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？App与AMS通过Binder进行IPC通信，AMS(SystemServer进程)与zygote通过Socket进行IPC通信。 与Activity启动有关的类我们下面的文章将围绕着这几个类进行介绍。可能你第一次看的时候，印象不深，不过没关系，当你跟随者我读完这篇文章的时候，相信那时候你会对这些类更加的熟悉和深刻。 ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期，查看源码，点击这里 ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作 ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。 ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。 Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。 ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。 ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息，比如在哪进程中ProcessState，当前的状态CurentState等。其实就是服务器端的Activity对象的映像。 TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。 ProcessRecord，这个类记录的是一个进程中的信息，因为一个应用中可能会包含多个进程。 App程序的入口我们一般在启动Activity的时候都是使用系统提供的方法Activity.startActivity()操作的，本文就在此方法上分析整个过程: 这里我的app进程是：foo.bar.multi，后面深入源码后会在系统进程system_process和app进程之间切换。 @Overridepublic void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; //options这里为null startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125;public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; //这里mParent不为空 options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; // 代码省略.... &#125; else &#123; // 代码省略.... &#125;&#125; 上面代码可以看到，这里用到了mMainThread变量去执行的操作，再看看这个变量，它是ActivityThread的一个实例。ActivityThread是一个应用非常关键的一个类，首先它是一个应用的主线程，其次就是他才是一个程序的入口（main方法）的地方： public static void main(String[] args) &#123; //...代码省略&#125; 没有Android源码的，可以看这里：android.googlesource。后面介绍这个入口main方法什么时候执行。 上面的mInstrumentation对象，是在Activity的attach()方法中被赋值的 Instrumentation是什么？和ActivityThread是什么关系？接着说上面的mInstrumentation.execStartActivity()方法，有三个同名的重载方法：public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options)public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options)public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options, UserHandle user) 考验眼力的时候到了，仔细看下，上面的mInstrumentation.execStartActivity()调用的其实是第一个重载方法：public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; //...ignore some code... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null;&#125; 可以看到execStartActivity()方法，调用了ActivityManagerNative的startActivity()方法，看到这个ActivityManagerNative类有没有感觉和之前一篇文章，Android Binder机制分析（二）里的ServiceManagerNative有点类似，这里涉及到的是系统服务间的Binder机制，不了解的同学可以看看这篇文章。 稍后分析ActivityManagerNative，这里简单介绍下Instrumentation类。 Instrumentation意为“仪器”。每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。 Instrumentation这个类里面的方法大多数和Application和Activity有关，可以说是对Application和Activity初始化和生命周期的工具类。 举个例子，callActivityOnCreate()public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity);&#125; 对activity.performCreate(icicle);这一行代码熟悉吗？这一行里面就调用了传说中的Activity的入口函数onCreate()，不信？接着往下看Activity.performCreate()final void performCreate(Bundle icicle) &#123; onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; 确实，onCreate在这里调用了。但是有一件事情必须说清楚，那就是这个Instrumentation类这么重要，为啥我在开发的过程中，没有发现他的踪迹呢？ 是的，Instrumentation这个类很重要，对Activity生命周期方法的调用根本就离不开他，但他只负责Activity的内部管理。外部想调整Activity的状态，必须通过ActivityThread。 ActivityThread你都没听说过？那你肯定听说过传说中的UI线程吧？是的，这就是UI线程。我们前面说过，App和AMS是通过Binder传递信息的，那么ActivityThread就是专门与AMS的外交工作的。Instrumentation相当于老板娘，处理家务，很少露面。ActivityThread是老板，处理对外事务。 所以说，AMS是董事会，负责指挥和调度的，ActivityThread是老板，虽然说家里的事自己说了算，但是需要听从AMS的指挥，而Instrumentation则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主ActivityThread的安排。 简介AMS和ActivityThread之间的Binder通信前面的两篇文章：Android Binder机制分析（一）和Android Binder机制分析（二）。已经介绍了Android都是通过Binder机制调用远程的系统服务。这里在介绍下ActivityThread（App进程）是如何调用AMS服务的。 前面我们说到，在调用Activity.startActivity()的时候，实际上调用的是：mInstrumentation.execStartActivity()这个方法里面调用的是：ActivityManagerNative.getDefault().startActivity() 用鼠标定位一下，上面的startActivity()方法，会发现这个方法是IActivityManager接口里的方法。注意IActivityManager继承了IInterface接口，而这个接口就是AIDL接口类必须实现的接口。 再看，ActivityManagerNative.getDefault()返回的就是ActivityManagerService的远程接口的本地代理，即ActivityManagerProxy。public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; //从类声明上，我们可以看到ActivityManagerNative是Binder的一个子类，而且实现了IActivityManager接口 static public IActivityManager getDefault() &#123; return gDefault.get(); &#125;//最终返回的还是一个ActivityManagerProxy对象static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; //这里面的Binder类型的obj参数会作为ActivityManagerProxy的成员变量保存为mRemote成员变量，负责进行IPC通信 return new ActivityManagerProxy(obj); &#125;&#125; 其实ActivityManagerNative类就是远端服务的中间者Stub类，其实名字不叫Stub罢了，以后其实只要看到是继承了Binder类和实现了AIDL接口类型的就是Stub类，不要关心类名了。看到他的asInterface方法的时候也是和之前的其他系统服务都是类似的。//通过单例模式获取一个IActivityManager对象，这个对象通过asInterface(b)获得private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125; &#125;;&#125; 在这里可以看到了，其实gDefalut借助Singleton实现的单例模式，而在内部可以看到先从ServiceManager中获取到AMS远端服务的Binder对象，然后使用asInterface方法转化成本地化对象（其实就是ActivityManagerProxy对象，这个对象是ActivityManagerNative的内部类）。然后我们在看看上面调用了startActivity方法，其实就是调用了ActivityManagerProxy对象的这个方法。 在这里面做的事情就是IPC通信，利用Binder对象，调用transact()，把所有需要的参数封装成Parcel对象，向AMS发送数据进行通信。 这个方法中添加一个断点，注意这里startActivity()是ActivityManagerProxy类的方法，这里的进程应该还是App进程：foo.bar.multi public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); //...省略部分代码 mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result;&#125; 注意，这里先别放开断点 Binder本质上只是一种底层通信方式，和具体服务没有关系。为了提供具体服务，Server必须提供一套接口函数以便Client通过远程访问使用各种服务。这时通常采用Proxy设计模式：将接口函数定义在一个抽象类中，Server和Client都会以该抽象类为基类实现所有接口函数，所不同的是Server端是真正的功能实现，而Client端是对这些函数远程调用请求的包装。 客户端：ActivityManagerProxy =====&gt;Binder驱动=====&gt; ActivityManagerService：服务器 Binder只能传递数据，并不知道是要调用ActivityManagerServices的哪个方法，所以在数据中会添加方法的唯一标识码，比如前面的startActivity()方法中的标识：START_ACTIVITY_TRANSACTION。 在远端服务调用了transact()方法后，即mRemote.transact()，会转接到远端服务中间者ActivityManagerNative的onTransact方法中，找到对应的标识码： 注意这里的接收者ActivityManagerNative的onTransact方法是在system_process进程中，想要继续debug调试的的话，需要在monitor中选中这个进程，然后再在下面的方法中添加断点。最后放开上面添加的断点。 @Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; //最好在case方法里面添加断点，避免受其他系统发送的消息影响 data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); String callingPackage = data.readString(); Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); IBinder resultTo = data.readStrongBinder(); String resultWho = data.readString(); int requestCode = data.readInt(); int startFlags = data.readInt(); ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; Bundle options = data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null; int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125; //...省略&#125; 这里的startActivity方法，是在IActivityManager接口中定义的，跟ActivityManagerProxy没有关系了，是由远端服务来实现的，这里我们可以猜想应该是叫做ActivityManagerService中，这个类的源代码可以在android.googlesource里找到： 这个类里有三个重载的startActivity()方法，仔细看，对应的应该是第三个方法：final int startActivity(Intent intent, ActivityStackSupervisor.ActivityContainer container)@Overridepublic int startActivity(IBinder whoThread, String callingPackage, Intent intent, String resolvedType, Bundle bOptions)@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) 这个方法直接调用了startActivityAsUser()方法@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // TODO: Switch to user app stacks here. return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null);&#125; 这里的mActivityStarter是在ActivityManagerService创建的时候初始化的。public ActivityManagerService(Context systemContext) &#123; //...省略代码 mStackSupervisor = new ActivityStackSupervisor(this); mActivityStarter = new ActivityStarter(this, mStackSupervisor); //...省略代码&#125; 下面就是ActiviStarter、ActivityStack和ActivityStackSupervisor三个类之间方法调来调去了，这里为了节省篇幅就不再贴代码了，有毅力的同学可以每个方法都打上一个断点，走一遍： ActivityStarter.startActivityMayWait()-&gt; ActivityStarter.startActivityLocked()-&gt; ActivityStarter.startActivityUnchecked()-&gt; ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() 再往后都是ActivityStackSupervisor类的方法，调用： 从resumeFocusedStackTopActivityLocked()-&gt; resumeFocusedStackTopActivityLocked()-&gt; resumeTopActivityUncheckedLocked()-&gt; resumeTopActivityInnerLocked()-&gt; startSpecificActivityLocked()-&gt; realStartActivityLocked() IApplicationThread接口简介重点在最后的方法里realStartActivityLocked()调用了，app.thread.scheduleLaunchActivity()方法final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; //...代码省略 final ActivityStack stack = task.stack; try &#123; //...代码省略 app.forceProcessStateUpTo(mService.mTopProcessState); app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); //...代码省略 &#125; catch (RemoteException e) &#123; &#125; return true;&#125; scheduleLaunchActivity()方法是IApplicationThread接口里面的方法，但是是由那个类实现的呢，这里就需要猜了，哈哈 下面几个类都实现了相同的接口IApplicationThread：private class ApplicationThread extends ApplicationThreadNative &#123;&#125;public abstract class ApplicationThreadNative extends Binder implements IApplicationThread&#123;&#125;class ApplicationThreadProxy implements IApplicationThread &#123;&#125;public interface IApplicationThread extends IInterface &#123;&#125; IApplicationThread的源码在这里：android.googlesource IApplicationThread是实现了IInterface接口的，说明也是用的Binder远程通讯，这里的当前进程是system_process，本地代理类应该是ApplicationThreadProxy类，而这个类是内部类，在ApplicationThreadNative类中 来看ApplicationThreadProxy类的scheduleLaunchActivity()方法：public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); //....写入数据 mRemote.transact(SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 记住这个标识，SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION，在ApplicationThreadNative类的onTransact()方法里找： 这里注意，调用完mRemote.transact()方法，回调的onTransact()方法已经不再system_process进程中了，而是到了App进程：foo.bar.multi //onTransact()方法里：case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); // 取出数据 scheduleLaunchActivity(intent, b, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, ri, pi, notResumed, isForward, profilerInfo); return true; &#125; 取出各种数据，在调用scheduleLaunchActivity()方法。 这里的cheduleLaunchActivity()在哪里实现？感觉应该在ApplicationThreadService类里。但是并没有这个类。其实应该是ApplicationThread类，不叫XXXService了，这个类实现了ApplicationThreadNative接口，同时它是ActivityThread的内部类 到这里总结下IApplicationThread接口的Binder机制： 客户端：ApplicationThread &lt;=====Binder驱动&lt;===== ApplicationThreadProxy：服务器对比之前的IActivityManager：客户端：ActivityManagerProxy =====&gt;Binder驱动=====&gt; ActivityManagerService：服务器有没有发现Binder只能单向传递。 这两次的Binder通信如下图所示： 再来看ApplicationThread类的scheduleLaunchActivity()方法// we use token to identify this activity without having to send the// activity itself back to the activity manager. (matters more with ipc)@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 在继续看接收消息的地方，在H类里（H类继承了Handler），public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; //.... handleLaunchActivity()-&gt;performLaunchActivity()。 performLaunchActivity()通过ClassLoader导入相应的Activity类，然后把它启动起来，注意看代码里的注释。Activity activity = null;try &#123; //通过ClassLoader将foo.bar.multi.XXXActivity类加载进来： java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125;&#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e);try &#123; //创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的 Application app = r.packageInfo.makeApplication(false, mInstrumentation); //代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到XXXActivity中去： if (activity != null) &#123; activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); //调用activity的onCreate函数，上面提到过这个方法： mInstrumentation.callActivityOnCreate(activity, r.state); 无论是通过点击应用程序图标来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都要借助于应用程序框架层的ActivityManagerService服务进程。在Android应用程序框架层中，ActivityManagerService是一个非常重要的接口，它不但负责启动Activity和Service，还负责管理Activity和Service。 Android应用程序框架层中的ActivityManagerService启动Activity的过程大致如下图所示： 在这个图中，ActivityManagerService和ActivityStack位于同一个进程中，而ApplicationThread和ActivityThread位于另一个进程中。其中，ActivityManagerService是负责管理Activity的生命周期的，ActivityManagerService还借助ActivityStack是来把所有的Activity按照后进先出的顺序放在一个堆栈中；对于每一个应用程序来说，都有一个ActivityThread来表示应用程序的主进程，而每一个ActivityThread都包含有一个ApplicationThread实例，它是一个Binder对象，负责和其它进程进行通信。 下面简要总结一下启动的过程： Step 1. 无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口； Step 2. ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息； Step 3. ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread代表的是调用ActivityManagerService.startActivity接口的进程，对于通过点击应用程序图标的情景来说，这个进程就是Launcher了，而对于通过在Activity内部调用startActivity的情景来说，这个进程就是这个Activity所在的进程了； Step 4. ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity； Step 5. 对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动； Step 6. ActivityManagerServic调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作； Step 7. ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。 补充，通过Launcher启动ActivityAndroid的Launcher本身也是一个应用程序，点击应用图标，调用的方法还是Activity.startActivity()。与之前分析的不同之处是在ActivityStackSupervisor.startSpecificActivityLocked()方法中：void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); //区别在这里，Launcher启动方式，app为null，应用内启动app不为null if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !\"android\".equals(r.info.packageName)) &#123; // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; //所以要执行ActivityServiceManager的去开启一个新的进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 每一个应用程序都有自己的uid，uid + process的组合就可以为每一个应用程序创建一个ProcessRecord。当然，我们可以配置两个应用程序具有相同的uid和package，或者在AndroidManifest.xml 配置文件的application标签或者activity标签中显式指定相同的process属性值，这样，不同的Activity可以运行在不同的进程中。 mService.startProcessLocked()方法最终会调用到下面的代码去开启新的进程Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); 新的进程会导入android.app.ActivityThread 类，并且执行它的main方法，这个main方法其实就是一个应用进程的入口方法。这就是为什么我们前面说每一个应用程序都有一个ActivityThread实例来对应的原因。 在main方法中，调用了自身的attach方法，在attach方法中：private void attach(boolean system) &#123; //... final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; //...&#125; 在ActivityManagerService的attachApplication()方法中又调用了ttachApplicationLocked()方法：private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; //...代码省略 // See if the top visible activity is waiting to run in this process... if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown launching activities in \" + app, e); badApp = true; &#125; &#125; // Find any services that should be running in this process... if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown starting services in \" + app, e); badApp = true; &#125; &#125; // Check if a next-broadcast receiver is in this process... if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123; try &#123; didSomething |= sendPendingBroadcastsLocked(app); &#125; catch (Exception e) &#123; // If the app died trying to launch the receiver we declare it 'bad' Slog.wtf(TAG, \"Exception thrown dispatching broadcasts in \" + app, e); badApp = true; &#125; &#125; //...代码省略 这个方法中最终调用了ActivityStackSupervisor类的attachApplicationLocked()方法，而attachApplicationLocked()方法又调用了realStartActivityLocked()方法。 后面的过程就基本与普通Activity启动模式一样了。 参考资料Android源码分析-Activity的启动过程 罗老师的，Android应用程序的Activity启动过程简要介绍和学习计划和 Android应用程序启动过程源代码分析 【凯子哥带你学Framework】Activity启动过程全解析 Android系统篇之—-解读AMS远端服务调用机制以及Activity的启动流程 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/08/02/activity-start-process/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Binder","slug":"binder","permalink":"http://agehua.github.io/tags/binder/"},{"name":"AOSP","slug":"aosp","permalink":"http://agehua.github.io/tags/aosp/"},{"name":"AMS","slug":"ams","permalink":"http://agehua.github.io/tags/ams/"}]},{"title":"Mac下Android源码编译（AOSP）","slug":"aosp-compile","date":"2017-07-31T16:00:00.000Z","updated":"2017-11-23T07:16:20.000Z","comments":true,"path":"2017/08/01/aosp-compile/","link":"","permalink":"http://agehua.github.io/2017/08/01/aosp-compile/","excerpt":"Android源码下载Mac上源码下载没有太大问题，主要参考下面两篇文章：自己动手编译最新Android源码及SDK谷歌下载源代码\nMac上创建磁盘空间，直接区分大小写hdiutil resize -size 100g ~/android.dmg.sparseimage\n我编译的是7.1.1版本的系统源码，所以给了100G空间\nAndroid Build系统","text":"Android源码下载Mac上源码下载没有太大问题，主要参考下面两篇文章：自己动手编译最新Android源码及SDK谷歌下载源代码 Mac上创建磁盘空间，直接区分大小写hdiutil resize -size 100g ~/android.dmg.sparseimage 我编译的是7.1.1版本的系统源码，所以给了100G空间 Android Build系统 代码下载完成以后，不着急编译，先了解下Android Build系统，看下IBM的这篇文章：Android Build系统 Android Build 系统用来编译 Android 系统，Android SDK 以及相关文档。该系统主要由 Make 文件，Shell 脚本以及 Python 脚本组成，其中最主要的是 Make 文件。 主要编译步骤初始化编译环境：source build/envsetup.sh 这句话的意思是引入build/envsetup.sh脚本。该脚本的作用是初始化编译环境，并引入一些辅助的 Shell 函数，这其中就包括下面使用 lunch 函数。lunch 执行完lunch函数，可以看到下面的结果：You're building on DarwinLunch menu... pick a combo: 1. aosp_arm-eng 2. aosp_arm64-eng 3. aosp_mips-eng 4. aosp_mips64-eng 5. aosp_x86-eng 6. aosp_x86_64-eng 7. full_fugu-userdebug 8. aosp_fugu-userdebug 9. mini_emulator_arm64-userdebug 10. m_e_arm-userdebug 11. m_e_mips-userdebug 12. m_e_mips64-eng 13. mini_emulator_x86-userdebug 14. mini_emulator_x86_64-userdebug 15. aosp_dragon-userdebug 16. aosp_dragon-eng 17. aosp_marlin-userdebug 18. aosp_sailfish-userdebug 19. aosp_flounder-userdebug 20. aosp_angler-userdebug 21. aosp_bullhead-userdebug 22. hikey-userdebug 23. aosp_shamu-userdebugWhich would you like? [aosp_arm-eng] 这里的lunch是选择编译目标，直接输入数字就代表选中 编译目标格式说明: 编译目标的格式:BUILD-BUILDTYPE,比如上面的第一个，aosp_arm-eng的BUILD是aosp_arm,BUILDTYPE是eng. 那么选择哪个编译目标呢？这里StackOverflow上有提问，建议编译aosp_x86-userdebug with HAXM installed 但是我的lunch并没有列出这个编译目标： 所以这里不使用lunch选择，而是使用choosecombo命令： 记住也要先执行envsetup.sh脚本哟 choosecomboBuild type choices are: 1. release 2. debugWhich would you like? [1]//这里直接输入2，选择第二个Which product would you like? [aosp_arm]//这里并没有对应的BUILD，所以直接自己输入：aosp_x86Variant choices are: 1. user 2. userdebug 3. eng//这里选择第二个，直接输入2 这样就选择好了编译目标，对应的Terminal的顶部标题也已经改变然后调用“make -j4”进行编译就可以了 make 的参数“-j”指定了同时编译的 Job 数量，这是个整数，该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（例如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16） 下面介绍几个常用到的命令：当电脑磁盘空间不够用时，用下面的命令，遍历大文件sudo ncdu //查看硬盘中的大文件 如果make失败，或是想换一个BUILD类型，使用下面的命令：make clobber //清理out目录下的文件 调试Android源码：参考这篇文章：自己动手调试Android源码 将Android源码导入Android Studio：source build/envsetup.shmmm development/tools/idegen/sudo ./development/tools/idegen/idegen.sh 上面代码执行完后，会在源码目录下生成IEDA工程配置文件: android.ipr,android.iml及android.iws.可以发现android.ipr文件的应用图标应该改成了Android Studio样式。 但这里不用Android Studio来打开工程，而是使用IntelliJ来查看和DebugAndroid源码，具体参考这篇文章使用 IntelliJ 查看 Android 源码 单独编译Android源代码工程的模块在Android源码找到目录/packages/experimental，在这个目录下有Google提供基于前面提到的Android BUILD模式构建的apk工程。如下图： 我们选择一个工程：MultiPackageApk，要把它安装到模拟器上需要执行下面的命令：source build/envsetup.shmmm packages/experimental/MultiPackageApk make snod 重启下模拟器，刚才安装的应用就会出现了 单独编译源代码工程出错： ninja: error: 'out/target/common/obj/JAVA_LIBRARIES/core-junit_intermediates/classes.dex.toc', needed by 'out/target/common/obj/APPS/MultiPackageApk_intermediates/with-local/classes.dex', missing and no known rule to make itmake: *** [ninja_wrapper] Error 1 解决方案：应该选择好编译环境后（用lunch或choosecombo命令），再执行单独编译源码工作，最后别忘了执行make snod make failed to build some targets (4 seconds)使用 IntelliJ Debug Android 源码参考这篇文章：使用 IntelliJ Debug Android 源码 文中，有一个地方跟我的电脑上不太一样： 打开 monitor 选择 debug 进程我电脑上的monitor不是用命令行打开，而是有monitor.app。位置在：/Library/Android_sdk/tools/lib/monitor-x86_64/monitor.app如下图： 到这里Android源码部分的内容就整理完了，下篇文章利用Android源码分析下Activity的启动流程。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/08/01/aosp-compile/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"AOSP","slug":"aosp","permalink":"http://agehua.github.io/tags/aosp/"},{"name":"sdk compile","slug":"sdk-compile","permalink":"http://agehua.github.io/tags/sdk-compile/"}]},{"title":"Android免root实现hook系统服务拦截方法","slug":"android-noroot-hook","date":"2017-07-11T16:00:00.000Z","updated":"2017-11-23T07:25:44.000Z","comments":true,"path":"2017/07/12/android-noroot-hook/","link":"","permalink":"http://agehua.github.io/2017/07/12/android-noroot-hook/","excerpt":"本文转载自博文：Android系统篇之—-免root实现Hook系统服务拦截方法，结合最新开源的滴滴插件化方案 VirtualApk 对hook系统服务进行分析。\n360之前开源了一款插件框架 Droid Plugin。与滴滴同一天，360又开源了一款插件框架 RePlugin。\n有关新闻介绍在这里：https://www.itcodemonkey.com/article/278.html                https://www.itcodemonkey.com/article/277.html\n关于360两款插件框架有什么不同，可以查看RePlugin里的readme\n本文简单结合VirtualApk源码来记录实现hook系统服务方法。\nAndroid免root实现hook系统服务拦截方法Binder机制回顾","text":"本文转载自博文：Android系统篇之—-免root实现Hook系统服务拦截方法，结合最新开源的滴滴插件化方案 VirtualApk 对hook系统服务进行分析。 360之前开源了一款插件框架 Droid Plugin。与滴滴同一天，360又开源了一款插件框架 RePlugin。 有关新闻介绍在这里：https://www.itcodemonkey.com/article/278.html https://www.itcodemonkey.com/article/277.html 关于360两款插件框架有什么不同，可以查看RePlugin里的readme 本文简单结合VirtualApk源码来记录实现hook系统服务方法。 Android免root实现hook系统服务拦截方法Binder机制回顾 在之前一篇文章中介绍了 Android中的Binder机制和系统远程服务调用机制，本文将继续借助上一篇的内容来实现Hook系统服务拦截指定方法的逻辑，了解了上一篇文章之后，知道系统的服务其实都是一个远程Binder对象，而这个对象都是由ServiceManager大管家管理的，用户在使用系统服务的时候，会通过指定服务的Stub方法的asInterface把远程的Binder对象转化成本地化对象即可使用，而在这个过程中，我们也知道因为系统服务是在system_server进程中的，所以这个系统服务使用过程中属于跨进程调用，那么返回的对象其实就是Proxy代理对象。 系统中服务使用流程本文主要就是借助这个知识点，通过Hook系统的服务来拦截服务方法，下面我们就通过系统剪切板服务案例作为分析//获取剪切板服务ClipboardManager cm =(ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);//设置剪切板内容cm.setPrimaryClip(ClipData.newPlainText(\"data\",\"jack\"));//获取剪切板数据对象ClipData cd = cm.getPrimaryClip();String msg = cd.getItemAt(0).getText().toString();Log.d(\"jw\", \"msg:\"+ msg); 这里看到了，使用系统服务的时候都是用了getSystemService方法，通过定义在Context中的服务描述符常量来获取服务对象，而getSystemService方法定义在ComtextImpl.java类中：@Overridepublic Object getSystemService(String name) &#123; ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name); return fetcher == null ? null : fetcher.getService(this);&#125; 这里维护了一个ServiceFetcher的Map结构，看看这个结构在哪里填充数据的：private static void registerService(String serviceName, ServiceFetcher fetcher) &#123; if (!(fetcher instanceof StaticServiceFetcher)) &#123; fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++; &#125; SYSTEM_SERVICE_MAP.put(serviceName, fetcher);&#125; 在registerService方法中添加一个服务名称和一个ServiceFetcher对象，而这个方法在静态代码块中进行调用的:static &#123; registerService(ACCESSIBILITY_SERVICE, new ServiceFetcher() &#123; public Object getService(ContextImpl ctx) &#123; return AccessibilityManager.getInstance(ctx); &#125;&#125;); //... registerService(CLIPBOARD_SERVICE, new ServiceFetcher() &#123; public Object createService(ContextImpl ctx) &#123; return new ClipboardManager(ctx.getOuterContext(), ctx.mMainThread.getHandler()); &#125;&#125;); //.... registerService(CONNECTIVITY_SERVICE, new ServiceFetcher() &#123; public Object createService(ContextImpl ctx) &#123; IBinder b = ServiceManager.getService(CONNECTIVITY_SERVICE); return new ConnectivityManager(IConnectivityManager.Stub.asInterface(b)); &#125;&#125;); //....&#125; ClipboardManager这个服务也在这个代码块中注册了 这里其实是一个ClipboardManager对象，其实这个对象是内部封装了IClipboard.Stub功能，可以看看其他的服务，比如上面的联网服务，直接调用了IConnectivityManager.Stub类的asInterface方法获取Proxy对象。 下面就进去ClipboardManager.java中看看究竟：public void setPrimaryClip(ClipData clip) &#123; try &#123; if (clip != null) &#123; clip.prepareToLeaveProcess(); &#125; getService().setPrimaryClip(clip, mContext.getOpPackageName()); &#125; catch (RemoteException e) &#123; &#125;&#125; 看到这里的设置剪切板内容的方法，其实内部是调用了getService方法获取对象然后在调用指定方法，那么可以大概知道了这个getService方法返回的应该就是IClipboard.Stub通过asInterface方法返回的Proxy对象：static private IClipboard getService() &#123; synchronized (sStaticLock) &#123; if (sService != null) &#123; return sService; &#125; IBinder b = ServiceManager.getService(\"clipboard\"); sService = IClipboard.Stub.asInterface(b); return sService; &#125;&#125; 吧，果然是这样，这里通过ServiceManager获取到Clipboard的远端IBinder对象，然后通过asInterface方法返回一个Proxy对象即可。 到这里我们就简单的分析完了系统中的获取剪切板的服务，其实系统中的服务都是这么个逻辑，只是有的可能会在外面包装一层罢了，下面总结一下流程： 现在只要记住一点：每次获取系统服务的流程都是一样的，先通过ServiceManager的getService方法获取远端服务的IBinder对象，然后在通过指定服务的Stub类的asInterface方法转化成本地可使用对象，而这个对象其实就是一个Proxy对象，在这个过程中，Stub类继承了Binder对象和实现了AIDL接口类型，Proxy对象实现了AIDL接口类型，而AIDL接口类型实现了IInterface接口类型。 Hook系统服务上面分析完了Android中系统服务的使用流程以及原理解析，下面在来看一下android中实现Hook机制的方法和原理解析，我们知道其实在很多系统中都存在这样一个Hook技术，有的也叫作钩子，但是不管任何系统，Hook技术的核心点都是一样的，只有两点即可完成Hook技术： 1、找到Hook点，即你想Hook哪个对象，那么得先找到这个对象定义的地方，然后使用反射获取到这个对象实例。所以这里可以看到，一般Hook点都是一个类的单例方法或者是静态变量，因为这样的话Hook起来就非常方便，都是static类型，反射调用都比较方便无需具体的实例对象即可。而关于这个点也是整个Hook过程中最难的点，因为很难找到这个点。Android中主要是依靠分析系统源码类来做到的。 2、构造一个Hook原始对象的代理类，关于这个代理其实在Java中有两种方式，一种是静态代理，一种是动态代理。 静态代理：代理类中维护一个原始对象的成员变量，每个方法调用之前调用原始对象的方法即可。无需任何条件限制 动态代理：比静态代理复杂点就是有一个规则：就是原始对象必须要实现接口才可以操作，原理是因为动态代理其实是自动生成一个代理类的字节码，类名一般都是Proxy$0啥的，这个类会自动实现原始类实现的接口方法，然后在使用反射机制调用接口中的所有方法。 下面结合VirtualApk源码，分析这个原理： 这里的代码与原博文里的代码有所不同，原博文是结合DroidPlugin进行分析 在VirtualApk的源码com/didi/virtualapk/delegate/目录下，有两个Proxy结尾的类，这两个类动态代理模式相同，我们只看一个。在IContentProviderProxy.java文件中public class IContentProviderProxy implements InvocationHandler &#123; //.....代码省略 public static IContentProvider newInstance(Context context, IContentProvider iContentProvider) &#123; return (IContentProvider) Proxy.newProxyInstance(iContentProvider.getClass().getClassLoader(), new Class[] &#123; IContentProvider.class &#125;, new IContentProviderProxy(context, iContentProvider)); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Log.v(TAG, method.toGenericString() + \" : \" + Arrays.toString(args)); wrapperUri(method, args); try &#123; return method.invoke(mBase, args); &#125; catch (InvocationTargetException e) &#123; throw e.getTargetException(); &#125; &#125; //...代码省略&#125; 看到这里，了解java AOP技术的已经知道IContentProviderProxy这个类使用了java.lang.ref.proxy方案来实现动态生成代理类。 不了解ASM和InvocationHandler的同学可以看IBM的这篇文章：AOP 的利器：ASM 3.0 介绍 简单介绍下java本身的动态代理机制在java的动态代理机制中，有两个重要的类或接口，一个是InvocationHandler(Interface)、另一个则是Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。 这里借用上面IBM的文章中的例子：Account类是一个接口，具体操作由AccountImpl类实现public interface Account &#123; void operation();&#125; public class AccountImpl extends Account&#123; public void operation() &#123; System.out.println(\"operation...\"); //TODO real operation &#125;&#125; 现在的要求是在Account的operation()方法执行前加入一个checkSecurity()检查。 那么使用InvocationHandler和Proxy的实现方式就是：class SecurityProxyInvocationHandler implements InvocationHandler &#123; private Object proxyedObject; public SecurityProxyInvocationHandler(Object o) &#123; proxyedObject = o; &#125; @Override public Object invoke(Object object, Method method, Object[] arguments) throws Throwable &#123; if (object instanceof Account &amp;&amp; method.getName().equals(\"opertaion\")) &#123; SecurityChecker.checkSecurity(); &#125; return method.invoke(proxyedObject, arguments); &#125;&#125; public static void main(String[] args) &#123; Account account = (Account) Proxy.newProxyInstance( Account.class.getClassLoader(), new Class[] &#123; Account.class &#125;, new SecurityProxyInvocationHandler(new AccountImpl()) ); account.function();&#125; 总结如下： InvocationHandler这个接口只有一个方法invoke()： Object invoke(Object proxy, Method method, Object[] args) throws Throwable proxy: 指代我们所代理的那个真实对象 method: 指代的是我们所要调用真实对象的某个方法的Method对象 args: 指代的是调用真实对象某个方法时接受的参数 每一个动态代理类都必须要实现InvocationHandler这个接口，当我们通过代理对象（这里就是account对象）调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke方法来进行调用 Proxy类使用的最多的就是newProxyInstance这个方法： public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException loader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载 interfaces: 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了 h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 Proxy类并不负责实例化对象，newProxyInstance()方法的作用是动态创建一个代理对象的类。 Proxy动态生成代理的不足之处在于： Proxy 是面向接口的，所有使用 Proxy 的对象都必须定义一个接口，而且用这些对象的代码也必须是对接口编程的：Proxy 生成的对象是接口一致的而不是对象一致的：例子中 Proxy.newProxyInstance 生成的是实现 Account接口的对象而不是 AccountImpl 的子类。这对于软件架构设计，尤其对于既有软件系统是有一定掣肘的。 Proxy 毕竟是通过反射实现的，必须在效率上付出代价：有实验数据表明，调用反射比一般的函数开销至少要大10倍。而且，从程序实现上可以看出，对 proxy class 的所有方法调用都要通过使用反射的 invoke 方法。因此，对于性能关键的应用，使用 proxy class 是需要精心考虑的，以避免反射成为整个应用的瓶颈。 对比VirtualApk框架中的 IContentProviderProxy 类，和上面Account例子里的 SecurityProxyInvocationHandler 类，可以发现，IContentProviderProxy 使用了 InvocationHandler 的动态代理机制，而代理的具体内容就在invoke()回调里。 好的，现在在回到VirtualApk的IContentProviderProxy源码的invoke()方法里。invoke() 方法中调用了wrapperUri()，来看下这个方法：private void wrapperUri(Method method, Object[] args) &#123; Uri uri = null; int index = 0; if (args != null) &#123; for (int i = 0; i &lt; args.length; i++) &#123; if (args[i] instanceof Uri) &#123; uri = (Uri) args[i]; index = i; break; &#125; &#125; &#125; //如果挂钩的是call方法 Bundle bundleInCallMethod = null; if (method.getName().equals(\"call\")) &#123; bundleInCallMethod = getBundleParameter(args); if (bundleInCallMethod != null) &#123; String uriString = bundleInCallMethod.getString(KEY_WRAPPER_URI); if (uriString != null) &#123; uri = Uri.parse(uriString); &#125; &#125; &#125; //... PluginManager pluginManager = PluginManager.getInstance(mContext); //这里根据uri找到对应的ContentProvider ProviderInfo info = pluginManager.resolveContentProvider(uri.getAuthority(), 0); if (info != null) &#123; String pkg = info.packageName; LoadedPlugin plugin = pluginManager.getLoadedPlugin(pkg); String pluginUri = Uri.encode(uri.toString()); StringBuilder builder = new StringBuilder(PluginContentResolver.getUri(mContext)); builder.append(\"/?plugin=\" + plugin.getLocation()); builder.append(\"&amp;pkg=\" + pkg); builder.append(\"&amp;uri=\" + pluginUri); Uri wrapperUri = Uri.parse(builder.toString()); if (method.getName().equals(\"call\")) &#123; bundleInCallMethod.putString(KEY_WRAPPER_URI, wrapperUri.toString()); &#125; else &#123; args[index] = wrapperUri; &#125; &#125;&#125; 1.从wrapperUri()的第二个参数找到Uri 2.调用resolveContentProvider()方法，根据uri找到占坑的ContentProvider public ProviderInfo resolveContentProvider(String name, int flags) &#123; return this.mProviders.get(name);&#125; ProviderInfo对象的解释就是：Holds information about a specific content provider 3.使用StringBuilder对，将uri，pkg，plugin等参数等拼接上去，替换到args中的uri，然后继续走原本的流程。 假设是调用了query方法，应该就可以到达占坑的provider的query方法了。这就是插件框架里传说中的占坑，即不用注册就可以启动插件里的组件啦 剪切板实例到此我们了解了Java中的Hook技术的核心知识点了，下面就用开始的剪切板服务来做实验，我们Hook系统的剪切板服务功能，拦截其方法，上面也说道了，既然要Hook服务，首先得找到Hook点，通过开始对Android中系统服务的调用流程分析知道，其实这些服务都是一些保存在ServiceManager中的远端IBinder对象，这其实是一个Hook点： public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in getService\", e); &#125; return null;&#125; 其实ServiceManager中每次在获取服务的时候，其实是先从一个缓存池中查找，如果有就直接返回了：private static HashMap&lt;String, IBinder&gt; sCache = new HashMap&lt;String, IBinder&gt;(); 这个缓存池正好是全局的static类型，所以就可以很好的使用反射机制获取到它了，然后进行操作了 接下来，我们就需要构造一个剪切板的服务IBinder对象了，然后在把这个对象放到上面得到的池子中即可。 那么按照上面的动态代理的流程（使用Proxy Java原生动态代理） 第一、原始对象必须实现一个接口，这里也正好符合这个规则，每个远程服务其实是实现了IBinder接口的。 第二、其次是要有原始对象，这个也可以，通过上面的缓存池即可获取。 有了这两个条件那么接下来就可以使用动态代理构造一个代理类了：try &#123; //下面这一段的意思其实就是ServiceManager.getService(\"clipboard\") //只不过ServiceManager这个类是@hide的 Class&lt;?&gt; serviceManager = Class.forName(\"android.os.ServiceManager\"); Method getService = serviceManager.getDeclaredMethod(\"getService\", String.class); //取得ServiceManager里的原始的clipboard binder对象 //一般来说这是一个Binder代理对象 IBinder rawBinder =(IBinder) getService.invoke(null, Context.CLIPBOARD_SERVICE); //Hook掉这个Binder代理的queryLocalInterface 方法 //然后在queryLocalInterface返回一个IInterface对象，hook掉我们感兴趣的方法即可 IBinder hookedBinder =(IBinder) Proxy.newProxyInstance( serviceManager.getClassLoader, new Class&lt;?&gt;[](IBinder.class), new IClipboardHookBinderHandler(rawBinder) ); //放回ServiceManager中，替换掉原有的 Field cacheField = serviceManager.getDeclaredField(\"sCache\"); cacheField.setAccessible(true); @SuppressWarnings(&#123;\"unchecked\"&#125;) Map&lt;String, IBinder&gt; cache = (Map&lt;String,IBinder&gt;) cacheField.get(null); cache.put(Context.CLIPBOARD_SERVICE, hookedBinder);&#125;catch (Exception e)&#123;&#125; Field.get()可以返回一个Object，字段不是静态字段的话，要传入反射类的对象。如果传null是会报 java.lang.NullPointerException。但是如果字段是静态字段的话,传入任何对象都是可以的,包括null 这里是通过反射去获取ServiceManager中的缓存池Binder对象。我们先获取到缓存池，然后得到剪切板服务Binder对象，构造一个代理类，最后在设置回去即可。 下面主要来看一下构造了代理类之后，如何拦截哪些方法？@Overridepublic Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; if (method.getName().equals(\"queryLocalInterface\")) &#123; Log.d(TAG, \"hook queryLocalInterface\"); //这里直接返回真正被hook掉的Service接口 //这个代理类必须实现IInterface接口 return Proxy.newProxyInstance( base.getClassLoader, new Class&lt;?&gt;[](this.iinterface), new HookBinderInvocationHander(base,stub) ); &#125; return method.invoke(base, args);&#125; 因为拦截的是queryLocalInterface()方法，这个方法返回的是一个远端的服务，还没有转化为本地对象，所以不能去拦截具体的服务方法 这里一定要注意了，有的同学可能想直接在这里拦截setPrimaryClip这样的剪切板方法不就可以了吗？想想是肯定不可以的，为什么呢？因为我们现在代理的是远端服务的Binder对象，他还没有转化成本地对象呢？如何会有这些方法呢，而我们真正要拦截的方法是IClipboardManager，其实就是Proxy类，而这个对象也是Stub类的asInterface方法得到的，所以我们现在的思路是有了远端服务的代理对象，拦截肯定是拦截这个代理对象Binder的一些方法，那么这个远端服务有哪些方法会在这个过程中被调用呢？我们再看看之前的一个简单AIDL的例子：public static com.agehua.aidldemo.Demo asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; //这里的obj就是远端对象，它通过queryLocalInterface()方法获取本进程中的服务，这里就是hook点 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.agehua.aidldemo.Demo))) &#123; return ((com.agehua.aidldemo.Demo) iin); &#125; return new com.agehua.aidldemo.Demo.Stub.Proxy(obj);&#125; 然后在想，我们如果想拦截IClipboardManager的setPrimaryClip方法，其实就是要拦截ClipboardManager$Proxy的这些方法，那么还需要做一次代理，代理ClipboardManager$Proxy类对象 第一、ClipboardManager$Proxy类实现了AIDL接口类型，符合规则。 第二、我们可以直接使用反射获取到IClipboardManager$Stub类，然后反射调用它的asInterface方法就可以得到了IClipboardManager$Proxy对象了，符合规则。 public IClipboardHookBinderHandler(IBinder base) &#123; this.base = base; try &#123; this.stub =Class.forName(\"android.content.IClipboard$Stub\"); this.iinterface = Class.forName(\"android.content.IClipboard\"); &#125;catch (ClassNotFoundException e)&#123; &#125;&#125; 到这里，看来这个对象也符合了代理的条件，那么就简单了，继续使用动态代理机制产生一个代理类即可：public IClipboardHookBinderHandler(IBinder base, Class&lt;?&gt; stubClass) &#123; try &#123; Method asInterfaceMethod = stubClass.getDeclaredMethod(\"asInterface\", IBinder.class); this.base = asInterfaceMethod.invoke(null, base); &#125;catch (Exception e)&#123; throw new RuntimeException(\"hooked failed\") &#125;&#125; 这个代理类的InvocationHandler中，先需要通过反射获取到Proxy原始对象：@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; if (\"getPrimaryClip\".equals(method.getName())) &#123; return ClipData.newPlainText(null, \"you are hooked\"); &#125; //欺骗系统，使之认为剪切板上一直有内容 if (\"hasPrimaryClip\".equals(method.getName())) &#123; return true; &#125; //千万不要忘了调用原始对象的方法 return method.invoke(base, args);&#125; 到这里就已经完成了hook剪切板服务的整个步骤，再看一下流程图： 1、我们的目的就是拦截系统的服务功能，那么最开始的入口就是服务大管家ServiceManager对象，而在他内部也正好有一个远端服务对象的IBinder缓存池，那么这个变量就是我们操作的对象了，可以先使用反射机制去获取到他，然后在获取到指定的剪切板服务IBinder对象实例。 2、下一步肯定是Hook这个剪切板服务的Binder对象，这里采用动态代理方式产生一个Binder对象代理类，符合两个规则： 1) 这个Binder对象实现了IBinder接口类型 2) 我们已经得到了原始的Binder对象实例构造完代理类之后，我们拦截的方法是queryLocalInterface方法，为什么是这个方法呢？因为在整个服务使用过程中之后在Stub类中使用到了这个方法，很多同学会认为为什么不在这里直接拦截系统方法呢？这是一个误区，要想清楚，这里的代理对象是远程服务的Binder，还不是本地化对象，不能会有哪些系统方法的，所以得再做一次Hook，去Hook住系统的本地化对象。 3、在拦截了Binder对象的queryLocalInterface方法之后，再一次做一下本地化服务对象的代理生成操作，而这个本地化对象一般都是IClipboard$Proxy，那么动态代理的规则： 1) 本地化服务对象都会实现AIDL接口类型(这里才有哪些我们想拦截的系统方法) 2) 通过反射调用IClipboard$Stub类的asInterface方法得到IClipboard$Proxy类对象实例符合这两个规则那么就可以产生代理对象了，然后开始拦截服务的指定方法即可。 这个Hook系统服务只对本应用有效。真正能够拦截系统并对所有应用有效的，需要hook进system_server进程中，所以就需要root权限 总结到这里我们就介绍完了Android中Hook系统服务的流程，本文中主要介绍了Hook系统剪切板服务，拦截指定方法。同时，对VirtualApk插件框架感兴趣的同学也可以看看张鸿洋的这篇文章： 滴滴插件化方案 VirtualApk 源码解析 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/07/12/android-noroot-hook/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Binder","slug":"binder","permalink":"http://agehua.github.io/tags/binder/"},{"name":"HOOK","slug":"hook","permalink":"http://agehua.github.io/tags/hook/"},{"name":"Android system service","slug":"android-system-service","permalink":"http://agehua.github.io/tags/android-system-service/"}]},{"title":"Android Binder机制分析（二）","slug":"android-binder-principle2","date":"2017-07-09T16:00:00.000Z","updated":"2017-11-23T07:15:48.000Z","comments":true,"path":"2017/07/10/android-binder-principle2/","link":"","permalink":"http://agehua.github.io/2017/07/10/android-binder-principle2/","excerpt":"背景上篇文章分析到了Binder机制，分别介绍了自定义AIDL服务和调用系统的远程服务和他们之间的区别。本文承接上篇文章，继续介绍ServiceManager和系统服务的注册流程，最后对Binder机制进行分析。\n\n关于系统服务的注册流程，大都转载自这篇文章\n\n服务大管家ServiceManager\nServiceManager.java的源码可以在谷歌源码中看到，点击这里\n\n上篇文章末尾提到，系统服务的IBinder对象都是由ServiceManager统一管理的。为什么这么说呢，先看下ServiceManager.getService方法:","text":"背景上篇文章分析到了Binder机制，分别介绍了自定义AIDL服务和调用系统的远程服务和他们之间的区别。本文承接上篇文章，继续介绍ServiceManager和系统服务的注册流程，最后对Binder机制进行分析。 关于系统服务的注册流程，大都转载自这篇文章 服务大管家ServiceManager ServiceManager.java的源码可以在谷歌源码中看到，点击这里 上篇文章末尾提到，系统服务的IBinder对象都是由ServiceManager统一管理的。为什么这么说呢，先看下ServiceManager.getService方法:/** * Returns a reference to a service with the given name. * * @param name the name of the service to get * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn't exist */public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in getService\", e); &#125; return null;&#125; sCache是一个本地静态Map对象，作为缓存池：private static HashMap&lt;String, IBinder&gt; sCache = new HashMap&lt;String, IBinder&gt;(); ServiceManager本身会维护一个IBinder缓存池，也是为了效率高考虑，对于一个应用频繁的使用一些服务的话效率就会高很多。 然后最核心的获取服务的方法是getIServiceManager方法：private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject()); return sServiceManager;&#125; 在上面的代码中，调用了ServiceManagerNative.asInterface()方法，是不是说明ServiceManager也通过远端服务来取得对应的服务呢？ 具体在看一下ServiceManagerNative.java方法：public abstract class ServiceManagerNative extends Binder implements IServiceManager&#123; /** * Cast a Binder object into a service manager interface, generating * a proxy if needed. */ static public IServiceManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj); &#125; //....&#125; 看到上面的代码，基本可以确认，在获取ServiceManager对象也是通过了远程调用。只是名字改成了ServiceManagerNative，本应该叫ServiceManagerService的。 看到这里的ServiceManager也是通过远端服务获取到他的IBinder对象，然后在转化成本地对象进行使用的。那么刚刚看到系统的服务都是通过ServiceManager管理获取的，而现在ServiceManager本身是怎么获取到的IBinder对象的呢？这个就要从系统启动的时机看了，众所周知系统启动的时候是根据init.rc文件进行操作的： service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm 这里会启动一个servicemanager服务，那么就要去service_manager.c程序中的入口程序看了： 这个入口其实包含了Binder机制的重要信息，而主要就是三件事： 1、打开底层的Binder驱动程序，这个后面介绍Binder机制在介绍 2、通过向binder程序发送命令：BINDER_SET_CONTEXT_MGR，告诉binder程序，我要成为大管家 3、进入循环监听上层应用的服务请求处理，所以这里可以看到其实ServiceManager是一个守护进程在后台默默监听 在第二步中成为大管家的代码深入看一看： 其实这里的逻辑也是比较简单的，首先创建一个属于servicemanager的binder节点，然后在创建一个binder链表，而这个链表的作用就是存放上层中需要系统服务的所有binder对象的节点，这样ServiceManager就可以实现了服务的增加和查询操作了。 再来看看ServiceManager的添加服务操作： 添加服务比较复杂，首先查看这个服务有没有注册权限限制，不是所有的服务都能注册的，然后在查看这个服务是不是已经被注册过了，最后在通知binder驱动程序注册一个服务即可。 然后在来看看ServiceManager的查找服务功能： 查找服务就比较简单了，直接通过服务的描述符名称遍历binder链表节点即可。 1、Service Manager能集中管理系统内的所有服务，它能被施加权限控制，并不是任何进程都能注册服务的。 2、Service Manager支持通过字符串名称来查找对应的Service。 3、由于各种原因的影响，Server进程可能生死无常。如果有了Service Manager做统一的管理，那么Client只要向Service Manager做查询，就能得到Server的最新信息。 系统服务注册流程分析这部分内容也可以参考博客：Android深入浅出之Binder机制 下面来看一下一些系统服务是如何进程注册的，这里用MediaService来进行查看吧。 系统中的MediaService服务的启动也是在init.rc中的service media /system/bin/mediaserver class main user media group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm ioprio rt 4 查看Main_mediaserver.cpp源码的main函数：int main(int argc, char** argv)&#123; //获得一个ProcessState实例 sp&lt;ProcessState&gt; proc(ProcessState::self()); //得到一个ServiceManager对象 sp&lt;IServiceManager&gt; sm = defaultServiceManager(); MediaPlayerService::instantiate();//初始化MediaPlayerService服务 ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool();&#125; sp是google搞出来的为了方便C/C++程序员管理指针的分配和释放的一套方法，就把它当做一个普通的指针看待，sp&lt;XXX&gt;就看成是XXX*就可以了 这里用MediaPlayerService来看看注册操作：void MediaPlayerService::instantiate() &#123; defaultServiceManager()-&gt;addService( String16(\"media.player\"), new MediaPlayerService()); )&#125; 看到熟悉的代码了把，这里通过ServiceManager来进行服务注册了，那么这里是如何获取到ServiceManager的？sp&lt;IServiceManager&gt; defaultServiceManager() &#123; if (gDefaultServiceManager != NULL) return gDefaultServiceManager; &#123; AutoMutex _l(gDefaultServiceManagerLock); //---&gt;锁保护 while (gDefaultServiceManager == NULL) &#123; gDefaultServiceManager = interface_cast&lt;IServiceManager&gt; ( ProcessState::self()-&gt;getContextObject(NULL)); if (gDefaultServiceManager == NULL) sleep(1); &#125; &#125; return gDefaultServiceManager;&#125; 看看ProcessState.cpp的源码：sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller) &#123; return getStrongProxyForHandle(0);&#125; 看看getStrongProxyForHandle方法实现： 这里看到了，会使用IPCThreadState的transact方法和底层的Binder进行通信的，然后使用一个句柄handle构造一个BpBinder对象，而BpBinder对象其实就是native层实现的Binder对象，以后只要看到Bp开头的就是代理对象对应Java层的Proxy对象，Bn开头的就是native对象对应Java层的Stub对象。 在上面分析servicemanager的时候知道会维护一个binder节点链表，那里其实就有一个每个binder对应句柄handle，而后续进行通信的话都是通过这个句柄来标识是哪个服务的binder对象了，这样也就在通信的时候不会发生紊乱了，而servicemanager的句柄handle就是0。还有一个知识点就是可以看到IPC通信的时候传输数据使用的就是Parcel类，这个类就是为了跨进程通信产生的，他有一个方法readStrongBinder，就是可以从Parcel的数据中获取到Binder对象，这个也是在跨进程中传递Binder对象的核心地方。public final IBinder readStrongBinder() &#123; return nativeReadStronBinder(mNativePtr);&#125; 好了，上面就通过系统的mediaserver服务来讲解了系统服务的注册流程： 到这里就分析完了Android中的远程服务调用机制逻辑以及ServiceManager这个服务大管家的作用: 1、首先跨进程通信的话，肯定会有两个对象：一个是本地端的中间者Proxy对象，一个是远程端的中间者Stub对象 2、Proxy对象通过静态代理模式维持一个远端传递过来的Binder对象，而Stub对象可以把远端传递过来的Binder对象转化成一个实际服务对象给应用使用 3、Android中在使用系统服务的时候通过getSystemService方法获取到的其实都是Stub把远端的Binder转化的对象，因为系统服务都是在system_server进程中，所以肯定是跨进程获取对象的，那么这个Binder对象其实就是上面的Proxy对象 4、系统的服务都是在一个指定的系统进程中system_server 5、服务大管家ServiceManager在系统启动的时候也是先获取自生的Binder对象，然后转化成实际操作对象，然后才可以操作系统服务的注册和查询功能 下面是系统一些服务的注册流程： 上面已经介绍了远程服务调用机制以及ServiceManager的实现原理，下面就要看看另外一个重点，也是上面提到的一个重要对象Binder，准确来说这个是Binder机制，在Android中Binder机制最复杂的一个架构系统了，它的设计很复杂，所以有很多同学在了解Binder机制的时候，总是看着看着就晕了，今天我们就直说重点，而且说得要相对明了简单。 Binder机制解析第一、Android中的IPC为何要采用Binder机制Binder是Android系统进程间通信(IPC)方式之一。Linux已经拥有的进程间通信IPC手段包括(Internet Process Connection)：管道(Pipe)、信号(Signal)和跟踪(Trace)、插口(Socket)、报文队列(Message)、共享内存(Share Memory)和信号量(Semaphore)。 Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送发添加UID,PID身份，既支持实名Binder也支持匿名Binder，安全性高。对Binder而言，Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。 第二、Android中的Binder实现原理其实Android中的Binder通信都是通过虚拟驱动设备程序/dev/binder来实现的，我们知道一些硬件都会对应一个驱动程序，而binder驱动程序没有对应的硬件，所以叫做虚拟驱动设备程序，其实他就是一个字符驱动设备，或者叫做miscdevice混杂设备驱动。 其实混杂驱动设备是字符设备的一种，它们共享一个主设备号(10)，但次设备号不同，所有的混杂设备形成一个链表，对设备访问时内核根据次设备号查找到相应的miscdevice设备。例如:触摸屏，LED，按键，串口。即：为了节约主设备号，将某些设备用链表的形式连接在一起，最后通过查找次设备区分。这里用主设备无法匹配出设备驱动，只能找到链表，再通过次设备号，才能找到设备驱动。而之前所学的，一般字符设备，通过主设备号，就能找到设备驱动了。我们可以通过命令查看/dev/binder驱动的主设备号： 第三、Android中Binder通信机制先来看一张图，我们可以大体的了解到了客户端和服务端通过Binder驱动进行通信 首先不管是客户端进程还是服务端进程都是在用户空间的，而binder驱动是在内核空间的，通信的数据是有规定格式也叫作IPC数据，既然是一种通信机制，肯定是需要协议，数据格式等基础结构信息的： 上面在分析了ServiceManager的启动的时候说到了，第一步是打开驱动程序，具体打开函数在binder.c中： 在使用一个驱动之前，肯定要先打开驱动，然后把驱动程序映射到内存中，接着借助IPCTreadState.cpp和binder驱动进行通信了： 所以看到这里IPCThreadState也是需要进入后台进行监听的，处理来自客户端和服务端的数据传输消息 最后再来看一下通信时序图。 到这里我们就介绍完了Binder机制了，关于Binder机制最好不要看太深，因为越深你觉得越复杂越难理解，其实你只要了解到他是一个通信工具，通信采用的是驱动操作，通过传输IPC数据来进行通信即可。其他的关于他的详细数据格式和通信协议，感兴趣的同学可以了解一下，但是太过复杂而且在实际中也没多大用途，所以这里就不介绍了。 技术点概要理解远程服务通信机制通过案例先了解到本地端和服务端跨进程通信，主要就是借助Binder进行功能调用，而在这里主要有两个核心类，一个是Stub类，这个类是继承了Binder类具备了将远程传递的Binder对象转化成本地实际对象asInterface方法即可，同时实现了IXXX接口，需要实现AIDL中的功能方法，还有一个类就是Proxy类，实现了IXXX接口，同时内部保留着远端传递的Binder对象，然后通过这个对象调用远端方法。这里Stub类就是服务端的中间者，而Proxy就是本地端的中间者。 系统服务调用流程通过分析了跨进程通信机制原理之后，再去看看Android系统中在使用一些服务的时候，通过getSystemService方法获取服务对象，其实这内部就是通过跨进程获取到了远端服务的Binder对象，然后转化成系统服务对象给应用调用，而这些系统服务的Binder对象在系统启动的时候服务会自动注册到ServiceManager中。 服务大管家ServiceManager在整个远程服务调用过程中两个重要对象，一个是Binder对象，一个就是ServiceManager类，这个类是管理系统服务的类，他可以注册服务，查询服务，系统服务在系统启动的时候会通过addService进行服务注册，然后应用就可以通过getService进行服务查询，而在这个过程中，底层会维护一个这些服务的binder链表结构，同时每个服务的binder对象都一个句柄handle，通过这个句柄来表示通信标识，这样通信才不会紊乱。 底层通信核心Binder最后分析了底层真正实现跨进程通信的机制Binder，其实是通过虚拟驱动程序/dev/binder进行通信的。一个通信机制肯定有通信协议，传输的数据结构，但是这里并没有介绍这些知识，原因是我们后面的需求并不会用到这些，其次是这些知识点太详细介绍也不好，因为会越看越乱。 总结本文介绍的东东有点多，但是如果掌握了Android中的Binder机制和远程服务调用机制对后面拦截系统api做了铺垫，说到结束了才告诉大家为什么要介绍这个知识点，是因为最近在研究如何拦截系统启动Activity的事，那么就必须了解Activity的启动流程，但是在这个过程中有一个对象就是ActivityManagerService，而他就和Binder以及远程服务调用机制紧密联系了，如果不了解Binder机制，后面工作是没办法进行的，好了，说到最后再来一张神图算是总结了本文内容： 这张图非常好的表达了Android中应用使用系统服务的一个流程，也是最好的最全的解释了。看懂这张图之后，那么对Android中的binder机制和远程服务调用机制就可以掌握了，可以进行后续的拦截操作了。 参考文献：Android系统篇之—-Binder机制和远程服务调用机制分析 进击的Android注入术《五》 Android深入浅出之Binder机制 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/07/10/android-binder-principle2/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"AIDL","slug":"aidl","permalink":"http://agehua.github.io/tags/aidl/"},{"name":"Binder","slug":"binder","permalink":"http://agehua.github.io/tags/binder/"}]},{"title":"Android Binder机制分析（一）","slug":"android-binder-principle","date":"2017-07-07T16:00:00.000Z","updated":"2017-11-23T07:15:37.000Z","comments":true,"path":"2017/07/08/android-binder-principle/","link":"","permalink":"http://agehua.github.io/2017/07/08/android-binder-principle/","excerpt":"背景分析最近在学习Android非侵入Hook机制，\n6月30日，360开源RePlugin，安卓进入“全面插件化”时代：https://www.itcodemonkey.com/article/278.html\n同一天，滴滴开源Android端插件化框架VirtualAPK：https://www.itcodemonkey.com/article/277.html\n然后本人发现竟然可以不在清单文件中注册就可以启动Activity，还有这种操作？哈哈。后面会有单独的文章介绍这种骚操作。\n在搜索中发现了这篇博客，Android系统篇之—-Binder机制和远程服务调用机制分析。本文大部分转载自原来博客，结合自己的分析，是研究Hook机制前的知识储备。\nAndroid中远程服务调用分析简单介绍，跨进程调用一个远程服务需要下面这几步：","text":"背景分析最近在学习Android非侵入Hook机制， 6月30日，360开源RePlugin，安卓进入“全面插件化”时代：https://www.itcodemonkey.com/article/278.html 同一天，滴滴开源Android端插件化框架VirtualAPK：https://www.itcodemonkey.com/article/277.html 然后本人发现竟然可以不在清单文件中注册就可以启动Activity，还有这种操作？哈哈。后面会有单独的文章介绍这种骚操作。 在搜索中发现了这篇博客，Android系统篇之—-Binder机制和远程服务调用机制分析。本文大部分转载自原来博客，结合自己的分析，是研究Hook机制前的知识储备。 Android中远程服务调用分析简单介绍，跨进程调用一个远程服务需要下面这几步： 1.定义一个AIDL文件：Demo.aidl 类似于定义接口类型，这个AIDL文件将在本地和远端都要使用到 package com.agehua.aidldemo;interface Demo &#123; int sendData(String data); String getData();&#125; 2.定义远程服务在远程服务中的onBind方法，实现AIDL接口的具体方法，并且返回Binder对象//远程服务，应该定义在另个一进程中public class DemoService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; //返回远程的Binder对象，并且实现类 return new Demo.Stub() &#123; @Override public int sendData(String data) throws RemoteException &#123; return 0; &#125; @Override public String getData() throws RemoteException &#123; return \"\"; &#125; &#125; &#125;&#125; 接口方法的具体传递实现都是在远端服务中。 3.本地创建连接对象本地创建一个服务连接对象，实现ServiceConnection接口，在连接成功之后，会得到一个远端传递过来的Binder对象，就是上面的远端服务onBind方法返回的，得到Binder对象之后在进行转化就可以得到AIDL对象，然后即可调用方法。 //连接远程服务的回调public class DemoConnection implements ServiceConnection &#123; @Override public void onServiceConnected(Component name, IBinder service) &#123; //连接成功后，会传递远端的Binder对象 Demo demo =Demo.Stub.asInterface(service); try &#123; demo.setData(\" \"); demo.getData(); &#125;catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(Component name) &#123; //断开连接 &#125;&#125; 连接成功后，从远端服务中获取到了Binder对象，然后在转化成本地接口对象，即可调用方法。 4、连接服务连接服务也是比较简单的，这时候把上面的连接对象传递进去即可 Intent intent = new Intent(this, DemoService.class);bindService(intent, new DemoConnection(), Context.BIND_AUTO_CREATE); AIDL实现机制分析上面的步骤就可以实现一个远程服务调用了。但是有一个核心的地方就是Demo.Stub类，这个类起着重要的作用，下面来分析一下它的实现： 每次定义了AIDL接口文件之后，编译一下就会在build/generated/source/目录中产生对应的java文件了： package com.agehua.aidldemo;//IInterface接口由AIDL类去实现。IInterface接口包含一个方法asBinder()public interface Demo extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. * 由Stub类实现Binder类和AIDL接口 */ public static abstract class Stub extends android.os.Binder implements com.agehua.aidldemo.Demo &#123; private static final java.lang.String DESCRIPTOR = \"com.agehua.aidldemo.Demo\"; public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.agehua.aidldemo.Demo interface, * generating a proxy if needed. * 将远端传过来的Binder对象转化成本地对象 */ public static com.agehua.aidldemo.Demo asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; //如果本地进程和服务端都在一个进程中，那么直接返回当前类的IInterface android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.agehua.aidldemo.Demo))) &#123; return ((com.agehua.aidldemo.Demo) iin); &#125; //如果本地进程和服务端不在一个进程中，则返回一个代理对象给客户端 return new com.agehua.aidldemo.Demo.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; //处理客户端发过来的请求方法，这里不详细展开了 @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_sendData: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _arg0; _arg0 = data.readString(); int _result = this.sendData(_arg0); reply.writeNoException(); reply.writeInt(_result); return true; &#125; case TRANSACTION_getData: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _result = this.getData(); reply.writeNoException(); reply.writeString(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; //稍后分析这个类 private static class Proxy implements android.app.IServiceConnection &#123; /** ... **/ &#125; &#125; //Demo.aidl提供的方法，由Proxy类去实现，这里不用实现 public int sendData(java.lang.String data) throws android.os.RemoteException; //Demo.aidl提供的方法，由Proxy类去实现，这里不用实现 public java.lang.String getData() throws android.os.RemoteException;&#125; 1、AIDL接口必须实现IInterface接口IInterface接口包含一个asBinder()方法，由这个方法进行转化对象功能，把当前的AIDL对象转化成一个IBinder对象。package android.os;public interface IInterface&#123; /** * Retrieve the Binder object associated with this interface. * You must use this instead of a plain cast, so that proxy objects * can return the correct result. */ public IBinder asBinder();&#125; 2、AIDL接口中肯定有一个静态实现类Stub这个类必须实现Binder类，以及本身的AIDL接口类型。那么这个类就具备了Binder类中的四个功能： 1.可以将Binder对象转化成AIDL对象，调用asInterface方法，可以看到这个方法其实和上面的asBinder方法对立的 2.通信方法onTransact实现，这个方法是最核心的用于通信之间的逻辑实现 3.通过queryLocalInterface方法可以根据类的描述符(字符串可以唯一标识这个远端服务的名称即可)获取到对应的AIDL对象(其实是IInterface类型的) 4.在构造方法中必须调用Binder中的attachInterface方法把当前服务对象和描述符进行关联 3、Stub类只是中间者，由Proxy类生成服务端的代理 为什么说是由Proxy类生成服务端的代理的呢？ 因为在上面的DemoConnection类中，生成本地Demo对象，是调用了Demo.Stub.asInterface(IBinder)这个方法。前面提到，服务端和客户端不在同一个进程的时候，asInterface()方法实际上调用了Demo.Stub.Proxy(IBinder)这个方法。 而且Demo.aidl中定义的抽象方法，具体都是由Proxy类去实现的。 Stub类，其实只是远端服务Binder对象的一个中间者，下面看代码： //实现了aidl接口类。private static class Proxy implements com.agehua.aidldemo.Demo &#123; //保存了一个mRemote变量，这个变量就是由服务端传递过来的IBinder对象 private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public int sendData(java.lang.String data) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(data); //调用Binder的transact()方法，会调用上面Stub类中的onTransact方法进一步处理 mRemote.transact(Stub.TRANSACTION_sendData, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public java.lang.String getData() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); //调用Binder的transact()方法，会调用上面Stub类中的onTransact方法进一步处理 mRemote.transact(Stub.TRANSACTION_getData, _data, _reply, 0); _reply.readException(); _result = _reply.readString(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125;&#125; Proxy是Stub类中的一个静态类，Proxy对象就是远端传递过来的Binder对象在本地的代理。这里用到的是静态代理模式。 在服务连接成功后，在onServiceConnected()方法中，返回一个服务端Binder对象，本地通过asInterface()方法生成的一个代理；Demo demo = Demo.Stub.asInterface(IBinder); 这个demo对象，就是客户端这边用户和服务端交互的中间者。我们在前面的Stub类的asInterface()方法实现中可以看到： 借助queryLocalInterface()方法根据服务描述符来获取对象，会把远端传递过来的Binder对象转化成一个本地对象：public IInterface queryLocalInterface(String descriptor) &#123; if (mDescriptor.equals(descriptor)) &#123; return mOwner; &#125; return null;&#125; 而这个mOwner和mDescriptor之间的对应关系就在attachInterface方法中进行初始化的，也就是在Stub类的构造方法中public void attachInterface(IInterface owner, String descriptor) &#123; mOwner = owner; mDescriptor = descriptor;&#125; 那么现在就清楚了，如果客户端和服务端是在一个进程中，那么其实queryLocalInterface获取的就是Stub对象，如果不在一个进程queryLocalInterface查询的对象肯定为null，因为new Demo.Stub()和Demo.Stub.asInterface(IBinder)方法分别是在远端进程和本地进程中调用的，在不同进程有不同虚拟机，肯定查不到mOwner对象的，所以这时候其实是返回的Proxy对象了。 通过上面的讲解之后，发现多进程服务通信基准就是借助Binder对象，先传递Binder对象，然后在把Binder转成可以使用的原生对象即可调用了，而对于Stub类和Proxy类其实就是相当于是服务端和客户端的中间者，把一些逻辑封装起来，这种设计也会显得不是那么凌乱： 分析系统服务调用流程其实系统中的一些服务使用的时候其实也是跨进程使用，比如下面来看一下著名的PackageManager，IPackageManager，PackageManagerService体系： PackageManagerService是Android系统中最常用的服务之一。它负责系统中Package的管理，应用程序的安装、卸载、信息查询等。PackageManager获取的信息即来自AndroidManifest.XML interface IPackageManager &#123; boolean isPackageAvailable(String packageName, int userId); PackageInfo getPackageInfo(String packageName, int flags, int userId); int getPackageUid(String packageName, int userId); int[] getPackageGids(String packageName); String[] currentToCanonicalPackageNames(String[] names); String[] canonicalToCurrentPackageNames(String[] names); PermissionInfo getPermissionInfo(String name, int flags) ParceledListSlice&lt;PermissionInfo&gt; queryPermissionsByGroup(String group, int flags) //...&#125; 上面代码在谷歌的源码中查到，详情点击链接 因为我们还没有编译源码，所以看不到IPackageManager.java，这里可能需要AIDL工具单独编译才能看到了：public interface IPackageManager extends android.os.IInterface &#123; //定义内部类Stub，派生自Binder，实现IPackageManager接口 public static abstract class Stub extends android.os.Binder implements android.content.pm.IPackageManager &#123; private static final java.lang.String DESCRIPTOR = \"android.content.pm.IPackageManager\"; publicStub() &#123; this.attachInterface(this,DESCRIPTOR); &#125; //...... //定义Stub的内部类Proxy，实现IPackageManager接口 private static class Proxy implements android.content.pm.IPackageManager&#123; //通过mRemote变量和服务端交互 private android.os.IBinder mRemote; Proxy(android.os.IBinderremote) &#123; mRemote = remote; &#125; //...... &#125; //......&#125; 这里看到了熟悉的远端服务中间者Stub和本地端的中间者Proxy类了，而这两个类的规则都和上面一样的。 下面来看一下远端服务实现代码PackageManagerService.java，(这个类就可以在IDE中看到了)：public class PackageManagerService extends IPackageManager.Stub &#123; static final String TAG = \"PackageManager\"; static final boolean DEBUG_SETTINGS = false; static final boolean DEBUG_PREFERRED = false; static final boolean DEBUG_UPGRADE = false; static final boolean DEBUG_DOMAIN_VERIFICATION = false; //...&#125; 实现了上面的的Stub类功能。 下面我们再走一遍获取PackageManager的流程：PackageManager pm = getPackageManager(); 而这个getPackageManager方法是在ContextImpl.java中实现的： @Overridepublic PackageManager getPackageManager() &#123; if (mPackageManager != null) &#123; return mPackageManager; &#125; IPackageManager pm = ActivityThread.getPackageManager(); if (pm != null) &#123; // Doesn't matter if we make more than one instance. return (mPackageManager = new ApplicationPackageManager(this, pm)); &#125; return null;&#125; 具体内容实现是在ActivityThread.getPackageManager()方法中：public static IPackageManager getPackageManager() &#123; if (sPackageManager != null) &#123; //Slog.v(\"PackageManager\", \"returning cur default = \" + sPackageManager); return sPackageManager; &#125; IBinder b = ServiceManager.getService(\"package\"); //Slog.v(\"PackageManager\", \"default service binder = \" + b); sPackageManager = IPackageManager.Stub.asInterface(b); //Slog.v(\"PackageManager\", \"default service = \" + sPackageManager); return sPackageManager;&#125; 看到了吧，IPackageManager.Stub.asInterface(b)中的参数b由ServiceManager.getService方法获取到。然后在使用Stub的asInterface方法进行转化成本地的PackageManager对象，其实就是那个Proxy对象。然后就可以通过PackageManager来调用方法和远端的PackageManagerService服务进行通信了。 而DemoService是在DemoConnection（继承自ServiceConnection）的onServiceConnected回调中得到远端的IBinder对象，然后获得Proxy对象。 这里与自定义远程服务然后调用的区别就是，系统的远程服务都是由ServiceManager保存的，也就是由系统去创建和管理；而自定义的远程服务由开发者去创建、维护和销毁 通过上面的PackageManager案例可以分析，我们在使用系统中的服务的时候的流程都是如此： 总结一下，每个应用在使用系统服务的时候，都会走这么几步： 1、调用getService(String serviceName)方法获取服务对象 2、而getSystemService一般都是在ContextImpl类中实现的，其实是调用了ServiceManager的getService方法 3、调用ServiceManager的getService方法获取远端服务的IBinder对象 4、有了远端服务的IBinder对象之后，在使用远端服务的中间者类Stub进行转化对象asInterface方法 5、因为系统中的服务获取都是肯定是跨进程的，远端服务都是在system_server进程中的，所以asInterface方法中返回的是Proxy代理对象，也就是本地端的中间者。 6、最后返回的对象其实就是这个Proxy对象，而这个对象内部使用了静态代理方式，内部有一个来自远端的mRemote变量即IBinder对象。然后直接调用方法其实就是调用mRemote的transact方法进行通信了。 所以在这个过程中可以看到有两个对象很重要，一个是ServiceManager，一个是IBinder对象。下篇文章再来一一介绍 参考文献： Android系统篇之—-Binder机制和远程服务调用机制分析 《Android上玩玩Hook？》: http://blog.csdn.net/yzzst/article/details/47318751 《进击的Android注入术&lt;一&gt;》:http://blog.csdn.net/l173864930/article/details/38455951 极客学院——深入理解Android卷②：http://wiki.jikexueyuan.com/project/deep-android-v2/powermanagerservice.html 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/07/08/android-binder-principle/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"AIDL","slug":"aidl","permalink":"http://agehua.github.io/tags/aidl/"},{"name":"Binder","slug":"binder","permalink":"http://agehua.github.io/tags/binder/"}]},{"title":"Handler替代TimerTask","slug":"handler-replace-timertask","date":"2017-05-17T16:00:00.000Z","updated":"2017-11-23T07:15:28.000Z","comments":true,"path":"2017/05/18/handler-replace-timertask/","link":"","permalink":"http://agehua.github.io/2017/05/18/handler-replace-timertask/","excerpt":"Handler替代TimerTask原文来自：http://www.mopri.de/2010/timertask-bad-do-it-the-android-way-use-a-handler/\n作者文中提到，使用TimerTask更新GUI，debug看起来可以，但实际上根本不起作用。同时作者发现，使用handler可以得到更好的表现。\n下面是一个例子，使用handler在100ms后启动一个Runnable:private Handler handler = new Handler();handler.postDelayed(runnable, 100);\n下面代码里有一个小技巧，实现每隔100ms运行一次Runnable，就像TimerTask的scheduleAtFixedRate()方法:","text":"Handler替代TimerTask原文来自：http://www.mopri.de/2010/timertask-bad-do-it-the-android-way-use-a-handler/ 作者文中提到，使用TimerTask更新GUI，debug看起来可以，但实际上根本不起作用。同时作者发现，使用handler可以得到更好的表现。 下面是一个例子，使用handler在100ms后启动一个Runnable:private Handler handler = new Handler();handler.postDelayed(runnable, 100); 下面代码里有一个小技巧，实现每隔100ms运行一次Runnable，就像TimerTask的scheduleAtFixedRate()方法: private Runnable runnable = new Runnable() &#123; @Override public void run() &#123; /* do what you need to do */ foobar(); /* and here comes the \"trick\" */ handler.postDelayed(this, 100); &#125;&#125;; 如何取消运行Runnable呢？只需要调用handler.removeCallback(runnable)就可以了。 这样做还有另一个有点，就是不用总是new Timer(Task)了，可以重复使用上面代码中的handler和runnable。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/05/18/handler-replace-timertask/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"TimerTask","slug":"timertask","permalink":"http://agehua.github.io/tags/timertask/"},{"name":"handler","slug":"handler","permalink":"http://agehua.github.io/tags/handler/"}]},{"title":"Android架构师积累","slug":"Object-Oriented","date":"2017-05-10T16:00:00.000Z","updated":"2017-11-23T07:15:17.000Z","comments":true,"path":"2017/05/11/Object-Oriented/","link":"","permalink":"http://agehua.github.io/2017/05/11/Object-Oriented/","excerpt":"Android架构师积累 ——By 高焕堂“-Oriented”的涵意◎ ”-Oriented”意味着一种信仰 。◎ ”Object-oriented”相信任何软件都是由对象所构成的，而且Nothing else 。\n”-Driven”的涵意; 例如:Model-driven、Use Case-driven– 其实”-driven”是”引导”，而不是大家常说的”驱动”。– 就向北极星引导我们，指出方向而已。也像汽车司机(Driver)只是引导汽车方向，并没有去驱动汽车;而是引擎才是驱动汽车。\n“-Centered”的涵意; 例如:Architecture-centered、 Architecture-centeric–一切软件开发的活动都围绕着架构，就像盛诞节的糖果和礼物都挂在圣诞树上一样。\n卡榫函数• 所谓「卡榫(Hook)」，就是用来接合两个东西的接口。如果两个东西于不同时间出现，则一方会预留虚空，给予另一边于未来时刻能以实体来填补该空间，两者虚实相依，就密合起来了。设计优良的卡榫，可以让实体易于新陈代谢、抽换自如(Plug and Play, 俗称PnP)。","text":"Android架构师积累 ——By 高焕堂“-Oriented”的涵意◎ ”-Oriented”意味着一种信仰 。◎ ”Object-oriented”相信任何软件都是由对象所构成的，而且Nothing else 。 ”-Driven”的涵意; 例如:Model-driven、Use Case-driven– 其实”-driven”是”引导”，而不是大家常说的”驱动”。– 就向北极星引导我们，指出方向而已。也像汽车司机(Driver)只是引导汽车方向，并没有去驱动汽车;而是引擎才是驱动汽车。 “-Centered”的涵意; 例如:Architecture-centered、 Architecture-centeric–一切软件开发的活动都围绕着架构，就像盛诞节的糖果和礼物都挂在圣诞树上一样。 卡榫函数• 所谓「卡榫(Hook)」，就是用来接合两个东西的接口。如果两个东西于不同时间出现，则一方会预留虚空，给予另一边于未来时刻能以实体来填补该空间，两者虚实相依，就密合起来了。设计优良的卡榫，可以让实体易于新陈代谢、抽换自如(Plug and Play, 俗称PnP)。 • 变与不变的分离(Separate code that changes from the code that doesn’t)是设计卡榫(Hook)函数及应用框架之基本原则和手艺。• 分离出变(Variant)与不变(Invariant)部份之后，就可以将不变部份写在父类别(Super- class)里，而变的部份就写在子类别 (Subclass)里。 在Java里，使用抽象(abstract)函数或可覆写(overridable)函数来实现卡榫函数。 IoC机制与Default函数卡榫函数实现IoC机制• 控制反转(IoC: Inversion of Control)• IoC机制源自于OO语言(如C++等)的类别 继承体系，例如C++语言中，基类的函数可以主动调用子类的函数，这就是典型的IoC机制• 基类与子类之间，主控权是在基类手上， 透过Hook函数来调用子类• 通常基类是撰写在先，而子类则撰写在后， 这种前辈拥有主导权，进而「控制」后辈 之情形，就通称为「控制反转」。 默认(Default)行为• 基类的重要功能:提供默认(预设)行为• 基类可事先定义许多「默认」(Default)函数。这些默认函数可让子类来继承(或调用)之。 interface IShape &#123; void template_paint(Graphics gr);&#125; // 一般接口 // Shape.javaimport java.awt.*;public abstract class Shape implements IShape &#123; public void template_paint(Graphics gr)&#123; //默认行为 invariant_paint(gr); //画背景 hook_paint(gr); //画前景 &#125; private void invariant_paint(Graphics gr)&#123; gr.setColor(Color.black); gr.fillRect(10,30, 200,100); &#125; abstract protected void hook_paint(Graphics gr);&#125; // Bird.javaimport java.awt.*;public class Bird extends Shape &#123; private void hook_paint(Graphics gr)&#123; //控制反转 gr.setColor(Color.cyan); gr.drawArc(30,80,90,110,40,100); gr.drawArc(88,93,90,100,40,80); gr.setColor(Color.white); gr.drawArc(30,55,90,150,35,75); gr.drawArc(90,80,90,90,40,80); &#125;&#125; 在Android中，子类Activity继承父类Activity，需要重写onCreate()方法，onCreate()方法就是基类主动调用，这也是IOC机制 认识EIT造形 有了架构设计造形的&lt;简单性&gt;，人们就很容易理解软件的复杂关系，进而提升了掌握软件系统复杂多变的能力，唯有熟谙此道，才能创造架构和产品的&lt;未来性&gt;。 高焕堂老师提出简单的EIT软件造形；则让人们能理解Android多层框架体系里的复杂关系 EIT造形是一种基本的结构(Structure)，一种概念(Concept)；我们称它为”EIT造形(Form)”。 强龙做&lt;E&amp;I&gt;，将&lt;T&gt;外包给地头蛇。 强龙掌控&lt;E&amp;I&gt;，外包就不会失控。 所以EIT造形支持当今主流的外包模式。 题目演练：由提供一个值N，由&lt;T&gt;通过不同的算法，如1+2+3+ … + N或1+2^2+ … + N^2进行计算，最后将计算结果传递给&lt;E&gt;。 现在可以试试先想想接口&lt;I&gt;设计:1.&lt;T&gt;必须有个抽象函数，被&lt;T&gt;反向调用(IoC)到&lt;T&gt;。在调用该函数时，顺便把&lt;E&gt;里的N值传递下去给&lt;T&gt;。2.由&lt;T&gt;进行计算工作，然后将计算结果传回给&lt;E&gt;。3.不同的算法就对应不同的&lt;T&gt;类 代码实现如下：//Counter.java，这就对应接口&lt;I&gt;public abstract class Counter &#123; public int run()&#123; int N = getCount(); return onCal(N); &#125; public int getCount() &#123; return 6; &#125; protected abstract int onCal(int n);&#125; //myCounter.java，是&lt;T&gt;类的一种算法public class myCounter extends Counter&#123; @Override protected int onCal(int n) &#123; int sum = 0; for(int i=1; i&lt;=n; i++) &#123; sum += i; &#125; return sum; &#125;&#125; //在&lt;E&gt;类中，调用方式如下counter = new myCounter();int sum = counter.run(); 框架(或架构)设计的关键任务就是接口(Interface)设计，这项接口是框架&lt;E&gt;与插件&lt;T&gt;之间的接口，这就是所谓的：框架API。 IPCIPC(Inter-Process Communication)通信， 是跨越两个不同进程(Process)之通信 IPC通信的效率 当我们启动某一支应用程序(App)时， Android系统里的Zygote服务孵化(Fork)一个新进程(Process)给它，然后将它(该App)加载到这个新诞生的进程里。 基于Linux的安全限制，以及进程的基本特性(例如，不同进程的地址空间是独立的)，如果两个类(或其对象)在同一个进程里执行时，两者沟通方便也快速 。 但是，当它们分别在不同的进程里执行时，两者沟通就属于IPC跨进程沟通了，不如前者方便，也慢些 一个进程是一个独立的执行空间，不会被正在其它进程里的程序所侵犯。这种保护方法是Android的重要安全机制。于是，得先认识进程的内涵，才能进一步了解跨进 程IPC机制。 在Android的进程里，有一个虚拟机(Virtual Machine，简称VM)的对象，可执行Java代码，也引导JNI本地程序的执行，实现Java与C/C++之间的沟通。如下图: 不同进程的地址空间是独立的 每一个进程在诞生时，都会诞生一个主线程(Main Thread)，以及诞生一个Looper类的对象和一个MQ(Message Queue)数据结构。每当主线程作完事情，就会去执行Looper类。 主线程最主要的工作就是处理UI画面的事件(Event)，每当UI事件发生时，Android框架会丢信息(Message)到MQ里。主线程看到MQ有新的信息时，就取出信息，然后依据信息内容而去执行特定的函数。执行完毕，就再继续执行Looper类，不断地观察MQ的动态。 IPC的IBinder接口 – 定义与实现大家都知道，当两个类都在同一个进程里执行时，两者之间的沟通，只要采取一般的函数调用(Function Call)就行了，既快速又方便。一旦两个类分别在不同的进程里执行时，两者之间的沟通，就不能采取一般的函数调用途径了。只好采取IPC沟通途径。 Android框架的IPC沟通仰赖单一的IBinder接口。此时Client端调用IBinder接口的transact()函数，透过IPC机制而调用到远方(Remote)的onTransact()函数。 Java层的IBinder 接口是定义于IBinder.java代码文档里// IBinder.java// .......public interface IBinder &#123;// ........public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException; // ...........&#125; IBinder接口定义了一些函数，可以让Client程序可以进行跨进程的调用(当然也能支持同进程的短程调用)。其中，最主要的一个函数就是: transact()函数 在Android的框架里，由Binder基类实现IBinder接口。 Binder基类的很重要目的是支持跨进程调 用Service，也就是让远程的Client可以跨 进程调用某个Service。Binder基类定义于Binder.java文件里:// Binder.java// .......public class Binder implements IBinder &#123; // .......... private int mObject; public Binder() &#123; init(); // ........... &#125; //用来实现IBinder的transact()函数接口 public final boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; // ................ boolean r = onTransact(code, data, reply, flags); return r; &#125; //其角色与transact()函数是相同的，只是这是用来让C/C++本地程序来调用的。 private boolean execTransact(int code, int dataObj, int replyObj, int flags) &#123; Parcel data = Parcel.obtain(dataObj); Parcel reply = Parcel.obtain(replyObj); boolean res; res = onTransact(code, data, reply, flags); // ............ return res; &#125; //这是一个抽象函数，让应用子类来覆写(Override)的. //上述的transact()和 execTransact()两者都是调用onTransact()函数来实现反向调用(IoC, Inversion of Control)的。 protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; &#125; //这是一个本地(Native)函数，让JNI模块来实现这个函数. //Binder()构造函数会调用这个init()本地函数 private native final void init();&#125; Binder就是EIT造形里的&lt;E&gt; 这个IBinder接口是Binder(即&lt;E&gt;)提供给Client的接口，简称为&lt;CI&gt; onTransact()就是EIT造形里的&lt;I&gt;，是支持&lt;基类/子类&gt;之间IoC调用的接口 示例：有一个Activity类别，它想跨进程去调用MediaPlayer播放引擎，以便播放MP3音乐. 类结构图如下： 在上图里，从myActivity到IBinder接口，画上了虚线箭头，表示那是抽象概念的。实际上，myActivity并没有直接调用Java层的IBinder接口，而是绕到底层C/C++和Binder驱动而间接调用到Binder基类的execTransact()函数，转而调用myBinder的onTransact()函数。如下图: IPC通信的三步骤还是用上面的MediaPlayer例子，其IPC通信的三个步骤是: Step-1. Activity使用startService()函數來启动Service。 Step-2. Activity调用bindService()来绑定Service。亦即，Activity建立与Service之间的连结(Connection)。 Step-3. Activity调用IBinder接口的transact() 函数，透过底层Binder Driver驱动而间接调用到Binder基类的execTransact()函数， 转而调用 myBinder的onTransact()函数。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/05/11/Object-Oriented/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Android Framework","slug":"android-framework","permalink":"http://agehua.github.io/tags/android-framework/"},{"name":"EIT","slug":"eit","permalink":"http://agehua.github.io/tags/eit/"},{"name":"Object-oriented","slug":"object-oriented","permalink":"http://agehua.github.io/tags/object-oriented/"}]},{"title":"注解在Android中的应用","slug":"Annotation-Android-usage","date":"2017-04-09T16:00:00.000Z","updated":"2017-11-23T07:25:29.000Z","comments":true,"path":"2017/04/10/Annotation-Android-usage/","link":"","permalink":"http://agehua.github.io/2017/04/10/Annotation-Android-usage/","excerpt":"注解在Android中的应用注解是Java语言的特性之一，它是在源代码中插入标签，这些标签在后面的编译或者运行过程中起到某种作用，每个注解都必须通过注解接口 @Interface 进行声明，接口的方法对应着注解的元素。\n在上一篇文章Injection(CDI)和assertion(断言)中介绍了Java中的CDI（上下文依赖注入）规范，这个规范就是使用注解的方式。这篇文章主要介绍注解在Android中的应用。\n先看看Android上著名的View注入框架Butterknife的Bind注解的源码：\n@Retention (RetentionPolicy.Class)@Target (ElementType.FIELD)public @interface Bind &#123;   /** View ID to which the field will be found. **/   int[] value();&#125;\n@interface 声明会创建一个实际的Java接口，与其他任何接口一样，注解也会编译成.class文件。@Retention 和@Target 下面会介绍到。\nJava注解的分类","text":"注解在Android中的应用注解是Java语言的特性之一，它是在源代码中插入标签，这些标签在后面的编译或者运行过程中起到某种作用，每个注解都必须通过注解接口 @Interface 进行声明，接口的方法对应着注解的元素。 在上一篇文章Injection(CDI)和assertion(断言)中介绍了Java中的CDI（上下文依赖注入）规范，这个规范就是使用注解的方式。这篇文章主要介绍注解在Android中的应用。 先看看Android上著名的View注入框架Butterknife的Bind注解的源码： @Retention (RetentionPolicy.Class)@Target (ElementType.FIELD)public @interface Bind &#123; /** View ID to which the field will be found. **/ int[] value();&#125; @interface 声明会创建一个实际的Java接口，与其他任何接口一样，注解也会编译成.class文件。@Retention 和@Target 下面会介绍到。 Java注解的分类 Java API中默认定义的注解叫做标准注解。它们定义在java.lang、java.lang.annotation和javax.annotation包中。按照使用场景不同，可以分为如下三类： 编译相关注解编译相关的注解是给编译器使用的，有以下几种： @Override：编译器检查被注解的方法是否真的重载了一个来自父类的方法，如果没有，编译器会给出错误提示。 @Deprecated：可以用来修饰任何不再鼓励使用或已被弃用的属性、方法等。 @SuppressWarnings：可用于除了包之外的其他声明项中，用来抑制某种类型的警告。 @SafeVarargs：用于方法和构造函数，用来断言不定长参数可以安全使用 @Generated：一般是给代码生成工具使用，用来表示这段代码不是开发者手动编写的，而是工具生成的。被@Generated修饰的代码一般不建议手动修改它。 @FunctionalInterface：用来修饰接口，表示对应得接口是带单个方法的函数式接口 资源相关注解一共有四个，一帮用在JavaEE领域，Android开发中应该不会用到，就不在详细介绍\b了。分别是： @PostConstruct @PreDestroy @Resource @Resources 元注解Butterknife的Bind注解用到的就是元注解。 元注解，顾名思义，就是用来定义和实现注解的注解，总共有如下五种： @Retention, 用来指明注解的访问范围，也就是在什么级别保留注解，有三种选择： 源码级注解：使用@Retention(RetentionPolicy.SOURCE)修饰的注解，该类型修饰的注解信息只会保留在 .java源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的 .class文件中。 编译时注解：使用@Retention(RetentionPolicy.CLASS)修饰的注解，该类型的注解信息会保留在 .java源码里和 .class文件里，在执行的时候会被Java虚拟机丢弃，不会加载到虚拟机中。 运行时注解：使用@Retention(RetentionPolicy.RUNTIME)修饰的注解，Java虚拟机在运行期间也保留注解信息，可以通过反射机制读取注解的信息未指定类型时，默认是CLASS类型。 @Target, 这个注解的取值是一个ElementType类型的数组，用来指定注解所使用的对象范围，共有十种不同的类型，如下表所示，同时支持多种类型共存，可以进行灵活的组合。 元素类型 适用于 ANNOTATION_TYPE 注解类型声明 CONSTRUCTOR 构造函数 FIELD 实例变量 LOCAL_VARIABLE 局部变量 METHOD 方法 PACKAGE 包 PARAMETER 方法参数或者构造函数的参数 TYPE 类（包含enum）和接口（包含注解类型） TYPE_PARAMETER 类型参数 TYPE_USE 类型的用途 如果一个注解的定义没有使用@Target修饰，那么它可以用在除了TYPE_USE和TYPE_PARAMETER之外的其他类型声明中 @Inherited, 表示该注解可以被子类继承的。 @Documented, 表示被修饰的注解应该被包含在被注解项的文档中（例如用JavaDoc生成的文档） @Repeatable, 表示这个注解可以在同一个项上面应用多次。不过这个注解是在Java 8中才引入的，前面四个元注解都是在Java 5中就已经引入。 运行时注解前面说过，要定义运行时注解只需要在声明注解时指定 @Retention(RetentionPolicy.RUNTIME)即可，运行时注解一般和反射机制配合使用。相比编译时注解性能比较低，但灵活性好，实现起来比较简单。 Butterknife在较低版本依然是通过运行时反射实现View的注入，性能较低下，不过在8.0.0版本以后使用编译时注解来提升性能。 运行时注解的简单使用下面展示一个Demo。其功能是通过注解实现布局文件的设置。 之前我们是这样设置布局文件的： @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_home);&#125; 如果使用注解，我们就可以这样设置布局了 @ContentView(R.layout.activity_home)public class HomeActivity extends BaseActivity &#123; ...&#125; 我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。 那么这样的注解是怎么实现的呢？很简单，往下看。 创建一个注解@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)public @interface ContentView &#123; int value();&#125; 前面已经讲过元注解，这不不再介绍。 对于：public @interface ContentView 这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。 （值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为ElementType.Type，并且从官方注解来看，interface是包含@interface的） /** Class, interface (including annotation type), or enum declaration */TYPE, 对于：int value(); 返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的@ContentView(R.layout.activity_home) R.layout.activity_home 实质是一个int型id，如果这样用就会报错： @ContentView(“string”) 关于注解的具体语法，可以看这篇文章Android编译时注解框架-语法讲解 注解解析注解申明好了，但具体是怎么识别这个注解并使用的呢？@ContentView(R.layout.activity_home)public class HomeActivity extends BaseActivity &#123; ...&#125; 注解的解析就在BaseActivity中。我们看一下BaseActivity代码public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //注解解析 for (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) &#123; ContentView annotation = (ContentView) c.getAnnotation(ContentView.class); if (annotation != null) &#123; try &#123; this.setContentView(annotation.value()); &#125; catch (RuntimeException e) &#123; e.printStackTrace(); &#125; return; &#125; &#125;&#125; 解释下上面的代码： 第一步：遍历所有的子类 第二步：找到修饰了注解ContentView的类 第三步：获取ContentView的属性值。 第四步：为Activity设置布局。 总结：要定义运行时注解，只需要在声明注解时指定@Retention(RetentionPolicy.RUNTIME)即可，运行时注解一般和反射机制配合使用，相比编译时注解性能比较低，但实现比较简单，会提高一定的开发效率。 编译时注解编译时注解能够自动处理Java源文件并生成更多的源码、配置文件、脚本或其他可能想要生成的东西。这些操作是通过注解处理器完成的。Java通过在编译期间调用 javac -processor命令可以调起注解处理器，它能够实现编译时注解的功能，从而提高函数库的性能。 定义注解处理器自定义编译时注解后，需要编写Processor类实现注解处理器，处理自定义注解。Processor继承自AbstractProcessor类并实现process方法，同时需要指定注解处理器能够处理的注解类型以及支持的Java版本，语句如下： public class JsonAnnotationProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment env)&#123; super.init(env); //初始化方法，会被注解处理工具调用，并传入ProcessingEnvironment类型参数， //这个参数包含了很多工具类，如Elements、Types、Filer等 elementUtils = env.getElementUtils(); typeUtils = env.getTypeUtils(); filer = env.getFiler(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; //指定这个注解处理器能够处理的注解类型，返回一个支持的类型字符串合集 return super.getSupportedAnnotationTypes(); &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; //指定注解处理器使用的Java版本 return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; //在这个方法中实现注解处理器的具体业务逻辑，根据输入参数roundEnv可以得到包含特定注解的被注解元素 //下面代码是Butterknife中这个方法的源码 Map&lt;TypeElement, BindingClass&gt; targetClassMap = findAndParseTargets(env); for (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingClass bindingClass = entry.getValue(); try &#123; JavaFileObject jfo = filer.createSourceFile(bindingClass.getFqcn(), typeElement); Writer writer = jfo.openWriter(); writer.write(bindingClass.brewJava()); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; error(typeElement, \"Unable to write view binder for type %s: %s\", typeElement, e.getMessage()); &#125; &#125; //返回值 表示这组 annotations 是否被这个 Processor 接受， //如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理 return true; &#125; //Butterknife源码：RoundEnvironment表示当前或是之前的运行环境，可以通过该对象查找找到相应的注解。 private Map&lt;TypeElement, BindingClass&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingClass&gt; targetClassMap = new LinkedHashMap&lt;TypeElement, BindingClass&gt;(); Set&lt;String&gt; erasedTargetNames = new LinkedHashSet&lt;String&gt;(); // Process each @Bind element. for (Element element : env.getElementsAnnotatedWith(Bind.class)) &#123; //所有被使用的@Bind注解 try &#123; parseBind(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, Bind.class, e); &#125; &#125; ...... &#125; &#125; 一个注解处理器，只能产生新的源文件，它不能够修改一个已经存在的源文件。当没有属于该Process处理的注解被使用时，process不会执行。 从Java7 开始，我们也可以使用注解来代替上面的getSupportedAnnotationTypes()和getSupportedSourceVersion()方法，代码如下：@SupportedAnnotationTypes(&#123; //该注解处理器支持的所有注解全名&#125;)@SupportedSourceVersion(SourceVersion.RELEASE_7)public class ContentViewProcessor extends AbstractProcessor &#123; ...&#125; Element类型所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。 Element的官方注释：Represents a program element such as a package, class, or method.Each element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine). 表示一个程序元素，比如包、类或者方法。 Element的子类有： ExecutableElement表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR) PackageElement表示一个包程序元素。提供对有关包极其成员的信息访问。对应@Target(ElementType.PACKAGE) TypeElement表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。对应@Target(ElementType.TYPE) 注意：枚举类型是一种类，而注解类型是一种接口。 TypeParameterElement表示一般类、接口、方法或构造方法元素的类型参数。对应@Target(ElementType.PARAMETER) VariableElement表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。对应@Target(ElementType.LOCAL_VARIABLE) Processor输出日志虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。Processor日志输出的位置在编译器下方的Messages窗口中。Processor支持最基础的System.out方法。 同样Processor也有自己的Log输出工具: Messager。//同样是Butterknife源码private void error(Element element, String message, Object... args) &#123; if (args.length &gt; 0) &#123; message = String.format(message, args); &#125; processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);&#125; 注册注解处理器为了让javac -processor能够对定义好的注解处理进行处理，我们需要将注解处理器打包到一个jar文件中，同时，需要在jar文件中增加一个名为javax.annotation.processing.processor的文件来指明jar文件中有哪些注解处理器，这个文件最终目录在jar文件根目录的META-INF/service目录中，jar文件解压后的目录结构如下图： javax.annotation.processing.Processor文件的内容是注解处理器全路径名，如果存在多个注解处理器，以换行进行分隔，代码看图片 源文件的目录是，我们需要在src/main/java同级目录中新建一个名为resources的目录，将META-INF/services/javax.annotation.processing.Processor文件放进去就行 注意，注解处理器所在的Android Studio工程必须是Java Library类型，而不应该是Android Library类型。因为Android Library的JDK中不包含某些javax包里面的类。 手动实现上面注册过程很繁琐，因此Google开源了一个名为AutoService的函数库，使用这个库后，只需在自定义Processor时使用@AutoService注解标记即可完成上面注册步骤。 @AutoService(Processor.class)@SupportedAnnotationTypes(&#123; //该注解处理器支持的所有注解全名&#125;)@SupportedSourceVersion(SourceVersion.RELEASE_7)public class ContentViewProcessor extends AbstractProcessor &#123; ...&#125; android-apt插件注解处理器所在的jar文件只能在编译期间起作用，到应用运行时不会用到，因此，在build.gradle中引入依赖时应该以provided方式，而不是compile方式引入。 当然，我们可以使用android-apt插件的方式。 APT(Annotation Processing Tool)是一种处理注释的工具,它对源代码文件进行检测找出其中的Annotation，使用Annotation进行额外的处理。注解处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由注解处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。 android-apt是在Android Studio中使用注解处理器的一个辅助插件，它的作用主要如下： 只在编译期间引入注解处理器所在的函数库作为依赖，不会打包到最终生成的APK中。 为注解处理器生成的源码设置好正确的路径，以便Android Studio能够正常找到，避免报错。 Project项目中使用apt使用该插件，添加如下到你的构建脚本中：//配置在Project下的build.gradle中buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; ... //替换成最新android-apt版本 classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125;apply plugin: 'com.neenbedankt.android-apt' 接着以apt的方式引入注解处理器函数库作为依赖dependencies &#123; apt'com.bluelinelabs:logansquare-compiler:1.3.6' compile 'com.bluelinelabs:logansquare:1.3.6'&#125; LoganSquare是一个实现了编译时注解以提高性能的JSON解析函数库。上面的compiler库就是LoganSquare的注解处理器。 在Module中使用apt在Module中build.gradle的配置 通常在使用的时候，使用apt声明注解用到的库文件。项目依赖可能分为多个部分。例如Dagger有两个组件Dagger-compiler和dagger。dagger-commpiler仅用于编译时，运行时必需使用dagger。//配置到Module下的build.gradle中apply plugin: 'com.android.application'apply plugin: 'com.neenbedankt.android-apt'dependencies &#123; apt 'com.squareup.dagger:dagger-compiler:1.1.0' compile 'com.squareup.dagger:dagger:1.1.0'&#125; provided vs apt使用注解处理器的不同？ provided 将会导入注解处理器的classes和它的依赖到IDE的类路径下。这意味着你可以附带的引入并使用这些classes。例如，当注解处理器使用Guava，你可能错误的import其相关代码到你的Android 代码中。当运行时将导致crash。 provided也可以用在重复引用的库上，避免依赖重复的资源。 而使用apt，注解处理器的classes将不会添加到你当前的类路径下，仅仅用于注解处理过程。并且会把所有注解处理器生成的source放在IDE的类路径下，方便Android Studio引用。 越来越多第三方库使用apt技术，如DBflow、Dagger2、ButterKnife、ActivityRouter、AptPreferences。在编译时根据Annotation生成了相关的代码，非常高大上但是也非常简单的技术，可以给开发带来了很大的便利。 APT处理annotation的流程注解处理器（AbstractProcess）+代码处理（javaPoet）+处理器注册（AutoService）+apt 具体流程： 1.定义注解（如@inject） 2.定义注解处理器 3.在处理器里面完成处理方式，通常是生成Java代码。 4.注册处理器 5.利用APT完成如下图的工作内容。 annotationProcessor介绍annotationProcessor是APT工具中的一种，他是google开发的内置框架，不需要引入，可以直接在build.gradle文件中使用，ButterKnife就是使用annotationProcessor处理注解，如下： dependencies &#123; annotationProcessor project(':xx') annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'&#125; apt vs annotationProcessor两者有何不同？ android-apt是由一位开发者自己开发的apt框架，源代码托管在这里，随着Android Gradle 插件 2.2 版本的发布，Android Gradle 插件提供了名为 annotationProcessor 的功能来完全代替 android-apt ，自此android-apt 作者在官网发表声明最新的Android Gradle插件现在已经支持annotationProcessor，并警告和或阻止android-apt ，并推荐大家使用 Android 官方插件annotationProcessor。 最近Android N的发布，android 迎来了Java 8，要想使用Java 8的话必须使用Jack编译，android-apt只支持javac编译而annotationProcessor既支持javac同时也支持jack编译。 想用annotationProcessor替代android-apt。删除和替换相应部分即可，具体可以参考这篇文章 文章参考： Android 打造编译时注解解析框架 这只是一个开始Android APT（编译时代码生成）最佳实践Android编译时注解框架系列1-什么是编译时注解你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注解《Android高级进阶》一书——注解在Android中的应用 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/04/10/Annotation-Android-usage/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"Annotation","slug":"annotation","permalink":"http://agehua.github.io/tags/annotation/"}]},{"title":"linux(centos) 搭建SVN服务器","slug":"SVN-server-linux","date":"2017-03-19T16:00:00.000Z","updated":"2017-11-23T07:14:05.000Z","comments":true,"path":"2017/03/20/SVN-server-linux/","link":"","permalink":"http://agehua.github.io/2017/03/20/SVN-server-linux/","excerpt":"linux(centos) 搭建SVN服务器安装步骤如下：\n第一步：安装SVNyum install subversion\n第二步：创建SVN版本库目录mkdir -p /var/svn/svnrepos\n第三步：创建版本库","text":"linux(centos) 搭建SVN服务器安装步骤如下： 第一步：安装SVNyum install subversion 第二步：创建SVN版本库目录mkdir -p /var/svn/svnrepos 第三步：创建版本库 svnadmin create /var/svn/svnrepos 第四步：进入conf目录（该SVN版本库配置文件）authz文件是权限控制文件passwd是帐号密码文件svnserve.confSVN服务配置文件 第五步：修改svnserve.conf文件vi svnserve.conf打开下面的几个注释： anon-access = read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz #使用哪个文件作为权限文件realm = /var/svn/svnrepos # 认证空间名，版本库所在目录 svnserve.conf、passwd、authz文件中各配置项前不要有空格 第六步：设置帐号密码vi passwd 在[users]块中添加用户和密码，格式：帐号=密码，如binjoo = 123456。 [users]binjoo = 123456 第七步：设置权限vi authz 在末尾添加如下代码： [groups][/]binjoo=rw 意思是版本库的根目录binjoo对其有读写权限。 第八步：启动svn版本库svnserve -d -r /var/svn/svnrepos 链接方式svn://127.0.0.1 遇到问题在客户端试图 svn merge 总是报svn: E220001: 遇到不可读的路径；拒绝访问。这个错误 提示 : SVN 遇到不可读的路径；拒绝访问。 英文是: Unreadable path encountered; access denied; 既然看不到日志又无法merge等操作. GOOGLE了一下，下面的方法解决了问题。 后面才发现是配置问题. 在项目的conf/svnserve.conf 中, 设置 anon-access = none 即可. 然后重启Subversion服务. 如果本地SVN客户端查看过日志会有缓存, 需要在 设置-&gt;日志缓存-&gt;缓存的版本库 中删除有问题的版本缓存 再重新查看日志就好了. linux svn启动和关闭 1，启动SVNsudo svnserve -d -r /var/svn/svnrepos 其中 -d 表示守护进程， -r 表示在后台执行/var/svn/svnrepos 为svn的安装目录 2，关闭SVN这里采取linux杀死进程的方式处理的ps -ef|grep svnserveroot 4967 1 0 Aug23 ? 00:00:00 svnserve -d -r repository/ 这里 kill -9 4967杀死进程， 此4967为进程号 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/03/20/SVN-server-linux/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://agehua.github.io/tags/linux/"},{"name":"svn server","slug":"svn-server","permalink":"http://agehua.github.io/tags/svn-server/"}]},{"title":"Injection(CDI)和assertion(断言)","slug":"JAVA-CDI-Assertion","date":"2017-03-13T16:00:00.000Z","updated":"2017-11-23T07:13:55.000Z","comments":true,"path":"2017/03/14/JAVA-CDI-Assertion/","link":"","permalink":"http://agehua.github.io/2017/03/14/JAVA-CDI-Assertion/","excerpt":"@Inject注解和CDI（上下文依赖注入）怎么让代码显得高大上呢，当然是多使用注解，那Android Support Annotation使用完了，有没有更高端的呢？\n这篇文章就简单介绍下Java中存在的注解。\nCDI（Contexts and Dependency Injection 上下文依赖注入）Java 依赖注入标准（JSR-330）规范，在javax.inject包中提供了一个接口Provider，和几个注解类型@Scope、@Inject、@Named、@Qualifier\n@Inject@Inject是javax.inject中提供的一个注解，可以不使用new关键字直接创建对象，怎么样，是不是很高端 :)\n在字段注解：用@Inject注解，字段不能是final的。可以拥有一个合法的名称","text":"@Inject注解和CDI（上下文依赖注入）怎么让代码显得高大上呢，当然是多使用注解，那Android Support Annotation使用完了，有没有更高端的呢？ 这篇文章就简单介绍下Java中存在的注解。 CDI（Contexts and Dependency Injection 上下文依赖注入）Java 依赖注入标准（JSR-330）规范，在javax.inject包中提供了一个接口Provider，和几个注解类型@Scope、@Inject、@Named、@Qualifier @Inject@Inject是javax.inject中提供的一个注解，可以不使用new关键字直接创建对象，怎么样，是不是很高端 :) 在字段注解：用@Inject注解，字段不能是final的。可以拥有一个合法的名称 doc文档原文： Injectable fields: - are annotated with @Inject. - are not final. - may have any otherwise valid name.@Inject FieldModifiers(opt) Type VariableDeclarators; (opt)这里表示可选 在方法上注解：用@Inject注解，不能是抽象方法，不能声明自身参数类型。可以有返回结果。拥有一个合法的名称。可以有0个或多个参数 doc文档原文： Injectable methods:- are annotated with @Inject.- are not abstract.- do not declare type parameters of their own.- may return a result- may have any otherwise valid name.- accept zero or more dependencies as arguments.@Inject MethodModifiers(opt) ResultType Identifier(FormalParameterList(opt)) Throws(opt) MethodBody (opt)这里表示可选 代码示例： @InjectWeatherDao weatherDao; @InjectWeatherDao(Context context) &#123; this.context = context;&#125; @Inject支持构造函数、方法和字段注解，也可能使用于静态实例成员。可注解成员可以是任意修饰符（private,package-private,protected,public）。注入顺序：构造函数、字段，然后是方法。父类的字段和方法注入优先于子类的字段和方法，同一类中的字段和方法是没有顺序的。 @Inject注解的构造函数可以是无参或多个参数的构造函数。@Inject每个类中最多注解一个构造函数。 除了@Inject注解，还有@Named、@Qualifier和@Provider，下面简单介绍一下。 @Named@Named，一般和@Inject一起使用，如果没有值生成的Bean名称默认和类名相同。 如果指定名称，那么就生成一个指定名称的Bean。public class Car &#123; @Inject @Named(\"driver\") Seat driverSeat; @Inject @Named(\"passenger\") Seat passengerSeat; ...&#125; @Qualifier自定义一个新的修饰语（注解），一个qualifier注解应该满足如下条件： 定义的注解类有@Qualifier，@Retention(RUNTIME)和@Documented。 可以有属性 可以是公共API的一部分 可以用@Target注解限定使用范围 doc文档原文是：Identifies qualifier annotations. Anyone can define a new qualifier. A qualifier annotation:- is annotated with @Qualifier, @Retention(RUNTIME), and typically @Documented.- can have attributes.- may be part of the public API, much like the dependency type, but unlike implementation types which needn't be part of the public API.- may have restricted usage if annotated with @Target. While this specification covers applying qualifiers to fields and parameters only, some injector configurations might use qualifier annotations in other places (on methods or classes for example). 下面是java doc文档@Named注解的生成代码@Qualifier@Documented@Retention(value=RUNTIME)public @interface Named @Documented @Retention(RetentionPolicy.RUNTIME) @Qualifier @Target(value = &#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE&#125;) public @interface Genre &#123; User user() default User.STUDENT; public enum User &#123;STUDENT, TEACHER&#125; &#125; @Named @Genre(user = User.STUDENT) public class StudentDAO implements IUserDAO&#123; @Override public int count() &#123; System.out.println(\"----StudentDAO----\"); return 0; &#125; &#125; @Provider@Provider注解，可以实现任意类型的对象的注入。相对于直接注入T对象，@Provider提供了一个T.get()方法来获取注入的对象 doc文档原文:Provides instances of T. Typically implemented by an injector. For any type T that can be injected, you can also inject Provider&lt;T&gt;. Compared to injecting T directly, injecting Provider&lt;T&gt; enables:- retrieving multiple instances.- lazy or optional retrieval of an instance.- breaking circular dependencies.- abstracting scope so you can look up an instance in a smaller scope from an instance in a containing scope. For example:class Car &#123;@Inject Car(Provider&lt;Seat&gt; seatProvider) &#123; Seat driver = seatProvider.get(); Seat passenger = seatProvider.get(); ... &#125;&#125; get方法解释T get() Provides a fully-constructed and injected instance of T. @Singleton使用该注解标记该类只创建一次，不能被继承。一般在类上用该注解。 doc原文:@Scope@Documented@Retention(value=RUNTIME)public @interface SingletonIdentifies a type that the injector only instantiates once. Not inherited. @Scope注解 @Scope 用于标识作用域注解。一个作用域注解是被标识在包含一个可注入构造器的类上的，用于控制该类型的实例如何被注入器重用。缺省情况下，如果没有标识作用域注解，注入器将为每一次注入都创建（通过注入类型的构造器）新实例，并不重用已有实例。如果多个线程都能够访问一个作用域内的实例，该实例实现应该是线程安全的。作用域实现由注入器完成。 在下面的例子中，作用域注解 @Singleton 确保我们始终只有一个 Log 实例： @Singletonclass Log &#123; void log(String message) &#123; ... &#125;&#125; 当多于一个作用域注解或不被注入器支持的作用域注解被使用在同一个类上时，注入器将生成一个错误。 一个作用域注解： 被标注了 @Scope、@Retention(RUNTIME) 标注的，通常也被 @Documented 标注。 不应该含有属性。 不应该被 @Inherited 标注，因此作用域与继承实现（正交）无关。 如果标注了 @Target 可能会有一些用法限制。 使用 @Scope 来标识一个作用域注解有助于注入器探测程序员使用了作用域注解但却忘了去配置作用域的情况。一个保守的注入器应该生成一个错误而不是去适用该作用域。 doc原文请点击 assertion(断言)在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告并且退出。 在语法上，为了支持assertion，Java增加了一个关键字assert。它包括两种表达式，分别如下： 1.assert expression1;2.assert expression1: expression2; expression1表示一个boolean表达式，expression2表示一个基本类型、表达式或者是一个Object，用于在失败时输出错误信息。 在运行时，如果关闭了assertion功能，这些语句将不起任何作用。 如果打开了assertion功能，那么expression1的值将被计算。 如果它的值为false，该语句强抛出一个AssertionError对象。 如果expression1值为true，expression2将不被计算。 如何关闭和开启assertion功能，请看这篇文章 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/03/14/JAVA-CDI-Assertion/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Injection","slug":"injection","permalink":"http://agehua.github.io/tags/injection/"},{"name":"assertion","slug":"assertion","permalink":"http://agehua.github.io/tags/assertion/"}]},{"title":"“HTTPS”安全在哪里？","slug":"Https-Questions","date":"2017-03-08T16:00:00.000Z","updated":"2017-11-23T07:13:29.000Z","comments":true,"path":"2017/03/09/Https-Questions/","link":"","permalink":"http://agehua.github.io/2017/03/09/Https-Questions/","excerpt":"\n文章转载自：“HTTPS”安全在哪里？ (出处: Bugly)\n\n\n背景最近基于兴趣学学习了下 HTTPS 相关的知识，在此记录下学习心得。\n在上网获取信息的过程中，我们接触最多的信息加密传输方式也莫过于HTTPS了。每当访问一个站点，浏览器的地址栏中出现绿色图标时，意味着该站点支持HTTPS信息传输方式。我们知道HTTPS是我们常见的HTTP协议与某个加密协议的混合体，也就是 HTTP+S。这个 S 可以是 TLS（安全传输层协议）、也可以是 SSL（安全套接层），不过我更认可另一个抽象概括的说法，HTTP+Security。不过要谈论 HTTPS 为何安全，还得从 HTTP 为何不安全说起。","text":"文章转载自：“HTTPS”安全在哪里？ (出处: Bugly) 背景最近基于兴趣学学习了下 HTTPS 相关的知识，在此记录下学习心得。 在上网获取信息的过程中，我们接触最多的信息加密传输方式也莫过于HTTPS了。每当访问一个站点，浏览器的地址栏中出现绿色图标时，意味着该站点支持HTTPS信息传输方式。我们知道HTTPS是我们常见的HTTP协议与某个加密协议的混合体，也就是 HTTP+S。这个 S 可以是 TLS（安全传输层协议）、也可以是 SSL（安全套接层），不过我更认可另一个抽象概括的说法，HTTP+Security。不过要谈论 HTTPS 为何安全，还得从 HTTP 为何不安全说起。 假设你现在正坐在教室里上课，现在你非常想和走道旁的迷人的 TA 说一些话，一般这个时候你会用“传纸条”的方式来交流。而这个方式和 TCP/IP 协议基本的工作模式十分相像： 通过小动作引起对方注意； 对方以多种可能的方式（注视、肢体语言等）回应于你； 你确认对方感知到你后，将纸条传给对方； 对方阅读纸条； 对方给予你阅读后的反应； 怎么样，这个流程是不是很熟悉？ 如果你要传递纸条的 TA 距离你很远怎么办？HTTP 协议就是指你在纸条上写明你要传给的 TA 是谁，或者 TA 的座位在哪，接着只需要途径的同学拿到纸条后根据纸条上的指示依次将纸条传过去就 OK 了。 这个时候问题来了：途径的同学完全可以观看并知道你在纸条上写了什么。 这就是 HTTP 传输所面临的问题之一：中间人攻击，指消息传递的过程中，处在传递路径上的攻击者可以嗅探或者窃听传输数据的内容。 加密HTTPS 针对这个问题，采用了“加密”的方式来解决。最著名原始的加密方法就是对称加密算法了，就是双方约定一个暗号，用什么字母替换什么字母之类的。现在一般采用一种叫 AES（高级加密算法）的对称算法。 对称加密算法既指加密和解密需要使用的密钥 key 是一样的。 AES 在数学上保证了，只要你使用的 key 足够长，破解几乎是不可能的（除非光子计算机造出来了）我们先假设在没有密钥 key 的情况下，密文是无法被破解的，然后再回到这个教室。你将用 AES 加密后的内容噌噌噌地写在了纸条上，正要传出去的时候你突然想到，TA 没有 key 怎么解密内容呀，或者说，应该怎么把 key 给TA？ 如果把 key 也写在纸条上，那么中间人照样可以破解窃听纸条内容。也许在现实环境中你有其他办法可以把 key 通过某种安全的渠道送到 TA 的手里，但是互联网上的实现难度就比较大了，毕竟不管怎样，数据都要经过那些路由。 于是聪明的人类发明了另一种加密算法——非对称加密算法。这种加密算法会生成两个密钥（key1 和 key2）。凡是 key1 加密的数据，key1 自身不能解密，需要 key2 才能解密；凡事 key2 加密的数据，key2 自身不能解密，只有 key1 才能解密。 目前这种算法有很多中，最常用的是RSA。其基于的数学原理是： 两个大素数的乘积很容易算，但是用这个乘积去算出是哪两个素数相乘就很复杂了。好在以目前的技术，分解大数的素因确实比较困难，尤其是当这个大数足够大的时候（通常使用2的10次方个二进制位那么大），就算是超级计算机，解密也需要非常长的时间。现在就把这种非对称加密的方法应用在我们教室传纸条的场景里。 你在写纸条内容之前先用 RSA 技术生成了一对密钥 k1 和 k2。 你把 k1 用明文传了出去，路经也许有人会截取，但是没有用，k1 加密的数据需要 k2 才可以破解，而 k2 在你自己手中。 k1 传到了目的人，目的人会去准备一个接下来准备用于对称加密（AES）的传输密钥 key，然后用收到的 k1 把 key 加密，传给你。 你用手上的 k2 解出 key 后，全教室只有你和你的目的人拥有这个对称加密的 key，你们俩就可以尽情聊天不怕窃听啦~ 这里也许你会有问题，为什么不直接用非对称加密来加密信息，而是加密 AES 的 key 呢？ 因为非对称加密和解密的平均消耗时间比较长，为了节省时间提高效率，我们通常只是用它来交换密钥，而非直接传输数据。然而使用非对称加密真的可以防范中间人攻击吗？虽然看上去很安全，但是实际上却挡不住可恶的中间人攻击。 假设你是 A，你的目的地是 B，现在要途径一个恶意同学M。 中间人的恶意之处在于它会伪装成你的目标。当你要和 B 完成第一次密钥交换的时候，M 把纸条扣了下来，假装自己是B并伪造了一个 key，然后用你发来的 k1 加密了 key 发还给你。你以为你和 B 完成了密钥交换，实际上你是和 M 完成了密钥交换。同事M 和 B 完成一次密钥交换，让 B 以为和 A 你完成了密钥交换。现在整体的加密流程变成了A（加密链接1）-&gt;M(明文)-&gt;B(加密链接2)的情况了，这时候 M 依然可以知道A和B传输的全部消息。 这个时候就是体现 HTTPS 和传纸条的区别了。在教室里，你是和一位与你身份几乎对等的的对象来通信；而在访问网站时，对方往往是一个比较大（或者知名）的服务者，他们有充沛的资源，或许他们可以向你证明他们的合法性。此时我们需要引入一个非常权威的第三方，一个专门用来认证网站合法性的组织，可以叫做 CA（Certificate Authority）。各个网站服务商可以向CA申请证书，使得他们在建立安全连接时可以带上CA的签名。而CA得安全性是由操作系统或者浏览器来认证的。 你的Windows、Mac、Linux、Chrome、Safari等会在安装的时候带上一个他们认为安全的 CA 证书列表，只有和你建立安全连接的网站带有这些CA的签名，操作系统和浏览器才会认为这个链接是安全的，否则就有可能遭到中间人攻击。一旦某个CA颁发的证书被用于的非法途径，那么这个CA之前颁发过的所有证书都将被视为不安全的，这让所有CA在颁发证书时都十分小心，所以CA证书在通常情况下是值得信任的。 总结使 HTTP 后面增加一个S（Security）的技术，正是 对称加密 + 非对称加密 + CA认证 这三种技术的混合体。当然这个主要是 HTTPS 的基本原理，真正实际中的 HTTPS 的协议是比以上的描述更为复杂一些的，并且其中任何一步稍有闪失，整个流程都将不再安全。这也是为什么 HTTPS 协议从 SSL 1.0升级到 SSL 3.0，再被 TLS 1.0 现在被 TLS 1.3取代，其背后都是一个个细节上的优化，以防有任何闪失。TLS 协议相比 SSL 协议增加了传输层的安全保证。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/03/09/Https-Questions/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"HTTPS","slug":"https","permalink":"http://agehua.github.io/tags/https/"}]},{"title":"解决Android多进程导致Application重复创建问题","slug":"Multi-Process-Dispatch","date":"2017-02-20T16:00:00.000Z","updated":"2017-11-23T07:25:19.000Z","comments":true,"path":"2017/02/21/Multi-Process-Dispatch/","link":"","permalink":"http://agehua.github.io/2017/02/21/Multi-Process-Dispatch/","excerpt":"\n本编文章是在阅读：Android架构思考(模块化、多进程)过程中，结合自己的理解，对Android开启多进程，会导致Application重复创建问题进行一个总结。\n\n\nAndroid开启多进程一般情况下，一个应用程序就一个进程，这个进程的名称就是应用程序包名。Android的四大组件在AndroidManifest文件中注册的时候，有个属性是android:process，这里可以指定组件的所处的进程。\n一个进程情况下，Application的onCreate方法只会执行一次，但如果应用中采用多进程方式，onCreate方法会执行多次。\n解决Application的onCreate方法多次调用总结了两种实现方式：","text":"本编文章是在阅读：Android架构思考(模块化、多进程)过程中，结合自己的理解，对Android开启多进程，会导致Application重复创建问题进行一个总结。 Android开启多进程一般情况下，一个应用程序就一个进程，这个进程的名称就是应用程序包名。Android的四大组件在AndroidManifest文件中注册的时候，有个属性是android:process，这里可以指定组件的所处的进程。 一个进程情况下，Application的onCreate方法只会执行一次，但如果应用中采用多进程方式，onCreate方法会执行多次。 解决Application的onCreate方法多次调用总结了两种实现方式： 一、根据不同的进程名字进行不同数据的初始化。这是现在网络上通用的方法，在自定义的Application的onCreate方法中控制不同进程的初始化 代码如下： @Overridepublic void onCreate() &#123; super.onCreate(); String processName = getProcessName(this, android.os.Process.myPid()); if (processName != null) &#123; boolean defaultProcess = processName.equals(Constants.REAL_PACKAGE_NAME); // 默认的主进程启动时初始化应用 if (defaultProcess) &#123; initAppForMainProcess(); &#125; // 其他进程启动时初始化对应内容 else if (processName.contains(\":webbrowser\")) &#123; &#125; else if (processName.contains(\":bgmusic\")) &#123; &#125; &#125; 获取当前进程名的方法如下： /** * @return null may be returned if the specified process not found */public static String getProcessName(Context cxt, int pid) &#123; ActivityManager am = (ActivityManager) cxt.getSystemService(Context.ACTIVITY_SERVICE); List&lt;RunningAppP.rocessInfo&gt; runningApps = am.getRunningAppProcesses(); if (runningApps == null) &#123; return null; &#125; for (RunningAppProcessInfo procInfo : runningApps) &#123; if (procInfo.pid == pid) &#123; return procInfo.processName; &#125; &#125; return null;&#125; 二、剥离出一个类，具有同Application相同的生命周期方法，每个进程拥有一个该类实例这就是文章开头提到的博客中使用的方式Android架构思考(模块化、多进程) 实现这种方式，一共有涉及到3个类， 一个是MaApplication继承了Application，是程序的入口，这是一个抽象类，需要子类去实现一些方法 一个是BaseApplicationLogic，这也是基类，由这个类来实现每个进程单独管理Application的生命周期，每个进程实现一个该类的子类 还有一个类是PriorityLogicWrapper，它是一个封装类，继承了Comparable接口，实现了对BaseApplicationLogic按照指定顺序排序（也就是可以按照优先级顺序初始化BaseApplicationLogic） 首先，我们先把所有ApplicationLogic注册到MaApplication中；然后，MaApplication会根据注册时的进程名信息进行筛选，选择相同进程名的ApplicationLogic，保存到本进程中；其次，对这些本进程的ApplicationLogic进行实例化；最后，调用ApplicationLogic的onCreate方法，实现ApplicationLogic与Application生命周期同步，同时还有onTerminate、onLowMemory、onTrimMemory、onConfigurationChanged等方法，与onCreate一致。 流程图如下所示： 代码实现，先看基类BaseApplicationLogic，每个进程都要实现一个该类的子类： public class BaseApplicationLogic &#123; protected MaApplication mApplication; public BaseApplicationLogic() &#123; &#125; public void setApplication(@NonNull MaApplication application) &#123; mApplication = application; &#125; public void onCreate() &#123; &#125; public void onTerminate() &#123; &#125; public void onLowMemory() &#123; &#125; public void onTrimMemory(int level) &#123; &#125; public void onConfigurationChanged(Configuration newConfig) &#123; &#125;&#125; 其次PriorityLogicWrapper，这是一个封装类，实现了BaseApplicationLogic的按优先级排列：public class PriorityLogicWrapper implements Comparable&lt;PriorityLogicWrapper&gt; &#123; public int priority = 0; public Class&lt;? extends BaseApplicationLogic&gt; logicClass = null; public BaseApplicationLogic instance; public PriorityLogicWrapper(int priority, Class&lt;? extends BaseApplicationLogic&gt; logicClass) &#123; this.priority = priority; this.logicClass = logicClass; &#125; @Override public int compareTo(PriorityLogicWrapper o) &#123; return o.priority - this.priority; &#125;&#125; 在MaApplication中直接对PriorityLogicWrapper进行操作，无需操作BaseApplicationLogic对象public abstract class MaApplication extends Application &#123; //mLogicList只持有当前进程的PriorityLogicWrapper对象 private ArrayList&lt;PriorityLogicWrapper&gt; mLogicList; //mLogicClassMap持有所有进程的PriorityLogicWrapper数组对象 private HashMap&lt;String, ArrayList&lt;PriorityLogicWrapper&gt;&gt; mLogicClassMap; @Override public void onCreate() &#123; super.onCreate(); init(); initializeLogic(); dispatchLogic(); instantiateLogic(); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; //找到当前进程的BaseApplicationLogic实例后，执行其onCreate()方法 priorityLogicWrapper.instance.onCreate(); &#125; &#125; &#125; &#125; private void init() &#123; mLogicClassMap = new HashMap&lt;&gt;(); &#125; public abstract boolean needMultipleProcess(); //由MaApplication的实现类，去实现这个方法，调用registerApplicationLogic() //注册所有进程的BaseApplicationLogic对象 protected abstract void initializeLogic(); /** * 添加所有来自不同进程的，不同的BaseApplicationLogic对象到HashMap中 * @param processName 进程名 * @param priority 优先级 * @param logicClass 继承BaseApplicationLogic的对象 * @return */ protected boolean registerApplicationLogic(String processName, int priority, @NonNull Class&lt;? extends BaseApplicationLogic&gt; logicClass) &#123; boolean result = false; if (null != mLogicClassMap) &#123; ArrayList&lt;PriorityLogicWrapper&gt; tempList = mLogicClassMap.get(processName); if (null == tempList) &#123; tempList = new ArrayList&lt;&gt;(); mLogicClassMap.put(processName, tempList); &#125; if (tempList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : tempList) &#123; if (logicClass.getName().equals(priorityLogicWrapper.logicClass.getName())) &#123; throw new RuntimeException(logicClass.getName() + \" has registered.\"); &#125; &#125; &#125; PriorityLogicWrapper priorityLogicWrapper = new PriorityLogicWrapper(priority, logicClass); tempList.add(priorityLogicWrapper); //tempList更新，则mLogicClassMap中的value也跟着更新了，不用再调用mLogicClassMap.put方法 &#125; return result; &#125; /** * 得到一个属于本进程的ArrayList对象，里面保存着封装类PriorityLogicWrapper */ private void dispatchLogic() &#123; if (null != mLogicClassMap) &#123; //根据进程名，得到该进程名对应的ArrayList&lt;PriorityLogicWrapper&gt; mLogicList = mLogicClassMap.get(ProcessUtil.getProcessName(this, ProcessUtil.getMyProcessId())); &#125; &#125; /** * 取得mLogicList中的PriorityLogicWrapper对象，并按优先级顺序初始化BaseApplicationLogic对象 */ private void instantiateLogic() &#123; if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; Collections.sort(mLogicList); //根据进程优先级，按顺序初始化 for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper) &#123; try &#123; /** * 调用Class.newInstance()，会创建这个Class的实例，但是不会执行Android中这个类相关的生命周期 * **/ priorityLogicWrapper.instance = priorityLogicWrapper.logicClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; if (null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.setApplication(this); &#125; &#125; &#125; &#125; &#125; &#125; //Application生命周期的处理，下面方法都类似 @Override public void onTerminate() &#123; super.onTerminate(); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.onTerminate(); &#125; &#125; &#125; &#125; @Override public void onLowMemory() &#123; super.onLowMemory(); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.onLowMemory(); &#125; &#125; &#125; &#125; @Override public void onTrimMemory(int level) &#123; super.onTrimMemory(level); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.onTrimMemory(level); &#125; &#125; &#125; &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.onConfigurationChanged(newConfig); &#125; &#125; &#125; &#125;&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/02/21/Multi-Process-Dispatch/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"multi-process","slug":"multi-process","permalink":"http://agehua.github.io/tags/multi-process/"}]},{"title":"MAC下用iTerm2连接远程主机","slug":"iterm2-to-linux","date":"2017-02-11T16:00:00.000Z","updated":"2017-11-23T07:13:09.000Z","comments":true,"path":"2017/02/12/iterm2-to-linux/","link":"","permalink":"http://agehua.github.io/2017/02/12/iterm2-to-linux/","excerpt":"MAC下用iTerm2连接远程主机iTerm2是MAC的一个终端工具。简单介绍一个小功能，使用iTerm2连接远程主机：\n\n1.先打开一个iTerm2窗口，选择菜单profiles中的Open Profiles，然后选择Edit Profiles中创建一个新的Profile，随便命名成容易记的。\n2.选择command，输入ssh -A -p xxx root@输入远程计算机的IP地址（xxx表示端口）。\n3.然后选择这个新的profile，New一个window就可以连接远程服务器了。\n\nSCP命令使用说明","text":"MAC下用iTerm2连接远程主机iTerm2是MAC的一个终端工具。简单介绍一个小功能，使用iTerm2连接远程主机： 1.先打开一个iTerm2窗口，选择菜单profiles中的Open Profiles，然后选择Edit Profiles中创建一个新的Profile，随便命名成容易记的。 2.选择command，输入ssh -A -p xxx root@输入远程计算机的IP地址（xxx表示端口）。 3.然后选择这个新的profile，New一个window就可以连接远程服务器了。 SCP命令使用说明 scp用来在网络上不同的主机之间复制文件，它使用ssh安全协议传输数据，具有和ssh一样的验证机制，从而安全的远程拷贝文件。 下面是一个简单例子： 首先创建一个本地文件echo hello, world &gt; a-file.txt copy本地文件到服务器的命令如下：scp &lt;local file&gt; &lt;remote user&gt;@&lt;remote machine&gt;:&lt;remote path&gt; 如果想Copy远程文件到本地，则是：scp &lt;remote user&gt;@&lt;remote machine&gt;:&lt;remote path&gt; &lt;local file&gt; 如果想复制目录也是可以的：scp -r local_folder remote_username@remote_ip:remote_folder 比如下面命令：scp -r /home/space/jdk-8u121-linux-x64.tar.gz root@107.182.178.94:/home/root/others/ 参数说明： [root@tank test]# scp –helpusage: scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program] [[user@]host1:]file1 […] [[user@]host2:]file2 -1 强制scp命令使用协议ssh1-2 强制scp命令使用协议ssh2-4 强制scp命令只使用IPv4寻址-6 强制scp命令只使用IPv6寻址-B 使用批处理模式（传输过程中不询问传输口令或短语）-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p 保留原文件的修改时间，访问时间和访问权限。-q 不显示传输进度条。-r 递归复制整个目录。-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，-P port 注意是大写的P, port是指定数据传输用到的端口号-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 转载自：http://blog.51yip.com/linux/1027.html iTerm从mac传文件到linuxsudo scp -P 28547 ~/Downloads/nexus-3.2.1-01-unix.tar.gz root@107.182.178.94:/usr/local -P 指定linux服务器的端口号，必须是大写 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/02/12/iterm2-to-linux/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://agehua.github.io/tags/linux/"},{"name":"iterm","slug":"iterm","permalink":"http://agehua.github.io/tags/iterm/"},{"name":"scp","slug":"scp","permalink":"http://agehua.github.io/tags/scp/"}]},{"title":"IM 国外公司，服务费，方案","slug":"abroad-IM-service-company","date":"2017-01-12T16:00:00.000Z","updated":"2017-11-23T07:12:47.000Z","comments":true,"path":"2017/01/13/abroad-IM-service-company/","link":"","permalink":"http://agehua.github.io/2017/01/13/abroad-IM-service-company/","excerpt":"一、海外提供IM服务的公司1.1 Sinch官网： https://www.sinch.com/products/instant-messaging/收费介绍","text":"一、海外提供IM服务的公司1.1 Sinch官网： https://www.sinch.com/products/instant-messaging/收费介绍 1.2 quickblox官网：https://quickblox.com/收费介绍 1.3 Layerhttps://layer.com/use-cases 具体价格需要注册，然后注册的邮箱里会收到一封邮件： 1.4sendbirdhttps://sendbird.com 收费介绍 1.5 applozichttps://www.applozic.com/收费介绍 二、各家IM服务公司比较 图片来源：Which Chat SDK is better for user experience? Applozic, Sendbird, Layer or Quickblox! 2.1 QuickBlox vs Applozic这部分内容转载自stackoverflow I have recently just tested two of the solutions you have cited. QuickBlox: protocol xmpp open source documentated less clearly than applozic easy set up Applozic: protocol mqtt open source easy set up, if a bit laborious well documented, and very easy API to use. Very customizable. Both programs: have video call/audio call/groups have code bases that are constantly being updated, and from their Github pages new version have been released in the past few months I preferred Applozic as the user interface was nicer and easier to use, and the features and pricing clearer. I also preferred the API and the setup code was easier. 2.2 Quickblox vs SendBird vs Layer本部分内容转载自Do I need to have my own backend? My research on Quickblox vs SendBird vs Layer.com is: 1.Backend-as-a-Service (BaaS) or Chat-as-a-Service (CaaS): Quickblox: Both, BaaS and CaaS SendBird (aka JIVER): CaaS (BaaS for Enterprise-only) Layer.com: CaaS only 2.WebSocket-based: Quickblox: No (XMPP) SendBird: Yes Layer.com: Yes 3.Voice and Video: Quickblox: Yes SendBird: No Layer.com: No 4.Chat UI Kit: Quickblox: QMChatViewController SendBird: Open-source Sample UIs for iOS, Android, JavaScript (Web &amp; React Native), Xamarin, Unity (You can use their Sample UI or 3rd party UI Kit like JSQMessagesViewController) Layer.com: Atlas 5.Number of Members in a Group: Quickblox: Thousands (you may need to host Quickblox BaaS at a dedicated AWS infrastructure for better performance) SendBird: Thousands (no need for an extra infrastructure) Layer.com: limited to 25 per group 6.The ability to host the BaaS/CaaS at your own IaaS: Quickblox: Yes (setup cost starts from $599) SendBird: Yes (limited to Enterprise plans only) Layer.com: No 7.Custom Objects Backend (the need for extra infrastructure): Quickblox: Included in Quickblox BaaS SendBird: Partial support (Key/value custom object stores for channels to be released in March) Layer.com: No 8.BaaS/CaaS Admin Panel/Dashboard: Quickblox: Basic with Custom Dashboard when subscribed to the enterprise plan, starts from $599/month (Classic UI) SendBird: Advanced (Modern UI) Layer.com: Basic (Modern UI) 9.Attachment max file size: Quickblox: Unknown SendBird: 25MB per file (custom limit for Enterprise plans) Layer.com: 2GB (be aware that their pricing is based on the data transfer) 10.Availability SLA: Quickblox: Based on AWS EC2 SLA (99.95%) SendBird: 99.9% Layer.com: 99.9% 11.Pricing (per month): Quickblox: Mainly based on the number of messengers per second (/s) and monthly active users: Free-$49-$214-$599-$1,199-$2,399 (Plans) SendBird: Mainly based on the number of monthly active users (MAU): Free-$59-$179-$599-Custom (https://sendbird.com/pricing) Layer.com: Mainly based on the monthly data transfer and monthly users: Free-$599 per month-Custom (https://layer.com/plans) 12.Number of freelancers at UpWork.com who have this Baas/CaaS as one of their skill set: Quickblox: 547 (keyword: “Quickblox”) SendBird: 0 (keyword: “SendBird” or “JIVER”) « new to the market Layer: 13 (keyword: “Layer.com” not Layer) 2.3 更多比较：https://www.quora.com/Quickblox-vs-SendBird-vs-Layer-com-Do-I-need-to-have-my-own-backend http://stackoverflow.com/questions/37678528/comparing-layer-applozic-quickblox-sendbird-for-quick-whatsapp-like-messagin https://www.applozic.com/blog/applozic-vs-sendbird-vs-layer-vs-quickblox-alternatives/ https://siftery.com/product-comparison/sendbird-vs-quickblox-vs-layer https://stackshare.io/stackups/sendbird-vs-sinch-vs-layer https://www.quora.com/What-SDKs-APIs-are-viable-for-implementing-instant-messaging-between-clients-Android-iOS-and-web 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/01/13/abroad-IM-service-company/","raw":null,"content":null,"categories":[{"name":"Investigation","slug":"investigation","permalink":"http://agehua.github.io/categories/investigation/"}],"tags":[{"name":"IM Company","slug":"im-company","permalink":"http://agehua.github.io/tags/im-company/"}]},{"title":"Android 增量更新整理","slug":"Android-patch-update","date":"2016-12-19T16:00:00.000Z","updated":"2017-11-23T07:25:12.000Z","comments":true,"path":"2016/12/20/Android-patch-update/","link":"","permalink":"http://agehua.github.io/2016/12/20/Android-patch-update/","excerpt":"背景在前几年，整体移动网络环境相比现在差很多，加之流量费用又相对较高，因此每当我们发布新版本的时候，一些用户升级并不是很积极，这就造成了新版本的升级率并不高。而google为了解决了这个问题，提出了Smart App Update，即增量更新（也叫做差分升级）。\n增量更新与热修复完全不是一个东西。增量更新需要重新安装apk，而热修复不需要。热修复也能完成部分增量更新的功能。\n增量更新的流程增量更新的具体流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的，当然部分应用市场有root权限你可能感知不到）。","text":"背景在前几年，整体移动网络环境相比现在差很多，加之流量费用又相对较高，因此每当我们发布新版本的时候，一些用户升级并不是很积极，这就造成了新版本的升级率并不高。而google为了解决了这个问题，提出了Smart App Update，即增量更新（也叫做差分升级）。 增量更新与热修复完全不是一个东西。增量更新需要重新安装apk，而热修复不需要。热修复也能完成部分增量更新的功能。 增量更新的流程增量更新的具体流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的，当然部分应用市场有root权限你可能感知不到）。 增量更新的原理增量更新的原理也很简单，就是将手机上已安装的旧版本apk与服务器端新版本apk进行二进制对比，并得到差分包（patch），用户在升级更新应用时，只需要下载差分包，然后在本地使用差分包与旧版的apk合成新版apk，然后进行安装。差分包文件的大小，那就远比APK小得多了，这样也便于用户进行应用升级。 那么增量更新的流程可以细化为几个关键点： 1.用户手机上提取当前安装应用的apk 2.如何利用old.apk和new.apk生成增量文件（差分包） 3.增加文件与1.中的old.apk合并，然后安装 旧版的APK可以在/data/app/%packagename%/下找到。 也可以参考下面的代码： public class ApkExtract &#123; public static String extract(Context context) &#123; context = context.getApplicationContext(); ApplicationInfo applicationInfo = context.getApplicationInfo(); String apkPath = applicationInfo.sourceDir; Log.d(\"hongyang\", apkPath); return apkPath; &#125;&#125; 这部分可以参考张鸿洋的博客 关于生成差分包制作差分包的工具为bsdiff， 网址： http://www.daemonology.net/bsdiff/ 下载地址： http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz 这是一个非常牛的二进制查分工具，bsdiff源代码在Android的源码目录下 ”\\external\\bsdiff“”这边也可以找到。另外还需要依赖bzlib来进行打包。在安全性方面，补丁和新旧版APK最好都要进行MD5验证，以免被篡改。 关于这个工具可以使用别人编译好的so库，这里；熟悉NDK开发的也可以自己编译，请看这里。这里就不在考虑这个工具问题了。 生成增量文件./bsdiff old.apk new.apk old-to-new.patch 这样就生成了一个增量文件old-to-new.patch 关于合并差分包生成差分包肯定是在服务端，合并差分包才是Android客户端需要做的： 增量文件和old.apk合并成新的apk./bspatch old.apk new2.apk old-to-new.patch 这样就生成一个new2.apk 生成后，要查看下两个文件的md5值。如果两个文件md5值一致，那么几乎可以肯定两个文件时一模一样的。 增量更新存在的不足 1、增量升级是以两个应用版本之间的差异来生成补丁的，但是我们无法保证用户每次的及时升级到最新，也就是在更新前，新版和旧版只差一个版本，所以必须对你所发布的每一个版本都和最新的版本作差分，以便使所有版本的用户都可以差分升级，这样相对就比较繁琐了。解决方法也有，可以通过Shell脚本来实现批量生成。 2.增量升级能成功的前提是，从手机端能够获得旧版APK，并且与服务端的APK签名是一样的，所以像那些破解的APP就无法实现更新。前面也提到了，为了安全性，防止补丁合成错误，最好在补丁合成前对旧版本的apk进行sha1或者MD5校验，保证基础包的一致性，这样才能顺利的实现增量升级。 想要封装一套增量更新的工具，请看这篇文章：打造Android万能的软件更新库，修改只要一点点 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/20/Android-patch-update/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"Patch Update","slug":"patch-update","permalink":"http://agehua.github.io/tags/patch-update/"}]},{"title":"ThreadLocal一个使用——SimpleDateFormat","slug":"ThreadLocal-usage","date":"2016-12-10T16:00:00.000Z","updated":"2017-11-23T07:12:02.000Z","comments":true,"path":"2016/12/11/ThreadLocal-usage/","link":"","permalink":"http://agehua.github.io/2016/12/11/ThreadLocal-usage/","excerpt":"背景之前写过一篇文章：《ThreadLocal、HandlerThread、Lopper区别》，其中简单提及了ThreadLocal的解释。本篇文章主要结合具体应用场景——SimpleDateFormat，和大家来一起学习ThreadLocal的原理，并对ThreadLocal进行一个详细的介绍。\n下面是本文的参考资料：\njava学习记录–ThreadLocal使用案例——SimpleDateFormat：http://blog.csdn.net/u012706811/article/details/53231598\nSimpleDateFormat的线程安全问题与解决方案：http://www.cnblogs.com/zemliu/archive/2013/08/29/3290585.html\n前言Thread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals。\n这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。\n我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（ThreadLocal用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。\nThreadLocal为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。\n本篇文章结合具体应用场景，来分析ThreadLocal为什么可以实现不同线程之间不会互相干扰。","text":"背景之前写过一篇文章：《ThreadLocal、HandlerThread、Lopper区别》，其中简单提及了ThreadLocal的解释。本篇文章主要结合具体应用场景——SimpleDateFormat，和大家来一起学习ThreadLocal的原理，并对ThreadLocal进行一个详细的介绍。 下面是本文的参考资料： java学习记录–ThreadLocal使用案例——SimpleDateFormat：http://blog.csdn.net/u012706811/article/details/53231598 SimpleDateFormat的线程安全问题与解决方案：http://www.cnblogs.com/zemliu/archive/2013/08/29/3290585.html 前言Thread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals。 这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。 我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（ThreadLocal用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。 ThreadLocal为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。 本篇文章结合具体应用场景，来分析ThreadLocal为什么可以实现不同线程之间不会互相干扰。 应用场景那么，在什么场景下比较适合使用ThreadLocal呢？ stackoverflow上有人给出了还不错的回答： When and how should I use a ThreadLocal variable?One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object (I’m looking at you, SimpleDateFormat). Instead, give each thread its own instance of the object. SimpleDateFormat为什么线程不安全SimpleDateFormat类内部持有一个Calendar对象引用， 如果你的工具类里，SimpleDateFormat是个static的，那么多个thread之间就会共享这个SimpleDateFormat，同时也会共享这个Calendar引用。 查看下源码中的SimpleDateFormat.parse()方法，你会发现有如下的调用: protected Calendar calendar;Date parse() &#123; calendar.clear(); // 清理calendar ... // 执行一些操作, 设置 calendar 的日期什么的 calendar.getTime(); // 获取calendar的时间&#125; 这里calendar.clear()方法是线程不安全的，不同thread调用parse()方法，会导致结果不可预期 问题重现可以看：这篇博客 解决方案最简单的解决方案我们可以把static去掉，这样每个新的线程都会有一个自己的SimpleDateFormat实例，从而避免线程安全的问题 但是，使用这种方法，在高并发的情况下会大量的new SimpleDateFormat以及销毁SimpleDateFormat，这样是非常耗费资源的 下面是一个从网上找的使用ThreadLocal解决SimpleDateFormat线程不安全问题的例子： import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;public class DateUtil &#123; /** 锁对象 */ private static final Object lockObj = new Object(); /** 存放不同的日期模板格式的SimpleDateFormat的Map */ private static Map&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt; sdfMap = new HashMap&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt;(); /** * 返回一个ThreadLocal的SimpleDateFormat,每个线程只会new一次SimpleDateFormat * * @param pattern * @return */ private static SimpleDateFormat getSdf(final String pattern) &#123; ThreadLocal&lt;SimpleDateFormat&gt; tl = sdfMap.get(pattern); // 此处的双重判断和同步是为了防止sdfMap这个单例被多次put重复的sdf if (tl == null) &#123; synchronized (lockObj) &#123; tl = sdfMap.get(pattern); if (tl == null) &#123; // 只有Map中还没有这个pattern的sdf才会生成新的sdf并放入map System.out.println(\"put new sdf of pattern \" + pattern + \" to map\"); // 这里是关键,使用ThreadLocal&lt;SimpleDateFormat&gt;替代原来直接new SimpleDateFormat tl = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; @Override protected SimpleDateFormat initialValue() &#123; System.out.println(\"thread: \" + Thread.currentThread() + \" init pattern: \" + pattern); return new SimpleDateFormat(pattern); &#125; &#125;; sdfMap.put(pattern, tl); &#125; &#125; &#125; return tl.get(); &#125; /** * 是用ThreadLocal&lt;SimpleDateFormat&gt;来获取SimpleDateFormat,这样每个线程只会有一个SimpleDateFormat * * @param date * @param pattern * @return */ public static String format(Date date, String pattern) &#123; return getSdf(pattern).format(date); &#125; public static Date parse(String dateStr, String pattern) throws ParseException &#123; return getSdf(pattern).parse(dateStr); &#125;&#125; 实现原理那为什么ThreadLocal为变量在每个线程都保存了一个副本呢？ 下面部分内容来自博文，http://www.jianshu.com/p/33c5579ef44f (深入浅出ThreadLocal) 先看一下Thread和ThreadLocal两个类的具体结构，如下： 从线程Thread的角度来看，每个线程内部都会持有一个对ThreadLocalMap实例的引用（也就是threadLocals变量），ThreadLocalMap是TThreadLocal的静态内部类。而Entry则是ThreadLocalMap的静态内部类。ThreadLocalMap实例相当于线程的局部变量空间，由Entry[] table存储着线程的私有数据。 EntryEntry继承自WeakReference类，是存储线程私有变量的数据结构。ThreadLocal实例作为引用，意味着如果ThreadLocal实例为null，就可以从table中删除对应的Entry。 class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; ThreadLocalMap内部使用table数组存储Entry，默认大小INITIAL_CAPACITY(16)，先介绍几个参数： size：table中元素的数量。 threshold：table大小的2/3，当size &gt;= threshold时，遍历table并删除key为null的元素，如果删除后size &gt;= threshold*3/4时，需要对table进行扩容。 ThreadLocal.set()实现/** * ThreadLocal.set() */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 从上面代码中看出来： 1.从当前线程Thread中获取ThreadLocalMap实例。 2.ThreadLocal实例和value封装成Entry。 ThreadLocal.get() 实现public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 从上面代码中可以看出， ThreadLocal.get()方法，如果是不同线程ThreadLocalMap为null，最终会调用initialValue()方法，这个方法也是我们给出的解决方案中重载的方法。最后得到的结果是，不同线程ThreadLocal只有一个，而SimpleDateFormat则每个线程都有一个。 但当同一线程有了一个SimpleDateFormat了，会是什么情况呢？看下面代码： //同一线程中再次执行ThreadLocal.get()public T get() &#123; Thread t = Thread.currentThread();//得到当前子线程 ThreadLocalMap map = getMap(t); //同一个线程，map不为空 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;ThreadLocalMap getMap(Thread t) &#123; //同一线程Thread，变量threadLocals经过初始化了，则不为空 return t.threadLocals;&#125; ThreadLocalMap.getEntry()是如何实现的呢？先看下Entry是如何存入table数组的 Entry存入table数组如何实现的：/** * static class ThreadLocalMap.set()方法 */private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 1.通过ThreadLocal的nextHashCode方法生成hash值。 threadLocalHashCode，由nextHashCode()方法得到/** * 对应上面代码的key.threadLocalHashCode * 在ThreadLocal 类中 */private final int threadLocalHashCode = nextHashCode(); 2.通过 key.threadLocalHashCode &amp; (len -1) 定位到table的位置i，假设table中i位置的元素为f。 3.如果f != null，假设f中的引用为k： 如果k和当前ThreadLocal实例一致，则修改value值，返回。 如果k为null，说明这个f已经是stale(陈旧的)的元素。调用replaceStaleEntry方法删除table中所有陈旧的元素（即entry的引用为null）并插入新元素，返回。 否则通过nextIndex方法找到下一个元素f，继续进行步骤3。 4.如果f == null，则把Entry加入到table的i位置中。 5.通过cleanSomeSlots删除陈旧的元素，如果table中没有元素删除，需判断当前情况下是否要进行扩容。 /** * ThreadLocal 类中 */private static AtomicInteger nextHashCode = new AtomicInteger();private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 从nextHashCode方法可以看出，ThreadLocal每实例化一次，其hash值就原子增加HASH_INCREMENT。 Entry从table数组中取出在回看getEntry()方法，就简单多了：/** * ThreadLocalMap的getEntry()方法 */private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125; 1.通过key.threadLocalHashCode &amp; (len -1)定位到table的位置i，假设table中i位置的元素为g。 2.如果g不为null，且和当前ThreadLocal实例一致，则返回这个Entry。 在看一遍ThreadLocal.get()的代码：//同一线程中再次执行ThreadLocal.get()public T get() &#123; Thread t = Thread.currentThread();//得到当前子线程 ThreadLocalMap map = getMap(t); //同一个线程，map不为空 if (map != null) &#123; //当前ThreadLocal实例一致，则Entry不为null ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 所以，同一个线程，ThreadLocalMap不为空，Entry不为null，则返回table中保存的result。不会执行到setInitialValue()。所以，而SimpleDateFormat则会每一个线程只有一个。 由此，就可以得出结论了，确实可以使用ThreadLocal解决SimpleDateFormat的线程安全问题。 p.s. 感兴趣的可以结合ThreadLocal源码继续研究下面的内容： 获取当前的线程的threadLocals。 如果threadLocals不为null，则通过ThreadLocalMap.getEntry方法找到对应的entry，如果其引用和当前key一致，则直接返回，否则在table剩下的元素中继续匹配。 如果threadLocals为null，则通过setInitialValue方法初始化，并返回。private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; table扩容如果table中的元素数量达到阈值threshold的3/4，会进行扩容操作，过程很简单： /** * 在ThreadLocalMap类中 */private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab;&#125; 新建新的数组newTab，大小为原来的2倍。 复制table的元素到newTab，忽略陈旧的元素，假设table中的元素e需要复制到newTab的i位置，如果i位置存在元素，则找下一个空位置进行插入。 文章到这里就结束了，没有更多了:） 文章内容部分来自互联网，部分为自己整理，最后感谢耐心看到这里的人， 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/11/ThreadLocal-usage/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://agehua.github.io/tags/java/"},{"name":"ThreadLocal","slug":"threadlocal","permalink":"http://agehua.github.io/tags/threadlocal/"}]},{"title":"Hexo 模板学习——Hexo 结构","slug":"hexo-learning1","date":"2016-12-05T16:00:00.000Z","updated":"2017-11-23T07:11:47.000Z","comments":true,"path":"2016/12/06/hexo-learning1/","link":"","permalink":"http://agehua.github.io/2016/12/06/hexo-learning1/","excerpt":"起步Hexo会读取根目录下的_config.yml里面的theme属性, 从而采用对应的主题。而主题都是放在themes/目录下面的，然后你会发现他里面有个landscape的目录，这个就是默认主题啦。\n接着，我们查看themes/landscape/目录，以及根据文档docs-themes，我们很容易得出：一个主题其实由4部分组成。\n\n_config.yml: 主题的配置文件\nsource/: 放我们的CSS文件以及图片\nlayout/: 模板文件\nscripts: 放JavaScript文件，他们会自动加载\n\n根据文档docs-templates，下面表格中每个页面都有一个可用的模板，可以没有这些模板，但至少要有一个index模板。","text":"起步Hexo会读取根目录下的_config.yml里面的theme属性, 从而采用对应的主题。而主题都是放在themes/目录下面的，然后你会发现他里面有个landscape的目录，这个就是默认主题啦。 接着，我们查看themes/landscape/目录，以及根据文档docs-themes，我们很容易得出：一个主题其实由4部分组成。 _config.yml: 主题的配置文件 source/: 放我们的CSS文件以及图片 layout/: 模板文件 scripts: 放JavaScript文件，他们会自动加载 根据文档docs-templates，下面表格中每个页面都有一个可用的模板，可以没有这些模板，但至少要有一个index模板。 Template Page Fallback index Home page post Posts index page Pages index archive Archives index category Category archives archive tag Tag archives archive 每次当我们在浏览器访问时，Hexo都会去解析sources目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以EJS为例) 无论URL是什么，Hexo先读取layout.ejs，然后里面的body变量会替换成上面表格里的模板：(Fallback的意思是如果访问/archives时，我们的archives.ejs不存在的话，就会返回index.ejs) 布局编写布局文件(layout.ejs)模板文件在layout文件夹下，文件名对应Hexo中的模板名，有index,post,page,archive,category,tag几种，对于普通的header + content + footer的页面结构，header和footer往往是可以复用的，因此我们可以使用layout.ejs进行布局，动态的内容使用body变量去动态渲染，所以我的layout.ejs大概长这样: &lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/&gt; &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt; &lt;%- css('css/style') %&gt;&lt;/head&gt;&lt;body&gt; &lt;%- partial('_partial/header') %&gt; &lt;div class=\"main\"&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;%- partial('_partial/footer') %&gt; &lt;%- js('js/index.js') %&gt;&lt;/body&gt;&lt;/html&gt; partial,js和css是Hexo提供的辅助函数，后面再说。 其他模板文件每一个模板文件对应的是一种布局，当你使用hexo new 的时候，其实忽略了一个参数，完整的命令是hexo new [layout] ，这个layout就决定了文章使用何种方式布局，比如创建一个自己简介的About页面，hexo new page “about”其实就是使用了page布局。每种布局对应到我们的模板文件上就是index.ejs(首页),post.ejs(文章),archive.ejs(归档),tag.ejs(标签归档),page.ejs(分页)。 index.ejs首页一般是一些博文的摘要和一个分页器，通过Hexo的page变量拿到页面的数据渲染即可，这里我们不直接在index.ejs中写HTML结构，新建一个_partial/article.ejs，将文章数据传给子模板渲染，然后再额外传入一个参数{index: true}，对后面的post.ejs和page.ejs加以区分，让子模板能正确渲染。最后，index.ejs大致是这样的: //index.ejs&lt;% page.posts.each(function(post, index)&#123; %&gt; &lt;%- partial('_partial/article', &#123;index: true, post: post&#125;) %&gt;&lt;% &#125;) %&gt;&lt;div class=\"pagination\"&gt; &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt;&lt;/div&gt; post.ejs文章模板和首页差不多，只是对应的是一篇具体的文章，所以就把文章传入，再额外传入{index: false}告诉子模板不要按首页的方式去渲染就好了。就一行代码(因为都在子模板里 XD //post.ejs&lt;%- partial('_partial/article', &#123;index: false, post: page&#125;) %&gt; page.ejs我个人对Page模板其实是有点懵逼的，在我自己的实践中是添加about(hexo new page “about”)页面后，访问/about会走分页布局，实际上这个页面对应的内容是/source/about里的index.md，也相当于对文章的渲染，因此我把Page模板也写成了和文章模板一样: //page.ejs&lt;%- partial('_partial/article', &#123;index: false, post: page&#125;) %&gt;_partial/article.ejs 前面一共有三处共用了article模板，另外page和post的一样的，所以实际上只有两种情况:主页(index: true)和非主页(index: false)。对应的_partial/article.ejs里只要判断这个值就可以正确渲染了，基本结构如下： //_partial/article.ejs&lt;% if(index)&#123; %&gt; //index logic...&lt;% &#125;else&#123; %&gt; //post or page logic...&lt;% &#125; %&gt; tag.ejs标签归档页内容很少，直接用Hexo的辅助函数list_tags生成一个标签的列表就ok了: //tag.ejs&lt;%- list_tags() %&gt; 归档页模板和首页差不多，归档页只需要展示文章标题和最后的分页器就好: //archive.ejs&lt;div class=\"archive\"&gt; &lt;% var lastyear; %&gt; &lt;% page.posts.each(function(post)&#123; %&gt; &lt;% var year = post.date.year() %&gt; &lt;% if(lastyear !== year)&#123; %&gt; &lt;h4 class=\"year\"&gt;&lt;%= year %&gt;&lt;/h4&gt; &lt;% lastyear = year %&gt; &lt;% &#125; %&gt; &lt;div class=\"archive_item\"&gt; &lt;a class=\"title\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;span class=\"date\"&gt;&lt;%= post.date.format('YYYY-MM-DD') %&gt;&lt;/span&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;div class=\"pagination\"&gt; &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt; &lt;/div&gt;&lt;/div&gt; 至此，模板文件就写好了，对于category模板就放弃了，感觉比较鸡肋。。。 变量其实在模板文件中我们已经看到了page.post,site.posts.length,config.per_page等等，页面的内容就是根据这些变量获取的，由Hexo提供，拿来直接用，Hexo提供了很多变量，但不是都很常用，一般就用到以下变量: site: 对应整个网站的变量，一般会用到site.posts.length制作分页器 page: 对应当前页面的信息，例如我在index.ejs中使用page.posts获取了当前页面的所有文章而不是使用site.posts。 config: 博客的配置信息，博客根目录下的_config.yml。 theme: 主题的配置信息，对于主题根目录下的_config.yml。 辅助函数(Helper)制作一个分页器，我们需要知道文章的总数和每页展示的文章数，然后通过循环生成每个link标签，还要根据当前页面判断link标签的active状态，但是在Hexo中这些都不用我们自己来做了!Hexo提供了paginator这一辅助函数帮助我们生成分页器，只需要将文章总数site.posts.length和每页文章数config.per_page传入就可以生成了。 其他的Helper: list_tags([options]): 快速生成标签列表 js(path/to/js), css(path/to/css) 用来载入静态资源，path可以是字符串或数组(载入多个资源)，默认会去source文件夹下去找。 partial(path/to/partial) 引用字模板，默认会去layout文件夹下找。 样式知道了Hexo的渲染方式，我们就可以使用HTML标签+CSS样式个性化我们的主题了，推荐大家使用CSS预处理语言的一种来写样式，这样就可以通过预处理语言自身的特点让样式更灵活。 其他添加对多说和Disqus的支持评论是很常用的功能，不如就直接在我们的主题里支持了，然后通过配置变量决定是否开启，评论区跟在文章内容下面，对于这种三方的代码块，最好也以partial的方式提取出来，方便移除或是替换。 //_partial/article.ejs&lt;section class='post-content'&gt; &lt;%- post.content %&gt;&lt;/section&gt;//评论部分，post.comments判断是否开启评论，config.duoshuo_shortname和config.disqus_shortname来判断启用那种评论插件，这里优先判断了多说&lt;% if(post.comments)&#123; %&gt; &lt;section id=\"comments\"&gt; &lt;% if (config.duoshuo_shortname)&#123; %&gt; &lt;%- partial('_partial/duoshuo') %&gt; &lt;% &#125;else if(config.disqus_shortname)&#123; %&gt; &lt;%- partial('_partial/disqus') %&gt; &lt;% &#125; %&gt; &lt;/section&gt;&lt;% &#125; %&gt; 再将多说和Disqus提供的js脚本代码放在_partial/duoshuo.ejs和_partial/disqus.ejs下就ok了~ 使用highlight.js提供代码高亮highlight.js提供了多种语言的支持和多种皮肤，用法也很简单，载入文件后调用初始化方法，一切都帮你搞定，对于使用那种皮肤，喜好因人而异，我们干脆在主题的配置文件中做成配置项让用户自己选择: //showonne/_config.yml...other configs# highlight.jshighlight_theme: zenburn 对应的layout.ejs中: &lt;link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/&lt;%= theme.highlight_theme %&gt;.min.css\"&gt; 样式文件通过CDN引入，因为不同皮肤对应不同的文件名，所以十分灵活。 最后当初是对应着landscape照葫芦画瓢写的，最近回头来发现一些不合理的地方，所以就又改了改，也对应着写了这么一篇总结，接下来准备再把样式划分一下，对于颜色这类样式通过变量的方式提取出来，也变得可配置，能让主题更灵活一些。 参考资源 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/06/hexo-learning1/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"http://agehua.github.io/tags/hexo/"},{"name":"Hexo structure","slug":"hexo-structure","permalink":"http://agehua.github.io/tags/hexo-structure/"}]},{"title":"Hexo 模板学习——EJS介绍","slug":"hexo-learning0","date":"2016-12-03T16:00:00.000Z","updated":"2017-11-23T07:11:33.000Z","comments":true,"path":"2016/12/04/hexo-learning0/","link":"","permalink":"http://agehua.github.io/2016/12/04/hexo-learning0/","excerpt":"什么是EJS？EJS是JavaScript模板库，用来从JSON数据中生成HTML字符串\nEJS的语法和功能：1、缓存功能，能够缓存已经解析好的html模版2、&lt;% code %&gt;用于执行其中javascript代码。&lt;% alert('hello world') %&gt;\n3、&lt;%= code =%&gt;会对code进行html转义；","text":"什么是EJS？EJS是JavaScript模板库，用来从JSON数据中生成HTML字符串 EJS的语法和功能：1、缓存功能，能够缓存已经解析好的html模版2、&lt;% code %&gt;用于执行其中javascript代码。&lt;% alert('hello world') %&gt; 3、&lt;%= code =%&gt;会对code进行html转义； &lt;h1&gt;&lt;%=title %&gt;&lt;/h1&gt; 注：会把title里面存的值给显示出来在h1中。&lt;p&gt;&lt;%= 'hello world' %&gt;&lt;/p&gt; 注：会把hello world显示在h1中。&lt;h1&gt;&lt;%= '&lt;b&gt;hello world&lt;/b&gt;' %&gt;&lt;/h1&gt; 注：会把hello world变粗，然后显示在h1中。~~~ javascript#### 4、&lt;%- code %&gt;将不会进行转义；，这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。~~~ javascript&lt;h1&gt;&lt;%-title %&gt;asd&lt;/h1&gt; 最后显示asd，及显示原网页&lt;p&gt;&lt;%# 'hello world' %&gt;asd&lt;/p&gt; 最后显示asd，及显示原网页 5、支持自定义标签，比如’&lt;%’可以使用’NaN‘代替；ejs 里，默认的闭合标记是 &lt;% .. %&gt;，我们也可以定义自己的标签。例如： app.set(\"view options\",&#123; \"open\":\"&#123;&#123;\", \"close\":\"&#125;&#125;\"&#125;); 6、提供一些辅助函数，用于模版中使用 1)、first，返回数组的第一个元素； 2)、last，返回数组的最后一个元素； 3)、capitalize，返回首字母大写的字符串； 4)、downcase，返回字符串的小写； 5)、upcase，返回字符串的大写； 6)、sort，排序（Object.create(obj).sort()？）； 7)、sort_by:’prop’，按照指定的prop属性进行升序排序； 8)、size，返回长度，即length属性，不一定非是数组才行； 9)、plus:n，加上n，将转化为Number进行运算； 10)、minus:n，减去n，将转化为Number进行运算； 11)、times:n，乘以n，将转化为Number进行运算； 12)、divided_by:n，除以n，将转化为Number进行运算； 13)、join:’val’，将数组用’val’最为分隔符，进行合并成一个字符串； 14)、truncate:n，截取前n个字符，超过长度时，将返回一个副本 15)、truncate_words:n，取得字符串中的前n个word，word以空格进行分割； 16)、replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串； 17)、prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面； 18)、append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面； 19)、map:’prop’，返回对象数组中属性为prop的值组成的数组； 20)、reverse，翻转数组或字符串； 21)、get:’prop’，取得属性为’prop’的值； 22)、json，转化为json格式字符串 利用&lt;%- include filename %&gt;加载其他页面模版； ejs我的总结：ejs 写法： 1.普通传入并使用变量： &lt;%= title %&gt; 2.普通for执行js代码（for中间的代码一定可以执行到）： &lt;% for(var i=0; i&lt;headerNavbar.length; i++) &#123;%&gt; &lt;li&gt;&lt;a href=\"/reg\"&gt;&lt;%= headerNavbar[i].name %&gt;&lt;/a&gt;&lt;/li&gt;&lt;% &#125; %&gt; 3.特殊if语句的js代码（if中间的额代码不一定可以执行到）： &lt;% if(active=='index')&#123;%&gt;class=\"active\" &lt;% &#125;%&gt; stylus介绍部分内容转载自：stylus入门使用方法 stylus项目地址：http://stylus-lang.com/ Stylus 是一个CSS的预处理框架，2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，所以 Stylus 是一种新型语言，可以创建健壮的、动态的、富有表现力的CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似，应该是有很多借鉴，所以近似脚本的方式去写CSS代码。 Stylus功能上更为强壮，和js联系更加紧密（EXPRESSIVE, DYNAMIC, ROBUST CSS） Stylus安装使用node包管理器，全局安装$ npm install stylus -g 生成CSS建立一个stylusExample/，再在里面建立 src 目录专门存放 stylus 文件，在里面建立 example.styl 文件。然后在 stylusExample 目录下面执行下面命令$ stylus --compress src/ 输出compiled src/example.css ，这个时候表示你生成成功了，带上–compress参数表示你生成压缩的CSS文件。$ stylus --css css/example.css css/out.styl CSS转换成styl$ stylus help box-shadow CSS属性的帮助$ stylus --css test.css 输出基本名一致的.styl文件 具体语法和应用可以参考: Stylus中文参考文档 CSS3 column多列布局介绍CSS3提供了个新属性columns用于多列布局。在这之前，有些大家习以为常的排版，要用CSS动态实现其实是比较困难的。如竖版报纸 Columns属性最大的问题还是浏览器兼容性问题摘选自：CSS3 column多列布局介绍 栅格与响应式设计栅格样式库一般是这样做的：将页面划分为若干等宽的列（column），然后推荐你通过等宽列来创建响应式的页面区块。 虽然看起来都是这样的思路，但不同的栅格样式库，在做法上却是各有各的点子。下面，本文将介绍几个比较有代表性的栅格样式库，讲述它们的简要原理和用法 Bootstrap中的栅格:Bootstrap把它的栅格放在CSS这个分类下，并称它为Gird system。默认分为12列。 要理解Bootstrap中的栅格，最好从掌握正确的使用方法开始。这其中有2个要点。 第1个要点是容器（container），行（row）和列（column）之间的层级关系。一个正确的写法示例如下： &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 第2个要点，是不同的断点类型的意义及其搭配。 Bootstrap栅格的column对应的类名形如.col-xx-y。y是数字，表示该元素的宽度占据12列中的多少列。而xx只有特定的几个值可供选择，分别是xs、sm、md、lg，它们就是断点类型。 在Bootstrap栅格的设计中，断点的意义是，当视口（viewport）宽度小于断点时，column将竖直堆叠（display: block的默认表现），而当视口宽度大于或等于断点时，column将水平排列（float的效果）。按照xs、sm、md、lg的顺序，断点像素值依次增大，其中xs表示极小，即认为视口宽度永远不小于xs断点，column将始终水平浮动。 Foundation中的栅格Foundation栅格叫做Grid，它和Bootstrap栅格的设计十分近似，只是在类名和结构上有所差异。Foundation栅格同样默认12列。 行与列类比之前Bootstrap栅格的例子，Foundation栅格的一个正确的写法示例如下：&lt;div class=\"row\"&gt; &lt;div class=\"medium-6 columns\"&gt;&lt;/div&gt; &lt;div class=\"medium-6 columns\"&gt;&lt;/div&gt;&lt;/div&gt; Foundation栅格的行用.row表示，而列由至少两个类名组成，一是.columns或.column（2种写法完全相同，单纯为了支持语法偏好）表明这是列元素，二是.medium-6这种用于表示断点类型和对应宽度。在默认情况下，Foundation栅格的断点类型从小到大依次是small、medium、large，其中small类似Bootstrap栅格的xs，也是指任意屏幕尺寸下都水平排列。 Foundation栅格没有container，只需要row和column，因此显得比Bootstrap栅格更简单一些。其中row定义了最大宽度（可以认为承担了container的部分功能），column定义了0.9375rem的水平内边距。如果要嵌套，仍然是column内续接row，再继续接column。 组合使用多个断点类型，其方法也和Bootstrap栅格相同。需要注意的是，Foundation栅格的断点值是用的em而不是px，对应的，它们转换后的像素值也有别于Bootstrap栅格。 Block Grid作为栅格系统的补充，Foundation还提供了另外一个叫做Block Grid的栅格。不过，它并不是一个超出传统栅格的新东西，而只是一个针对特定栅格应用场景的方法糖。 摘选自：有关css栅格系统的故事 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/04/hexo-learning0/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"http://agehua.github.io/tags/hexo/"},{"name":"EJS","slug":"ejs","permalink":"http://agehua.github.io/tags/ejs/"}]},{"title":"nodejs入门","slug":"nodejs-learning-getting-started","date":"2016-12-02T16:00:00.000Z","updated":"2017-11-23T07:10:12.000Z","comments":true,"path":"2016/12/03/nodejs-learning-getting-started/","link":"","permalink":"http://agehua.github.io/2016/12/03/nodejs-learning-getting-started/","excerpt":"\n本文是我自己的学习笔记，整理自《Node入门》\n\nNode入门作者： Manuel Kiessling翻译： goddyzhao &amp; GrayZhang &amp; MondayChen\n本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。\n服务端JavaScriptJavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。\nNode.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。","text":"本文是我自己的学习笔记，整理自《Node入门》 Node入门作者： Manuel Kiessling翻译： goddyzhao &amp; GrayZhang &amp; MondayChen 本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。 服务端JavaScriptJavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。 Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。 要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。 除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。 因此，Node.js事实上既是一个运行时环境，同时又是一个库。 要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考官方的安装指南。安装完成后，继续回来阅读本书下面的内容。 “Hello World”好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。 打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码： console.log(\"Hello World\"); 保存该文件，并通过Node.js来执行：node helloworld.js 正常的话，就会在终端输出Hello World 。 好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。 一个完整的基于Node.js的web应用用例我们来把目标设定得简单点，不过也要够实际才行： 用户可以通过浏览器使用我们的应用。当用户请求http://domain/start 时，可以看到一个欢迎页面，页面上有一个文件上传的表单。用户可以选择一个图片并提交表单，随后文件将被上传到http://domain/upload ，该页面完成上传后会把图片显示在页面上。差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。 更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。 应用不同模块分析我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？ 我们需要提供Web页面，因此需要一个HTTP服务器对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（request handler）当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。 不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。 听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。 现在我们就来开始实现之路，先从第一个部分–HTTP服务器着手。 构建应用的模块一个基础的HTTP服务器当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？ 实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。 这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。 那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。 在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。 让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码： var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888); 搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本： node server.js 接下来，打开浏览器访问http://localhost:8888/ ，你会看到一个写着“Hello World”的网页。 这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。 分析HTTP服务器那么接下来，让我们分析一下这个HTTP服务器的构成。 第一行请求（require）Node.js自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用http模块提供的函数： createServer 。这个函数会返回一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。 咱们暂时先不管 http.createServer 的括号里的那个函数定义。 我们本来可以用这样的代码来启动服务器并侦听8888端口：var http = require(\"http\");var server = http.createServer();server.listen(8888); 这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。 最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 createServer() 的第一个参数，一个函数定义。 实际上，这个函数定义是 createServer() 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。 进行函数传递举例来说，你可以这样做： function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, \"Hello\"); 请仔细阅读这段代码！在这里，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！ 这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。 当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数： function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word)&#123; console.log(word) &#125;, \"Hello\"); 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。 用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 匿名函数 。 这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 函数传递是如何让HTTP服务器工作的带着这些知识，我们再来看看我们简约而不简单的HTTP服务器： var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888); 现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。 用这样的代码也可以达到同样的目的： var http = require(\"http\");function onRequest(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;http.createServer(onRequest).listen(8888); 也许现在我们该问这个问题了：我们为什么要用这种方式呢？ 基于事件驱动的回调这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。 你也许会想花点时间读一下Felix Geisendörfer的大作Understanding node.js，它介绍了一些背景知识。 这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。 当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。 问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。 写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。 那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？ 嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。 我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。 我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。 这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。 至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。 让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个： var http = require(\"http\");function onRequest(request, response) &#123; console.log(\"Request received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;http.createServer(onRequest).listen(8888);console.log(\"Server has started.\"); 注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。 当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问http://localhost:8888/ ），“Request received.”这条消息就会在命令行中出现。 这就是事件驱动的异步服务器端JavaScript和它的回调啦！ （请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分浏览器都会在你访问 http://localhost:8888/ 时尝试读取 http://localhost:8888/favicon.ico ) 服务器是如何处理请求的好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 onRequest() 的主体部分。 当回调启动，我们的 onRequest() 函数被触发的时候，有两个参数被传入： request 和 response 。 它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。 所以我们的代码就是：当收到请求时，使用 response.writeHead() 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 response.write() 函数在HTTP相应主体中发送文本“Hello World”。 最后，我们调用 response.end() 完成响应。 目前来说，我们对请求的细节并不在意，所以我们没有使用 request 对象。 服务端的模块放在哪里 OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 server.js 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 index.js 的文件去调用应用的其他模块（比如 server.js 中的HTTP服务器模块）来引导和启动应用。 我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 index.js 主文件使用。 也许你已经注意到，我们已经在代码中使用了模块了。像这样： var http = require(\"http\");...http.createServer(...); Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。 这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。 给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来： var foo = require(\"http\");...foo.createServer(...); 很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？ 等我们把 server.js 变成一个真正的模块，你就能搞明白了。 事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本。 目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。 我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。 var http = require(\"http\");function start() &#123; function onRequest(request, response) &#123; console.log(\"Request received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。 创建 index.js 文件并写入以下内容： var server = require(\"./server\");server.start(); 正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。 好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子： node index.js 非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。 我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。 对于一个非常简单的应用来说，你可以直接在回调函数 onRequest() 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。 处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做路由的模块吧。 如何来进行请求的“路由”我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。 因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。 我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。 url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring(string)[\"foo\"] | | querystring(string)[\"hello\"] 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。 现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径： var http = require(\"http\");var url = require(\"url\");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。 在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。 现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容： function route(pathname) &#123; console.log(\"About to route a request for \" + pathname);&#125;exports.route = route; 如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。 我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读Martin Fowlers关于依赖注入的大作来作为背景知识）。 首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去： var http = require(\"http\");var url = require(\"url\");function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(pathname); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：var server = require(\"./server\");var router = require(\"./router\");server.start(router.route); 在这里，我们传递的函数依旧什么也没做。 如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由： bash$ node index.jsRequest for /foo received.About to route a request for /foo （以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。 行为驱动执行请允许我再次脱离主题，在这里谈一谈函数式编程。 将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。 就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。 嗨那个叫路由的东西，能帮我把这个路由一下吗？ 但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。 理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。 我是在读了Steve Yegge的大作名词王国中的死刑之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。 路由给真正的请求处理程序回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。 当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。 在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。 我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。 应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出： function start() &#123; console.log(\"Request handler 'start' was called.\");&#125;function upload() &#123; console.log(\"Request handler 'upload' was called.\");&#125;exports.start = start;exports.upload = upload; 这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。 在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。 这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。 那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆if request == x then call handler y也使得系统丑陋不堪。 仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎关联数组（associative array） 能完美胜任。 不过结果有点令人失望，JavaScript没提供关联数组 – 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。 在这方面，http://msdn.microsoft.com/en-us/magazine/cc163419.aspx 有一个不错的介绍，我在此摘录一段： 在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 – 你可以把JavaScript的对象想象成一个键为字符串类型的字典。 但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！ 好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。 我们先将这个对象引入到主文件index.js中： var server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = &#123;&#125;handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;server.start(router.route, handle); 虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。 正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为”/“的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。 在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(handle, pathname); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。 然后我们相应地在route.js文件中修改route()函数： function route(handle, pathname) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; handle[pathname](); &#125; else &#123; console.log(\"No request handler found for \" + pathname); &#125;&#125;exports.route = route; 通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handlepathname;的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。 有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序： Server has started.Request for /start received.About to route a request for /startRequest handler 'start' was called. 并且在浏览器中打开http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了： Request for / received.About to route a request for /Request handler 'start' was called. 让请求处理程序作出响应很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。 这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们server.js文件中的onRequest函数。 其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。 不好的实现方式对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。 这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。 我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。 让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式： function start() &#123; console.log(\"Request handler 'start' was called.\"); return \"Hello Start\";&#125;function upload() &#123; console.log(\"Request handler 'upload' was called.\"); return \"Hello Upload\";&#125;exports.start = start;exports.upload = upload; 好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式： function route(handle, pathname) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; return handle[pathname](); &#125; else &#123; console.log(\"No request handler found for \" + pathname); return \"404 Not found\"; &#125;&#125;exports.route = route; 正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。 最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); var content = route(handle, pathname) response.write(content); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 如果我们运行重构后的应用，一切都会工作的很好：请求http://localhost:8888/start, 浏览器会输出“Hello Start”，请求http://localhost:8888/upload 会输出“Hello Upload”,而请求http://localhost:8888/foo 会输出“404 Not found”。 好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。 没理解？没关系，下面就来详细解释下。 阻塞与非阻塞正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。 我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。 这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。 让我们将requestHandlers.js修改成如下形式： function start() &#123; console.log(\"Request handler 'start' was called.\"); function sleep(milliSeconds) &#123; var startTime = new Date().getTime(); while (new Date().getTime() &lt; startTime + milliSeconds); &#125; sleep(10000); return \"Hello Start\";&#125;function upload() &#123; console.log(\"Request handler 'upload' was called.\"); return \"Hello Upload\";&#125;exports.start = start;exports.upload = upload; 上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。 （当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。） 接下来就让我们来看看，我们的改动带来了哪些变化。 如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入http://localhost:8888/start， 但是先不要打开它！ 在第二个浏览器窗口的地址栏中输入http://localhost:8888/upload， 同样的，先不要打开它！ 接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。 注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！ 这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。 这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。 这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。 然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。 对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！” （如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——理解node.js的事件轮询。） 接下来，我们会介绍一种错误的使用非阻塞操作的方式。 和上次一样，我们通过修改我们的应用来暴露问题。 这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式： var exec = require(\"child_process\").exec;function start() &#123; console.log(\"Request handler 'start' was called.\"); var content = \"empty\"; exec(\"ls -lah\", function (error, stdout, stderr) &#123; content = stdout; &#125;); return content;&#125;function upload() &#123; console.log(\"Request handler 'upload' was called.\"); return \"Hello Upload\";&#125;exports.start = start;exports.upload = upload; 上述代码中，我们引入了一个新的Node.js模块，child_process。之所以用它，是为了实现一个既简单又实用的非阻塞操作：exec()。 exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。 上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。 和往常一样，我们启动服务器，然后访问“http://localhost:8888/start” 。 之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？ 这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。 （如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。 然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？ 好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。 问题就在于，为了进行非阻塞工作，exec()使用了回调函数。 在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数： function (error, stdout, stderr) &#123; content = stdout;&#125; 现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。 我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。 为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。 那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？ 好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。 以非阻塞操作进行请求响应我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。 不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。 到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。 现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。 原理就是如此，接下来让我们来一步步实现这种方案。 先从server.js开始： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(handle, pathname, response); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。 下面就来看看我们的router.js: function route(handle, pathname, response) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; handle[pathname](response); &#125; else &#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; 同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。 如果没有对应的请求处理器处理，我们就直接返回“404”错误。 最后，我们将requestHandler.js修改为如下形式： var exec = require(\"child_process\").exec;function start(response) &#123; console.log(\"Request handler 'start' was called.\"); exec(\"ls -lah\", function (error, stdout, stderr) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(stdout); response.end(); &#125;);&#125;function upload(response) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello Upload\"); response.end();&#125;exports.start = start;exports.upload = upload; 我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。 start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。 这时再次我们启动应用（node index.js），一切都会工作的很好。 如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式： var exec = require(\"child_process\").exec;function start(response) &#123; console.log(\"Request handler 'start' was called.\"); exec(\"find /\", &#123; timeout: 10000, maxBuffer: 20000*1024 &#125;, function (error, stdout, stderr) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(stdout); response.end(); &#125;);&#125;function upload(response) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello Upload\"); response.end();&#125;exports.start = start;exports.upload = upload; 这样一来，当请求http://localhost:8888/start 的时候，会花10秒钟的时间才载入，而当请求http://localhost:8888/upload 的时候，会立即响应，纵然这个时候/start响应还在处理中。 更有用的场景到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。 服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。 好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。 要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。 第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。 处理POST请求考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。 /start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式： function start(response) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" method=\"post\"&gt;'+ '&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'+ '&lt;input type=\"submit\" value=\"Submit text\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello Upload\"); response.end();&#125;exports.start = start;exports.upload = upload; 好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问http://localhost:8888/start 就可以看到简单的表单了，要记得重启服务器哦！ 你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。 余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。 现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。 这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。 为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。 我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。 如下所示： request.addListener(\"data\", function(chunk) &#123; // called when a new chunk of data was received&#125;);request.addListener(\"end\", function() &#123; // called when all chunks of data have been received&#125;); 问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。 在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。 因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。 还等什么，马上来实现。先从server.js开始： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var postData = \"\"; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); request.setEncoding(\"utf8\"); request.addListener(\"data\", function(postDataChunk) &#123; postData += postDataChunk; console.log(\"Received POST data chunk '\"+ postDataChunk + \"'.\"); &#125;); request.addListener(\"end\", function() &#123; route(handle, pathname, response, postData); &#125;); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。 上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。 我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。 再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式： function route(handle, pathname, response, postData) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; handle[pathname](response, postData); &#125; else &#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; 然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中： function start(response, postData) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" method=\"post\"&gt;'+ '&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'+ '&lt;input type=\"submit\" value=\"Submit text\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, postData) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"You've sent: \" + postData); response.end();&#125;exports.start = start;exports.upload = upload; 好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。 我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。 我们可以使用此前介绍过的querystring模块来实现： var querystring = require(\"querystring\");function start(response, postData) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" method=\"post\"&gt;'+ '&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'+ '&lt;input type=\"submit\" value=\"Submit text\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, postData) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"You've sent the text: \"+ querystring.parse(postData).text); response.end();&#125;exports.start = start;exports.upload = upload; 好了，以上就是关于处理POST数据的全部内容。 处理文件上传最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。 回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。 这里我们要用到的外部模块是Felix Geisendörfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。 使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装： npm install formidable 如果终端输出如下内容： npm info build Success: formidable@1.0.9npm ok 就说明模块已经安装成功了。 现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可： var formidable = require(\"formidable\"); 这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。 node-formidable官方的例子展示了这两部分是如何融合在一起工作的： var formidable = require('formidable'), http = require('http'), util = require('util');http.createServer(function(req, res) &#123; if (req.url == '/upload' &amp;&amp; req.method.toLowerCase() == 'post') &#123; // parse a file upload var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) &#123; res.writeHead(200, &#123;'content-type': 'text/plain'&#125;); res.write('received upload:\\n\\n'); res.end(util.inspect(&#123;fields: fields, files: files&#125;)); &#125;); return; &#125; // show a file upload form res.writeHead(200, &#123;'content-type': 'text/html'&#125;); res.end( '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"text\" name=\"title\"&gt;&lt;br&gt;'+ '&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;&lt;br&gt;'+ '&lt;input type=\"submit\" value=\"Upload\"&gt;'+ '&lt;/form&gt;' );&#125;).listen(8888); 如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示： received upload:&#123; fields: &#123; title: 'Hello World' &#125;, files: &#123; upload: &#123; size: 1558, path: '/tmp/1c747974a27a6292743669e91f29350b', name: 'us-flag.png', type: 'image/png', lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT, _writeStream: [Object], length: [Getter], filename: [Getter], mime: [Getter] &#125; &#125; &#125; 为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。 我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？ 显然，我们需要将该文件读取到我们的服务器中，使用一个叫fs的模块。 我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。 将requestHandlers.js修改为如下形式： var querystring = require(\"querystring\"), fs = require(\"fs\");function start(response, postData) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" '+ 'content=\"text/html; charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" method=\"post\"&gt;'+ '&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'+ '&lt;input type=\"submit\" value=\"Submit text\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, postData) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"You've sent the text: \"+ querystring.parse(postData).text); response.end();&#125;function show(response, postData) &#123; console.log(\"Request handler 'show' was called.\"); fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) &#123; if(error) &#123; response.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(error + \"\\n\"); response.end(); &#125; else &#123; response.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); response.write(file, \"binary\"); response.end(); &#125; &#125;);&#125;exports.start = start;exports.upload = upload;exports.show = show; 我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中： var server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = &#123;&#125;handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;handle[\"/show\"] = requestHandlers.show;server.start(router.route, handle); 重启服务器之后，通过访问http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。 好，最后我们要的就是： 在/start表单中添加一个文件上传元素 将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png 将上传的图片内嵌到/uploadURL输出的HTML中 第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示： var querystring = require(\"querystring\"), fs = require(\"fs\");function start(response, postData) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" '+ 'content=\"text/html; charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"file\" name=\"upload\"&gt;'+ '&lt;input type=\"submit\" value=\"Upload file\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, postData) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"You've sent the text: \"+ querystring.parse(postData).text); response.end();&#125;function show(response, postData) &#123; console.log(\"Request handler 'show' was called.\"); fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) &#123; if(error) &#123; response.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(error + \"\\n\"); response.end(); &#125; else &#123; response.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); response.write(file, \"binary\"); response.end(); &#125; &#125;);&#125;exports.start = start;exports.upload = upload;exports.show = show; 很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。 但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。 到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存） 我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(handle, pathname, response, request); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象： function route(handle, pathname, response, request) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; handle[pathname](response, request); &#125; else &#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; 现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。 这里采用fs.renameSync(path1,path2)来实现。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。 接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示： var querystring = require(\"querystring\"), fs = require(\"fs\"), formidable = require(\"formidable\");function start(response) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;'+ '&lt;input type=\"submit\" value=\"Upload file\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, request) &#123; console.log(\"Request handler 'upload' was called.\"); var form = new formidable.IncomingForm(); console.log(\"about to parse\"); form.parse(request, function(error, fields, files) &#123; console.log(\"parsing done\"); fs.renameSync(files.upload.path, \"/tmp/test.png\"); response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(\"received image:&lt;br/&gt;\"); response.write(\"&lt;img src='/show' /&gt;\"); response.end(); &#125;);&#125;function show(response) &#123; console.log(\"Request handler 'show' was called.\"); fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) &#123; if(error) &#123; response.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(error + \"\\n\"); response.end(); &#125; else &#123; response.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); response.write(file, \"binary\"); response.end(); &#125; &#125;);&#125;exports.start = start;exports.upload = upload;exports.show = show; 好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。 总结与展望恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。 当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。 但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/03/nodejs-learning-getting-started/","raw":null,"content":null,"categories":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/categories/read/"}],"tags":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/tags/read/"},{"name":"nodejs","slug":"nodejs","permalink":"http://agehua.github.io/tags/nodejs/"}]},{"title":"JAVA泛型通配符T，E，K，V区别，T以及Class<T>，Class<?>的区别","slug":"Difference_between-T-E-K-V","date":"2016-11-20T16:00:00.000Z","updated":"2017-11-23T07:11:19.000Z","comments":true,"path":"2016/11/21/Difference_between-T-E-K-V/","link":"","permalink":"http://agehua.github.io/2016/11/21/Difference_between-T-E-K-V/","excerpt":"\n文章转载自《JAVA泛型通配符T，E，K，V区别，T以及Class，Class&lt;?&gt;的区别》\n\n1. 先解释下泛型概念泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。Java语言引入泛型的好处是安全简单。\n在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。","text":"文章转载自《JAVA泛型通配符T，E，K，V区别，T以及Class，Class&lt;?&gt;的区别》 1. 先解释下泛型概念泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。Java语言引入泛型的好处是安全简单。 在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。 泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。 以上内容摘自百度百科 举个栗子:Box类定义为一个泛型类public class Box&lt;T&gt; &#123; private T object; public void set(T object) &#123; this.object = object; &#125; public T get() &#123; return object; &#125;&#125; 创建一个Box对象，不带泛型参数，发现获取对象的时候需要强制转换 Box box2 = new Box();box2.set(new Apple());Apple apple = (Apple) box2.get(); 创建一个Box对象，带泛型参数，获取对象的时候就不需要强制转换 Box&lt;Apple&gt; box = new Box&lt;Apple&gt;();box.set(new Apple());Apple apple = box.get(); 总结下泛型的好处就是： 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上 但是我们定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符T，E，K，V等等，这些通配符又都是什么意思呢？继续往下看 2. 下来说说泛型通配符T，E，K，V区别这些全都属于java泛型的通配符，刚开始我看到这么多通配符，一下晕了，这几个其实没什么区别，只不过是一个约定好的代码，也就是说使用大写字母A,B,C,D……X,Y,Z定义的，就都是泛型，把T换成A也一样，这里T只是名字上的意义而已 ？ 表示不确定的java类型 T (type) 表示具体的一个java类型 K V (key value) 分别代表java键值中的Key Value E (element) 代表Element 举个栗子：public class Test&lt;T&gt; &#123; public List&lt;T&gt; list = new ArrayList&lt;T&gt;(); public static void main(String[] args) &#123; Test&lt;String&gt; test = new Test&lt;String&gt;(); test.list.add(\"hello\"); System.out.println(test.list);&#125;&#125; 和public class Test&lt;A&gt; &#123; public List&lt;A&gt; list = new ArrayList&lt;A&gt;(); public static void main(String[] args) &#123; Test&lt;String&gt; test = new Test&lt;String&gt;(); test.list.add(\"hello\"); System.out.println(test.list);&#125;&#125; 将T换成了A，在执行效果上是没有任何区别的，只不过我们约定好了T代表type，所以还是按照约定规范来比较好，增加了代码的可读性。 如果要定义多个泛型参数，比如说两个泛型参数，很典型的一个栗子是Map的key,value泛型，我们也可以定义一个这样的public interface Mymap&lt;K, V&gt; &#123; public K getKey(); public V getValue();&#125;public class MymapImpl&lt;K, V&gt; implements Mymap&lt;K, V&gt; &#123; private K key; private V value; public MymapImpl(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125;&#125; 下来就可以传入任意类型，创建实例了，不用转化类型Mymap&lt;String, Integer&gt; mp1= new MymapImpl&lt;String, Integer&gt;(\"Even\", 8);Mymap&lt;String, String&gt; mp2= new MymapImpl&lt;String, String&gt;(\"hello\", \"world\");Mymap&lt;Integer, Integer&gt; mp3= new MymapImpl&lt;Integer, Integer&gt;(888, 888); 如果要定义超过两个，三个或三个以上的泛型参数可以使用T1, T2, …, Tn，像这样子public class Test&lt;T1,T2,T3&gt; &#123; public void print(T1 t1,T2 t2,T3 t3)&#123; System.out.println(t1.getClass()); System.out.println(t2.getClass()); System.out.println(t3.getClass()); &#125;&#125; 3. 下来说说T，Class，Class&lt;?&gt;区别T是一种具体的类，例如String,List,Map……等等，这些都是属于具体的类，这个比较好理解 Class是什么呢，Class也是一个类，但Class是存放上面String,List,Map……类信息的一个类，有点抽象，我们一步一步来看 。 如何获取到Class类呢，有三种方式： 调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。例如：List list = null;Class clazz = list.getClass(); 使用Class类的中静态forName()方法获得与字符串对应的Class对象。例如： Class clazz = Class.forName(\"com.lyang.demo.fanxing.People\"); 3.获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。Class clazz = List.class; 那么问题来了？Class类是创建出来了，但是Class和Class&lt;?&gt;适用于什么时候呢？？？ 使用Class和Class&lt;?&gt;多发生在反射场景下，先看看如果我们不使用泛型，反射创建一个类是什么样的。People people = (People) Class.forName(\"com.lyang.demo.fanxing.People\").newInstance(); 看到了么，需要强转，如果反射的类型不是People类，就会报java.lang.ClassCastException错误。 使用Class泛型后，不用强转了public class Test &#123; public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws IllegalAccessException, InstantiationException &#123; return clazz.newInstance(); &#125; public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123; Fruit fruit= createInstance(Fruit .class); People people= createInstance(People.class); &#125;&#125; 那Class和Class&lt;?&gt;有什么区别呢？ Class在实例化的时候，T要替换成具体类 Class&lt;?&gt;它是个通配泛型，?可以代表任何类型，主要用于声明时的限制情况 例如可以声明一个public Class&lt;?&gt; clazz; 但是你不能声明一个public Class&lt;T&gt; clazz; 因为T需要指定类型 所以当不知道定声明什么类型的Class的时候可以定义一个Class&lt;?&gt;,Class&lt;?&gt;可以用于参数类型定义，方法返回值定义等。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/11/21/Difference_between-T-E-K-V/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://agehua.github.io/tags/java/"},{"name":"genericity","slug":"genericity","permalink":"http://agehua.github.io/tags/genericity/"}]},{"title":"Hexo 出错情况收集","slug":"hexo-mac-module-not-found","date":"2016-11-02T16:00:00.000Z","updated":"2017-11-23T07:09:46.000Z","comments":true,"path":"2016/11/03/hexo-mac-module-not-found/","link":"","permalink":"http://agehua.github.io/2016/11/03/hexo-mac-module-not-found/","excerpt":"Error: Cannot find module ‘./build/Release/DTraceProviderBindings’我在更新hexo，准备安装别的module时，不小心按到了 ctrl+c，结果发现使用hexo命令会报如下错误：&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;    &#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;","text":"Error: Cannot find module ‘./build/Release/DTraceProviderBindings’我在更新hexo，准备安装别的module时，不小心按到了 ctrl+c，结果发现使用hexo命令会报如下错误：&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; &#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; 网上一大堆的解决办法都不好用，这里特别记录下我找到的一个解决办法，亲测可用 1. 重新安装Hexo，需要手动删除隐藏的hexo文件 需要删除 /usr/local/lib/node_modules/ 目录下的hexo文件夹 /usr/local/bin/ 下的hexo文件. 直接删掉就好了. 注意这两个都是隐藏文件，要想在finder中显示隐藏文件，需要在Terminal中执行：defaults write com.apple.finder AppleShowAllFiles -bool true 2. 重新执行命令：npm install -g hexo –save 这样就可以了 :) 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/11/03/hexo-mac-module-not-found/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"http://agehua.github.io/tags/hexo/"}]},{"title":"gradle 学习2——生成指定文件名的apk","slug":"gradle-learning2","date":"2016-10-12T16:00:00.000Z","updated":"2017-11-23T07:09:33.000Z","comments":true,"path":"2016/10/13/gradle-learning2/","link":"","permalink":"http://agehua.github.io/2016/10/13/gradle-learning2/","excerpt":"上一篇Gradle学习了解了Gradle的基本结构和依赖关系，这篇文章介绍下怎么在Android上使用Gradle生成指定包名的APK\n需求场景在我们Android开发基本进入测试阶段后，会根据后台的不同环境，打包出对应不同环境（如SIT、UAT、PRD等）的APK安装包。\n每次去手动修改Java类改变后台环境太麻烦还容易忘记修改。打包成功后，还需要手动将默认的包名app-release.apk改成我们需要的包名，也是非常麻烦，有没有直接指定环境，生成指定文件名的安装包呢？\n方法是有的，就是利用gradle的分渠道打包特性，下面上代码分别解释。\n\n主要在这两个个地方修改：\n\nbuildType（构建类型）\nproductFlavors （不同定制的产品）\n\n","text":"上一篇Gradle学习了解了Gradle的基本结构和依赖关系，这篇文章介绍下怎么在Android上使用Gradle生成指定包名的APK 需求场景在我们Android开发基本进入测试阶段后，会根据后台的不同环境，打包出对应不同环境（如SIT、UAT、PRD等）的APK安装包。 每次去手动修改Java类改变后台环境太麻烦还容易忘记修改。打包成功后，还需要手动将默认的包名app-release.apk改成我们需要的包名，也是非常麻烦，有没有直接指定环境，生成指定文件名的安装包呢？ 方法是有的，就是利用gradle的分渠道打包特性，下面上代码分别解释。 主要在这两个个地方修改： buildType（构建类型） productFlavors （不同定制的产品） buildType（构建类型）介绍默认情况下，Android Plugin会自动给项目设置同时构建应用程序的debug和release版本。 两个版本之间的不同主要围绕着能否在一个安全设备上调试，以及APK如何签名。 可以创建一个新的构建类型就是简单的在buildType标签下添加一个新的元素，并且可以使用initWith()或者直接使用闭包来配置它。 以下是一些可能使用到的属性和默认值： Property name Default values for debug Default values for release / other debuggable true false jniDebugBuild false false renderscriptDebugBuild false false renderscriptOptimLevel 3 3 applicationIdSuffix null null versionNameSuffix null null signingConfig android.signingConfigs.debug null zipAlign false true runProguard false false proguardFile N/A (set only) N/A (set only) proguardFiles N/A (set only) N/A (set only) 上面介绍摘选自Gralde plugin User Guide 中文版 Product flavors（不同定制的产品）介绍一个product flavor定义了从项目中构建了一个应用的自定义版本。一个单一的项目可以同时定义多个不同的flavor来改变应用的输出。 这个新的设计概念是为了解决不同的版本之间的差异非常小的情况。虽然最项目终生成了多个定制的版本，但是它们本质上都是同一个应用，那么这种做法可能是比使用库项目更好的实现方式。 Product flavor需要在productFlavors这个DSL容器中声明： android &#123; .... productFlavors &#123; flavor1 &#123; ... &#125; flavor2 &#123; ... &#125; &#125;&#125; 这里创建了两个flavor，名为flavor1和flavor2。 注意：flavor的命名不能与已存在的Build Type或者androidTest这个sourceSet有冲突。 Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）正如前面章节所提到的，每一个Build Type都会生成一个新的APK。 Product Flavor同样也会做这些事情：项目的输出将会拼接所有可能的Build Type和Product Flavor（如果有Flavor定义存在的话）的组合。 每一种组合（包含Build Type和Product Flavor）就是一个Build Variant（构建变种版本）。 例如，在上面的Flavor声明例子中与默认的debug和release两个Build Type将会生成4个Build Variant： Flavor1 - debug Flavor1 - release Flavor2 - debug Flavor2 - release 项目中如果没有定义flavor同样也会有Build Variant，只是使用的是默认的flavor和配置。default(默认)的flavor/config是没有名字的，所以生成的Build Variant列表看起来就跟Build Type列表一样。 具体使用我们的需求就要用到Build Type和Product Flavor我在项目中Build Type的使用，先看代码： buildTypes &#123; release &#123; buildConfigField \"boolean\", \"LEO_DEBUG\", \"false\" minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' debuggable false jniDebuggable false &#125; debug &#123; buildConfigField \"int\", \"buildType\", \"2\" buildConfigField \"boolean\", \"LEO_DEBUG\", \"true\" &#125; &#125; 和Product Flavor的使用 productFlavors&#123; kaifa&#123; buildConfigField \"int\", \"buildType\", \"1\" &#125; ceshi &#123; buildConfigField \"int\", \"buildType\", \"2\" &#125; SIT &#123; buildConfigField \"int\", \"buildType\", \"3\" &#125; UAT &#123; buildConfigField \"int\", \"buildType\", \"4\" &#125; PRD &#123; buildConfigField \"int\", \"buildType\", \"5\" &#125;&#125; 每一个构建过的productFlavors都会在app-&gt;build-&gt;generated-&gt;source-&gt;buildConfig目录下创建自己对应的一个flavor目录，如下图： 而，buildConfigField会在指定的目录，flavor-&gt;release/debug-&gt;包名，下生成一个BuildConfig.java文件，我的代码在BuildConfig.java中定义了一个int类型的buildType和boolean类型的LEO_DEBUG。要使用这两个字段只需要: if (BuildConfig.LEO_DEBUG)&#123; //用来控制本地Log日志&#125;if (Environment ==BuildConfig.buildType)&#123; //用来控制开发环境&#125; gradle中修改apk生成名字的方法这个方法是定义在productFlavors同一层级的 android.applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; //这里修改apk文件名 def flavorname =variant.productFlavors[0].name if (flavorname.equals('kaifa')) flavorname = 'debug' else if (flavorname.equals('ceshi')) flavorname = 'release' def fileName = \"app-$&#123;flavorname&#125;-$&#123;defaultConfig.versionName&#125;-$&#123;releaseTime() &#125;.apk\" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; 这个方法要定义在最外层def releaseTime() &#123; return new Date().format(\"MMdd\", TimeZone.getTimeZone(\"UTC\"))&#125; 最后生成的apk名字 Mac下Android Studio中获取SHA1和MD5打开Android Studio中的Terminal，也可以直接打开系统的终端 获取debug.keystore的SHA1和MD5输入: keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android 获取其他keystore的，如正式签名文件的，keytool -list -v -keystore ~/User/你的用户名/debug.keystore -alias androiddebugkey -storepass android -keypass android 需要把路径和密码改成相应的就可以了 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/10/13/gradle-learning2/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://agehua.github.io/tags/gradle/"}]},{"title":"gradle 学习","slug":"gradle-learning","date":"2016-10-11T16:00:00.000Z","updated":"2017-11-23T07:09:26.000Z","comments":true,"path":"2016/10/12/gradle-learning/","link":"","permalink":"http://agehua.github.io/2016/10/12/gradle-learning/","excerpt":"Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库\nGradle的基本组成\n项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。\n","text":"Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库 Gradle的基本组成 项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。 项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。 任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。 每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试） 一个工程的Build，是由多个Project组成，而一个Project又是由task组成的 任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。 Gradle构建系统的组成Gradle的构建系统是由以下几个文件组成 build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的 settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的 gradle.properties 用来配置构建属性，这个不是必须的 Gradle插件Gradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 apply plugin: ‘java’ 这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task: 1.gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等 2.gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试 3.gradle clean：删除 build 生成的目录和所有生成的文件 4.gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs Gradle各个task的关系图： 从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。 外部依赖通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。 首先，指定maven的仓库地址： repositories &#123; mavenCentral()&#125; mavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。 dependencies &#123; compile group: 'commons-collections', name: 'commons-collections', version: '3.2' // 简化写法 // compile 'commons-collections:commons-collections:3.2'&#125; 引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。 本地依赖Gradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包 dependencies &#123; compile files('dir/file.jar') compile fileTree(dir: 'libs', include: '*.jar')&#125; 项目依赖往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。 include 'sub-project1', 'sub-project2', 'sub-project3' 如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可： dependencies &#123; compile project(':sub-project2')&#125; 依赖关系管理从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。 例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如： apply plugin: 'java'repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final' testCompile group: 'junit', name: 'junit', version: '4.+'&#125; 在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活 Java 插件中定义了许多标准的配置，例如如下： compile 用来编译项目源代码的 runtime 在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。 testCompile 编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。 testRuntime 运行测试所需要的依赖。 默认的, 包含上面三个依赖。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/10/12/gradle-learning/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://agehua.github.io/tags/gradle/"}]},{"title":"Android面试知识点整理","slug":"Android-interview-questions","date":"2016-09-27T16:00:00.000Z","updated":"2017-11-23T07:24:55.000Z","comments":true,"path":"2016/09/28/Android-interview-questions/","link":"","permalink":"http://agehua.github.io/2016/09/28/Android-interview-questions/","excerpt":"只整理android面试中涉及到的知识点。不断补充中。。。\n1.Android事件传递机制下面内容摘选自《Android开发艺术探索》\n\n(1) 当一个点击事件发生之后，传递过程遵循如下顺序：Activity -&gt; Window -&gt; View。如果一个view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent方法将会被调用，依此类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理(调用Activity的onTouchEvent方法)。\n","text":"只整理android面试中涉及到的知识点。不断补充中。。。 1.Android事件传递机制下面内容摘选自《Android开发艺术探索》 (1) 当一个点击事件发生之后，传递过程遵循如下顺序：Activity -&gt; Window -&gt; View。如果一个view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent方法将会被调用，依此类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理(调用Activity的onTouchEvent方法)。 (2) 正常情况下，一个事件序列只能被一个view拦截并消耗，因为一旦某个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，并且该元素的onInterceptTouchEvent方法不会再被调用了。 (3) 某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，并且事件将重新交给它的父容器去处理(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，当前view依然可以收到后续的事件，但是这些事件最后都会传递给Activity处理。 (4) ViewGroup默认不拦截任何事件，因为它的onInterceptTouchEvent方法默认返回false。view没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。 (5) View的onTouchEvent默认都会消耗事件(返回true)，除非它是不可点击的(clickable和longClickable都为false)。view的longClickable默认是false的，clickable则不一定，Button默认是true，而TextView默认是false。 (6) View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。 (7) 事件传递过程总是先传递给父元素，然后再由父元素分发给子view，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外，即当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。ViewGroup的dispatchTouchEvent方法中有一个标志位FLAG_DISALLOW_INTERCEPT，这个标志位就是通过子view调用requestDisallowInterceptTouchEvent方法来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。 (8) 以上结论均可以在书中的源码解析部分得到解释。Window的实现类为PhoneWindow，获取Activity的contentView的方法 ((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); 2.OnTouchListener、onTouchEvent、OnClickListener优先级顺序如果给一个view设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，那么当前view的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。在onTouchEvent方法中，如果当前view设置了OnClickListener，那么它的onClick方法会被调用，所以OnClickListener的优先级最低。 3.AsyncTask的方法介绍4.项目中Handler怎么使用？5.项目中图片的适配问题怎么解决？6.Android存储敏感信息的方式有？7.自定义广播 继承自BroadcastReceiver 重写onReceive(Context,Intent)Intent.getAction 动态注册（Context.registerReceiver()），静态注册（使用IntentFilter指定action） 8.加分项 JNI开发 性能优化 优秀作品 9.Sqlite数据库更新并保留升级前的数据我们知道在SQLiteOpenHelper的构造方法: super(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) 中最后一个参数表示数据库的版本号.当新的版本号大于当前的version时会调用方法: onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) 所以我们的重点是在该方法中实现SQLite数据库版本升级的管理 对于保留升级前的数据，有两种解决办法： SQLite提供了ALTER TABLE命令，允许用户重命名或添加新的字段到已有表中，但是不能从表中删除字段。并且只能在表的末尾添加字段，比如，为Subscription添加两个字段： ALTER TABLE Subscription ADD COLUMN Activation BLOB; ALTER TABLE Subscription ADD COLUMN Key BLOB; 注释：Sqlite支持BLOB(二进制大对象)数据类型 保留数据删除原表创建新表，具体思路是： 1：将表A重新命名：例如重新命名为：temp_A 2：创建新表A 3：将temp_A中的数据【也就是更新前的数据】插入到新表A 具体操作如下： //重命名原来的数据表public static final String TEMP_SQL_CREATE_TABLE_SUBSCRIBE = \"alter table \" + A + \" rename to temp_A\";//然后把备份表temp_A中的数据copy到新创建的数据库表A中，这个表A没发生结构上的变化public static final String INSERT_SUBSCRIBE = \"select 'insert into A (code,name,username,tablename) values (\"code\",\"name\",\"cnki\",\"tablename\")' as insertSQL from temp_A\";//删除备份表public static final String DELETE_TEMP_SUBSCRIBE = \"delete from temp_A \";public static final String DROP_TEMP_SUBSCRIBE = \"drop table if exists temp_A\";@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; for (int j = oldVersion; j &lt;= newVersion; j++) &#123; switch (j) &#123; case 2: //创建临时表 db.execSQL(TEMP_SQL_CREATE_TABLE_SUBSCRIBE); //执行OnCreate方法，这个方法中放的是表的初始化操作工作，比如创建新表之类的 onCreate(db); //删除之前的表里面的默认数据 for (int i = 0; i &lt; arrWhereAct.length; i++) &#123; db.execSQL(DELETE_TEMP_SUBSCRIBE + arrWhereAct[i]); &#125; //将临时表中的数据放入表A Cursor cursor = db.rawQuery(INSERT_SUBSCRIBE, null); if (cursor.moveToFirst()) &#123; do &#123; db.execSQL(cursor.getString(cursor .getColumnIndex(\"insertSQL\"))); &#125; while (cursor.moveToNext()); &#125; cursor.close(); //将临时表删除掉 db.execSQL(DROP_TEMP_SUBSCRIBE); break; default: break; &#125; &#125;&#125; 注意，为什么要在方法里写for循环，主要是考虑到跨版本升级，比如有的用户一直不升级版本，数据库版本号一直是1，而客户端最新版本其实对应的数据库版本已经是4了，那么我中途可能对数据库做了很多修改，通过这个for循环，可以迭代升级，不会发生错误。 10.AIDL支持的数据类型其实AIDL这门语言非常的简单，基本上它的语法和 Java 是一样的，只是在一些细微处有些许差别——毕竟它只是被创造出来简化Android程序员工作的，太复杂不好——所以在这里我就着重的说一下它和 Java 不一样的地方。主要有下面这些点： 文件类型：用AIDL书写的文件的后缀是 .aidl，而不是 .java。 数据类型：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，就算目标文件与当前正在编写的 .aidl 文件在同一个包下——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文件，一个叫做Book.java ，另一个叫做 BookManager.aidl，它们都在 com.lypeer.aidldemo 包下 ，现在我们需要在 .aidl 文件里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 import com.lypeer.aidldemo.Book; 哪怕 .java 文件和 .aidl 文件就在一个包下。 默认支持的数据类型包括： Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char。 String 类型。 CharSequence类型。 List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable（下文关于这个会有详解）。List可以使用泛型。 Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的。 定向tag：这是一个极易被忽略的点——这里的“被忽略”指的不是大家都不知道，而是很少人会正确的使用它。在我的理解里，定向tag是这样的：AIDL中的定向tag表示了在跨进程通信中数据的流向，其中in表示数据只能由客户端流向服务端，out表示数据只能由服务端流向客户端，而inout则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。in为定向tag的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；out的话表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；inout为定向tag的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。 另外，Java 中的基本类型和String，CharSequence的定向tag默认且只能是in。还有，请注意，请不要滥用定向tag，而是要根据需要选取合适的——要是不管三七二十一，全都一上来就用inout，等工程大了系统的开销就会大很多——因为排列整理参数的开销是很昂贵的。 两种AIDL文件：在我的理解里，所有的AIDL文件大致可以分为两类。一类是用来定义parcelable对象，以供其他AIDL文件使用AIDL中非默认支持的数据类型的。一类是用来定义方法接口，以供系统使用来完成跨进程通信的。可以看到，两类文件都是在“定义”些什么，而不涉及具体的实现，这就是为什么它叫做“Android接口定义语言”。注：所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。 下面是两个例子，对于常见的AIDL文件都有所涉及： // Book.aidl//第一类AIDL文件的例子//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用//注意：Book.aidl与Book.java的包名应当是一样的package com.lypeer.ipcclient;//注意parcelable是小写parcelable Book;// BookManager.aidl//第二类AIDL文件的例子package com.lypeer.ipcclient;//导入所需要使用的非默认支持数据类型的包import com.lypeer.ipcclient.Book;interface BookManager &#123; //所有的返回值前都不需要加任何东西，不管是什么数据类型 List&lt;Book&gt; getBooks(); Book getBook(); int getBookCount(); //传参时除了Java基本类型以及String，CharSequence之外的类型 //都需要在前面加上定向tag，具体加什么量需而定 void setBookPrice(in Book book , int price) void setBookName(in Book book , String name) void addBookIn(in Book book); void addBookOut(out Book book); void addBookInout(inout Book book);&#125; 11.Android布局的优化方案 层级观察器(Hierarchy Viewer)： 使用layoutopt工具输出 重用布局文件： 使用&lt; merge /&gt;标签减少布局的嵌套层次； 仅在需要时才加载布局，ViewStub 12.Android性能调优 UI卡顿 ANR异常 内存性能优化 Android API使用：StringBuffer/String、HashMap/ArrayMap/SparseArray 性能调优参考这篇博客Andoid应用开发性能优化完全分析 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/28/Android-interview-questions/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"Interview Knowledge","slug":"interview-knowledge","permalink":"http://agehua.github.io/tags/interview-knowledge/"}]},{"title":"使用JNI获取publickey实现","slug":"JNI-get-publickey","date":"2016-09-21T16:00:00.000Z","updated":"2017-11-23T07:08:18.000Z","comments":true,"path":"2016/09/22/JNI-get-publickey/","link":"","permalink":"http://agehua.github.io/2016/09/22/JNI-get-publickey/","excerpt":"1.前言之前写过一篇文件是关于JNI学习和积累的文章。这篇文章主要讲在使用JNI取得Publickey过程中遇到的问题和一些总结。\n2.JNI获取Publickey实现在上篇文章中，最终采用的加密方法来自github项目。\n但该项目中在4.0.4版本的手机上，取得publickey遇到兼容性问题。","text":"1.前言之前写过一篇文件是关于JNI学习和积累的文章。这篇文章主要讲在使用JNI取得Publickey过程中遇到的问题和一些总结。 2.JNI获取Publickey实现在上篇文章中，最终采用的加密方法来自github项目。 但该项目中在4.0.4版本的手机上，取得publickey遇到兼容性问题。 正常的Publickey字段样式是这样的： OpenSSLRSAPublicKey&#123;modulus=a0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb26a73305eea631ab18ec3ce746eb253e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9480cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a312c73cf0b98e0ce9a8cf6a682fa,publicExponent=10001&#125; 但是某些低版本手机上（我遇到的是三星GT-S7568 Android版本4.0.4）的Publickey字段样式是： RSA Public Key modulus: a0d169cedabdaac3527c2099eeaca0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb6a73305eea631ab18ec3ce746eb23e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9410cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a313c73cf0b98e0ce9a8cf6a682aff0b98e0ce9a8cf6a682fa public exponent: 10001 第一个字段modulus是一致的，第二个字段一个是“publicExponent”，另一个是“public exponent”。 所以我在代码中的处理是这样的 jmethodID substring_mid = env-&gt;GetMethodID(string_cls,\"substring\", \"(II)Ljava/lang/String;\");jmethodID indexOf_mid = env-&gt;GetMethodID(string_cls,\"indexOf\", \"(Ljava/lang/String;)I\");jint bb = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param2);jstring publicKey2_str =NULL;if (bb ==-1)&#123; jstring param3 = env-&gt;NewStringUTF(\"public exponent\"); jint cc = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param3); __android_log_print(ANDROID_LOG_ERROR, TAG, \"CC value is %d\", cc); publicKey2_str= static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+8,cc-1));&#125;else &#123; publicKey2_str = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+8,bb-1));&#125; 2.1 在JNI native代码中打印日志上面提供的JNI方法中涉及到了JNI日志打印（“__android_log_print”） __android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey value is %s\", jstringTostring(env,publicKey2_str)); 该方法第一个参数以日志级别，有：ANDROID_LOG_INFO，ANDROID_LOG_DEBUG和ANDROID_LOG_ERROR 第二个参数设置过滤的标签，可以在LogCat视图中过滤。 后面参数是具体的日志内容 jstringTostring是将jstring转换成char*的方法： char* jstringTostring(JNIEnv* env, jstring jstr)&#123; char* rtn = NULL; jclass clsstring = env-&gt;FindClass(\"java/lang/String\"); jstring strencode = env-&gt;NewStringUTF(\"utf-8\"); jmethodID mid = env-&gt;GetMethodID(clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\"); jbyteArray barr= (jbyteArray)env-&gt;CallObjectMethod(jstr, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) &#123; rtn = (char*)malloc(alen + 1); memcpy(rtn, ba, alen); rtn[alen] = 0; &#125; env-&gt;ReleaseByteArrayElements(barr, ba, 0); return rtn;&#125; jstring是Java提供的一个本地类型（Native Type），对应Java语言中的string类型 想了解JNI其他数据类型的，请看这里JNI学习积累之二 —- 数据类型映射、域描述符说明 要使用JNI日志打印还需要： 1.导入.h文件及定义宏在输出日志的.c文件中加入: #include &lt;android/log.h&gt;#define LOG_TAG \"From JNI ===&gt;&gt;\" 2.在Android.mk中引用日志库加入下面这行代码: LOCAL_LDLIBS := -lm -llog -ljnigraphics 具体学习可以移步这两篇文章： JNI的native代码中打印日志到eclipse的logcat中 JNI中使用LOGCAT 进行Debug 2.2 完整代码下面是我修改后的完整代码 jstring getPublicKey(JNIEnv* env, jobject thiz,jobject context) &#123; jclass context_cls = env-&gt;GetObjectClass(context); jmethodID get_package_manager_mid = env-&gt;GetMethodID(context_cls, \"getPackageManager\", \"()Landroid/content/pm/PackageManager;\"); jmethodID get_package_name_mid = env-&gt;GetMethodID(context_cls, \"getPackageName\", \"()Ljava/lang/String;\"); env-&gt;DeleteLocalRef(context_cls); jobject pm_obj = env-&gt;CallObjectMethod(context, get_package_manager_mid); jclass pm_cls = env-&gt;FindClass(\"android/content/pm/PackageManager\"); jmethodID get_package_info_mid = env-&gt;GetMethodID(pm_cls, \"getPackageInfo\", \"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\"); jstring package_name = reinterpret_cast&lt;jstring&gt;(env-&gt;CallObjectMethod( context, get_package_name_mid)); jfieldID flag_fid = env-&gt;GetStaticFieldID(pm_cls, \"GET_SIGNATURES\", \"I\"); jint flag = env-&gt;GetStaticIntField(pm_cls, flag_fid); env-&gt;DeleteLocalRef(pm_cls); jobject pi_obj = env-&gt;CallObjectMethod(pm_obj, get_package_info_mid, package_name, flag); env-&gt;DeleteLocalRef(package_name); jclass pi_cls = env-&gt;FindClass(\"android/content/pm/PackageInfo\"); jfieldID signatures_fid = env-&gt;GetFieldID(pi_cls, \"signatures\", \"[Landroid/content/pm/Signature;\"); env-&gt;DeleteLocalRef(pi_cls); jobject sig_obj = env-&gt;GetObjectField(pi_obj, signatures_fid); env-&gt;DeleteLocalRef(pi_obj); jobjectArray sigs = reinterpret_cast&lt;jobjectArray&gt;(sig_obj); jclass signature_cls = env-&gt;FindClass(\"android/content/pm/Signature\"); jmethodID to_byte_array_mid = env-&gt;GetMethodID(signature_cls, \"toByteArray\", \"()[B\"); jbyteArray sig_bytes = reinterpret_cast&lt;jbyteArray&gt;(env-&gt;CallObjectMethod( env-&gt;GetObjectArrayElement(sigs, 0), to_byte_array_mid)); jclass certificate_factory_cls = env-&gt;FindClass( \"java/security/cert/CertificateFactory\"); jmethodID get_certificate_instance_mid = env-&gt;GetStaticMethodID( certificate_factory_cls, \"getInstance\", \"(Ljava/lang/String;)Ljava/security/cert/CertificateFactory;\"); jobject certificate_factory_obj = env-&gt;CallStaticObjectMethod( certificate_factory_cls, get_certificate_instance_mid, env-&gt;NewStringUTF(\"X509\")); jmethodID generate_certificate_mid = env-&gt;GetMethodID( certificate_factory_cls, \"generateCertificate\", \"(Ljava/io/InputStream;)Ljava/security/cert/Certificate;\"); env-&gt;DeleteLocalRef(certificate_factory_cls); jclass certificate_cls = env-&gt;FindClass(\"java/security/cert/Certificate\"); jclass byte_input_stream_cls = env-&gt;FindClass( \"java/io/ByteArrayInputStream\"); jmethodID new_sig_bytes_is_mid = env-&gt;GetMethodID(byte_input_stream_cls, \"&lt;init&gt;\", \"([B)V\"); jobject sig_bytes_is = env-&gt;NewObject(byte_input_stream_cls, new_sig_bytes_is_mid, sig_bytes); env-&gt;DeleteLocalRef(sig_bytes); env-&gt;DeleteLocalRef(byte_input_stream_cls); jobject cert = env-&gt;CallObjectMethod(certificate_factory_obj, generate_certificate_mid, sig_bytes_is); env-&gt;DeleteLocalRef(sig_bytes_is); env-&gt;DeleteLocalRef(certificate_factory_obj); jmethodID get_pubic_key_mid = env-&gt;GetMethodID(certificate_cls, \"getPublicKey\", \"()Ljava/security/PublicKey;\"); env-&gt;DeleteLocalRef(certificate_cls); jobject publicKey = env-&gt;CallObjectMethod(cert, get_pubic_key_mid); jclass publicKey_cls = env-&gt;GetObjectClass(publicKey); jmethodID toString_mid = env-&gt;GetMethodID(publicKey_cls,\"toString\", \"()Ljava/lang/String;\"); jstring publicKey_str = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey,toString_mid)); env-&gt;DeleteLocalRef(cert); env-&gt;DeleteLocalRef(publicKey_cls); env-&gt;DeleteLocalRef(publicKey); jclass string_cls = env-&gt;GetObjectClass(publicKey_str); jmethodID indexOf_mid = env-&gt;GetMethodID(string_cls,\"indexOf\", \"(Ljava/lang/String;)I\"); jstring param = env-&gt;NewStringUTF(\"modulus\"); jint aa = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param); jstring param2 = env-&gt;NewStringUTF(\"publicExponent\"); jmethodID substring_mid = env-&gt;GetMethodID(string_cls,\"substring\", \"(II)Ljava/lang/String;\"); __android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey String is %s\", jstringTostring(env,publicKey_str)); jint bb = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param2); jstring publicKey2_str =NULL; if (bb ==-1)&#123; jstring param3 = env-&gt;NewStringUTF(\"public exponent\"); jint cc = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param3); __android_log_print(ANDROID_LOG_ERROR, TAG, \"CC value is %d\", cc); publicKey2_str= static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+8,cc-1)); &#125;else &#123; publicKey2_str = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+8,bb-1)); &#125; __android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey value is %s\", jstringTostring(env,publicKey2_str)); return publicKey2_str;&#125; 3.附赠版本兼容的方法问题（随时更新）低于Jellybean版本报如下错误： 01-20 08:53:00.141: E/AndroidRuntime(24005): java.lang.NoSuchMethodError: android.view.ViewTreeObserver.removeOnGlobalLayoutListener 正确调用方式应该是： if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123; ViewTreeObserver.removeGlobalOnLayoutListener(this);&#125;else ViewTreeObserver.removeOnGlobalLayoutListener(this); 还有一个setBackground方法： if(Build.VERSION.SzDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; View.setBackground(new ColorDrawable(Color.parseColor(\"#CCCCCC\")));&#125; else &#123; View.setBackgroundColor(Color.parseColor(\"#CCCCCC\"));&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/22/JNI-get-publickey/","raw":null,"content":null,"categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"JNI","slug":"jni","permalink":"http://agehua.github.io/tags/jni/"},{"name":"publickey","slug":"publickey","permalink":"http://agehua.github.io/tags/publickey/"}]},{"title":"Android 退出整个应用程序解决方案","slug":"quit-whole-application","date":"2016-09-21T16:00:00.000Z","updated":"2017-11-23T07:24:52.000Z","comments":true,"path":"2016/09/22/quit-whole-application/","link":"","permalink":"http://agehua.github.io/2016/09/22/quit-whole-application/","excerpt":"关于这个功能，每个公司项目都有自己的解决方案\n搜索了一下，网上大概有以下几种方法解决这个问题：\n\n(1)System.exit(0);\n\n(2)Process.killProcess(Process.myPid());\n\n(3)ActivityManager activityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);\n  activityManager.restartPackage(“packagename”);\n\n\n但这些貌似不是万能的，有的说在2.2版本后就失效了，那我们怎么办呢？","text":"关于这个功能，每个公司项目都有自己的解决方案 搜索了一下，网上大概有以下几种方法解决这个问题： (1)System.exit(0); (2)Process.killProcess(Process.myPid()); (3)ActivityManager activityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE); activityManager.restartPackage(“packagename”); 但这些貌似不是万能的，有的说在2.2版本后就失效了，那我们怎么办呢？ 1、通过广播在起初的一个项目里我用了一个比较笨的方法，我用一个类来专门管理所有的Activity。这个类里有一个List，每打开一个Activity我就把这个Activity放到这个List中，当退出时再将List中所有的Activity一个一个的关闭。 在后来的项目中发现了一个更好地方法，就是通过广播来完成退出功能，具体实现过程是这样的：在每个Activity创建时（onCreate时）给Activity注册一个广播接收器，当退出时发送该广播即可。大概的代码如下： @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); IntentFilter filter = new IntentFilter(); filter.addAction(\"finish\"); registerReceiver(mFinishReceiver, filter); ……&#125;private BroadcastReceiver mFinishReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if(\"finish\".equals(intent.getAction())) &#123; Log.e(\"#########\", \"I am \" + getLocalClassName() + \",now finishing myself...\"); finish(); &#125; &#125;&#125;; 相信聪明的大家会把上面的代码写在一个基类里面，因为如果你的项目中Activity很多的话，写起来很麻烦，而且也不符合代码规范。 在退出时执行以下代码即可关闭所有界面完全退出程序： getApplicationContext().sendBroadcast(new Intent(“finish”)); 转载：http://www.cnblogs.com/wader2011/archive/2011/10/10/2205161.html 2、使用退出类public class CloseActivity&#123; private static LinkedList&lt;Activity&gt; acys = new LinkedList&lt;Activity&gt;(); public static Activity curActivity; public static void add(Activity acy) &#123; acys.add(acy); &#125; public static void remove(Activity acy) &#123; acys.remove(acy); &#125; public static void close() &#123; Activity acy; while (acys.size() != 0) &#123; acy = acys.poll(); if (!acy.isFinishing()) &#123; acy.finish(); &#125; &#125;// android.os.Process.killProcess(android.os.Process.myPid()); &#125;&#125; 3.利用activity stack的原理我们知道Android的窗口类提供了历史栈，我们可以通过stack的原理来巧妙的实现，这里我们在D窗口打开A窗口时在Intent中直接加入标志Intent.FLAG_ACTIVITY_CLEAR_TOP，再次开启A时将会清除该进程空间的所有Activity。 在D中使用下面的代码: Intent intent = new Intent();intent.setClass(D.this, A.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //注意本行的FLAG设置startActivity(intent);finish(); 关掉自己，在A中加入代码： @Overrideprotected void onNewIntent(Intent intent) &#123; // TODO Auto-generated method stub super.onNewIntent(intent); //退出 if ((Intent.FLAG_ACTIVITY_CLEAR_TOP &amp; intent.getFlags()) != 0) &#123; finish(); &#125;&#125; A的Manifest.xml配置成android:launchMode=&quot;singleTop&quot; 原理总结： 一般A是程序的入口点，从D起一个A的activity，加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP这个过程中会把栈中B，C，都清理掉。因为A是android:launchMode=”singleTop” 不会调用oncreate(),而是响应onNewIntent（）这时候判断Intent.FLAG_ACTIVITY_CLEAR_TOP，然后把A finish（）掉。 栈中A,B,C,D全部被清理。所以整个程序退出了。 4.JNI实现守护进程请看这篇博客Android 通过JNI实现守护进程 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/22/quit-whole-application/","raw":null,"content":null,"categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"exitApplication","slug":"exitapplication","permalink":"http://agehua.github.io/tags/exitapplication/"}]},{"title":"apk中含有admob广告插件","slug":"AVG-unwanted-software","date":"2016-09-19T16:00:00.000Z","updated":"2017-11-23T07:24:46.000Z","comments":true,"path":"2016/09/20/AVG-unwanted-software/","link":"","permalink":"http://agehua.github.io/2016/09/20/AVG-unwanted-software/","excerpt":"问题出现使用这个杀毒软件antivirus-for-android，检测我们团队的apk后，AVG提示警告unwanted software。\n生成的报告说是：Beware of Adware! 1 Types of Adware DetectedLast reported adware activity:    Sep 16Days with adware in last 30:    1 days\n见下图：","text":"问题出现使用这个杀毒软件antivirus-for-android，检测我们团队的apk后，AVG提示警告unwanted software。 生成的报告说是：Beware of Adware! 1 Types of Adware DetectedLast reported adware activity: Sep 16Days with adware in last 30: 1 days 见下图： 排查使用这个广告插件检测工具全能工具箱，检测后，确实提示我们的apk含有广告“admob” 但是这个apk是我们团队自己开发的，有项目源码，AndroidManifest文件中没有网络上说的Google AdMob注册，更没有com.google.ads.AdView这个布局文件 代码中没有，可能在第三方库中？ 结果就是在排查第三方库的过程中，发现google service的jar包中有名字是ads的文件夹。如下图： 删除后上图中的两个ads文件夹，再打包apk后，用软件检测，果然没有admob插件了。哈哈，恼人的问题解决了。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/20/AVG-unwanted-software/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"remove admob","slug":"remove-admob","permalink":"http://agehua.github.io/tags/remove-admob/"}]},{"title":"ANDROID设计模式之单例模式","slug":"android-design-pattern-singleton","date":"2016-09-19T16:00:00.000Z","updated":"2017-11-23T07:24:42.000Z","comments":true,"path":"2016/09/20/android-design-pattern-singleton/","link":"","permalink":"http://agehua.github.io/2016/09/20/android-design-pattern-singleton/","excerpt":"向大神致敬本文转载自stormzhang ANDROID设计模式之单例模式 ，稍有修改\n常用单例模式什么是设计模式？其实简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式的意思，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，但是我只会针对Android平台上常用的一些设计模式做分享，今天就先来分享下最常用的单例模式。","text":"向大神致敬本文转载自stormzhang ANDROID设计模式之单例模式 ，稍有修改 常用单例模式什么是设计模式？其实简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式的意思，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，但是我只会针对Android平台上常用的一些设计模式做分享，今天就先来分享下最常用的单例模式。 饿汉式public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton newInstance()&#123; return instance; &#125;&#125; 饿汉式 是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用饿汉式的单例模式就是不合适的，这时候就需要用到懒汉式的方式去按需延迟加载单例。 懒汉式public class Singleton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton newInstance()&#123; if(null == instance)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式与饿汉式的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用懒汉式就是非常不错的选择。 多线程下的单例模式上面介绍了一些单例模式的基本应用方法，但是上面所说的那些使用方式都是有一个隐含的前提，那就是他们都是应用在单线程条件下，一旦换成了多线程就有出错的风险。 如果在多线程的情况下，饿汉式不会出现问题，因为JVM只会加载一次单例类，但是懒汉式可能就会出现重复创建单例对象的问题。为什么会有这样的问题呢？因为懒汉式在创建单例时是 线程不安全的，多个线程可能会并发调用他的newInstance方法导致多个线程可能会创建多份相同的单例出来。 那有没有办法，使懒汉式的单利模式也是线程安全的呢？答案肯定是有的，就是使用加同步锁的方式去实现。 懒汉式同步锁public class Singleton &#123; private static Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 这种是最常见的解决同步问题的一种方式，使用同步锁synchronized (Singleton.class)防止多线程同时进入造成instance被多次实例化。举个在Android使用这种方式的例子： InputMethodManager示例public final class InputMethodManager &#123; //内部全局唯一实例 static InputMethodManager sInstance; //对外api public static InputMethodManager getInstance() &#123; synchronized (InputMethodManager.class) &#123; if (sInstance == null) &#123; IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE); IInputMethodManager service = IInputMethodManager.Stub.asInterface(b); sInstance = new InputMethodManager(service, Looper.getMainLooper()); &#125; return sInstance; &#125; &#125;&#125; 以上是Android源码中输入法类相关的单例使用方式。 但其实还有一种更好的方式如下： 双重校验锁public class Singleton &#123; private static volatile Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; // if already inited, no need to get lock everytime if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 可以看到上面在synchronized (Singleton.class)外又添加了一层if，这是为了在instance已经实例化后下次进入不必执行synchronized (Singleton.class)获取对象锁，从而提高性能。 以上两种方式还是挺麻烦的，我们不禁要问，有没有更好的实现方式呢？答案是肯定的。 我们可以利用JVM的类加载机制去实现。在很多情况下JVM已经为我们提供了同步控制，比如： 在static{}区块中初始化的数据访问final字段时等等因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现： 采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载和线程安全。 实现代码如下： 静态内部类public class Singleton&#123; //内部类，在装载该内部类时才会去创建单利对象 private static class SingletonHolder&#123; public static Singleton instance = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton newInstance()&#123; return SingletonHolder.instance; &#125; public void doSomething()&#123; //do something &#125;&#125; 这样实现出来的单例类就是线程安全的，而且使用起来很简洁，麻麻再也不用担心我的单例不是单例了。 然而这还不是最简单的方式，Effective Java中推荐了一种更简洁方便的使用方式，就是使用枚举。 枚举类型单例模式public enum Singleton&#123; //定义一个枚举的元素，它就是Singleton的一个实例 instance; public void doSomething()&#123; // do something ... &#125; &#125; 使用方法如下： public static void main(String[] args)&#123; Singleton singleton = Singleton.instance; singleton.doSomething();&#125; 默认枚举实例的创建是线程安全的(创建枚举类的单例在JVM层面也是能保证线程安全的), 所以不需要担心线程安全的问题，所以理论上枚举类来实现单例模式是最简单的方式。 总结一般单例模式包含了5种写法，分别是饿汉、懒汉、双重校验锁、静态内部类和枚举。相信看完之后你对单例模式有了充分的理解了，根据不同的场景选择最你最喜欢的一种单例模式吧！ 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/20/android-design-pattern-singleton/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"Singleton","slug":"singleton","permalink":"http://agehua.github.io/tags/singleton/"}]},{"title":"ThreadLocal、HandlerThread、Looper区别","slug":"ThreadLocal-HandlerThread-Looper","date":"2016-09-04T16:00:00.000Z","updated":"2017-11-23T07:06:42.000Z","comments":true,"path":"2016/09/05/ThreadLocal-HandlerThread-Looper/","link":"","permalink":"http://agehua.github.io/2016/09/05/ThreadLocal-HandlerThread-Looper/","excerpt":"1.前言Android中非UI线程（WorkThread）不能操作UI线程（MainThread）\nhandler 发送Message 给MessageQueue，Looper 来轮询消息，如果有Message，然后再发送给Handler，Handler 拿到消息就可以所在的线程执行了。\n2.ThreadLocalThread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals ，这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。","text":"1.前言Android中非UI线程（WorkThread）不能操作UI线程（MainThread） handler 发送Message 给MessageQueue，Looper 来轮询消息，如果有Message，然后再发送给Handler，Handler 拿到消息就可以所在的线程执行了。 2.ThreadLocalThread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals ，这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。 简单理解就是每个线程维护一个map，然后可以用一定的关键字取出这个map里的目标类（比如一个bean），这个“一定的关键字”说的就是这个ThreadLocal 。 ThreadLocal隔离了各个线程，让各线程之间没有什么共享的问题。 参考：Android 中 Handler，Looper，HandlerThread 的使用 3.LooperLooper是Android handler机制的重要组成部分，Looper这个名字起的很形象，翻译过来是：打环的人，就是维护一个循环的人。Looper里有一个静态变量：private static final ThreadLocal sThreadLocal = new ThreadLocal();这是典型的Android里用到ThreadLocal的一个情况，调用Looper.prepare的时候，唯一做的事情就是把sThreadLocal作为key，把一个new出来的looper对象作为value put到相应线程的map里。然后以后用到Looper.loop的时候，就从这个sThreadLocal里取出这个Looper，然后死循环（阻塞循环）MessageQueue，取出Message并执行message指向的Handler。 4.HandlerSDK中关于Handler的说明如下： A Handler allows you to sendand process Messageand Runnable objects associated with a thread’s MessageQueue.Each Handler instance is associated with a single thread and that thread’smessage queue. When you create a new Handler, it is bound to the thread /message queue of the thread that is creating it – from that point on, it willdeliver messages and runnables to that message queue and execute them as theycome out of the message queue. 4.1 Handler的作用 There are two main uses for aHandler: (1) to schedule messages and runnables to be executed as some point inthe future; and (2) to enqueue an action to be performed on a different thread than your own. 在线程中实例化Handler需要保证线程当中包含Looper(注意：UI-Thread默认包含Looper)。 4.2 不是所有的Handler都能更新UIHandler处理消息总是在创建Handler的线程里运行。而我们的消息处理中，不乏更新UI的操作，不正确的线程直接更新UI将引发异常。因此，需要时刻关心Handler在哪个线程里创建的。如何更新UI才能不出异常呢？SDK告诉我们，有以下4种方式可以从其它线程访问UI线程(也即线程间通信)： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) 在UI线程中创建的Handler 几点小结 Handler的处理过程运行在创建Handler的线程里 一个Looper对应一个MessageQueue，一个线程对应一个Looper，一个Looper可以对应多个Handler 不确定当前线程时，更新UI时尽量调用View.post方法 handler应该由处理消息的线程创建。 handler与创建它的线程相关联，而且也只与创建它的线程相关联。handler运行在创建它的线程中，所以，如果在handler中进行耗时的操作，会阻塞创建它的线程。 Android的线程分为有消息循环的线程和没有消息循环的线程，有消息循环的线程一般都会有一个Looper。主线程（UI线程）就是一个消息循环的线程。 Looper.myLooper(); //获得当前的LooperLooper.getMainLooper() //获得UI线程的Looper Handle的初始化函数（构造函数），如果没有参数，那么他就默认使用的是当前的Looper，如果有Looper参数，就是用对应的线程的Looper。 如果一个线程中调用Looper.prepare()，那么系统就会自动的为该线程建立一个消息队列，然后调用Looper.loop();之后就进入了消息循环，这个之后就可以发消息、取消息、和处理消息。 5.消息的发送与处理我们简单地看一下消息的循环过程： 5.1 消息的生成Message msg =mHandler.obtainMessage();msg.what = what;msg.sendToTarget(); 5.2 消息的发送MessageQueue queue= mQueue; if (queue != null)&#123; msg.target =this; sent =queue.enqueueMessage(msg, uptimeMillis);&#125; 在Handler.java的sendMessageAtTime(Messagemsg, long uptimeMillis)方法中，我们看到，它找到它所引用的MessageQueue，然后将Message的target设定成自己（目的是为了在处理消息环节，Message能找到正确的Handler），再将这个Message纳入到消息队列中。 5.3 消息的抽取Looper me =myLooper();MessageQueue queue= me.mQueue;while (true) &#123; Message msg =queue.next(); // might block if (msg !=null) &#123; if(msg.target == null) &#123; // Notarget is a magic identifier for the quit message. return; &#125; msg.target.dispatchMessage(msg); msg.recycle(); &#125;&#125; 在Looper.java的loop()函数里，我们看到，这里有一个死循环，不断地从MessageQueue中获取下一个（next方法）Message，然后通过Message中携带的target信息，交由正确的Handler处理（dispatchMessage方法）。 5.4 消息的处理if (msg.callback!= null) &#123; handleCallback(msg);&#125; else &#123; if (mCallback!= null) &#123; if(mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg);&#125; 在Handler.java的dispatchMessage(Messagemsg)方法里，其中的一个分支就是调用handleMessage方法来处理这条Message，而这也正是我们在职责处描述使用Handler时需要实现handleMessage(Messagemsg)的原因。至于dispatchMessage方法中的另外一个分支，我将会在后面的内容中说明。至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。 参考上面的消息的发送与处理，这里再解释一下View.post(Runnable)方法。 在post(Runnableaction)方法里，View获得当前线程（即UI线程）的Handler，然后将action对象post到Handler里。 在Handler里，它将传递过来的action对象包装成一个Message（Message的callback为action），然后将其投入UI线程的消息循环中。 在 Handler再次处理该Message时，有一条分支就是为它所设，直接调用mCallback.handleMessage的方法，返回到runnable的run方法。 而此时，已经路由到UI线程里，因此，我们可以毫无顾虑的来更新UI。 5.HandlerThreadHandlerThread就是在普通的Thread基础上加上了Looper的支持，让用户不必自己去创建Looper了，同时方便了Handler的使用。 创建HandlerThread时需要把它启动了，即调用start()方法。然后创建Handler时将HandlerThread中的looper对象传入。 HandlerThread thread = new HandlerThread(\"MyHandlerThread\");thread.start();mHandler = new Handler(thread.getLooper());mHandler.post(new Runnable()&#123;...&#125;); 那么这个Handler对象就是与HandlerThread这个线程绑定了（这时就不再是与UI线程绑定了，这样在Handler中处理耗时操作将不会阻塞UI）。 如果想让HandlerThread退出，则需要调用handlerThread.quit()。 具体可以看下面代码： public class HandlerThreadActivity extends Activity &#123; private static final String TAG = \"HandlerThreadActivity\"; private HandlerThreadmHandlerThread; private MyHandler mMyHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generatedmethod stub super.onCreate(savedInstanceState); TextView text = new TextView(this); text.setText(\"HandlerThreadActivity\"); setContentView(text); Log.d(TAG, \"The mainthread id = \" + Thread.currentThread().getId()); //生成一个HandlerThread对象，实现了使用Looper来处理消息队列的功能， //这个类由Android应用程序框架提供 mHandlerThread = new HandlerThread(\"handler_thread\"); //在使用HandlerThread的getLooper()方法之前，必须先调用该类的start(); mHandlerThread.start(); //即这个Handler是运行在mHandlerThread这个线程中 mMyHandler = new MyHandler(mHandlerThread.getLooper()); mMyHandler.sendEmptyMessage(1); &#125; private class MyHandler extends Handler &#123; public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; Log.d(TAG, \"MyHandler--&gt;handleMessage--&gt;threadid = \" + Thread.currentThread().getId()); super.handleMessage(msg); &#125; &#125;&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/05/ThreadLocal-HandlerThread-Looper/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ThreadLocal","slug":"threadlocal","permalink":"http://agehua.github.io/tags/threadlocal/"},{"name":"HandlerThread","slug":"handlerthread","permalink":"http://agehua.github.io/tags/handlerthread/"},{"name":"Looper","slug":"looper","permalink":"http://agehua.github.io/tags/looper/"}]},{"title":"RxJava 学习","slug":"RxAndroid-Learning","date":"2016-08-15T16:00:00.000Z","updated":"2017-11-23T07:06:24.000Z","comments":true,"path":"2016/08/16/RxAndroid-Learning/","link":"","permalink":"http://agehua.github.io/2016/08/16/RxAndroid-Learning/","excerpt":"1.向前辈致敬给Android开发者的RxJava详解，这篇文章讲解详细，如果耐心看完，相信肯定收获不小\n本篇博文用作学习RxJava过程中，记录知识和心得，如有冒犯还请见谅！\n2.简单介绍RxJava是通过一种扩展的观察者模式来实现的。RxJava有四个基本概念：Observable(可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。","text":"1.向前辈致敬给Android开发者的RxJava详解，这篇文章讲解详细，如果耐心看完，相信肯定收获不小 本篇博文用作学习RxJava过程中，记录知识和心得，如有冒犯还请见谅！ 2.简单介绍RxJava是通过一种扩展的观察者模式来实现的。RxJava有四个基本概念：Observable(可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。 与传统观察者模式不同， RxJava 的事件回调方法除了普通事件onNext()（相当于onClick()/onEvent()）之外，还定义了两个特殊的事件：onCompleted()和onError()。 RxJava的基本实现主要有三点：Observer的创建、Observable的创建、Scheduler线程控制 3.Observer的创建方法Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式： Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 除了 Observer 接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber。 Subscriber对Observer接口进行了一些扩展，但他们的基本使用方式是完全一样的： Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; Observer和Subscriber区别对于使用者来说主要有两点： onStart(): 这是Subscriber增加的方法。 它会在subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。 需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart()就不适用了，因为它总是在subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法。 unsubscribe(): 这是Subscriber所实现的另一个接口Subscription的方法，用于取消订阅。 在这个方法被调用后，Subscriber将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 unsubscribe()这个方法很重要，因为在subscribe()之后，Observable会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 4.Observable的几种创建方法：1.Observable.just(T…)和from(T[])/from(Iterable&lt;? extends T&gt;) 1). just(T…): 将传入的参数依次发送出来 2). from(T[])/from(Iterable&lt;? extends T&gt;): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 3). 由这两个方法创建的Observable对象的特点是：所有Observer一旦订阅这个Observable就会立即调用onNext()方法并传入Observable.just()/from()的参数，而后因为Observable没有数据可以发送了，onComplete()方法会被调用。 Observable&lt;List&lt;String&gt;&gt; listObservable = Observable.just(getColorList()); 注意，如果just()中传入的是耗时方法，该方法会被立即执行并阻塞UI线程。这里的getColorList()是一个不耗时的方法. 下一步，我们写一个Observer来观察Observable。 listObservable.subscribe(new Observer&lt;List&lt;String&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;String&gt; colors) &#123; mSimpleStringAdapter.setStrings(colors); &#125;&#125;); 在这个例子中我们不关心Observable何时完成数据的传输，所以我们不用在onComplete()方法里写代码。而且在这里不会有异常抛出，所以我们也不用管onError()方法 2.Observable.fromCallable() 先看代码： Observable&lt;List&lt;String&gt;&gt; tvShowObservable = Observable.fromCallable(new Callable&lt;List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; call() &#123; return mRestClient.getFavoriteTvShows(); &#125;&#125;); 使用Observable.fromCallable()方法有两点好处： 1).获取要发送的数据的代码只会在有Observer订阅之后执行。 2).获取数据的代码（指的是call()方法）可以在子线程中执行。对比just()中传入的方法只能运行在主线程。 这两点好处有时可能非常重要。 现在让我们订阅这个Observable。 mTvShowSubscription = tvShowObservable .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;String&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;String&gt; tvShows)&#123; displayTvShows(tvShows); &#125;&#125;); 上面代码逐一介绍： 1).subscribeOn() 指定事件发生的线程 在默认情况下Observable的所有代码，都会在执行subscribe()方法的线程中运行。而通过subscribeOn()方法，这些代码可以在其他线程中执行。在上面的例子中，我们让代码在”IO Scheduler”中执行（Schedulers.io()）。现在我们可以只把Scheduler当做一个可以工作的子线程。 2).observeOn() 会指定onNext()方法发生的线程 通过在observeOn()方法中指定另一个Scheduler来完成onNext()的内容，在这里也就是AndroidSchedules.mainThread()所返回的Scheduler(UI线程的Scheduler)。 3).subscribe() Callable只会在有在Observable调用subscribe()后执行。 Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）： // 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public Subscription subscribe(Subscriber subscriber) &#123; subscriber.onStart(); onSubscribe.call(subscriber); return subscriber;&#125; 可以看到，subscriber()做了3件事： ①.调用Subscriber.onStart()。这个方法在前面已经介绍过，是一个可选的准备方法。 ②.调用Observable中的OnSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在RxJava中， Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。 ③.将传入的Subscriber作为Subscription返回。这是为了方便unsubscribe(). 4).mTvShowSubscription 每当Observer订阅Observable时就会生成一个Subscription对象。一个Subscription代表了一个Observer与Observable之间的连接。有时我们需要操作这个连接，这里拿在Activity的onDestroy()方法中的代码举个例子： if (mTvShowSubscription != null &amp;&amp; !mTvShowSubscription.isUnsubscribed()) &#123; mTvShowSubscription.unsubscribe(); //取消订阅&#125; unsubscribe()方法告诉Observable它所发送的数据不再被Observer所接收。在调用unsubscribe()方法后，我们创建的Observer就不再会收到数据了，以免Observable异步加载数据时发生意外。 3.使用SingleSingle是Observable的精简版，一种特殊的只发射单个值的Observable，几乎和Observable一模一样，但其回调方法不是onComplete()/onNext()/onError()，而是onSuccess()/onError()。 我们现在把刚才写过的Observable用Single重写一遍。首先我们要创建一个Single: Single&lt;List&lt;String&gt;&gt; tvShowSingle = Single.fromCallable(new Callable&lt;List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; call() throws Exception &#123; mRestClient.getFavoriteTvShows(); &#125;&#125;); 然后订阅一下 mTvShowSubscription = tvShowSingle .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new SingleSubscriber&lt;List&lt;String&gt;&gt;() &#123; @Override public void onSuccess(List&lt;String&gt; tvShows) &#123; displayTvShows(tvShows); &#125; @Override public void onError(Throwable error) &#123; displayErrorMessage(); &#125;&#125;); 但这次我们不再使用Observer，而是使用一个叫SingleSubscriber的类。这个类和Observer非常像，只不过它只有上述两个方法：onSuccess()和onError()。SingleSubscriber之于Single就如Observer之于Observable。 订阅一个Single的同时也会自动创建一个Subscription对象。这里的Subscription和上面的例子没有区别，一定要在onDestroy()中解除订阅。 5.线程控制——Scheduler RxJava已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： 1.Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 2.Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 3.Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 4.Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 5.另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 6.特殊的情况1.Subject Observable和Observer的复合体，也是二者的桥梁 Subjects = Observable + Observer，Subject继承自Observable实现了Observer Rxjava提供的四种Subject: ①PublishSubject ： subject的基础子类。 ②BehaviorSubject : 会首先向它的订阅者发送截止订阅前最新的一个数据，然后正常发送订阅后的数据流。 ③ReplaySubject ： 会缓存它所订阅的所有数据，向所有订阅它的观察者重发。 ④AsyncSubject ： 只会发布最后一个数据给已经订阅的每一个观察者。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/08/16/RxAndroid-Learning/","raw":null,"content":null,"categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"RxJava","slug":"rxjava","permalink":"http://agehua.github.io/tags/rxjava/"},{"name":"RxAndroid","slug":"rxandroid","permalink":"http://agehua.github.io/tags/rxandroid/"}]},{"title":"Android手机定位服务","slug":"android-LocationListener","date":"2016-08-02T16:00:00.000Z","updated":"2017-11-23T07:24:27.000Z","comments":true,"path":"2016/08/03/android-LocationListener/","link":"","permalink":"http://agehua.github.io/2016/08/03/android-LocationListener/","excerpt":"1.LocationListener使用优先使用网络定位服务，当GPS服务不可用则跳转到手机位置服务设置页面","text":"1.LocationListener使用优先使用网络定位服务，当GPS服务不可用则跳转到手机位置服务设置页面 代码收集： /** * 使用手机定位服务 */private void startLocationService()&#123; locationListener = new LocationListener() &#123; @Override public void onStatusChanged(String provider, int status, Bundle extras) &#123; &#125; @Override public void onProviderEnabled(String provider) &#123; // 当GPS LocationProvider可用时，更新位置 location = locManager.getLastKnownLocation(provider); &#125; @Override public void onProviderDisabled(String provider) &#123; isLocatedSuccess = false; if (provider.equals(\"network\")) &#123; locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3 * 1000, 8,locationListener); &#125;else if(provider.equals(\"gps\"))&#123;//GPS服务不可用，跳到位置服务设置页面 startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS)); &#125;else &#123; updateToNewLocation(null); &#125; &#125; @Override public void onLocationChanged(Location location) &#123; // 当定位信息发生改变时，更新位置 isLocatedSuccess = true; updateToNewLocation(location); locManager.removeUpdates(this); &#125; &#125;; if (locManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) locManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 3 * 1000, 8,locationListener); else if (locManager.getProvider(LocationManager.GPS_PROVIDER) != null) locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3 * 1000, 8,locationListener); else Toast.makeText(mActivity(), \"获取手机位置信息错误\", Toast.LENGTH_SHORT).show();&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/08/03/android-LocationListener/","raw":null,"content":null,"categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"LocationListener","slug":"locationlistener","permalink":"http://agehua.github.io/tags/locationlistener/"}]},{"title":"Android Webview总结，不断更新中 :(","slug":"android-webview-summary","date":"2016-07-24T16:00:00.000Z","updated":"2017-11-23T07:24:24.000Z","comments":true,"path":"2016/07/25/android-webview-summary/","link":"","permalink":"http://agehua.github.io/2016/07/25/android-webview-summary/","excerpt":"1.Android Webview的坑\n1.webview再次加载页面空白\n\n1.可以关闭掉硬件加速\n\n2.不关闭硬件加速的情况下：在关闭Acivity之前手动调用下面方法，\n\n","text":"1.Android Webview的坑 1.webview再次加载页面空白 1.可以关闭掉硬件加速 2.不关闭硬件加速的情况下：在关闭Acivity之前手动调用下面方法， public void goFinish()&#123; isLoadWithError =false; if (null!=jsCallBack) mWebView.removeJavascriptInterface(\"XXX\"); mWebView.setFocusable(true); mWebView.removeAllViews(); try &#123; mWebView.clearHistory(); //webview没有历史记录，这里会抛出异常 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; mWebView.destroy(); try &#123; //mWebView为WebView所在类的全局变量名，不可以混淆 Field fieldWebView = this.getClass().getDeclaredField(\"mWebView\"); fieldWebView.setAccessible(true); WebView webView = (WebView) fieldWebView.get(this); webView.removeAllViews(); webView.destroy(); &#125;catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125;catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125;catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; this.finish(); &#125; 注意：因为用到了反射去清理webview，所以混淆时，这个方法所在的类不能混淆 2.部分手机h5 game屏幕闪烁 在小米的某些手机上，会出现这种情况。抱歉，还没有好的解决办法。谁有好的解决办法可以邮件告知，多谢 :) 3.android Webview替代品Crosswalk Crosswalk解决4,2以下的手机浏览器的兼容性问题。对html5的支持更好 Crosswalk官网 但Crosswalk也有缺点，将Crosswalk嵌入App中，会使APK增加大约20M。具体可以看这个知乎提问 4.腾讯浏览服务 官网地址 2.WebView防止远程代码攻击 1.使用Android4.2以上的系统，通过在Java的远程方法上面声明一个@JavascriptInterface，可以预防改安全漏洞 2.低于Android4.2的系统，如果系统自己添加了一个叫searchBoxJavaBridge_的Js接口，则需要把这个接口删除 详情参见这篇文章：Android WebView的Js对象注入漏洞解决方案 这里贴一个自己整理的webview类：BaseWebView 3.Android中WebView的JavaScript代码和本地代码交互的三种方式来自姜维的博客:Android中WebView的JavaScript代码和本地代码交互的三种方式 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/07/25/android-webview-summary/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"webview","slug":"webview","permalink":"http://agehua.github.io/tags/webview/"}]},{"title":"Gson解析使用总结","slug":"gson-summary","date":"2016-06-07T16:00:00.000Z","updated":"2017-11-23T07:05:38.000Z","comments":true,"path":"2016/06/08/gson-summary/","link":"","permalink":"http://agehua.github.io/2016/06/08/gson-summary/","excerpt":"1.Gson解析总结，就两种情况Gson 是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个JSON字符串转成一个Java对象，或者将Java对象转成一个JSON字符串。使用Gson来解析时，总结一下，就两句话：\n\n1.遇到“{”字符，表示单个对象，直接用XXXBean.class类去映射\n2.遇到“[”字符，表示对象数组，要用XXXBean[].class或list去映射\n","text":"1.Gson解析总结，就两种情况Gson 是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个JSON字符串转成一个Java对象，或者将Java对象转成一个JSON字符串。使用Gson来解析时，总结一下，就两句话： 1.遇到“{”字符，表示单个对象，直接用XXXBean.class类去映射 2.遇到“[”字符，表示对象数组，要用XXXBean[].class或list去映射 2.第一种情况，举例 json字符串是： &#123; \"items\": [ &#123; \"key\": \"H60-L12__1464938219953__346589_483\", \"hash\": \"Fip_In4BhB5syoZ28W3l_eb6rBDU\", \"fsize\": 348120, \"mimeType\": \"image/jpeg\", \"putTime\": 14649382507765902 &#125;, &#123; \"key\": \"H60-L12__1465352164202__397253_2946\", \"hash\": \"Fs-UwiosdckN9kVY01GrOYC-b7a9\", \"fsize\": 938413, \"mimeType\": \"image/jpeg\", \"putTime\": 14653521712332144 &#125;, &#123; \"key\": \"H60-L12__1465352548728__322577_4114\", \"hash\": \"Frga_QiMJVb9caiuwMlJABCsu1rc\", \"fsize\": 506921, \"mimeType\": \"image/jpeg\", \"putTime\": 14653525989907168 &#125; ]&#125; 分析 最开始是一个“{”字符，所以需要用gson.fromJson(jsonstring, XXXBean.class)来解析。同时，XXXBean中只有一个字段items。items里面是一个“[”字符，表示items里面是数组，可以用list去映射。 解析时， 最后对应的Gson对象就是： public class XXXBean &#123; public List&lt;XXXItem&gt; items; public List&lt;XXXItem&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;XXXItem&gt; items) &#123; this.items = items; &#125; public static class XXXItem &#123; private String key; private String hash; private String fsize; private String mimeType; private String putTime; ... &#125;&#125;Gson gson = new Gson();List&lt;XXXBean.XXXItem&gt; list = gson.fromJson(jsonstring,XXXBean.class).getItems(); 3.第二种情况，举例json字符串以“[”开头。 例如，json==[{“id”:1,”name”:”李坤”,”birthDay”:”Jun 22, 2012 8:28:52 AM”},{“id”:2,”name”:”曹贵生”,”birthDay”:”Jun 22, 2012 8:28:52 AM”},{“id”:3,”name”:”柳波”,”birthDay”:”Jun 22, 2012 8:28:52 AM”}] 解析时，需要使用list来接收。 List&lt;Student&gt; retList = gson.fromJson(jsonstring2, new TypeToken&lt;List&lt;Student&gt;&gt;()&#123;&#125;.getType()); 也可以这样 Student[] students= gson.fromJson(jsonstring2,new Student[].class); 对应list为什么要使用TypeToken？ TypeToken是Gson提供的，来实现对泛型的支持 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/06/08/gson-summary/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"gson","slug":"gson","permalink":"http://agehua.github.io/tags/gson/"}]},{"title":"七牛android使用总结","slug":"qiniu-android-summary","date":"2016-05-27T16:00:00.000Z","updated":"2017-11-23T07:24:19.000Z","comments":true,"path":"2016/05/28/qiniu-android-summary/","link":"","permalink":"http://agehua.github.io/2016/05/28/qiniu-android-summary/","excerpt":"1.在android上实现对七牛空间操作  在android上实现对七牛空间的各种操作，包括list，delete，upload，download。支持私有空间\n  注意：官方不建议开发者把AccessKey和SecretKey放在前端的java文件里，最好还是有一台应用服务器\n  如果只是想尝试一下，好吧:)  代码中都有说明，直接上代码","text":"1.在android上实现对七牛空间操作 在android上实现对七牛空间的各种操作，包括list，delete，upload，download。支持私有空间 注意：官方不建议开发者把AccessKey和SecretKey放在前端的java文件里，最好还是有一台应用服务器 如果只是想尝试一下，好吧:) 代码中都有说明，直接上代码 2.代码一共有三个类： 工具类： package com.qiniu.ui.utils;import android.graphics.Bitmap;import android.graphics.Bitmap.CompressFormat;import android.os.Environment;import android.util.Log;import com.loopj.android.http.AsyncHttpClient;import com.loopj.android.http.AsyncHttpResponseHandler;import com.loopj.android.http.RequestParams;import com.qiniu.android.storage.UpProgressHandler;import com.qiniu.android.storage.UploadManager;import com.qiniu.android.storage.UploadOptions;import com.qiniu.android.utils.UrlSafeBase64;import com.qiniu.api.auth.AuthException;import com.qiniu.api.auth.digest.Mac;import com.qiniu.api.rs.PutPolicy;import com.qiniu.ui.SHA;import com.qiniu.ui.contains.QiNiuConfig;import org.apache.http.Header;import org.json.JSONException;import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.util.Random;import static com.qiniu.ui.SHA.hMacSHA1Encrypt;/** * @date 2016年5月26日 上午11:00:43 * @author lijixin * @web https://agehua.github.io * @Description: 七牛云图片操作 */public class QiniuUitls &#123; private static final String fileName = \"temp.jpg\"; private static final String tempJpeg = Environment.getExternalStorageDirectory().getPath() + \"/\" + fileName; private static int maxWidth = 720; private static int maxHeight = 1080; public interface QiniuUploadUitlsListener &#123; void onSucess(String fileUrl); void onError(int errorCode, String msg); void onProgress(int progress); &#125; public interface QiniuRequestListener &#123; void onSucceed(byte[] bytes); void onFailed(byte[] bytes); &#125; /** * 将bitmap转换成jpeg，控制图片大小不大于720*1080，可以指定图片压缩质量 * @param bitmap * @param filePath * @param quality * @return */ public static boolean saveBitmapToJpegFile(Bitmap bitmap, String filePath, int quality) &#123; try &#123; FileOutputStream fileOutStr = new FileOutputStream(filePath); BufferedOutputStream bufOutStr = new BufferedOutputStream(fileOutStr); resizeBitmap(bitmap).compress(CompressFormat.JPEG, quality, bufOutStr); bufOutStr.flush(); bufOutStr.close(); &#125; catch (Exception exception) &#123; return false; &#125; return true; &#125; /** * 缩小图片 * * @param bitmap * @return */ public static Bitmap resizeBitmap(Bitmap bitmap) &#123; if (bitmap != null) &#123; int width = bitmap.getWidth(); int height = bitmap.getHeight(); //宽度大于720 if (width &gt; maxWidth) &#123; //按宽度等比例压缩图片 int pWidth = maxWidth; int pHeight = maxWidth * height / width; Bitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, false); bitmap.recycle(); return result; &#125; if (height &gt; maxHeight) &#123; //按高度等比例缩小图片 int pHeight = maxHeight; int pWidth = maxHeight * width / height; Bitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, false); bitmap.recycle(); return result; &#125; &#125; return bitmap; &#125; public static void uploadImage(Bitmap bitmap, QiniuUploadUitlsListener listener) &#123; saveBitmapToJpegFile(bitmap, tempJpeg,100); uploadImage(tempJpeg, listener); &#125; /** * 上传图片选择jpg格式，七牛图片api目前支持对jpg格式进行指定图片质量请求 * @param filePath * @param listener */ public static void uploadImage(String filePath, final QiniuUploadUitlsListener listener) &#123; final String fileUrlUUID = getFileUrlUUID(); String token = getToken(); if (token == null) &#123; if (listener != null) &#123; listener.onError(-1, \"token is null\"); &#125; return; &#125; UploadManager uploadManager = new UploadManager(); uploadManager.put(filePath, fileUrlUUID, token, (key, info, response) -&gt; &#123; System.out.println(\"debug:info = \" + info + \",response = \" + response); if (info != null &amp;&amp; info.statusCode == 200) &#123;// 上传成功 String fileRealUrl = getRealUrl(fileUrlUUID); System.out.println(\"debug:fileRealUrl = \" + fileRealUrl); if (listener != null) &#123; listener.onSucess(fileRealUrl); &#125; &#125; else &#123; if (listener != null) &#123; listener.onError(info.statusCode, info.error); &#125; &#125; &#125;, new UploadOptions(null, null, false, new UpProgressHandler() &#123; public void progress(String key, double percent) &#123; if (listener != null) &#123; listener.onProgress((int) (percent * 100)); &#125; &#125; &#125;, null)); &#125; /** * 生成远程文件路径（全局唯一） * &lt;p&gt;格式类似： H60-L12__1464851303930__156750_1884&lt;/p&gt; * @return */ private static String getFileUrlUUID() &#123; String filePath = android.os.Build.MODEL + \"__\" + System.currentTimeMillis() + \"__\" + (new Random().nextInt(500000)) + \"_\" + (new Random().nextInt(10000)); return filePath.replace(\".\", \"0\"); &#125; private static String getRealUrl(String fileUrlUUID) &#123; String filePath = \"http://\" + QiNiuConfig.QINIU_BUCKNAME + \".qiniudn.com/\" + fileUrlUUID; return filePath; &#125; /** * 获取token 本地生成 * * @return */ private static String getToken() &#123; Mac mac = new Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK); PutPolicy putPolicy = new PutPolicy(QiNiuConfig.QINIU_BUCKNAME); putPolicy.returnBody = \"&#123;\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)&#125;\"; try &#123; String uptoken = putPolicy.token(mac); System.out.println(\"debug:uptoken = \" + uptoken); return uptoken; &#125; catch (AuthException e) &#123; e.printStackTrace(); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 根据host和文件名，生成file的url下载地址，支持私有空间 * @param domain host：七牛的私有空间域名 * @param imgKey file key：空间里的文件名 * @return url下载地址 */ public static String downloadFile(String domain,String imgKey)&#123; //密钥配置 //构造私有空间的需要生成的下载的链接// String domain =\"http://example.xxx.clouddn.com/\";// String path =\"H60-L12__1464917382714__36888_5255\"; StringBuilder sb =new StringBuilder(); //加上过期时间戳字段 String url = sb.append(domain).append(imgKey).append(\"?e=1478365261\").toString(); Log.e(\"encodedEntryURI\",url); byte[] sign =null; try &#123; sign = SHA.hMacSHA1Encrypt(url,QiNiuConfig.QINIU_SK); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; String encodedSign = UrlSafeBase64.encodeToString(sign); sb.append(\"&amp;token=\").append(QiNiuConfig.QINIU_AK).append(\":\").append(encodedSign); Log.e(\"download token\",sb.toString()); return sb.toString(); &#125; /** * 列出空间中指定格式的文件 * @param bucket 空间名 * @param prefix 要指定的格式（前缀） * @param listener * @return */ public static void listFile(String bucket, String prefix,final QiniuRequestListener listener)&#123; try&#123; StringBuilder sb = new StringBuilder(); String entryUrl = sb.append(\"bucket=\").append(bucket) .append(\"&amp;prefix=\").append(prefix).toString(); String host = \"http://rsf.qbox.me\"; String path = \"/list?\" +entryUrl; String url = host+path; Log.e(\"AAAAAAA\", url); byte[] sign = SHA.hMacSHA1Encrypt(path+\"\\n\", QiNiuConfig.QINIU_SK); String encodedSign = UrlSafeBase64.encodeToString(sign); String authorization = QiNiuConfig.QINIU_AK + ':' + encodedSign; AsyncHttpClient client = new AsyncHttpClient(); client.addHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); client.addHeader(\"Authorization\", \"QBox \"+authorization); RequestParams params = new RequestParams(); client.post(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int i, Header[] headers, byte[] bytes) &#123; if (null!=listener) listener.onSucceed(bytes); &#125; @Override public void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) &#123; if (null!=listener) listener.onFailed(bytes); &#125; &#125;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return ; &#125; /** * 删除空间中的文件 * @param bucket 删除文件的空间 * @param fileName 删除的文件 * */ public static boolean deleteFile(String bucket,String fileName,final QiniuRequestListener listener)&#123; try&#123; String entryUrl = bucket+\":\"+fileName; String encodedEntryURI = UrlSafeBase64.encodeToString(entryUrl.getBytes()); String host = \"http://rs.qiniu.com\"; String path = \"/delete/\"+encodedEntryURI; String url = host+path; Log.e(\"AAAAAAA\", url); byte[] sign = hMacSHA1Encrypt(path+\"\\n\", QiNiuConfig.QINIU_SK); String encodedSign = UrlSafeBase64.encodeToString(sign); String authorization = QiNiuConfig.QINIU_AK + ':' + encodedSign; AsyncHttpClient client = new AsyncHttpClient(); client.addHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); client.addHeader(\"Authorization\", \"QBox \"+authorization); RequestParams params = new RequestParams(); client.post(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int i, Header[] headers, byte[] bytes) &#123; if (null!=listener) listener.onSucceed(bytes); &#125; @Override public void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) &#123; if (null!=listener) listener.onFailed(bytes); if (null!=bytes) &#123; String s = new String(bytes); &#125; &#125; &#125;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return false; &#125;&#125; HMAC-SHA1签名加密类 使用下面方法生成对应七牛资源管理里用到的管理凭证 /** * 对外提供HMAC-SHA1签名方法 * @author agehua * */public class SHA &#123; private static final String MAC_NAME = \"HmacSHA1\"; private static final String ENCODING = \"UTF-8\"; /** * * 使用 HMAC-SHA1 签名方法对对encryptText进行签名 * @param encryptText 被签名的字符串 * @param encryptKey 密钥 * @return * @throws Exception */ public static byte[] hMacSHA1Encrypt(String encryptText, String encryptKey) throws Exception &#123; byte[] data = encryptKey.getBytes(ENCODING); // 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称 SecretKey secretKey = new SecretKeySpec(data, MAC_NAME); // 生成一个指定 Mac 算法 的 Mac 对象 Mac mac = Mac.getInstance(MAC_NAME); // 用给定密钥初始化 Mac 对象 mac.init(secretKey); byte[] text = encryptText.getBytes(ENCODING); // 完成 Mac 操作 return mac.doFinal(text); &#125;&#125; ~~~ - 还有一个Config文件~~~ Javapublic final class QiNiuConfig &#123; public static final String token = getToken(); public static final String QINIU_AK = \"Your_AccessKey\"; public static final String QINIU_SK = \"Your_SecretKey\"; public static final String QINIU_BUCKNAME = \"你的私有空间\"; public static String getToken() &#123; Mac mac = new Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK); PutPolicy putPolicy = new PutPolicy(QiNiuConfig.QINIU_BUCKNAME); putPolicy.returnBody = \"&#123;\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)&#125;\"; try &#123; String uptoken = putPolicy.token(mac); System.out.println(\"debug:uptoken = \" + uptoken); return uptoken; &#125; catch (AuthException e) &#123; e.printStackTrace(); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 点击在Gist上查看上面这些代码 最后，如果有问题欢迎讨论，我的邮箱简介里有 :) 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/28/qiniu-android-summary/","raw":null,"content":null,"categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"qiniu","slug":"qiniu","permalink":"http://agehua.github.io/tags/qiniu/"}]},{"title":"android JNI学习② JNI调用过程","slug":"JNI-Learning0","date":"2016-05-23T16:00:00.000Z","updated":"2017-11-23T07:05:09.000Z","comments":true,"path":"2016/05/24/JNI-Learning0/","link":"","permalink":"http://agehua.github.io/2016/05/24/JNI-Learning0/","excerpt":"1.Android JNI调用过程1.1 由Android系统加载的JNIAndroid系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会AndroidRuntime.cpp中的startVm创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。","text":"1.Android JNI调用过程1.1 由Android系统加载的JNIAndroid系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会AndroidRuntime.cpp中的startVm创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。 在AndroidRuntime.cpp中： int AndroidRuntime::startReg(JNIEnv* env)&#123; //设置线程创建方法为javaCreateThreadEtc androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); env-&gt;PushLocalFrame(200); //进程NI方法的注册 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); return 0;&#125; register_jni_procs(gRegJNI, NELEM(gRegJNI), env)这行代码的作用就是就是循环调用gRegJNI数组成员所对应的方法。 static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)&#123; for (size_t i = 0; i &lt; count; i++) &#123; if (array[i].mProc(env) &lt; 0) &#123; return -1; &#125; &#125; return 0;&#125; gRegJNI数组，有100多个成员变量，定义在AndroidRuntime.cpp： static const RegJNIRec gRegJNI[] = &#123; REG_JNI(register_android_os_MessageQueue), REG_JNI(register_android_os_Binder), ...&#125;; 该数组的每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，该宏的作用就是调用相应的方法。 比如MessageQueue和Binder方法都是Android系统启动时就已经注册，所以在AndroidRuntime.cpp中可以找到相应的native方法，见AndroidRuntime.cpp的gRegJNI数组。这些注册方法命令格式为： register_[包名]_[类名] 示例一：以MessageQueue.java中的nativePollOnce方法为例，private native void nativePollOnce(long ptr, int timeoutMillis); 方法名：android.os.MessageQueue.nativePollOnce()，而相对应的native层方法名只是将点号替换为下划线，可得android_os_MessageQueue_nativePollOnce()。 前面说MessageQueue.java所定义的jni注册方法名应该是register_android_os_MessageQueue，的确存在于gRegJNI数组，说明这次JNI注册过程是有开机过程完成的。该方法在AndroidRuntime.cpp申明为extern方法： extern int register_android_os_MessageQueue(JNIEnv* env); 这些extern方法绝大多数位于/framework/base/core/jni/目录，大多数情况下native文件命名方式： [包名]_[类名].cpp[包名]_[类名].h Tips： MessageQueue.java ==&gt; android_os_MessageQueue.cpp 打开android_os_MessageQueue.cpp文件，搜索android_os_MessageQueue_nativePollOnce方法，这便找到了目标方法： static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 示例二：对于native文件命名方式，有时并非[包名]_[类名].cpp，比如Binder.javaBinder.java所对应的native文件：android_util_Binder.cpp public static final native int getCallingPid(); 根据示例一方式，找到getCallingPid ==&gt; android_os_Binder_getCallingPid()，并且在AndroidRuntime.cpp中的gRegJNI数组中找到register_android_os_Binder。 按实例(一)方式则native文名应该为android_os_Binder.cpp，可是在/framework/base/core/jni/目录下找不到该文件，这是例外的情况。其实真正的文件名为android_util_Binder.cpp，这就是例外，这一点有些费劲，不明白为何google要如此打破规律的命名。 static jint android_os_Binder_getCallingPid(JNIEnv* env, jobject clazz)&#123; return IPCThreadState::self()-&gt;getCallingPid();&#125; 有人可能好奇，既然如何遇到打破常规的文件命令，怎么办？这个并不难，首先，可以尝试在/framework/base/core/jni/中搜索，对于binder.java，可以直接搜索binder关键字，其他也类似。如果这里也找不到，可以通过grep全局搜索android_os_Binder_getCallingPid这个方法在哪个文件。 jni存在的常见目录： /framework/base/core/jni/ /framework/base/services/core/jni/ /framework/base/media/jni/ 1.2 加载自定义的JNI方法前面两种都是在Android系统启动之初，便已经注册过JNI所对应的方法。 那么如果程序自己定义的jni方法，该如何查看jni方法所在位置呢？下面以MediaPlayer.java为例，其包名为android.media： public class MediaPlayer&#123; static &#123; System.loadLibrary(\"media_jni\"); native_init(); &#125; private static native final void native_init(); ...&#125; 通过static静态代码块中System.loadLibrary方法来加载动态库，库名为media_jni, Android平台则会自动扩展成所对应的libmedia_jni.so库 接下来便要查看libmedia_jni.so库定义所在文件，一般都是通过Android.mk文件定义LOCAL_MODULE:= libmedia_jni，可以采用grep或者mgrep来搜索包含libmedia_jni字段的Android.mk所在路径。 搜索可知，libmedia_jni.so位于/frameworks/base/media/jni/Android.mk。用前面实例(一)中的知识来查看相应的文件和方法名分别为： android_media_MediaPlayer.cppandroid_media_MediaPlayer_native_init() 再然后，你会发现果然在该Android.mk所在目录/frameworks/base/media/jni/中找到android_media_MediaPlayer.cpp文件，并在文件中存在相应的方法： static voidandroid_media_MediaPlayer_native_init(JNIEnv *env)&#123; jclass clazz; clazz = env-&gt;FindClass(\"android/media/MediaPlayer\"); fields.context = env-&gt;GetFieldID(clazz, \"mNativeContext\", \"J\"); ...&#125; Tips：MediaPlayer.java中的native_init方法所对应的native方法位于/frameworks/base/media/jni/目录下的android_media_MediaPlayer.cpp文件中的android_media_MediaPlayer_native_init方法。 总结：System.loadLibrary()的作用就是调用相应库中的JNI_OnLoad()方法。 1.3 说说JNI_OnLoad()过程。[-&gt; android_media_MediaPlayer.cpp] jint JNI_OnLoad(JavaVM* vm, void* reserved)&#123; JNIEnv* env = NULL; if (register_android_media_MediaPlayer(env) &lt; 0) &#123; goto bail; &#125; ...&#125; 详细说一下register_android_media_MediaPlayer [-&gt; android_media_MediaPlayer.cpp] static int register_android_media_MediaPlayer(JNIEnv *env)&#123; //【见3.4】 return AndroidRuntime::registerNativeMethods(env, \"android/media/MediaPlayer\", gMethods, NELEM(gMethods));&#125; 虚拟机相关的变量中有两个非常重要的量JavaVM和JNIEnv: 1.JavaVM：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例 2.JNIEnv：是指线程上下文环境，每个线程有且只有一个JNIEnv实例 其中gMethods，记录java层和C/C++层方法的一一映射关系。 static JNINativeMethod gMethods[] = &#123; &#123;\"prepare\", \"()V\", (void *)android_media_MediaPlayer_prepare&#125;, &#123;\"_start\", \"()V\", (void *)android_media_MediaPlayer_start&#125;, &#123;\"_stop\", \"()V\", (void *)android_media_MediaPlayer_stop&#125;, &#123;\"seekTo\", \"(I)V\", (void *)android_media_MediaPlayer_seekTo&#125;, &#123;\"_release\", \"()V\", (void *)android_media_MediaPlayer_release&#125;, &#123;\"native_init\", \"()V\", (void *)android_media_MediaPlayer_native_init&#125;, ...&#125;; 这里涉及到结构体JNINativeMethod，其定义在jni.h文件： typedef struct &#123; const char* name; //Java层native函数名 const char* signature; //Java函数签名，记录参数类型和个数，以及返回值类型 void* fnPtr; //Native层对应的函数指针&#125; JNINativeMethod; 2.JNI资源JNINativeMethod结构体中有一个字段为signature(签名)，再介绍signature格式之前需要掌握各种数据类型在Java层、Native层以及签名所采用的签名格式。 2.1 数据类型 基本数据类型 Signature格式 Java Native B byte jbyte C char jchar D double jdouble F float jfloat I int jint S short jshort J long jlong Z boolean jboolean V void void 数组数据类型 数组简称则是在前面添加[： Signature格式 Java Native [B byte[] jbyteArray [C char[] jcharArray [D double[] jdoubleArray [F float[] jfloatArray [I int[] jintArray [S short[] jshortArray [J long[] jlongArray [Z boolean[] jbooleanArray 复杂数据类型 对象类型简称：L+classname +; Signature格式 Java Native Ljava/lang/String; String jstring L+classname +; 所有对象 jobject [L+classname +; Object[] jobjectArray Ljava.lang.Class; Class jclass Ljava.lang.Throwable; Throwable jthrowable Signature 有了前面的铺垫，那么再来通过实例说说函数签名： (输入参数…)返回值参数，这里用到的便是前面介绍的Signature格式。 Java函数 对应的签名 void foo() ()V float foo(int i) (I)F long foo(int[] i) ([I)J double foo(Class c) (Ljava/lang/Class;)D boolean foo(int[] i,String s) ([ILjava/lang/String;)Z String foo(int i) (I)Ljava/lang/String; 2.2 其他 (一)垃圾回收对于Java开发人员来说无需关系垃圾回收，完全由虚拟机GC来负责垃圾回收，而对于JNI开发人员，对于内存释放需要谨慎处理，需要的时候申请，使用完记得释放内容，以免发生内存泄露。在JNI提供了三种Reference类型，Local Reference(本地引用)， Global Reference（全局引用）， Weak Global Reference(全局弱引用)。其中Global Reference如果不主动释放，则一直不会释放；对于其他两个类型的引用都是释放的可能性，那是不是意味着不需要手动释放呢？答案是否定的，不管是这三种类型的那种引用，都尽可能在某个内存不再需要时，立即释放，这对系统更为安全可靠，以减少不可预知的性能与稳定性问题。 另外，ART虚拟机在GC算法有所优化，为了减少内存碎片化问题，在GC之后有可能会移动对象内存的位置，对于Java层程序并没有影响，但是对于JNI程序可要小心了，对于通过指针来直接访问内存对象是，Dalvik能正确运行的程序，ART下未必能正常运行。 (二)异常处理Java层出现异常，虚拟机会直接抛出异常，这是需要try..catch或者继续往外throw。但是对于JNI出现异常时，即执行到JNIEnv中某个函数异常时，并不会立即抛出异常来中断程序的执行，还可以继续执行内存之类的清理工作，直到返回到Java层时才会抛出相应的异常。 另外，Dalvik虚拟机有些情况下JNI函数出错可能返回NULL，但ART虚拟机在出错时更多的是抛出异常。这样导致的问题就可能是在Dalvik版本能正常运行的程序，在ART虚拟机上由于没有正确处理异常而崩溃。 3.JNI知识积累JNI学习积累之一 —- 常用函数大全http://blog.csdn.net/qinjuning/article/details/7595104 JNI学习积累之二 —- 数据类型映射、域描述符说明http://blog.csdn.net/qinjuning/article/details/7599796 JNI学习积累之三 —- 操作JNI函数以及复杂对象传递http://blog.csdn.net/qinjuning/article/details/7607214 JNI 实战全面解析http://blog.csdn.net/banketree/article/details/40535325 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/24/JNI-Learning0/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"JNI","slug":"jni","permalink":"http://agehua.github.io/tags/jni/"},{"name":"android source code","slug":"android-source-code","permalink":"http://agehua.github.io/tags/android-source-code/"}]},{"title":"android JNI学习① 基础知识","slug":"JNI-Learning","date":"2016-05-23T16:00:00.000Z","updated":"2017-11-23T07:04:34.000Z","comments":true,"path":"2016/05/24/JNI-Learning/","link":"","permalink":"http://agehua.github.io/2016/05/24/JNI-Learning/","excerpt":"本文只是用来记录，写的不好还请见谅。\n1.JNI介绍JNI概念 : Java本地接口,Java Native Interface, 它是一个协议, 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码;\nC和Java的侧重 :\n\nC语言 : C语言中最重要的是 函数 function;\nJava语言 : Java中最重要的是 JVM, class类, 以及class中的方法;\n\nC与Java如何交流 :\n\nJNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范;\nC语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法;\nJava语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上;\nJNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍;\n","text":"本文只是用来记录，写的不好还请见谅。 1.JNI介绍JNI概念 : Java本地接口,Java Native Interface, 它是一个协议, 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码; C和Java的侧重 : C语言 : C语言中最重要的是 函数 function; Java语言 : Java中最重要的是 JVM, class类, 以及class中的方法; C与Java如何交流 : JNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范; C语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法; Java语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上; JNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍; JNI中的一些概念 : native : Java语言中修饰本地方法的修饰符, 被该修饰符修饰的方法没有方法体; Native方法 : 在Java语言中被native关键字修饰的方法是Native方法; JNI层 : Java声明Native方法的部分; JNI函数 : JNIEnv提供的函数, 这些函数在jni.h中进行定义; JNI方法 : Native方法对应的JNI层实现的 C/C++方法, 即在jni目录中实现的那些C语言代码; 2.NDK简单介绍C代码执行 : C代码被编译成库文件之后, 才能执行, 库文件分为动态库 和静态库 两种; 动态库 : unix环境下.so后缀的是动态库, windows环境下.dll 后缀的是动态库; 动态库可以依赖静态库加载一些可执行的C代码; 静态库 :.a后缀是静态库的扩展名; 库文件来源 : C代码 进行 编译 链接操作之后, 才会生成库文件, 不同类型的CPU 操作系统 生成的库文件是不一样; CPU分类 : arm结构, 嵌入式设备处理器; x86结构, pc服务器处理器; 不同的CPU指令集不同; 交叉编译 :windows x86编译出来的库文件可以在arm平台运行的代码; 交叉编译工具链 : Google提供的 NDK 就是交叉编译工具链, 可以在linux环境下编译出在arn平台下执行的二进制库文件; NDK作用 : 是Google提供了交叉编译工具链, 能够在linux平台编译出在arm平台下执行的二进制库文件; NDK版本介绍 : android-ndk-windows 是在windows系统中的cygwin使用的, android-ndk-linux 是在linux下使用的; 想深入了解NDK开发的同学，可以去安装一下cygwin，本文只涉及简单的C语言代码，不需要使用cygwin。 3.环境准备，使用android studio还是Eclipse推荐使用Eclipse，这篇文章讲了使用Eclipse生成.h文件和生成so文件的配置过程。配置成功后可以远离命令行Eclipse ADT插件生成.h/.so文件 3.1 Java调用C流程 a. 定义 Native 方法 : 比如在com.packagename.jni.JNITest.java 类中定义 Native 方法 public native int add(int x, int y); b. 生成方法签名 : 进入 AndroidProject/bin/classes 目录, 使用 javah com.packagename.jni.JNITest 命令, 便生成了头文件, 该头文件引用了 jni.h, 以及定义好了对应的 Native 方法, 生成 JNIEXPORT jint JNICALL Java_com_packagename_jni_JNITest_add (JNIEnv *, jobject, jint, jint); Java中定义的方法 : //将Java中的两个int值 传给C语言, 进行相加后, 返回java语言 shuliang.han.ndkparameterpassing.DataProvider public native int add(int x, int y); 对应C语言中定义的方法 : #include &lt;jni.h&gt; //方法签名, Java环境和调用native方法的类必不可少, 后面的参数就是native方法的参数 jint Java_com_packagename_jni_JNITest_add(JNIEnv * env, jobject obj, jint x, jint y) &#123; return x + y; &#125; 3.2 生成.so文件Android.mk 文件： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := hello-jni LOCAL_SRC_FILES := hello-jni.c include $(BUILD_SHARED_LIBRARY) 文件内容解释： 获取当前文件内容 : $(call my-dir) 是编译器中的宏方法, 调用该宏方法, 就会返回前的目录路径; 赋值符号 : “ := “ 是赋值符号, 第一句话 是 返回当前文件所在的当前目录, 并将这个目录路径赋值给 LOCAL_PATH; 初始化编译模块参数 : $(CLEAR_VARS) 作用是将编译模块的参数初始化, LOCAL_MODULE LOCAL_SRC_FILES 也是这样的参数; 指定编译模块 : LOCAL_MODULE := hello-jni , 指定编译后的 so 文件名称, 编译好之后系统会在该名称前面加上 “lib”, 后缀加上 “.so”; 指定编译源文件 : LOCAL_SRC_FILES := hello-jni.c 告诉编译系统源文件, 如果有多个文件那么就依次写在后面即可; 编译成静态库 : include $(BUILD_SHARED_LIBRARY), 作用是告诉系统, 将编译的结果编译成.so后缀的静态库; 静态库引入 : NDK的platform中有很多 “.a” 结尾的动态库, 我们编译动态库的时候, 可以将一些静态库引入进来; 生成 动态库 so 文件 : 进入 Android.mk 所在目录, 在该目录执行ndk下的ndk-build命令; Java代码加载动态库 : 在 Java 代码中调用该类的类前面, 在类的一开始, 不在方法中, 加入 static&#123; System.loadLibrary(\"hello\"); &#125; ; Application.mk 文件内容为（不写这个文件也可以）: APP_STL := stlport_staticAPP_ABI := all 这篇文章是使用javah导出头文件过程中，常见错误和解决办法，这里做一个记录。 4.字符串的处理 Java中的String转为C语言中的char字符串下面的工具方法可以在C程序中解决这个问题： // java中的jstring, 转化为c的一个字符数组 char* Jstring2CStr(JNIEnv* env, jstring jstr) &#123; //声明了一个字符串变量 rtn char* rtn = NULL; //找到Java中的String的Class对象 jclass clsstring = (*env)-&gt;FindClass(env, \"java/lang/String\"); //创建一个Java中的字符串 \"GB2312\" jstring strencode = (*env)-&gt;NewStringUTF(env, \"GB2312\"); /* * 获取String中定义的方法 getBytes(), 该方法的参数是 String类型的, 返回值是 byte[]数组 * \"(Ljava/lang/String;)[B\" 方法前面解析 : * -- Ljava/lang/String; 表示参数是String字符串 * -- [B : 中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组 */ jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\"); //调用Java中的getBytes方法, 传入参数介绍 参数②表示调用该方法的对象, 参数③表示方法id , 参数④表示方法参数 jbyteArray barr = (jbyteArray)(*env)-&gt;CallObjectMethod(env, jstr, mid, strencode); // String .getByte(\"GB2312\"); //获取数组的长度 jsize alen = (*env)-&gt;GetArrayLength(env, barr); //获取数组中的所有的元素 , 存放在 jbyte*数组中 jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE); //将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 '\\0' if (alen &gt; 0) &#123; rtn = (char*) malloc(alen + 1); //new char[alen+1]; \"\\0\" memcpy(rtn, ba, alen); rtn[alen] = 0; &#125; (*env)-&gt;ReleaseByteArrayElements(env, barr, ba, 0); //释放内存 return rtn; &#125; Jstring2CStr方法讲解 : a. 获取Java中String类型的class对象 : 参数 : 上下文环境 env, String类完整路径 ; jclass clsstring = (*env)-&gt;FindClass(env, \"java/lang/String\"); b.创建Java字符串 : 使用 NewStringUTF 方法; jstring strencode = (*env)-&gt;NewStringUTF(env, \"GB2312\"); ~~~ - c.获取String中的getBytes()方法 : 参数介绍 ① env 上下文环境 ② 完整的类路径 ③ 方法名 ④ 方法签名, 方法签名 Ljava/lang/String; 代表参数是String字符串, [B 中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组;~~~ JavascriptjmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\"); ~~~ - d. 获取数组的长度 :~~~ Javascriptjsize alen = (*env)-&gt;GetArrayLength(env, barr); e. 获取数组元素 : 获取数组中的所有的元素 , 存放在 jbyte*数组中; jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE); f.数组拷贝: 将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 ‘\\0’; if (alen &gt; 0) &#123; rtn = (char*) malloc(alen + 1); //new char[alen+1]; \"\\0\" memcpy(rtn, ba, alen); rtn[alen] = 0; &#125; g.释放内存 : (*env)-&gt;ReleaseByteArrayElements(env, barr, ba, 0); //释放内存 5.JNI方法命名规则(标准JNI规范) JNI实现的方法与Java中Native方法的映射关系 : 使用方法名进行映射, 可以使用javah工具进入bin/classes目录下执行命令, 即可生成头文件; JNI方法参数介绍: 参数① : 第一个参数是JNI接口指针JNIEnv; 参数② : 如果Native方法是非静态的, 那么第二个参数就是对Java对象的引用, 如果Native方法是静态的, 那么第二个参数就是对Java类的Class对象的引用; JNI方法名规范: 返回值+Java前缀+全路径类名+方法名+参数① JNIEnv+参数② jobject+其它参数; 注意分隔符 : Java前缀 与 类名 以及类名之间的包名 和 方法名之间 使用 “_“ 进行分割; 声明 非静态 方法: Native方法 : public int hello (String str, int i); JNI方法: jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject obj, jstring str, jint i); 声明 静态 方法 : Native方法 : public static int hello (String str, int i); JNI方法 : jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject clazz, jstring str, jint i); 两种规范 : 以上是Java的标准JNI规范, 在Android中还有一套自定义的规范, 该规范是Android应用框架层 和 框架层交互使用的JNI规范, 依靠方法注册 映射 Native方法 和 JNI方法; JNIEnv作用 : JNIEnv 是一个指针,指向了一组JNI函数, 这些函数可以在jni.h中查询到,通过这些函数可以实现 Java层 与 JNI层的交互 , 通过JNIEnv 调用JNI函数 可以访问java虚拟机, 操作java对象; JNI线程相关性 : JNIEnv只在当前的线程有效,JNIEnv不能跨线程传递, 相同的Java线程调用本地方法, 所使用的JNIEnv是相同的, 一个Native方法不能被不同的Java线程调用; JNIEnv结构体系 : JNIEnv指针指向一个线程相关的结构,线程相关结构指向一个指针数组,指针数组中的每个元素最终指向一个JNI函数. 6.AES加密实现网上有几种AES实现的方式： 1.这个是我现在项目中使用的方法，在Github上有这个工程，这种方式是使用JNI生成一个与设备相关的密码，可以将该密码作为AES的密钥。链接地址 2.网上还有一种方式是由JNI生成keyValue和iv，Java层使用：链接地址 主要代码： static &#123; System.loadLibrary(\"cwtlib\"); keyValue = getKeyValue(); iv = getIv(); if(null != keyValue &amp;&amp; null != iv) &#123; KeyGenerator kgen; try &#123; kgen = KeyGenerator.getInstance(\"AES\"); kgen.init(128, new SecureRandom(keyValue)); key = kgen.generateKey(); paramSpec = new IvParameterSpec(iv); ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); &#125; catch (NoSuchAlgorithmException e) &#123; &#125; catch (NoSuchPaddingException e) &#123; &#125; &#125;&#125; public static native byte[] getKeyValue();public static native byte[] getIv(); 这种方式，在android app程序完全退出后，再进入该app时，之前加密好的字符串无法解密。 3.还有一种是直接由C或C++实现AES整个算法，直接使用网上代码并不知道靠不靠谱 所以，我们项目最终使用了第一种方法 7.JNI混淆问题 检查下 C/C++代码中没有直接访问Java代码的类或者类的成员变量、类的成员函数。 如果有的话，这些就不能混淆 //保留jni的回调类-keep class com.your.jnicallback.class &#123; *; &#125;//这个不用更改，直接复制就可以-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; 8.总结android 实现JNI入门并不难，笔者也刚刚入门，但要深入了解还是需要很长的路要走。 8.1 更新内容，JNI获取publickey实现在本文中最终使用第6点中的第一种方式，但原方法在4.0.4手机上遇到兼容性问题，详情请看我的这篇博客使用JNI获取publickey实现 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/24/JNI-Learning/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"JNI","slug":"jni","permalink":"http://agehua.github.io/tags/jni/"},{"name":"AES","slug":"aes","permalink":"http://agehua.github.io/tags/aes/"}]},{"title":"Java String与C/C++中byte[]","slug":"javaString-and-bytes","date":"2016-05-17T16:00:00.000Z","updated":"2017-11-23T07:04:19.000Z","comments":true,"path":"2016/05/18/javaString-and-bytes/","link":"","permalink":"http://agehua.github.io/2016/05/18/javaString-and-bytes/","excerpt":"   做JAVA经常会碰到中文乱码问题，还有各种编码的问题，特别是String类的内容需要重新编码的问题。要解决这些问题，必须了解清楚JAVA对于字符串是怎么处理的。\n1，“字符”是由数字来表示的   先来重新了解一下计算机是如何处理“字符”的，这个原理是大家必须记住的，特别是在用JAVA写程序的时候，万万不可模糊。我们知道，计算机把任何东西都用数字来表示，“字符”也不例外。比如我们要显示一个阿拉伯数字“3”，在我们的PC里，其实并不是仅仅用一个数字3来代表我们要写的“3”，而是以十六进制的0x33来代表，包括放在内存或者是写到文件里，其实都是写着0x33的，不信你可以编辑一个文本文件，写一个“3”，然后用ultraEdit看他的原始码。","text":"做JAVA经常会碰到中文乱码问题，还有各种编码的问题，特别是String类的内容需要重新编码的问题。要解决这些问题，必须了解清楚JAVA对于字符串是怎么处理的。 1，“字符”是由数字来表示的 先来重新了解一下计算机是如何处理“字符”的，这个原理是大家必须记住的，特别是在用JAVA写程序的时候，万万不可模糊。我们知道，计算机把任何东西都用数字来表示，“字符”也不例外。比如我们要显示一个阿拉伯数字“3”，在我们的PC里，其实并不是仅仅用一个数字3来代表我们要写的“3”，而是以十六进制的0x33来代表，包括放在内存或者是写到文件里，其实都是写着0x33的，不信你可以编辑一个文本文件，写一个“3”，然后用ultraEdit看他的原始码。 2，一切“字符”都必定用数字+编码表表示。 这时候，有一个问题：为什么一定要用0x33来代表“3”呢？而不用0x43来代表呢？或者是直接用0x03来代替？其实用什么来代表都可以，只不过大家都习惯了用ASCII编码表（是美国国家信息交换表）来确定各字符应该是用什么数字代表的。同样，为了表示中国字，我国也指定了中文的编码表，其中最广泛使用的是GB2312。比如中文的“当”字，就是用0xB5, 0xB1这两个八位的数字来表示的。所以 如果显示字符的程序不知道一列数字到底是按什么编码表编码的，他也无法去判断到底这些是什么文字。如果随便用一个不对的编码表来处理这些数字，处理出来的字符很可能完全是错的。比如在英文系统上，没有GB2312编码表，送给他一个0xB5,0xB1，他就傻傻的当作ASCII来处理（操作系统通常都有自己默认的编码表），结果显示出来就是两个奇怪的符号，因为这两个字在ASCII表里就是那两个符号。同样在繁体中文系统里，他的编码表是BIG5，显示出来也是一个奇怪的中文，不是“当”字。 3，UNICODE让全世界都说一种语言 看完上面的文字，是否觉得，世界有那么多语言，每个都有自己的一套编码表，很麻烦呢？就算是中文，也有两套流行的编码表，一个是GB2312，一个是BIG5。要使用不同中文的编码的字符时，还要转来转去，的确很麻烦。不光这个，如果想要写一篇包含很多过国文字的文章，就麻烦了，必须要让处理这个文章的程序知道，哪个字是什么编码标准的。如果你想要在文章里找一个字，也必须指定你要找的是哪种编码的哪个字。否则，你要找一个0xB5,0xB1的中文“当”字，很可能把同样数字表示的日文、波兰文这些不相干的字一起给你找出来，够麻烦的吧！ 所以人们想，不如大家都用同一个编码标准吧，各种文字都在编码表里有一席之地，处理文字的程序只需要都按这个编码表来处理就可以了。不过要一个编码表里包含所有的文字，这张表就大了，本来英文字+数字一共只有128个以内。但加上中文后，忽然就多了数万个，所以存放一个字符需要的大小也大了很多。现在 UNICODE规定了一个字符必须由2个8位数字来表示，想想，8x8x8x8x = 65536，是多大的一个数字啊！所以全世界的文字才能都包含进去。当然拉，也有人说中国字可能都不止6万个拉，还要包括别的文字，但人家外国人觉得你们中国人常用的也没那么多，所以就这么定了，我们也没办法。需要注意的是GB2312和UNICODE虽然都是用两个8位数来代表一个中文字，但具体的规格可不一样，比如0xB5,0xB1在UNICODE里面可不是“当”字，而是另外一国的文字来的。 4，C是如何简洁的处理字符的 我们来谈谈C的字符串。C语言诞生在JAVA之前，C语言的基本数据类型是没有字符串这个类型的，它只有char[]。也就是C把字符顺序放入一个字节数组就完了。而且C也不管放在数组里的是什么文字，也不管那些字是按什么编码标准的。而且他的char的大小也不一定是8位数字，有时候是16位也可能，这要看具体的机器和操作系统。所以写程序的人必须要知道正在处理的char[]的内容到底是按什么编码表表示的字符串，要知道如果比较两国文字是否相同，可是没任何意义的哦！ 5，JAVA是是如何处理字符的。 世界总会进步的，JAVA就是一个例子。JAVA终于有了String类了，它是解决字符问题的最好工具。在JAVA里，一个基本的要点是：String类对象是不需要指定编码表的！ 为什么它会自己知道一堆数字各代表什么字符呢？就是因为 String里的字符信息是用UNICODE编码存放的。而JAVA为了表示字符（注意是单个字符），也有char这个数据类型，而且他的大小是固定2个8位16进制数字长度，也就是0~65535罗。为的就是对应UNICODE里面的一个字符。大家如果想取一个String里的按UNICODE数字，可以用getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 方法取得一个char[]，这个char[]里就是表示String字符的，按UNICODE编码表编码的数字。 可惜现在绝大多数的系统和程序都不是按UNICODE来处理字符，而JAVA程序总是要和别的程序和系统交换数据的，所以在接收一个字符，或者是发送一个字符的时候，就必须要留意当前系统和UNICODE的关系了。比如你从网络或者文件接受到一数字：0xB5,0xB1，JAVA程序并不知道这两个字到底是中文呢？还是日文，或者英文。你如果不指明这个两个数字的编码表，JAVA就会按当前系统默认的编码表来处理。如果这两个数字是从中文WIN98发出去的，JAVA程序又是在英文LINUX上运行的，那就出现了所谓的乱码问题了。也就是JAVA按英文的编码表ASCII来处理这两个数字，当通过new String({0xB5,0xB1})得到的String的时候，这个String代表的已经不是中文的“当”字，而是两个英文的奇怪字符了。不过如果你知道这两个数字一定是中文的话，就可以指定用new String({0xB5,0xB1},”GB2312”)来处理，这时候新建立的String才真的是一个“当”字。当然拉，如果你要把一个“当”字的JAVA的String显示在中文WIN98上，必须把这个字输出成两个8位数字：0xB5,0xB1，不管是写成文件还是输出到浏览器上，都必须是0xB5,0xB1。如何把“当”字用GB2312输出？String.getBytes(“GB2312”) 就可以拉！所以有一点要记住：和外界交换任何信息都是以byte[]来进行的！。你可以留意一下JAVA大多数的I/O类，都有以byte[]作为参数和返回值的方法。不过，也有很多写的比较糊涂的程序，没有提供byte[]交换信息的方法，害的不同文字平台的程序员很头疼。Servlet的HttpRequest.getParameter()就是这样。好在有的JSP/SERVLET容易还提供先指定编码表的方法，才能比较简单的解决这个问题。 6，网上关于JAVA中文问题的一些错误处理方法。 一个是最常见的，不管什么内容，都用new String(…,”ISO-8859-1”)来建立字符串，然后使用的时候按默认的编码格式（通常在服务器上都是英文系统）输出字符串。这样其实你使用的String并不是按UNICODE来代表真正的字符，而是强行把BYTE数组复制到String的char[]里，一旦你的运行环境改变，你就被迫要修改一大堆的代码。而且也无法在同一个字符串里处理几种不同编码的文字。 另一个是把一种编码格式的字符串，比如是GB2312，转换成另一种格式的字符串，比如UTF-8，然后不指明是UTF-8编码，而直接用new String(…)来建立String，这样放在String里面的字符也是无法确定的，它在不同的系统上代表不同的字符。如果要求别人用“UTF-8格式”的String来交换信息的时候，其实已经破坏了JAVA为了兼容各种语言所做的规定。这种错误的本质思想是还按写C语言的方式，把字符串纯粹当作可以自己自由编码的存储器使用，而忽略了JAVA字符串只有一种编码格式。如果真的想自由编码，用byte[]或者char[]就完全了解决问题的了。 7，其他资料字符，字节和编码 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/18/javaString-and-bytes/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://agehua.github.io/tags/java/"},{"name":"byte[]","slug":"byte","permalink":"http://agehua.github.io/tags/byte/"}]},{"title":"google cloud message（GCM）和Azure实现Notification总结","slug":"GCM-Azure_summary","date":"2016-05-11T16:00:00.000Z","updated":"2017-11-23T07:24:10.000Z","comments":true,"path":"2016/05/12/GCM-Azure_summary/","link":"","permalink":"http://agehua.github.io/2016/05/12/GCM-Azure_summary/","excerpt":"1.相关资料我也是一知半解，基本上就是根据官方教程来实现，但microsoft的azure文档我找了好久，英文不好，汗。。。\ngcm start: https://developers.google.com/cloud-messaging/android/start\nazure start: https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/\ngcm official demo: https://github.com/google/gcm\ngcm personal demo: https://github.com/iammert/FastGCM","text":"1.相关资料我也是一知半解，基本上就是根据官方教程来实现，但microsoft的azure文档我找了好久，英文不好，汗。。。 gcm start: https://developers.google.com/cloud-messaging/android/start azure start: https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/ gcm official demo: https://github.com/google/gcm gcm personal demo: https://github.com/iammert/FastGCM 2.遇到的问题 1.手机运行官方demo时，发送消息，消息收不到必须切换一下网络才可以 stackoverflow上有人问过这个问题：http://stackoverflow.com/questions/13835676/google-cloud-messaging-messages-sometimes-not-received-until-network-state-cha 3.onActivityResult()和onResume()调用顺序API中这样描述：当你一个Activity是以请求码开始，结束时返回给前页面结果码，页面根据结果码进行相应的信息处理。我们会在返回的页面先接受结果码，然后才调用onResume()。 通常我们还会遇到这样一个问题：在处理返回页面的数据问题1.需要从服务器上刷新数据时我们会在onResume()方法里处理2.而刷新从结束界面返回的数据我们会在onAcitviyResult()方法里面处理 为了避免二者在同一块控件上对数据处理，我们只需加个标识符，在两个方法里进行判断，要用哪个方法进行刷新 4.Android4.4以上系统根据Uri正确获取文件路径的方法public static String getPhotoPathFromContentUri(Context context, Uri uri) &#123; String photoPath = \"\"; if(context == null || uri == null) &#123; return photoPath; &#125; if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123; String docId = DocumentsContract.getDocumentId(uri); if(isExternalStorageDocument(uri)) &#123; String [] split = docId.split(\":\"); if(split.length &gt;= 2) &#123; String type = split[0]; if(\"primary\".equalsIgnoreCase(type)) &#123; photoPath = Environment.getExternalStorageDirectory() + \"/\" + split[1]; &#125; &#125; &#125; else if(isDownloadsDocument(uri)) &#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.valueOf(docId)); photoPath = getDataColumn(context, contentUri, null, null); &#125; else if(isMediaDocument(uri)) &#123; String[] split = docId.split(\":\"); if(split.length &gt;= 2) &#123; String type = split[0]; Uri contentUris = null; if(\"image\".equals(type)) &#123; contentUris = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; &#125; else if(\"video\".equals(type)) &#123; contentUris = MediaStore.Video.Media.EXTERNAL_CONTENT_URI; &#125; else if(\"audio\".equals(type)) &#123; contentUris = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; &#125; String selection = MediaStore.Images.Media._ID + \"=?\"; String[] selectionArgs = new String[] &#123; split[1] &#125;; photoPath = getDataColumn(context, contentUris, selection, selectionArgs); &#125; &#125; &#125; else if(\"file\".equalsIgnoreCase(uri.getScheme())) &#123; photoPath = uri.getPath(); &#125; else &#123; photoPath = getDataColumn(context, uri, null, null); &#125; return photoPath;&#125;private static boolean isExternalStorageDocument(Uri uri) &#123; return \"com.android.externalstorage.documents\".equals(uri.getAuthority());&#125;private static boolean isDownloadsDocument(Uri uri) &#123; return \"com.android.providers.downloads.documents\".equals(uri.getAuthority());&#125;private static boolean isMediaDocument(Uri uri) &#123; return \"com.android.providers.media.documents\".equals(uri.getAuthority());&#125;private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123; Cursor cursor = null; String column = MediaStore.Images.Media.DATA; String[] projection = &#123; column &#125;; try &#123; cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; int index = cursor.getColumnIndexOrThrow(column); return cursor.getString(index); &#125; &#125; finally &#123; if (cursor != null &amp;&amp; !cursor.isClosed()) cursor.close(); &#125; return null;&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/12/GCM-Azure_summary/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"GCM","slug":"gcm","permalink":"http://agehua.github.io/tags/gcm/"},{"name":"azure","slug":"azure","permalink":"http://agehua.github.io/tags/azure/"},{"name":"notification","slug":"notification","permalink":"http://agehua.github.io/tags/notification/"}]},{"title":"android新特性新知识点总结","slug":"android-new-knowledge-summary","date":"2016-03-19T16:00:00.000Z","updated":"2017-11-23T07:24:07.000Z","comments":true,"path":"2016/03/20/android-new-knowledge-summary/","link":"","permalink":"http://agehua.github.io/2016/03/20/android-new-knowledge-summary/","excerpt":"一、mipmap 目录和drawable 目录有什么区别Nexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap：\n二、setTranslucentStatus()方法在Android4.4之后使用沉浸式状态栏，需要用到这个方法","text":"一、mipmap 目录和drawable 目录有什么区别Nexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap： 二、setTranslucentStatus()方法在Android4.4之后使用沉浸式状态栏，需要用到这个方法 public class MainActivity extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //首先检测当前的版本是否是api&gt;=19的 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; setTranslucentStatus(true); &#125; SystemBarTintManager tintManager = new SystemBarTintManager(this); tintManager.setStatusBarTintEnabled(true); tintManager.setStatusBarTintColor(Color.parseColor(\"#FFC1E0\")); &#125; @TargetApi(19) private void setTranslucentStatus(boolean on) &#123; Window win = getWindow(); WindowManager.LayoutParams winParams = win.getAttributes(); final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS; if (on) &#123; winParams.flags |= bits; &#125; else &#123; winParams.flags &amp;= ~bits; &#125; win.setAttributes(winParams); &#125;&#125; 布局设置 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &lt;!--这两行是必须设置的--&gt; android:fitsSystemWindows=&quot;true&quot; android:clipToPadding=&quot;true&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#FFD9EC&quot; &gt; &lt;TextView android:text=&quot;沉浸式状态栏&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:textSize=&quot;23dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:gravity=&quot;center&quot; android:background=&quot;#FFD9EC&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/darker_gray&quot;/&gt;&lt;/LinearLayout&gt; 三、获取Bitmap图片大小的代码public int getBitmapSize(Bitmap bitmap)&#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123; //API 19 return bitmap.getAllocationByteCount(); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1)&#123;//API 12 return bitmap.getByteCount(); &#125; return bitmap.getRowBytes() * bitmap.getHeight(); //earlier version&#125; 四、Activity横竖屏切换生命周期总结： 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 验证： 1、新建一个Activity，并把各个生命周期打印出来 2、运行Activity，得到如下信息 onCreate--&gt;onStart--&gt;onResume--&gt; 3、按crtl+f12切换成横屏时 onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt; 4、再按crtl+f12切换成竖屏时，发现打印了两次相同的log onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt;onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt; 5、修改AndroidManifest.xml，把该Activity添加 android:configChanges=”orientation”，执行步骤3 onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt; 6、再执行步骤4，发现不会再打印相同信息，但多打印了一行onConfigChanged onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt;onConfigurationChanged--&gt; 7、把步骤5的android:configChanges=”orientation” 改成android:configChanges=”orientation|keyboardHidden”，执行步骤3，就只打印onConfigChanged onConfigurationChanged--&gt; 8、执行步骤4 onConfigurationChanged--&gt;onConfigurationChanged--&gt; 总结一下整个Activity的生命周期 1.补充一点，当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变 2.Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState –&gt; onPause –&gt; onStop onRestart –&gt;onStart—&gt;onResume 3.Activity未被完全覆盖只是失去焦点：onPause—&gt;onResume 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/03/20/android-new-knowledge-summary/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"new features","slug":"new-features","permalink":"http://agehua.github.io/tags/new-features/"}]},{"title":"《android开发艺术探索》读书笔记","slug":"android-books-reading-","date":"2016-03-19T16:00:00.000Z","updated":"2017-11-23T07:24:03.000Z","comments":true,"path":"2016/03/20/android-books-reading-/","link":"","permalink":"http://agehua.github.io/2016/03/20/android-books-reading-/","excerpt":"第1章 Activity的生命周期和启动模式本节和《Android群英传》中的第8章Activity和Activity调用栈分析有关系，建议先阅读该章的总结\n第1章 Activity的生命周期和启动模式\n1.1 Activity生命周期全面分析1.1.1 典型情况下生命周期分析\n(1)一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart方法就会被调用。\n\n(2)当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新Activity采用了透明主题，那么onStop方法不会被回调。当用户再次回到原来的Activity时，回调如下：onRestart -&gt; onStart -&gt; onResume。\n\n","text":"第1章 Activity的生命周期和启动模式本节和《Android群英传》中的第8章Activity和Activity调用栈分析有关系，建议先阅读该章的总结 第1章 Activity的生命周期和启动模式 1.1 Activity生命周期全面分析1.1.1 典型情况下生命周期分析 (1)一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart方法就会被调用。 (2)当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新Activity采用了透明主题，那么onStop方法不会被回调。当用户再次回到原来的Activity时，回调如下：onRestart -&gt; onStart -&gt; onResume。 (3)onStart和onStop对应，它们是从Activity是否可见这个角度来回调的；onPause和onResume方法对应，它们是从Activity是否位于前台这个角度来回调的。 (4)从Activity A进入到Activity B，回调顺序是onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)，所以不能在onPause方法中做重量级的操作。 1.1.2 异常情况下生命周期分析 (1)onSaveInstanceState方法只会出现在Activity被异常终止的情况下，它的调用时机是在onStop之前，它和onPause方法没有既定的时序关系，可能在它之前，也可能在它之后。 当Activity被重新创建的时候，onRestoreInstanceState会被回调，它的调用时机是onStart之后。 系统只会在Activity即将被销毁并且有机会重新显示的情况下才会去调用onSaveInstanceState方法。 当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据，比如文本框中用户输入的数据、listview滚动的位置等，这些view相关的状态系统都会默认为我们恢复。具体针对某一个view系统能为我们恢复哪些数据可以查看view的源码中的onSaveInstanceState和onRestoreInstanceState方法。 (2)Activity按优先级的分类 前台Activity；可见但非前台Activity；后台Activity (3)android:configChanges=”xxx”属性，常用的主要有下面三个选项： local：设备的本地位置发生了变化，一般指切换了系统语言； keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘； orientation：屏幕方向发生了变化，比如旋转了手机屏幕。 配置了android:configChanges=”xxx”属性之后，Activity就不会在对应变化发生时重新创建，而是调用Activity的onConfigurationChanged方法。 1.2 Activity的启动模式1.2.1 启动模式 (1)当任务栈中没有任何Activity的时候，系统就会回收这个任务栈。 (2)从非Activity类型的Context(例如ApplicationContext、Service等)中以standard模式启动新的Activity是不行的，因为这类context并没有任务栈，所以需要为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标志位。 (3)任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。 (4)参数TaskAffinity用来指定Activity所需要的任务栈，意为任务相关性。 默认情况下，所有Activity所需的任务栈的名字为应用的包名。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。 当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中； 当TaskAffinity和allowTaskReparenting结合的时候，当一个应用A启动了应用B的某个Activity C后，如果Activity C的allowTaskReparenting属性设置为true的话，那么当应用B被启动后，系统会发现Activity C所需的任务栈存在了，就将Activity C从A的任务栈中转移到B的任务栈中。 (5)singleTask模式的具体分析： 当一个具有singleTask启动模式的Activity请求启动之后，系统首先会寻找是否存在A想要的任务栈， 如果不存在，就重新创建一个任务栈，然后创建Activity的实例把它放到栈中；如果存在Activity所需的任务栈，这时候要看栈中是否有Activity实例存在. 如果有，那么系统就会把该Activity实例调到栈顶，并调用它的onNewIntent方法(它之上的Activity会被迫出栈，所以singleTask模式具有FLAG_ACTIVITY_CLEAR_TOP效果)；如果Activity实例不存在，那么就创建Activity实例并把它压入栈中。 (6)设置启动模式既可以使用xml属性android:launchMode，也可以使用代码intent.addFlags()。区别在于限定范围不同，前者无法直接为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，而后者无法为Activity指定singleInstance模式。 1.2.2 Activity的FlagsFLAG_ACTIVITY_NEW_TASK,FLAG_ACTIVITY_SINGLE_TOP,FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用，它等同于属性设置android:excludeFromRecents=”true”。 1.3 IntentFilter的匹配规则 (1)IntentFilter中的过滤信息有action、category、data，为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。 一个过滤列表中的action、category、data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别和data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。此外，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intenf-filter即可成功启动对应的Activity。 &lt;intent-filter&gt; &lt;action android:name=\"com.ryg.charpter_1.c\" /&gt; &lt;action android:name=\"com.ryg.charpter_1.d\" /&gt; &lt;category android:name=\"com.ryg.category.c\" /&gt; &lt;category android:name=\"com.ryg.category.d\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:mimeType=\"text/plain\" /&gt;&lt;/intent-filter&gt;~~~ - (2)action匹配规则 只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，action匹配区分大小写。- (3)category匹配规则 Intent中如果有category那么所有的category都必须和过滤规则中的其中一个category相同，如果没有category的话那么就是默认的category，即android.intent.category.DEFAULT，所以为了Activity能够接收隐式调用，配置多个category的时候必须加上默认的category。- (4)data匹配规则 data的结构很复杂，语法大致如下：~~~ Javascript&lt;data android:scheme=\"string\" android:host=\"string\" android:port=\"string\" android:path=\"string\"` android:pathPattern=\"string\" android:pathPrefix=\"string\" android:mimeType=\"string\" /&gt; 主要由mimeType和URI组成，其中mimeType代表媒体类型，而URI的结构也复杂，大致如下： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;]|[&lt;pathPrefix&gt;]|[pathPattern] 例如content://com.example.project:200/folder/subfolder/etc scheme、host、port分别表示URI的模式、主机名和端口号，其中如果scheme或者host未指定那么URI就无效。 path、pathPattern、pathPrefix都是表示路径信息，其中path表示完整的路径信息，pathPrefix表示路径的前缀信息；pathPattern表示完整的路径，但是它里面包含了通配符(*)。 data匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。 URI有默认的scheme！ 如果过滤规则中的mimeType指定为image/*或者text/*等这种类型的话，那么即使过滤规则中没有指定URI，URI有默认的scheme是content和file！如果过滤规则中指定了scheme的话那就不是默认的scheme了。 //URI有默认值&lt;intent-filter&gt; &lt;data android:mimeType=\"image/*\"/&gt; ...&lt;/intent-filter&gt; //URI默认值被覆盖&lt;intent-filter&gt; &lt;data android:mimeType=\"image/*\" android:scheme=\"http\" .../&gt; ...&lt;/intent-filter&gt; 如果要为Intent指定完整的data，必须要调用setDataAndType方法！ 不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。intent.setDataAndType(Uri.parse(\"file://abc\"), \"image/png\"); data的下面两种写法作用是一样的： &lt;intent-filter&gt; &lt;data android:scheme=\"file\" android:host=\"www.github.com\"/&gt;&lt;/intent-filter&gt;&lt;intent-filter&gt; &lt;data android:scheme=\"file\"/&gt; &lt;data android:host=\"www.github.com\"/&gt;&lt;/intent-filter&gt; 如何判断是否有Activity能够匹配我们的隐式Intent？ (1)PackageManager的resolveActivity方法或者Intent的resolveActivity方法：如果找不到就会返回null (2)PackageManager的queryIntentActivities方法：它返回所有成功匹配的Activity信息针对Service和BroadcastReceiver等组件，PackageManager同样提供了类似的方法去获取成功匹配的组件信息，例如queryIntentServices、queryBroadcastReceivers等方法 有一类action和category比较重要，它们在一起用来标明这是一个入口Activity，并且会出现在系统的应用列表中。 &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;&lt;/intent-filter&gt; 第2章 IPC机制2.1 Android IPC简介(1)任何一个操作系统都需要有相应的IPC机制，Linux上可以通过命名通道、共享内存、信号量等来进行进程间通信。Android系统不仅可以使用了Binder机制来实现IPC，还可以使用Socket实现任意两个终端之间的通信。 2.2 Android中的多进程模式 (1)通过给四大组件指定android:process属性就可以开启多进程模式. 默认进程的进程名是包名packageName，进程名以:开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以:开头的进程属于全局进程，其他应用通过ShareUID方法可以和它跑在同一个进程中。 android:process=”:xyz” //进程名是 packageName:xyz android:process=”aaa.bbb.ccc” //进程名是 aaa.bbb.ccc (2)Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。 两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。 在这种情况下，它们可以相互访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。如果它们跑在同一个进程中，还可以共享内存数据，它们看起来就像是一个应用的两个部分。 (3)android系统会为每个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，所以不同的虚拟机中访问同一个类的对象会产生多个副本。 (4)使用多进程容易造成以下几个问题： 1.静态成员和单例模式完全失效； 2.线程同步机制完全失效：无论锁对象还是锁全局对象都无法保证线程同步； 3.SharedPreferences的可靠性下降：SharedPreferences不支持并发读写； 4.Application会多次创建：当一个组件跑在一个新的进程的时候，系统要在创建新的进程的同时分配独立的虚拟机，应用会重新启动一次，也就会创建新的Application。运行在同一个进程中的组件是属于同一个虚拟机和同一个Application。 同一个应用的不同组件，如果它们运行在不同进程中，那么和它们分别属于两个应用没有本质区别。 2.3 IPC基础概念介绍 (1)Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口。 (2)serialVersionUId是一串long型数字，主要是用来辅助序列化和反序列化的，原则上序列化后的数据中的serialVersionUId只有和当前类的serialVersionUId相同才能够正常地被反序列化。 serialVersionUId的详细工作机制：序列化的时候系统会把当前类的serialVersionUId写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUId，看它是否和当前类的serialVersionUId一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUId的值。 1.静态成员变量属于类不属于对象，所以不参与序列化过程； 2.声明为transient的成员变量不参与序列化过程。 (3)Parcelable接口内部包装了可序列化的数据，可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例 public class Book implements Parcelable &#123; public int bookId; public String bookName; public Book() &#123; &#125; public Book(int bookId, String bookName) &#123; this.bookId = bookId; this.bookName = bookName; &#125; //“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0 public int describeContents() &#123; return 0; &#125; //实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0 public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(bookId); out.writeString(bookName); &#125; //实现反序列化操作 public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Parcelable.Creator&lt;Book&gt;() &#123; //从序列化后的对象中创建原始对象 public Book createFromParcel(Parcel in) &#123; return new Book(in); &#125; public Book[] newArray(int size) &#123;//创建指定长度的原始对象数组 return new Book[size]; &#125; &#125;; private Book(Parcel in) &#123; bookId = in.readInt(); bookName = in.readString(); &#125;&#125; (4)Binder是Android中的一个类，它实现了IBinder接口。 从IPC角度看，Binder是Android中一种跨进程通信的方式；Binder还可以理解为虚拟的物理设备，它的设备驱动是/dev/binder； 从Framework层角度看，Binder是ServiceManager连接各种Manager和相应的ManagerService的桥梁； 从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。 在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。 (5)aidl工具根据aidl文件自动生成的java接口的解析： 首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法； 接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。 所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法： 1.asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。 2.asBinder：返回当前Binder对象。 3.onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。 这个方法的原型是public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags) 服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。 4.Proxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是： 首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。 如果搞清楚了自动生成的接口文件的结构和作用之后，其实是可以不用通过AIDL而直接实现Binder的，主席写的示例代码 (6)Binder的两个重要方法linkToDeath和unlinkToDeath Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。 如何给Binder设置死亡代理呢？ 1.声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。 private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; if (mRemoteBookManager == null) return; mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0); mRemoteBookManager = null; // TODO:这里重新绑定远程Service &#125;&#125;; 2.在客户端绑定远程服务成功之后，给binder设置死亡代理 mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, 0); 2.4 Android中的IPC方式 (1)使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。 (2)使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。 SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。 (3)使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形，详细的示例见原书。 (4)使用AIDL 大致流程：首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。 1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL； 2.某些类即使和AIDL文件在同一个包中也要显式import进来； 3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout； 4.AIDL接口中支持方法，不支持声明静态变量； 5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。 6.RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。 (5)使用ContentProvider 1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表； 2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider； 3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行； 4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者； (6)使用Socket Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。 2.5 Binder连接池 (1)当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。 整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。 Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。 (2)作者实现的Binder连接池BinderPool的实现源码，建议在AIDL开发工作中引入BinderPool机制。 2.6 选用合适的IPC方式 第9章 四大组件的工作过程本篇摘选自amurocrash的专栏 9.1 四大组件的运行状态 (1)四大组件中只有BroadcastReceiver既可以在AndroidManifest文件中注册，也可以在代码中注册，其他三个组件都必须在AndroidManifest文件中注册；ContentProvider的调用不需要借助Intent，其他三个组件都需要借助Intent。 (2)Activity是一种展示型组件，用于向用户展示界面，可由显式或者隐式Intent来启动。 (3)Service是一种计算型组件，用于在后台执行计算任务。尽管service是用于后台执行计算的，但是它本身是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。Service组件有两种状态：启动状态和绑定状态。当service处于绑定状态时，外界可以很方便的和service进行通信，而在启动状态中是不可与外界通信的。 (4)BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息，它工作在系统内部。广播有两种注册方式：静态注册和动态注册。静态注册是在AndroidManifest中注册，在应用安装的时候会被系统解析，这种广播不需要应用启动就可以收到相应的广播。动态注册需要通过Context.registerReceiver()来注册，这种广播需要应用启动才能注册并接收广播。BroadcastReceiver组件一般来说不需要停止，它也没有停止的概念。 (5)ContentProvider是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。ContentProvider中的insert、delete、update、query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的，另外ContentProvider组件也不需要手动停止。 9.2 Activity的工作过程(1)Activity启动的大致流程 (2)ApplicationThread是ActivityThread的一个内部类，它继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口，ApplicationThreadNative的作用其实就和系统为AIDL文件生成的类是一样的。(3)ActivityManagerService(AMS)继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。(4)一个应用只有一个Application对象，它的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。(5)ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当window接收到外部输入事件后就可以将事件传递给Activity。 [这里可能有误，应该是Activity将事件传递给window] 9.3 Service的工作过程(1)Service有两种状态：启动状态和绑定状态，两种状态是可以共存的。启动过程： 绑定过程： 9.4 BroadcastReceiver的工作过程(1)BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。注册过程：静态注册的时候是由PackageManagerService来完成整个注册过程，下面是动态注册的过程发送和接收： (2)广播的发送有几种类型：普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是发送和接收过程是类似的。 (3)一个应用处于停止状态分为两种情况：一是应用安装后未运行；二是应用被手动或者其他应用强停了。从Android 3.1开始，处于停止状态的应用无法接受到开机广播。 9.5 ContentProvider的工作过程(1)当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。(2)ContentProvider的启动过程： 1.当一个应用启动时，入口方法是ActivityThread的main方法，其中创建ActivityThread的实例并创建主线程的消息队列； 2.ActivityThread的attach方法中会远程调用ActivityManagerService的attachApplication，并将ApplicationThread提供给AMS，ApplicationThread主要用于ActivityThread和AMS之间的通信； 3.ActivityManagerService的attachApplication会调用ApplicationThread的bindApplication方法，这个方法会通过H切换到ActivityThread中去执行，即调用handleBindApplication方法； 4.handleBindApplication方法会创建Application对象并加载ContentProvider，注意是先加载ContentProvider，然后调用Application的onCreate方法。 (3)ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。(4)当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程： 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/03/20/android-books-reading-/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"reading","slug":"reading","permalink":"http://agehua.github.io/tags/reading/"}]},{"title":"近期总结facebook google+ Twitter sign-in fragment使用","slug":"facebook-google+signin","date":"2016-03-14T16:00:00.000Z","updated":"2017-11-23T07:23:59.000Z","comments":true,"path":"2016/03/15/facebook-google+signin/","link":"","permalink":"http://agehua.github.io/2016/03/15/facebook-google+signin/","excerpt":"1.相关资料blog: 关于Google+以及Facebook第三方登录实现的一点总结\ng+官方教程: G+ start\nfacebook官方教程: Facebook start\niCCP: Not recognizing known sRGB profile","text":"1.相关资料blog: 关于Google+以及Facebook第三方登录实现的一点总结 g+官方教程: G+ start facebook官方教程: Facebook start iCCP: Not recognizing known sRGB profile 今天做分享的时候遇到了这个问题： [2016-04-01 11:24:04 - Dex Loader] Unable to execute dex: method ID not in [0, 0xffff]: 65536 [2016-04-01 11:24:04 - VIVAT_SHARESDK] Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536 大项目中遇到的问题看这个博客 iCCP: Not recognizing known sRGB profile 删除png图片内嵌的iCCP profile sRGB报错 今天有碰见一个坑，改其他代码，然后在编译的时候就出现这个问题，对就是这个问题。网上查了资料，也就这个资料最全面，大家可以去看见http://my.oschina.net/1pei/blog/479162?fromerr=ARrUPlGS 处理这个问题我使用了一种方法，记录下来以便以后使用 步骤1:下载Image Magick http://www.imagemagick.com.cn/download.html.如果是windows的，请下载含dll的 步骤2： 在要处理的文件夹使用如下命令 ，一定要在要处理的文件夹使用 //WINDOWS使用set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe for /f \"tokens=*\" %i in ('dir/s/b *.png') do \"%fn%\" \"%i\" -strip \"%i\"（因为是window的，所以把%%i改为%i） //LINUX使用 set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe for /f \"tokens=*\" %%i in ('dir/s/b *.png') do \"%fn%\" \"%%i\" -strip \"%%i\" 2.遇到问题 1.“This client application’s callback url has been locked”. 使用Twitter signin时遇到了这个问题，这个错误信息是在logcat中找到的，原因是在Twitter的Settings里勾选了“Enable Callback Locking (It is recommended to enable callback locking to ensure apps cannot overwrite the callback url)”选项，这个选项表示不允许app本地更改callback url。也可看这个页面 3.add() vs. replace() 只有在Fragment数量大于等于2的时候，调用add()还是replace()的区别才能体现出来。 当通过add()连续两次添加Fragment的时候，每个Fragment生命周期中的onAttach()-onResume()都会被各调用一次，而且两个Fragment的View会被同时attach到containerView。 同样，退出Activty时，每个Fragment生命周期中的onPause()-onDetach()也会被各调用一次。 但当使用replace()来添加Fragment的时候，第二次添加会导致第一个Fragment被销毁，即执行第二个Fragment的onAttach()方法之前会先执行第一个Fragment的onPause()-onDetach()方法，同时containerView会detach第一个Fragment的View。 调用show() &amp; hide()方法时. Fragment的生命周期方法并不会被执行，仅仅是Fragment的View被显示或者​隐藏。而且，尽管Fragment的View被隐藏，但它在父布局中并未被detach，仍然是作为containerView的childView存在着。相比较下，attach() &amp; detach()做的就更彻底一些。一旦一个Fragment被detach()，它的onPause()-onDestroyView()周期都会被执行。 同时Fragment的View也会被detach。在重新调用attach()后，onCreateView()-onResume()周期也会被再次执行。 remove() 其实看完上面的分析，remove()方法基本也就明白了。相对应add()方法执行onAttach()-onResume()的生命周期，remove()就是完成剩下的onPause()-onDetach()周期。 4.FragmentTransaction add 和 replace 区别使用 FragmentTransaction 的时候，它提供了这样两个方法，一个 add ， 一个 replace .add 和 replace 影响的只是界面，而控制回退的，是事务。 add 是把一个fragment添加到一个容器 container 里。 Add a fragment to the activity state. This fragment may optionally also have its view (if Fragment.onCreateView returns non-null) into a container view of the activity. public abstract FragmentTransaction add (int containerViewId, Fragment fragment, String tag) replace 是先remove掉相同id的所有fragment，然后在add当前的这个fragment。 Replace an existing fragment that was added to a container. This is essentially the same as calling remove(Fragment) for all currently added fragments that were added with the same containerViewId and then add(int, Fragment, String) with the same arguments given here. public abstract FragmentTransaction replace (int containerViewId, Fragment fragment, String tag) 在大部分情况下，这两个的表现基本相同。因为，一般，咱们会使用一个FrameLayout来当容器，而每个Fragment被add 或者 replace 到这个FrameLayout的时候，都是显示在最上层的。所以你看到的界面都是一样的。但是，使用add的情况下，这个FrameLayout其实有2层，多层肯定要比一层的来得浪费，所以还是推荐使用replace。当然有时候还是需要使用add的。比如要实现轮播图的效果，每个轮播图都是一个独立的Fragment，而他的容器FrameLayout需要add多个Fragment，这样他就可以根据提供的逻辑进行轮播了。 而至于返回键的时候，这个跟事务有关，跟使用add还是replace没有任何关系。 5.要想fragment完整地执行生命周期fragment跳转是要使用replace()方法，并一定要指定tag，否则有些方法不会执行（比如onResume），例如： getFragmentManager() .beginTransaction() .replace(R.id.base_container, inputVerifyCodeFragment,\"tag_code\") .addToBackStack(null).commit(); 6.fragment事件穿透如果发现fragment2的点击事件可以被fragment栈下一层的fragment1获取到，可以在fragment2布局的根部加上：android:clickable=”true”。问题解决 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/03/15/facebook-google+signin/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"third-party signin","slug":"third-party-signin","permalink":"http://agehua.github.io/tags/third-party-signin/"}]},{"title":"android Google map使用总结","slug":"android-googlemap-summary","date":"2016-02-29T16:00:00.000Z","updated":"2017-11-23T07:23:56.000Z","comments":true,"path":"2016/03/01/android-googlemap-summary/","link":"","permalink":"http://agehua.github.io/2016/03/01/android-googlemap-summary/","excerpt":"1.在代码中编译google map要想编译编译google map必须使用Google map api。并在自己的工程中引入google-play-services_lib。两个都需要在SDK Manager中下载。前者要在对应android api中勾选，后者要勾选在Extras下的Google Play Service。\n要注意的是map2.0要使用com.google.android.gms包名下的类\nGoogle Maps Android API 使用OpenGL ES第2版来渲染地图。如果未安装OpenGL ES第2版，地图将不会出现。可以在 AndroidManifest.xml 中添加以下元素作为元素的子元素来过滤不能支持的手机：\n&lt;uses-feature        android:glEsVersion=\"0x00020000\"        android:required=\"true\"/&gt;","text":"1.在代码中编译google map要想编译编译google map必须使用Google map api。并在自己的工程中引入google-play-services_lib。两个都需要在SDK Manager中下载。前者要在对应android api中勾选，后者要勾选在Extras下的Google Play Service。 要注意的是map2.0要使用com.google.android.gms包名下的类 Google Maps Android API 使用OpenGL ES第2版来渲染地图。如果未安装OpenGL ES第2版，地图将不会出现。可以在 AndroidManifest.xml 中添加以下元素作为元素的子元素来过滤不能支持的手机： &lt;uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\"/&gt; 2.在编码中遇到的问题1.可以实现OnCameraChangeListener接口，来实现对相机状态的监听，比如我就记录下了地图缩放的大小 @Overridepublic void onCameraChange(CameraPosition arg0) &#123; // TODO Auto-generated method stub zoom = arg0.zoom;&#125; 2.向将处理地图的 Activity 添加 Fragment 对象。 最简单的实现方式是，向Activity 的布局文件添加 元素。 3.实现 OnMapReadyCallback 接口，并使用onMapReady(GoogleMap)回调方法获取GoogleMap对象的句柄。GoogleMap对象是对地图本身的内部表示。如需设置地图的视图选项，可以使用UiSettings设置地图的样式。 4.调用Fragment上的getMapAsync()以注册回调。 5.使用手机定位，定位成功后再map上显示标记： MarkerOptions markerOpt = new MarkerOptions(); markerOpt.position(new LatLng(geoLat, geoLng)); markerOpt.draggable(false); markerOpt.visible(true); markerOpt.anchor(0.5f, 0.5f);//设为图片中心 markerOpt.icon(BitmapDescriptorFactory .fromResource(R.drawable.sos_location_38x53)); mMap.addMarker(markerOpt); //将摄影机移动到指定的地理位置 cameraPosition = new CameraPosition.Builder() .target(new LatLng(geoLat, geoLng)) // Sets the center of the map to ZINTUN .zoom(zoom) // 缩放比例 .bearing(0) // Sets the orientation of the camera to east .build(); // Creates a CameraPosition from the builder mMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition));~~~ 6.实现地图圆角效果：使用圆角.9图片，中间透明，圆角四周不透明&lt;br&gt;详细可以看这个提问：[Is there a way to implement rounded corners to a Mapfragment?](http://stackoverflow.com/questions/14469208/is-there-a-way-to-implement-rounded-corners-to-a-mapfragment)7.去掉google地图自带的蓝色圆点GoogleMap.setMyLocationEnabled(false);8.解决mapview与scrollview嵌套滑动的问题：思路就是使用getParent().requestDisallowInterceptTouchEvent(true);方法，让子类接收到touch事件~~~ Javapublic class MyMapView extends MapView &#123; private ViewParent mViewParent; public MyMapView(Context context) &#123; super(context); &#125; public MyMapView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyMapView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; public MyMapView(Context context, GoogleMapOptions options) &#123; super(context, options); &#125; public void setViewParent(@Nullable final ViewParent viewParent) &#123; //any ViewGroup mViewParent = viewParent; &#125; @Override public boolean onInterceptTouchEvent(final MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (null == mViewParent) &#123; //设置父类不拦截touch事件，子view可以接收到touch事件 getParent().requestDisallowInterceptTouchEvent(true); &#125; else &#123; mViewParent.requestDisallowInterceptTouchEvent(true); &#125; break; case MotionEvent.ACTION_UP: if (null == mViewParent) &#123; //让父类拦截touch事件 getParent().requestDisallowInterceptTouchEvent(false); &#125; else &#123; mViewParent.requestDisallowInterceptTouchEvent(false); &#125; break; default: break; &#125; return super.onInterceptTouchEvent(event); &#125;&#125; 9.LocationListener，一直回调到onProviderDisabled 有可能是因为手机没有开启定位服务，解决办法是： @Overridepublic void onProviderDisabled(String provider) &#123; isLocatedSuccess = false; if (provider.equals(\"network\")) //跳到位置服务设置页面 startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));&#125; 3.在真机上测试效果需要在真机上安装这两个包：com.android.vending.apk（Google play store）和com.google.android.gms.apk（Google play services）可以在国内应用市场上去搜索最新版本，也可以使用我上传的文件： 链接：http://pan.baidu.com/s/1i5q8jo5 密码：solm 安装成功以后，再运行自己的程序，查看效果了 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/03/01/android-googlemap-summary/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"google map","slug":"google-map","permalink":"http://agehua.github.io/tags/google-map/"}]},{"title":"2015阅读书单","slug":"book-list-of-2015","date":"2015-11-05T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":true,"path":"2015/11/06/book-list-of-2015/","link":"","permalink":"http://agehua.github.io/2015/11/06/book-list-of-2015/","excerpt":"","text":"本文链接：http://agehua.github.io/2015/11/06/book-list-of-2015/","raw":null,"content":null,"categories":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/categories/read/"}],"tags":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/tags/read/"}]},{"title":"java多线程和并发面试问答","slug":"java-multithreading-concurrent","date":"2015-03-15T16:00:00.000Z","updated":"2017-11-23T06:58:42.000Z","comments":true,"path":"2015/03/16/java-multithreading-concurrent/","link":"","permalink":"http://agehua.github.io/2015/03/16/java-multithreading-concurrent/","excerpt":"本文基于酷勤网关于java多线程和并发面试题的文章，进行了少量的整理和补充。原文在这。\n\n以下是正文：\n多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。","text":"本文基于酷勤网关于java多线程和并发面试题的文章，进行了少量的整理和补充。原文在这。 以下是正文： 多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。 Java多线程面试问题1. 什么是进程和线程？进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。 2. 进程和线程之间有什么不同？一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 形象的讲，进程就是一个项目组，每个程序员就是里面的线程呀！当然一个程序员也可以叫做一个项目组，对应的就是一个进程只有一个线程。公司里面的任务是分配给项目组级别的，干活的就是其中的程序员。总的意思就是，进程和线程没有什么区别。吐槽的话：我的意思就是进程干不过来了，那就多开几个线程呀！from JacobK 3. 多线程编程的好处是什么？ 在进程内创建、终止线程比创建、终止进程要快； 同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。 在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。 4. 用户线程和守护线程有什么区别？当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出（与守护线程是否在运行没有关系）。一个守护线程创建的子线程依然是守护线程。守护线程应用背景：后台线程，比如可以收集某些系统状态的线程，发送email的线程，等不希望影响JVM的事情。 5. 我们如何创建一个线程？有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。Read more… 6. 有哪些不同的线程生命周期？当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked和Dead。Read more… 新建（new Thread）：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：Thread t1=new Thread(); 就绪（runnable）：线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start(); 运行（running）：线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。 死亡（dead）：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。 自然终止：正常运行run()方法后终止 异常终止：调用stop()方法让一个线程终止运行 堵塞（blocked）：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。 正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。 正在等待：调用wait()方法。（调用motify()方法回到就绪状态） 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复） 7. 可以直接调用Thread类的run()方法么？可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread。start()方法。 8. 如何让正在运行的线程暂停一段时间？我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。 9. 你对线程优先级的理解是什么？线程的优先级越高，那么就可以分占相对多的CPU时间片。每个进程都有相应的优先级，线程优先级决定它何时运行和占用CPU时间。最终的优先级共分32级。是从0到31的数值，称为 基本优先级别。OS调度的是线程，真正具有优先级的是线程，而进程优先级是作为一个优先级Class存在。一个线程创建的时候，会继承进程的优先级。 外线程优先级可以用SetThreadPriority来进行微调。常用的桌面系统，都是分时操调度，根据线程的优先级来分配调度时间。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。 10. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 11. 在多线程中，什么是上下文切换(context-switching)？上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。 12. 你如何确保main()方法所在的线程是Java程序最后结束的线程？我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。Read more… 线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。在join()方法内设定超时，使得join()方法的影响在特定超时后无效。当超时时，主方法和任务线程申请运行的时候是平等的。然而，当涉及sleep时，join()方法依靠操作系统计时，所以你不应该假定join()方法将会等待你指定的时间。 13.线程之间是如何通信的？线程间通信有三种方式： a. 使用全局变量。进程中的线程间内存共享，这是比较常用的通信方式和交互方式。主要由于多个线程可能更改全局变量，因此全局变量最好声明为violate b. 使用消息实现通信。在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。 1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20; 2)添加消息函数声明afx_msg int OnTSendmsg();3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)4)添加OnTSM()的实现函数；5)在线程函数中添加PostMessage消息Post函数 c. 使用事件CEvent类实现线程间通信。Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。 1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；2)threadStart.SetEvent();使其处于通信状态；3)调用WaitForSingleObject()来监视CEvent对象 当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()notify()notifyAll()方法可以用于线程间通信关于资源的锁的状态。Read more 14. 进程间通信方式及特点？进程是转入内存并准备执行的程序，每个程序都有私有的虚拟地址空间，由代码，数据以及它可利用的系统资源(如文件，管道)组成。多进程/多线程是windows操作系统的一个基本特征。Linux系统一般都统称为进程。 由于不同的进程运行在各自不同的内存空间中，其中一个进程对于变量的修改另一方是无法感知的，因此，进程之间的消息传递不能通过变量或其他数据结构直接进行，只能通过进程间通信来完成。进程间通信是指不同进程间进行数据共享和数据交换。 进程间通信方式：文件和记录锁定，管道，有名管道，FIFO，信号量，信号，消息队列，共享内存，套接字。[^14] Read Read Read… 15. 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法 16. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 17. 为什么Thread类的sleep()和yield()方法是静态的？Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。 18. 如何确保线程安全？在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。Read more 19. volatile关键字在Java中有什么作用？当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。 20. 同步方法和同步块，哪个是更好的选择？同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 21. 如何创建守护线程？使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。 22. 什么是ThreadLocal?ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。 每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。Read more。 23. 什么是死锁(Deadlock)？如何避免死锁？死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。死锁的四个必要条件： 互斥（Mutual exclusion）：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用； 持有（Hold and wait）：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源； 不可剥夺（No preemption）：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源； 环形等待（Circular wait）：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。 在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁。目前处理死锁的方法可归结为四种 24. 什么是线程池？如何创建一个Java线程池？一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。 java.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。如何创建和使用线程池 Java并发面试问题1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。Read more。 2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有： 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 3. 什么是Executors框架？Executor框架同java.util.concurrent.Executor 接口在Java5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。Read more 4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。 阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。 阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。 BlockingQueue接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。使用阻塞队列实现生产者-消费者问题。 5. 什么是并发容器的实现？Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。 并发容器支持并发的遍历和并发的更新。 主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet。 6. Executors类是什么？Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。 Executors可以用于方便的创建线程池。 好文推荐秒杀多线程面试题系列进程通信方式及特点 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2015/03/16/java-multithreading-concurrent/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Java","slug":"java","permalink":"http://agehua.github.io/tags/java/"},{"name":"multi-thread","slug":"multi-thread","permalink":"http://agehua.github.io/tags/multi-thread/"},{"name":"Interview Knowledge","slug":"interview-knowledge","permalink":"http://agehua.github.io/tags/interview-knowledge/"}]},{"title":"Android优秀开源项目【持续更新】","slug":"android-open-sources","date":"2015-01-26T16:00:00.000Z","updated":"2017-11-23T07:23:45.000Z","comments":true,"path":"2015/01/27/android-open-sources/","link":"","permalink":"http://agehua.github.io/2015/01/27/android-open-sources/","excerpt":"一直想找些Android经典的开源项目学习一下，大健发现了这么一篇帖子，不少好东西，分享在此。希望能够对Android开发的同学有所帮助。感谢作者的整理和分享。tisa007原帖在这里。\n项目篇：\nApollo音乐播放器：就一个播放器，但是实现的很好\noschina客户端：oschina网站的客户端哦，wp版，iOS版都有开源\nxabber实时聊天工具（基于xmpp协议）：不评价了，反正算是同类中比较好的了\n四次元新浪微博客户端：今天才知道是开源的，赶紧收藏\nGoogle IO：谷歌开发者大会应用，虽然有点难懂，还是很有参考价值（比如其中的图片加载）\neoe客户端：eoe网站Android客户端也开源咯，嘿嘿\n","text":"一直想找些Android经典的开源项目学习一下，大健发现了这么一篇帖子，不少好东西，分享在此。希望能够对Android开发的同学有所帮助。感谢作者的整理和分享。tisa007原帖在这里。 项目篇： Apollo音乐播放器：就一个播放器，但是实现的很好 oschina客户端：oschina网站的客户端哦，wp版，iOS版都有开源 xabber实时聊天工具（基于xmpp协议）：不评价了，反正算是同类中比较好的了 四次元新浪微博客户端：今天才知道是开源的，赶紧收藏 Google IO：谷歌开发者大会应用，虽然有点难懂，还是很有参考价值（比如其中的图片加载） eoe客户端：eoe网站Android客户端也开源咯，嘿嘿 软件篇： Android-Flip：可以实现类似FlipBoard那种华丽丽的翻页 Drag-Sort-Listview：可以拖动item重新排序的listview，效果非常赞 HoloEveryWhere：咳咳，有些同学非常喜欢Android的holo风格，这个项目绝对让你happy Universal-ImageLoader：这个经典的异步图片加载，不多说了 JazzyViewPager：这玩意可以让ViewPager翻起来更酷，谁用谁知道~~ SlidingMenu：这个是抽屉界面（就是facebook那种）的各种实现版本中，最好的，木有之一！ StickyListHeaders：iPhone上经常有这个，就是listview的……不知道怎么解释，自己下载看看吧 Android-PullToRefresh：下拉刷新，挺常用的一个组件 StaggeredGridView：这是一个瀑布流布局的实现，还不是很完善，但作为学习的案例或者在其基础上扩展还是不错的 android-async-http：android的异步请求组件，我个人习惯使用asynctask，不过这个实现还是很优秀的，也推荐给大家 ActionBarSherlock：大家熟知的ActionBar在2.x上的兼容性方案；类似的兼容性组件还有许多，有时间为大家一一列出； facebook-android-sdk：不止是一个SDK那么简单哦，比某浪和某人的SDK强几个数量级； NineOldAndroids：想在2.xSDK上使用Android 3.0新增的动画API，那就是它了；没用过的同学一定要试试哦，非常方便~ android-swipelistview：让listview的item可以向右滑动，新版Gmail和Pocket里面有用到哦~ DataDroid：Android的RESTful封装，没听过RESTful？你去死吧 EventBus：和上面的DataDroid同样属于美化底层代码的，这个lib简化了不同组件之间的事件传递 android-switch-backport：Android3.0以上才有的switch，有好心人给迁移到2.x上了，哈 PagerSlidingTabStrip：最新版的GooglePlay的那个tab效果，可炫可炫了 chromeview：我们都知道webview，也知道Android的chrome又自己的内核，这个项目就是把chrome的内核给导出来做成一个chromeview了，大家可以在自己的项目里用，有兴趣的可以玩玩 picasso：来自square的图片异步加载，好像是最近才开源的，API风格很独特，哥很喜欢~ 顺便推荐大家几个网站： github：各种项目很多，就是不容易挖掘，但是开发者必备 oschina：曾经一般，现在越做越好了，很多开源项目； eoeandroid：经过一番整理，现在非常强大；小作品居多； AndroidViews：我曾经想做这么一个网站来着，很多开源组件的集合，嘿嘿 vogella:国外的一个教程网站，不是逗小孩玩的那种哦~ 大家都说github上面的项目不容易发现，但其实还是有办法的，比如：关注java项目排名：大家戳 这个网址搜索“Android”，并按star排序：戳 这里 直达最后，还有一招，就是关注些牛人，他们通常会关注或fork一些很有水平的项目。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2015/01/27/android-open-sources/","raw":null,"content":null,"categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ANDROID","slug":"android","permalink":"http://agehua.github.io/tags/android/"},{"name":"Open souces","slug":"open-souces","permalink":"http://agehua.github.io/tags/open-souces/"}]},{"title":"Hello World","slug":"hello-world","date":"2014-12-22T16:00:00.000Z","updated":"2017-11-20T08:36:25.000Z","comments":true,"path":"2014/12/23/hello-world/","link":"","permalink":"http://agehua.github.io/2014/12/23/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\nMore info: Writing\nRun server$ hexo server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2014/12/23/hello-world/","raw":null,"content":null,"categories":[],"tags":[]}]}