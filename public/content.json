{"meta":{"title":"Agehua","subtitle":null,"description":"","author":"Jixin Li","url":"http://agehua.github.io"},"pages":[{"title":"人不逍遥，名逍遥","date":"2017-03-13T07:25:42.000Z","updated":"2017-03-13T07:25:42.000Z","comments":true,"path":"about/index.html","permalink":"http://agehua.github.io/about/index.html","excerpt":"","text":"本文链接：http://agehua.github.io/about/index.html"},{"title":"Categories","date":"2016-12-26T10:41:15.000Z","updated":"2016-12-26T10:41:15.000Z","comments":true,"path":"categories/index.html","permalink":"http://agehua.github.io/categories/index.html","excerpt":"","text":"本文链接：http://agehua.github.io/categories/index.html"}],"posts":[{"title":"注解在Android中的应用","slug":"Annotation-Android-usage","date":"2017-04-09T16:00:00.000Z","updated":"2017-04-24T11:35:16.000Z","comments":true,"path":"2017/04/10/Annotation-Android-usage/","link":"","permalink":"http://agehua.github.io/2017/04/10/Annotation-Android-usage/","excerpt":"注解在Android中的应用注解是Java语言的特性之一，它是在源代码中插入标签，这些标签在后面的编译或者运行过程中起到某种作用，每个注解都必须通过注解接口 @Interface 进行声明，接口的方法对应着注解的元素。 在上一篇文章Injection(CDI)和assertion(断言)中介绍了Java中的CDI（上下文依赖注入）规范，这个规范就是使用注解的方式。这篇文章主要介绍注解在Android中的应用。 先看看Android上著名的View注入框架Butterknife的Bind注解的源码： @Retention (RetentionPolicy.Class)@Target (ElementType.FIELD)public @interface Bind &#123; /** View ID to which the field will be found. **/ int[] value();&#125; @interface 声明会创建一个实际的Java接口，与其他任何接口一样，注解也会编译成.class文件。@Retention 和@Target 下面会介绍到。 Java注解的分类","text":"注解在Android中的应用注解是Java语言的特性之一，它是在源代码中插入标签，这些标签在后面的编译或者运行过程中起到某种作用，每个注解都必须通过注解接口 @Interface 进行声明，接口的方法对应着注解的元素。 在上一篇文章Injection(CDI)和assertion(断言)中介绍了Java中的CDI（上下文依赖注入）规范，这个规范就是使用注解的方式。这篇文章主要介绍注解在Android中的应用。 先看看Android上著名的View注入框架Butterknife的Bind注解的源码： @Retention (RetentionPolicy.Class)@Target (ElementType.FIELD)public @interface Bind &#123; /** View ID to which the field will be found. **/ int[] value();&#125; @interface 声明会创建一个实际的Java接口，与其他任何接口一样，注解也会编译成.class文件。@Retention 和@Target 下面会介绍到。 Java注解的分类 Java API中默认定义的注解叫做标准注解。它们定义在java.lang、java.lang.annotation和javax.annotation包中。按照使用场景不同，可以分为如下三类： 编译相关注解编译相关的注解是给编译器使用的，有以下几种： @Override：编译器检查被注解的方法是否真的重载了一个来自父类的方法，如果没有，编译器会给出错误提示。 @Deprecated：可以用来修饰任何不再鼓励使用或已被弃用的属性、方法等。 @SuppressWarnings：可用于除了包之外的其他声明项中，用来抑制某种类型的警告。 @SafeVarargs：用于方法和构造函数，用来断言不定长参数可以安全使用 @Generated：一般是给代码生成工具使用，用来表示这段代码不是开发者手动编写的，而是工具生成的。被@Generated修饰的代码一般不建议手动修改它。 @FunctionalInterface：用来修饰接口，表示对应得接口是带单个方法的函数式接口 资源相关注解一共有四个，一帮用在JavaEE领域，Android开发中应该不会用到，就不在详细介绍\b了。分别是： @PostConstruct @PreDestroy @Resource @Resources 元注解Butterknife的Bind注解用到的就是元注解。 元注解，顾名思义，就是用来定义和实现注解的注解，总共有如下五种： @Retention, 用来指明注解的访问范围，也就是在什么级别保留注解，有三种选择： 源码级注解：使用@Retention(RetentionPolicy.SOURCE)修饰的注解，该类型修饰的注解信息只会保留在 .java源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的 .class文件中。 编译时注解：使用@Retention(RetentionPolicy.CLASS)修饰的注解，该类型的注解信息会保留在 .java源码里和 .class文件里，在执行的时候会被Java虚拟机丢弃，不会加载到虚拟机中。 运行时注解：使用@Retention(RetentionPolicy.RUNTIME)修饰的注解，Java虚拟机在运行期间也保留注解信息，可以通过反射机制读取注解的信息未指定类型时，默认是CLASS类型。 @Target, 这个注解的取值是一个ElementType类型的数组，用来指定注解所使用的对象范围，共有十种不同的类型，如下表所示，同时支持多种类型共存，可以进行灵活的组合。 元素类型 适用于 ANNOTATION_TYPE 注解类型声明 CONSTRUCTOR 构造函数 FIELD 实例变量 LOCAL_VARIABLE 局部变量 METHOD 方法 PACKAGE 包 PARAMETER 方法参数或者构造函数的参数 TYPE 类（包含enum）和接口（包含注解类型） TYPE_PARAMETER 类型参数 TYPE_USE 类型的用途 如果一个注解的定义没有使用@Target修饰，那么它可以用在除了TYPE_USE和TYPE_PARAMETER之外的其他类型声明中 @Inherited, 表示该注解可以被子类继承的。 @Documented, 表示被修饰的注解应该被包含在被注解项的文档中（例如用JavaDoc生成的文档） @Repeatable, 表示这个注解可以在同一个项上面应用多次。不过这个注解是在Java 8中才引入的，前面四个元注解都是在Java 5中就已经引入。 运行时注解前面说过，要定义运行时注解只需要在声明注解时指定 @Retention(RetentionPolicy.RUNTIME)即可，运行时注解一般和反射机制配合使用。相比编译时注解性能比较低，但灵活性好，实现起来比较简单。 Butterknife在较低版本依然是通过运行时反射实现View的注入，性能较低下，不过在8.0.0版本以后使用编译时注解来提升性能。 运行时注解的简单使用下面展示一个Demo。其功能是通过注解实现布局文件的设置。 之前我们是这样设置布局文件的： @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_home);&#125; 如果使用注解，我们就可以这样设置布局了 @ContentView(R.layout.activity_home)public class HomeActivity extends BaseActivity &#123; ...&#125; 我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。 那么这样的注解是怎么实现的呢？很简单，往下看。 创建一个注解@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)public @interface ContentView &#123; int value();&#125; 前面已经讲过元注解，这不不再介绍。 对于：public @interface ContentView 这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。 （值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为ElementType.Type，并且从官方注解来看，interface是包含@interface的） /** Class, interface (including annotation type), or enum declaration */TYPE, 对于：int value(); 返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的@ContentView(R.layout.activity_home) R.layout.activity_home 实质是一个int型id，如果这样用就会报错： @ContentView(“string”) 关于注解的具体语法，可以看这篇文章Android编译时注解框架-语法讲解 注解解析注解申明好了，但具体是怎么识别这个注解并使用的呢？@ContentView(R.layout.activity_home)public class HomeActivity extends BaseActivity &#123; ...&#125; 注解的解析就在BaseActivity中。我们看一下BaseActivity代码public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //注解解析 for (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) &#123; ContentView annotation = (ContentView) c.getAnnotation(ContentView.class); if (annotation != null) &#123; try &#123; this.setContentView(annotation.value()); &#125; catch (RuntimeException e) &#123; e.printStackTrace(); &#125; return; &#125; &#125;&#125; 解释下上面的代码： 第一步：遍历所有的子类 第二步：找到修饰了注解ContentView的类 第三步：获取ContentView的属性值。 第四步：为Activity设置布局。 总结：要定义运行时注解，只需要在声明注解时指定@Retention(RetentionPolicy.RUNTIME)即可，运行时注解一般和反射机制配合使用，相比编译时注解性能比较低，但实现比较简单，会提高一定的开发效率。 编译时注解编译时注解能够自动处理Java源文件并生成更多的源码、配置文件、脚本或其他可能想要生成的东西。这些操作是通过注解处理器完成的。Java通过在编译期间调用 javac -processor命令可以调起注解处理器，它能够实现编译时注解的功能，从而提高函数库的性能。 定义注解处理器自定义编译时注解后，需要编写Processor类实现注解处理器，处理自定义注解。Processor继承自AbstractProcessor类并实现process方法，同时需要指定注解处理器能够处理的注解类型以及支持的Java版本，语句如下： public class JsonAnnotationProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment env)&#123; super.init(env); //初始化方法，会被注解处理工具调用，并传入ProcessingEnvironment类型参数， //这个参数包含了很多工具类，如Elements、Types、Filer等 elementUtils = env.getElementUtils(); typeUtils = env.getTypeUtils(); filer = env.getFiler(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; //指定这个注解处理器能够处理的注解类型，返回一个支持的类型字符串合集 return super.getSupportedAnnotationTypes(); &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; //指定注解处理器使用的Java版本 return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; //在这个方法中实现注解处理器的具体业务逻辑，根据输入参数roundEnv可以得到包含特定注解的被注解元素 //下面代码是Butterknife中这个方法的源码 Map&lt;TypeElement, BindingClass&gt; targetClassMap = findAndParseTargets(env); for (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingClass bindingClass = entry.getValue(); try &#123; JavaFileObject jfo = filer.createSourceFile(bindingClass.getFqcn(), typeElement); Writer writer = jfo.openWriter(); writer.write(bindingClass.brewJava()); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; error(typeElement, \"Unable to write view binder for type %s: %s\", typeElement, e.getMessage()); &#125; &#125; //返回值 表示这组 annotations 是否被这个 Processor 接受， //如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理 return true; &#125; //Butterknife源码：RoundEnvironment表示当前或是之前的运行环境，可以通过该对象查找找到相应的注解。 private Map&lt;TypeElement, BindingClass&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingClass&gt; targetClassMap = new LinkedHashMap&lt;TypeElement, BindingClass&gt;(); Set&lt;String&gt; erasedTargetNames = new LinkedHashSet&lt;String&gt;(); // Process each @Bind element. for (Element element : env.getElementsAnnotatedWith(Bind.class)) &#123; //所有被使用的@Bind注解 try &#123; parseBind(element, targetClassMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, Bind.class, e); &#125; &#125; ...... &#125; &#125; 一个注解处理器，只能产生新的源文件，它不能够修改一个已经存在的源文件。当没有属于该Process处理的注解被使用时，process不会执行。 从Java7 开始，我们也可以使用注解来代替上面的getSupportedAnnotationTypes()和getSupportedSourceVersion()方法，代码如下：@SupportedAnnotationTypes(&#123; //该注解处理器支持的所有注解全名&#125;)@SupportedSourceVersion(SourceVersion.RELEASE_7)public class ContentViewProcessor extends AbstractProcessor &#123; ...&#125; Element类型所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。 Element的官方注释：Represents a program element such as a package, class, or method.Each element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine). 表示一个程序元素，比如包、类或者方法。 Element的子类有： ExecutableElement表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR) PackageElement表示一个包程序元素。提供对有关包极其成员的信息访问。对应@Target(ElementType.PACKAGE) TypeElement表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。对应@Target(ElementType.TYPE) 注意：枚举类型是一种类，而注解类型是一种接口。 TypeParameterElement表示一般类、接口、方法或构造方法元素的类型参数。对应@Target(ElementType.PARAMETER) VariableElement表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。对应@Target(ElementType.LOCAL_VARIABLE) Processor输出日志虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。Processor日志输出的位置在编译器下方的Messages窗口中。Processor支持最基础的System.out方法。 同样Processor也有自己的Log输出工具: Messager。//同样是Butterknife源码private void error(Element element, String message, Object... args) &#123; if (args.length &gt; 0) &#123; message = String.format(message, args); &#125; processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);&#125; 注册注解处理器为了让javac -processor能够对定义好的注解处理进行处理，我们需要将注解处理器打包到一个jar文件中，同时，需要在jar文件中增加一个名为javax.annotation.processing.processor的文件来指明jar文件中有哪些注解处理器，这个文件最终目录在jar文件根目录的META-INF/service目录中，jar文件解压后的目录结构如下图： javax.annotation.processing.Processor文件的内容是注解处理器全路径名，如果存在多个注解处理器，以换行进行分隔，代码看图片 源文件的目录是，我们需要在src/main/java同级目录中新建一个名为resources的目录，将META-INF/services/javax.annotation.processing.Processor文件放进去就行 注意，注解处理器所在的Android Studio工程必须是Java Library类型，而不应该是Android Library类型。因为Android Library的JDK中不包含某些javax包里面的类。 手动实现上面注册过程很繁琐，因此Google开源了一个名为AutoService的函数库，使用这个库后，只需在自定义Processor时使用@AutoService注解标记即可完成上面注册步骤。 @AutoService(Processor.class)@SupportedAnnotationTypes(&#123; //该注解处理器支持的所有注解全名&#125;)@SupportedSourceVersion(SourceVersion.RELEASE_7)public class ContentViewProcessor extends AbstractProcessor &#123; ...&#125; android-apt插件注解处理器所在的jar文件只能在编译期间起作用，到应用运行时不会用到，因此，在build.gradle中引入依赖时应该以provided方式，而不是compile方式引入。 当然，我们可以使用android-apt插件的方式。 APT(Annotation Processing Tool)是一种处理注释的工具,它对源代码文件进行检测找出其中的Annotation，使用Annotation进行额外的处理。注解处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由注解处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。 android-apt是在Android Studio中使用注解处理器的一个辅助插件，它的作用主要如下： 只在编译期间引入注解处理器所在的函数库作为依赖，不会打包到最终生成的APK中。 为注解处理器生成的源码设置好正确的路径，以便Android Studio能够正常找到，避免报错。 Project项目中使用apt使用该插件，添加如下到你的构建脚本中：//配置在Project下的build.gradle中buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; ... //替换成最新android-apt版本 classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125;apply plugin: 'com.neenbedankt.android-apt' 接着以apt的方式引入注解处理器函数库作为依赖dependencies &#123; apt'com.bluelinelabs:logansquare-compiler:1.3.6' compile 'com.bluelinelabs:logansquare:1.3.6'&#125; LoganSquare是一个实现了编译时注解以提高性能的JSON解析函数库。上面的compiler库就是LoganSquare的注解处理器。 在Module中使用apt在Module中build.gradle的配置 通常在使用的时候，使用apt声明注解用到的库文件。项目依赖可能分为多个部分。例如Dagger有两个组件Dagger-compiler和dagger。dagger-commpiler仅用于编译时，运行时必需使用dagger。//配置到Module下的build.gradle中apply plugin: 'com.android.application'apply plugin: 'com.neenbedankt.android-apt'dependencies &#123; apt 'com.squareup.dagger:dagger-compiler:1.1.0' compile 'com.squareup.dagger:dagger:1.1.0'&#125; provided vs apt使用注解处理器的不同？ provided 将会导入注解处理器的classes和它的依赖到IDE的类路径下。这意味着你可以附带的引入并使用这些classes。例如，当注解处理器使用Guava，你可能错误的import其相关代码到你的Android 代码中。当运行时将导致crash。 provided也可以用在重复引用的库上，避免依赖重复的资源。 而使用apt，注解处理器的classes将不会添加到你当前的类路径下，仅仅用于注解处理过程。并且会把所有注解处理器生成的source放在IDE的类路径下，方便Android Studio引用。 越来越多第三方库使用apt技术，如DBflow、Dagger2、ButterKnife、ActivityRouter、AptPreferences。在编译时根据Annotation生成了相关的代码，非常高大上但是也非常简单的技术，可以给开发带来了很大的便利。 APT处理annotation的流程注解处理器（AbstractProcess）+代码处理（javaPoet）+处理器注册（AutoService）+apt 具体流程： 1.定义注解（如@inject） 2.定义注解处理器 3.在处理器里面完成处理方式，通常是生成Java代码。 4.注册处理器 5.利用APT完成如下图的工作内容。 annotationProcessor介绍annotationProcessor是APT工具中的一种，他是google开发的内置框架，不需要引入，可以直接在build.gradle文件中使用，ButterKnife就是使用annotationProcessor处理注解，如下： dependencies &#123; annotationProcessor project(':xx') annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'&#125; apt vs annotationProcessor两者有何不同？ android-apt是由一位开发者自己开发的apt框架，源代码托管在这里，随着Android Gradle 插件 2.2 版本的发布，Android Gradle 插件提供了名为 annotationProcessor 的功能来完全代替 android-apt ，自此android-apt 作者在官网发表声明最新的Android Gradle插件现在已经支持annotationProcessor，并警告和或阻止android-apt ，并推荐大家使用 Android 官方插件annotationProcessor。 最近Android N的发布，android 迎来了Java 8，要想使用Java 8的话必须使用Jack编译，android-apt只支持javac编译而annotationProcessor既支持javac同时也支持jack编译。 想用annotationProcessor替代android-apt。删除和替换相应部分即可，具体可以参考这篇文章 文章参考： Android 打造编译时注解解析框架 这只是一个开始Android APT（编译时代码生成）最佳实践Android编译时注解框架系列1-什么是编译时注解你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注解《Android高级进阶》一书——注解在Android中的应用 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/04/10/Annotation-Android-usage/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Annotation","slug":"annotation","permalink":"http://agehua.github.io/tags/annotation/"}]},{"title":"linux(centos) 搭建SVN服务器","slug":"SVN-server-linux","date":"2017-03-19T16:00:00.000Z","updated":"2017-03-28T01:12:33.000Z","comments":true,"path":"2017/03/20/SVN-server-linux/","link":"","permalink":"http://agehua.github.io/2017/03/20/SVN-server-linux/","excerpt":"linux(centos) 搭建SVN服务器安装步骤如下： 第一步：安装SVNyum install subversion 第二步：创建SVN版本库目录mkdir -p /var/svn/svnrepos 第三步：创建版本库","text":"linux(centos) 搭建SVN服务器安装步骤如下： 第一步：安装SVNyum install subversion 第二步：创建SVN版本库目录mkdir -p /var/svn/svnrepos 第三步：创建版本库 svnadmin create /var/svn/svnrepos 第四步：进入conf目录（该SVN版本库配置文件）authz文件是权限控制文件passwd是帐号密码文件svnserve.confSVN服务配置文件 第五步：修改svnserve.conf文件vi svnserve.conf打开下面的几个注释： anon-access = read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz #使用哪个文件作为权限文件realm = /var/svn/svnrepos # 认证空间名，版本库所在目录 svnserve.conf、passwd、authz文件中各配置项前不要有空格 第六步：设置帐号密码vi passwd 在[users]块中添加用户和密码，格式：帐号=密码，如binjoo = 123456。 [users]binjoo = 123456 第七步：设置权限vi authz 在末尾添加如下代码： [groups][/]binjoo=rw 意思是版本库的根目录binjoo对其有读写权限。 第八步：启动svn版本库svnserve -d -r /var/svn/svnrepos 链接方式svn://127.0.0.1 遇到问题在客户端试图 svn merge 总是报svn: E220001: 遇到不可读的路径；拒绝访问。这个错误 提示 : SVN 遇到不可读的路径；拒绝访问。 英文是: Unreadable path encountered; access denied; 既然看不到日志又无法merge等操作. GOOGLE了一下，下面的方法解决了问题。 后面才发现是配置问题. 在项目的conf/svnserve.conf 中, 设置 anon-access = none 即可. 然后重启Subversion服务. 如果本地SVN客户端查看过日志会有缓存, 需要在 设置-&gt;日志缓存-&gt;缓存的版本库 中删除有问题的版本缓存 再重新查看日志就好了. linux svn启动和关闭 1，启动SVNsudo svnserve -d -r /var/svn/svnrepos 其中 -d 表示守护进程， -r 表示在后台执行/var/svn/svnrepos 为svn的安装目录 2，关闭SVN这里采取linux杀死进程的方式处理的ps -ef|grep svnserveroot 4967 1 0 Aug23 ? 00:00:00 svnserve -d -r repository/ 这里 kill -9 4967杀死进程， 此4967为进程号 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/03/20/SVN-server-linux/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"svn server","slug":"svn-server","permalink":"http://agehua.github.io/tags/svn-server/"}]},{"title":"Injection(CDI)和assertion(断言)","slug":"JAVA-CDI-Assertion","date":"2017-03-13T16:00:00.000Z","updated":"2017-04-11T01:03:55.000Z","comments":true,"path":"2017/03/14/JAVA-CDI-Assertion/","link":"","permalink":"http://agehua.github.io/2017/03/14/JAVA-CDI-Assertion/","excerpt":"@Inject注解和CDI（上下文依赖注入）怎么让代码显得高大上呢，当然是多使用注解，那Android Support Annotation使用完了，有没有更高端的呢？ 这篇文章就简单介绍下Java中存在的注解。 CDI（Contexts and Dependency Injection 上下文依赖注入）Java 依赖注入标准（JSR-330）规范，在javax.inject包中提供了一个接口Provider，和几个注解类型@Scope、@Inject、@Named、@Qualifier @Inject@Inject是javax.inject中提供的一个注解，可以不使用new关键字直接创建对象，怎么样，是不是很高端 :) 在字段注解：用@Inject注解，字段不能是final的。可以拥有一个合法的名称","text":"@Inject注解和CDI（上下文依赖注入）怎么让代码显得高大上呢，当然是多使用注解，那Android Support Annotation使用完了，有没有更高端的呢？ 这篇文章就简单介绍下Java中存在的注解。 CDI（Contexts and Dependency Injection 上下文依赖注入）Java 依赖注入标准（JSR-330）规范，在javax.inject包中提供了一个接口Provider，和几个注解类型@Scope、@Inject、@Named、@Qualifier @Inject@Inject是javax.inject中提供的一个注解，可以不使用new关键字直接创建对象，怎么样，是不是很高端 :) 在字段注解：用@Inject注解，字段不能是final的。可以拥有一个合法的名称 doc文档原文： Injectable fields: - are annotated with @Inject. - are not final. - may have any otherwise valid name.@Inject FieldModifiers(opt) Type VariableDeclarators; (opt)这里表示可选 在方法上注解：用@Inject注解，不能是抽象方法，不能声明自身参数类型。可以有返回结果。拥有一个合法的名称。可以有0个或多个参数 doc文档原文： Injectable methods:- are annotated with @Inject.- are not abstract.- do not declare type parameters of their own.- may return a result- may have any otherwise valid name.- accept zero or more dependencies as arguments.@Inject MethodModifiers(opt) ResultType Identifier(FormalParameterList(opt)) Throws(opt) MethodBody (opt)这里表示可选 代码示例： @InjectWeatherDao weatherDao; @InjectWeatherDao(Context context) &#123; this.context = context;&#125; @Inject支持构造函数、方法和字段注解，也可能使用于静态实例成员。可注解成员可以是任意修饰符（private,package-private,protected,public）。注入顺序：构造函数、字段，然后是方法。父类的字段和方法注入优先于子类的字段和方法，同一类中的字段和方法是没有顺序的。 @Inject注解的构造函数可以是无参或多个参数的构造函数。@Inject每个类中最多注解一个构造函数。 除了@Inject注解，还有@Named、@Qualifier和@Provider，下面简单介绍一下。 @Named@Named，一般和@Inject一起使用，如果没有值生成的Bean名称默认和类名相同。 如果指定名称，那么就生成一个指定名称的Bean。public class Car &#123; @Inject @Named(\"driver\") Seat driverSeat; @Inject @Named(\"passenger\") Seat passengerSeat; ...&#125; @Qualifier自定义一个新的修饰语（注解），一个qualifier注解应该满足如下条件： 定义的注解类有@Qualifier，@Retention(RUNTIME)和@Documented。 可以有属性 可以是公共API的一部分 可以用@Target注解限定使用范围 doc文档原文是：Identifies qualifier annotations. Anyone can define a new qualifier. A qualifier annotation:- is annotated with @Qualifier, @Retention(RUNTIME), and typically @Documented.- can have attributes.- may be part of the public API, much like the dependency type, but unlike implementation types which needn't be part of the public API.- may have restricted usage if annotated with @Target. While this specification covers applying qualifiers to fields and parameters only, some injector configurations might use qualifier annotations in other places (on methods or classes for example). 下面是java doc文档@Named注解的生成代码@Qualifier@Documented@Retention(value=RUNTIME)public @interface Named @Documented @Retention(RetentionPolicy.RUNTIME) @Qualifier @Target(value = &#123;ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE&#125;) public @interface Genre &#123; User user() default User.STUDENT; public enum User &#123;STUDENT, TEACHER&#125; &#125; @Named @Genre(user = User.STUDENT) public class StudentDAO implements IUserDAO&#123; @Override public int count() &#123; System.out.println(\"----StudentDAO----\"); return 0; &#125; &#125; @Provider@Provider注解，可以实现任意类型的对象的注入。相对于直接注入T对象，@Provider提供了一个T.get()方法来获取注入的对象 doc文档原文:Provides instances of T. Typically implemented by an injector. For any type T that can be injected, you can also inject Provider&lt;T&gt;. Compared to injecting T directly, injecting Provider&lt;T&gt; enables:- retrieving multiple instances.- lazy or optional retrieval of an instance.- breaking circular dependencies.- abstracting scope so you can look up an instance in a smaller scope from an instance in a containing scope. For example:class Car &#123;@Inject Car(Provider&lt;Seat&gt; seatProvider) &#123; Seat driver = seatProvider.get(); Seat passenger = seatProvider.get(); ... &#125;&#125; get方法解释T get() Provides a fully-constructed and injected instance of T. @Singleton使用该注解标记该类只创建一次，不能被继承。一般在类上用该注解。 doc原文:@Scope@Documented@Retention(value=RUNTIME)public @interface SingletonIdentifies a type that the injector only instantiates once. Not inherited. @Scope注解 @Scope 用于标识作用域注解。一个作用域注解是被标识在包含一个可注入构造器的类上的，用于控制该类型的实例如何被注入器重用。缺省情况下，如果没有标识作用域注解，注入器将为每一次注入都创建（通过注入类型的构造器）新实例，并不重用已有实例。如果多个线程都能够访问一个作用域内的实例，该实例实现应该是线程安全的。作用域实现由注入器完成。 在下面的例子中，作用域注解 @Singleton 确保我们始终只有一个 Log 实例： @Singletonclass Log &#123; void log(String message) &#123; ... &#125;&#125; 当多于一个作用域注解或不被注入器支持的作用域注解被使用在同一个类上时，注入器将生成一个错误。 一个作用域注解： 被标注了 @Scope、@Retention(RUNTIME) 标注的，通常也被 @Documented 标注。 不应该含有属性。 不应该被 @Inherited 标注，因此作用域与继承实现（正交）无关。 如果标注了 @Target 可能会有一些用法限制。 使用 @Scope 来标识一个作用域注解有助于注入器探测程序员使用了作用域注解但却忘了去配置作用域的情况。一个保守的注入器应该生成一个错误而不是去适用该作用域。 doc原文请点击 assertion(断言)在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告并且退出。 在语法上，为了支持assertion，Java增加了一个关键字assert。它包括两种表达式，分别如下： 1.assert expression1;2.assert expression1: expression2; expression1表示一个boolean表达式，expression2表示一个基本类型、表达式或者是一个Object，用于在失败时输出错误信息。 在运行时，如果关闭了assertion功能，这些语句将不起任何作用。 如果打开了assertion功能，那么expression1的值将被计算。 如果它的值为false，该语句强抛出一个AssertionError对象。 如果expression1值为true，expression2将不被计算。 如何关闭和开启assertion功能，请看这篇文章 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/03/14/JAVA-CDI-Assertion/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Injection","slug":"injection","permalink":"http://agehua.github.io/tags/injection/"}]},{"title":"“HTTPS”安全在哪里？","slug":"Https-Questions","date":"2017-03-08T16:00:00.000Z","updated":"2017-03-13T06:06:24.000Z","comments":true,"path":"2017/03/09/Https-Questions/","link":"","permalink":"http://agehua.github.io/2017/03/09/Https-Questions/","excerpt":"文章转载自：“HTTPS”安全在哪里？ (出处: Bugly) 背景最近基于兴趣学学习了下 HTTPS 相关的知识，在此记录下学习心得。 在上网获取信息的过程中，我们接触最多的信息加密传输方式也莫过于HTTPS了。每当访问一个站点，浏览器的地址栏中出现绿色图标时，意味着该站点支持HTTPS信息传输方式。我们知道HTTPS是我们常见的HTTP协议与某个加密协议的混合体，也就是 HTTP+S。这个 S 可以是 TLS（安全传输层协议）、也可以是 SSL（安全套接层），不过我更认可另一个抽象概括的说法，HTTP+Security。不过要谈论 HTTPS 为何安全，还得从 HTTP 为何不安全说起。","text":"文章转载自：“HTTPS”安全在哪里？ (出处: Bugly) 背景最近基于兴趣学学习了下 HTTPS 相关的知识，在此记录下学习心得。 在上网获取信息的过程中，我们接触最多的信息加密传输方式也莫过于HTTPS了。每当访问一个站点，浏览器的地址栏中出现绿色图标时，意味着该站点支持HTTPS信息传输方式。我们知道HTTPS是我们常见的HTTP协议与某个加密协议的混合体，也就是 HTTP+S。这个 S 可以是 TLS（安全传输层协议）、也可以是 SSL（安全套接层），不过我更认可另一个抽象概括的说法，HTTP+Security。不过要谈论 HTTPS 为何安全，还得从 HTTP 为何不安全说起。 假设你现在正坐在教室里上课，现在你非常想和走道旁的迷人的 TA 说一些话，一般这个时候你会用“传纸条”的方式来交流。而这个方式和 TCP/IP 协议基本的工作模式十分相像： 通过小动作引起对方注意； 对方以多种可能的方式（注视、肢体语言等）回应于你； 你确认对方感知到你后，将纸条传给对方； 对方阅读纸条； 对方给予你阅读后的反应； 怎么样，这个流程是不是很熟悉？ 如果你要传递纸条的 TA 距离你很远怎么办？HTTP 协议就是指你在纸条上写明你要传给的 TA 是谁，或者 TA 的座位在哪，接着只需要途径的同学拿到纸条后根据纸条上的指示依次将纸条传过去就 OK 了。 这个时候问题来了：途径的同学完全可以观看并知道你在纸条上写了什么。 这就是 HTTP 传输所面临的问题之一：中间人攻击，指消息传递的过程中，处在传递路径上的攻击者可以嗅探或者窃听传输数据的内容。 加密HTTPS 针对这个问题，采用了“加密”的方式来解决。最著名原始的加密方法就是对称加密算法了，就是双方约定一个暗号，用什么字母替换什么字母之类的。现在一般采用一种叫 AES（高级加密算法）的对称算法。 对称加密算法既指加密和解密需要使用的密钥 key 是一样的。 AES 在数学上保证了，只要你使用的 key 足够长，破解几乎是不可能的（除非光子计算机造出来了）我们先假设在没有密钥 key 的情况下，密文是无法被破解的，然后再回到这个教室。你将用 AES 加密后的内容噌噌噌地写在了纸条上，正要传出去的时候你突然想到，TA 没有 key 怎么解密内容呀，或者说，应该怎么把 key 给TA？ 如果把 key 也写在纸条上，那么中间人照样可以破解窃听纸条内容。也许在现实环境中你有其他办法可以把 key 通过某种安全的渠道送到 TA 的手里，但是互联网上的实现难度就比较大了，毕竟不管怎样，数据都要经过那些路由。 于是聪明的人类发明了另一种加密算法——非对称加密算法。这种加密算法会生成两个密钥（key1 和 key2）。凡是 key1 加密的数据，key1 自身不能解密，需要 key2 才能解密；凡事 key2 加密的数据，key2 自身不能解密，只有 key1 才能解密。 目前这种算法有很多中，最常用的是RSA。其基于的数学原理是： 两个大素数的乘积很容易算，但是用这个乘积去算出是哪两个素数相乘就很复杂了。好在以目前的技术，分解大数的素因确实比较困难，尤其是当这个大数足够大的时候（通常使用2的10次方个二进制位那么大），就算是超级计算机，解密也需要非常长的时间。现在就把这种非对称加密的方法应用在我们教室传纸条的场景里。 你在写纸条内容之前先用 RSA 技术生成了一对密钥 k1 和 k2。 你把 k1 用明文传了出去，路经也许有人会截取，但是没有用，k1 加密的数据需要 k2 才可以破解，而 k2 在你自己手中。 k1 传到了目的人，目的人会去准备一个接下来准备用于对称加密（AES）的传输密钥 key，然后用收到的 k1 把 key 加密，传给你。 你用手上的 k2 解出 key 后，全教室只有你和你的目的人拥有这个对称加密的 key，你们俩就可以尽情聊天不怕窃听啦~ 这里也许你会有问题，为什么不直接用非对称加密来加密信息，而是加密 AES 的 key 呢？ 因为非对称加密和解密的平均消耗时间比较长，为了节省时间提高效率，我们通常只是用它来交换密钥，而非直接传输数据。然而使用非对称加密真的可以防范中间人攻击吗？虽然看上去很安全，但是实际上却挡不住可恶的中间人攻击。 假设你是 A，你的目的地是 B，现在要途径一个恶意同学M。 中间人的恶意之处在于它会伪装成你的目标。当你要和 B 完成第一次密钥交换的时候，M 把纸条扣了下来，假装自己是B并伪造了一个 key，然后用你发来的 k1 加密了 key 发还给你。你以为你和 B 完成了密钥交换，实际上你是和 M 完成了密钥交换。同事M 和 B 完成一次密钥交换，让 B 以为和 A 你完成了密钥交换。现在整体的加密流程变成了A（加密链接1）-&gt;M(明文)-&gt;B(加密链接2)的情况了，这时候 M 依然可以知道A和B传输的全部消息。 这个时候就是体现 HTTPS 和传纸条的区别了。在教室里，你是和一位与你身份几乎对等的的对象来通信；而在访问网站时，对方往往是一个比较大（或者知名）的服务者，他们有充沛的资源，或许他们可以向你证明他们的合法性。此时我们需要引入一个非常权威的第三方，一个专门用来认证网站合法性的组织，可以叫做 CA（Certificate Authority）。各个网站服务商可以向CA申请证书，使得他们在建立安全连接时可以带上CA的签名。而CA得安全性是由操作系统或者浏览器来认证的。 你的Windows、Mac、Linux、Chrome、Safari等会在安装的时候带上一个他们认为安全的 CA 证书列表，只有和你建立安全连接的网站带有这些CA的签名，操作系统和浏览器才会认为这个链接是安全的，否则就有可能遭到中间人攻击。一旦某个CA颁发的证书被用于的非法途径，那么这个CA之前颁发过的所有证书都将被视为不安全的，这让所有CA在颁发证书时都十分小心，所以CA证书在通常情况下是值得信任的。 总结使 HTTP 后面增加一个S（Security）的技术，正是 对称加密 + 非对称加密 + CA认证 这三种技术的混合体。当然这个主要是 HTTPS 的基本原理，真正实际中的 HTTPS 的协议是比以上的描述更为复杂一些的，并且其中任何一步稍有闪失，整个流程都将不再安全。这也是为什么 HTTPS 协议从 SSL 1.0升级到 SSL 3.0，再被 TLS 1.0 现在被 TLS 1.3取代，其背后都是一个个细节上的优化，以防有任何闪失。TLS 协议相比 SSL 协议增加了传输层的安全保证。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/03/09/Https-Questions/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"HTTPS","slug":"https","permalink":"http://agehua.github.io/tags/https/"}]},{"title":"解决Android多进程导致Application重复创建问题","slug":"Multi-Process-Dispatch","date":"2017-02-20T16:00:00.000Z","updated":"2017-03-15T01:02:01.000Z","comments":true,"path":"2017/02/21/Multi-Process-Dispatch/","link":"","permalink":"http://agehua.github.io/2017/02/21/Multi-Process-Dispatch/","excerpt":"本编文章是在阅读：Android架构思考(模块化、多进程)过程中，结合自己的理解，对Android开启多进程，会导致Application重复创建问题进行一个总结。 Android开启多进程一般情况下，一个应用程序就一个进程，这个进程的名称就是应用程序包名。Android的四大组件在AndroidManifest文件中注册的时候，有个属性是android:process，这里可以指定组件的所处的进程。 一个进程情况下，Application的onCreate方法只会执行一次，但如果应用中采用多进程方式，onCreate方法会执行多次。 解决Application的onCreate方法多次调用总结了两种实现方式：","text":"本编文章是在阅读：Android架构思考(模块化、多进程)过程中，结合自己的理解，对Android开启多进程，会导致Application重复创建问题进行一个总结。 Android开启多进程一般情况下，一个应用程序就一个进程，这个进程的名称就是应用程序包名。Android的四大组件在AndroidManifest文件中注册的时候，有个属性是android:process，这里可以指定组件的所处的进程。 一个进程情况下，Application的onCreate方法只会执行一次，但如果应用中采用多进程方式，onCreate方法会执行多次。 解决Application的onCreate方法多次调用总结了两种实现方式： 一、根据不同的进程名字进行不同数据的初始化。这是现在网络上通用的方法，在自定义的Application的onCreate方法中控制不同进程的初始化 代码如下： @Overridepublic void onCreate() &#123; super.onCreate(); String processName = getProcessName(this, android.os.Process.myPid()); if (processName != null) &#123; boolean defaultProcess = processName.equals(Constants.REAL_PACKAGE_NAME); // 默认的主进程启动时初始化应用 if (defaultProcess) &#123; initAppForMainProcess(); &#125; // 其他进程启动时初始化对应内容 else if (processName.contains(\":webbrowser\")) &#123; &#125; else if (processName.contains(\":bgmusic\")) &#123; &#125; &#125; 获取当前进程名的方法如下： /** * @return null may be returned if the specified process not found */public static String getProcessName(Context cxt, int pid) &#123; ActivityManager am = (ActivityManager) cxt.getSystemService(Context.ACTIVITY_SERVICE); List&lt;RunningAppP.rocessInfo&gt; runningApps = am.getRunningAppProcesses(); if (runningApps == null) &#123; return null; &#125; for (RunningAppProcessInfo procInfo : runningApps) &#123; if (procInfo.pid == pid) &#123; return procInfo.processName; &#125; &#125; return null;&#125; 二、剥离出一个类，具有同Application相同的生命周期方法，每个进程拥有一个该类实例这就是文章开头提到的博客中使用的方式Android架构思考(模块化、多进程) 实现这种方式，一共有涉及到3个类， 一个是MaApplication继承了Application，是程序的入口，这是一个抽象类，需要子类去实现一些方法 一个是BaseApplicationLogic，这也是基类，由这个类来实现每个进程单独管理Application的生命周期，每个进程实现一个该类的子类 还有一个类是PriorityLogicWrapper，它是一个封装类，继承了Comparable接口，实现了对BaseApplicationLogic按照指定顺序排序（也就是可以按照优先级顺序初始化BaseApplicationLogic） 首先，我们先把所有ApplicationLogic注册到MaApplication中；然后，MaApplication会根据注册时的进程名信息进行筛选，选择相同进程名的ApplicationLogic，保存到本进程中；其次，对这些本进程的ApplicationLogic进行实例化；最后，调用ApplicationLogic的onCreate方法，实现ApplicationLogic与Application生命周期同步，同时还有onTerminate、onLowMemory、onTrimMemory、onConfigurationChanged等方法，与onCreate一致。 流程图如下所示： 代码实现，先看基类BaseApplicationLogic，每个进程都要实现一个该类的子类： public class BaseApplicationLogic &#123; protected MaApplication mApplication; public BaseApplicationLogic() &#123; &#125; public void setApplication(@NonNull MaApplication application) &#123; mApplication = application; &#125; public void onCreate() &#123; &#125; public void onTerminate() &#123; &#125; public void onLowMemory() &#123; &#125; public void onTrimMemory(int level) &#123; &#125; public void onConfigurationChanged(Configuration newConfig) &#123; &#125;&#125; 其次PriorityLogicWrapper，这是一个封装类，实现了BaseApplicationLogic的按优先级排列：public class PriorityLogicWrapper implements Comparable&lt;PriorityLogicWrapper&gt; &#123; public int priority = 0; public Class&lt;? extends BaseApplicationLogic&gt; logicClass = null; public BaseApplicationLogic instance; public PriorityLogicWrapper(int priority, Class&lt;? extends BaseApplicationLogic&gt; logicClass) &#123; this.priority = priority; this.logicClass = logicClass; &#125; @Override public int compareTo(PriorityLogicWrapper o) &#123; return o.priority - this.priority; &#125;&#125; 在MaApplication中直接对PriorityLogicWrapper进行操作，无需操作BaseApplicationLogic对象public abstract class MaApplication extends Application &#123; //mLogicList只持有当前进程的PriorityLogicWrapper对象 private ArrayList&lt;PriorityLogicWrapper&gt; mLogicList; //mLogicClassMap持有所有进程的PriorityLogicWrapper数组对象 private HashMap&lt;String, ArrayList&lt;PriorityLogicWrapper&gt;&gt; mLogicClassMap; @Override public void onCreate() &#123; super.onCreate(); init(); initializeLogic(); dispatchLogic(); instantiateLogic(); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; //找到当前进程的BaseApplicationLogic实例后，执行其onCreate()方法 priorityLogicWrapper.instance.onCreate(); &#125; &#125; &#125; &#125; private void init() &#123; mLogicClassMap = new HashMap&lt;&gt;(); &#125; public abstract boolean needMultipleProcess(); //由MaApplication的实现类，去实现这个方法，调用registerApplicationLogic() //注册所有进程的BaseApplicationLogic对象 protected abstract void initializeLogic(); /** * 添加所有来自不同进程的，不同的BaseApplicationLogic对象到HashMap中 * @param processName 进程名 * @param priority 优先级 * @param logicClass 继承BaseApplicationLogic的对象 * @return */ protected boolean registerApplicationLogic(String processName, int priority, @NonNull Class&lt;? extends BaseApplicationLogic&gt; logicClass) &#123; boolean result = false; if (null != mLogicClassMap) &#123; ArrayList&lt;PriorityLogicWrapper&gt; tempList = mLogicClassMap.get(processName); if (null == tempList) &#123; tempList = new ArrayList&lt;&gt;(); mLogicClassMap.put(processName, tempList); &#125; if (tempList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : tempList) &#123; if (logicClass.getName().equals(priorityLogicWrapper.logicClass.getName())) &#123; throw new RuntimeException(logicClass.getName() + \" has registered.\"); &#125; &#125; &#125; PriorityLogicWrapper priorityLogicWrapper = new PriorityLogicWrapper(priority, logicClass); tempList.add(priorityLogicWrapper); //tempList更新，则mLogicClassMap中的value也跟着更新了，不用再调用mLogicClassMap.put方法 &#125; return result; &#125; /** * 得到一个属于本进程的ArrayList对象，里面保存着封装类PriorityLogicWrapper */ private void dispatchLogic() &#123; if (null != mLogicClassMap) &#123; //根据进程名，得到该进程名对应的ArrayList&lt;PriorityLogicWrapper&gt; mLogicList = mLogicClassMap.get(ProcessUtil.getProcessName(this, ProcessUtil.getMyProcessId())); &#125; &#125; /** * 取得mLogicList中的PriorityLogicWrapper对象，并按优先级顺序初始化BaseApplicationLogic对象 */ private void instantiateLogic() &#123; if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; Collections.sort(mLogicList); //根据进程优先级，按顺序初始化 for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper) &#123; try &#123; /** * 调用Class.newInstance()，会创建这个Class的实例，但是不会执行Android中这个类相关的生命周期 * **/ priorityLogicWrapper.instance = priorityLogicWrapper.logicClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; if (null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.setApplication(this); &#125; &#125; &#125; &#125; &#125; &#125; //Application生命周期的处理，下面方法都类似 @Override public void onTerminate() &#123; super.onTerminate(); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.onTerminate(); &#125; &#125; &#125; &#125; @Override public void onLowMemory() &#123; super.onLowMemory(); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.onLowMemory(); &#125; &#125; &#125; &#125; @Override public void onTrimMemory(int level) &#123; super.onTrimMemory(level); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.onTrimMemory(level); &#125; &#125; &#125; &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); if (null != mLogicList &amp;&amp; mLogicList.size() &gt; 0) &#123; for (PriorityLogicWrapper priorityLogicWrapper : mLogicList) &#123; if (null != priorityLogicWrapper &amp;&amp; null != priorityLogicWrapper.instance) &#123; priorityLogicWrapper.instance.onConfigurationChanged(newConfig); &#125; &#125; &#125; &#125;&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/02/21/Multi-Process-Dispatch/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"multi-process","slug":"multi-process","permalink":"http://agehua.github.io/tags/multi-process/"}]},{"title":"MAC下用iTerm2连接远程主机","slug":"iterm2-to-linux","date":"2017-02-11T16:00:00.000Z","updated":"2017-03-21T07:10:52.000Z","comments":true,"path":"2017/02/12/iterm2-to-linux/","link":"","permalink":"http://agehua.github.io/2017/02/12/iterm2-to-linux/","excerpt":"MAC下用iTerm2连接远程主机iTerm2是MAC的一个终端工具。简单介绍一个小功能，使用iTerm2连接远程主机： 1.先打开一个iTerm2窗口，选择菜单profiles中的Open Profiles，然后选择Edit Profiles中创建一个新的Profile，随便命名成容易记的。 2.选择command，输入ssh -A -p xxx root@输入远程计算机的IP地址（xxx表示端口）。 3.然后选择这个新的profile，New一个window就可以连接远程服务器了。 SCP命令使用说明","text":"MAC下用iTerm2连接远程主机iTerm2是MAC的一个终端工具。简单介绍一个小功能，使用iTerm2连接远程主机： 1.先打开一个iTerm2窗口，选择菜单profiles中的Open Profiles，然后选择Edit Profiles中创建一个新的Profile，随便命名成容易记的。 2.选择command，输入ssh -A -p xxx root@输入远程计算机的IP地址（xxx表示端口）。 3.然后选择这个新的profile，New一个window就可以连接远程服务器了。 SCP命令使用说明 scp用来在网络上不同的主机之间复制文件，它使用ssh安全协议传输数据，具有和ssh一样的验证机制，从而安全的远程拷贝文件。 下面是一个简单例子： 首先创建一个本地文件echo hello, world &gt; a-file.txt copy本地文件到服务器的命令如下：scp &lt;local file&gt; &lt;remote user&gt;@&lt;remote machine&gt;:&lt;remote path&gt; 如果想Copy远程文件到本地，则是：scp &lt;remote user&gt;@&lt;remote machine&gt;:&lt;remote path&gt; &lt;local file&gt; 如果想复制目录也是可以的：scp -r local_folder remote_username@remote_ip:remote_folder 比如下面命令：scp -r /home/space/jdk-8u121-linux-x64.tar.gz root@107.182.178.94:/home/root/others/ 参数说明： [root@tank test]# scp –helpusage: scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program] [[user@]host1:]file1 […] [[user@]host2:]file2 -1 强制scp命令使用协议ssh1-2 强制scp命令使用协议ssh2-4 强制scp命令只使用IPv4寻址-6 强制scp命令只使用IPv6寻址-B 使用批处理模式（传输过程中不询问传输口令或短语）-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p 保留原文件的修改时间，访问时间和访问权限。-q 不显示传输进度条。-r 递归复制整个目录。-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，-P port 注意是大写的P, port是指定数据传输用到的端口号-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 转载自：http://blog.51yip.com/linux/1027.html iTerm从mac传文件到linuxsudo scp -P 28547 ~/Downloads/nexus-3.2.1-01-unix.tar.gz root@107.182.178.94:/usr/local -P 指定linux服务器的端口号，必须是大写 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/02/12/iterm2-to-linux/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://agehua.github.io/tags/linux/"}]},{"title":"IM 国外公司，服务费，方案","slug":"abroad-IM-service-company","date":"2017-01-12T16:00:00.000Z","updated":"2017-02-23T06:10:53.000Z","comments":true,"path":"2017/01/13/abroad-IM-service-company/","link":"","permalink":"http://agehua.github.io/2017/01/13/abroad-IM-service-company/","excerpt":"一、海外提供IM服务的公司1.1 Sinch官网： https://www.sinch.com/products/instant-messaging/收费介绍","text":"一、海外提供IM服务的公司1.1 Sinch官网： https://www.sinch.com/products/instant-messaging/收费介绍 1.2 quickblox官网：https://quickblox.com/收费介绍 1.3 Layerhttps://layer.com/use-cases 具体价格需要注册，然后注册的邮箱里会收到一封邮件： 1.4sendbirdhttps://sendbird.com 收费介绍 1.5 applozichttps://www.applozic.com/收费介绍 二、各家IM服务公司比较 图片来源：Which Chat SDK is better for user experience? Applozic, Sendbird, Layer or Quickblox! 2.1 QuickBlox vs Applozic这部分内容转载自stackoverflow I have recently just tested two of the solutions you have cited. QuickBlox: protocol xmpp open source documentated less clearly than applozic easy set up Applozic: protocol mqtt open source easy set up, if a bit laborious well documented, and very easy API to use. Very customizable. Both programs: have video call/audio call/groups have code bases that are constantly being updated, and from their Github pages new version have been released in the past few months I preferred Applozic as the user interface was nicer and easier to use, and the features and pricing clearer. I also preferred the API and the setup code was easier. 2.2 Quickblox vs SendBird vs Layer本部分内容转载自Do I need to have my own backend? My research on Quickblox vs SendBird vs Layer.com is: 1.Backend-as-a-Service (BaaS) or Chat-as-a-Service (CaaS): Quickblox: Both, BaaS and CaaS SendBird (aka JIVER): CaaS (BaaS for Enterprise-only) Layer.com: CaaS only 2.WebSocket-based: Quickblox: No (XMPP) SendBird: Yes Layer.com: Yes 3.Voice and Video: Quickblox: Yes SendBird: No Layer.com: No 4.Chat UI Kit: Quickblox: QMChatViewController SendBird: Open-source Sample UIs for iOS, Android, JavaScript (Web &amp; React Native), Xamarin, Unity (You can use their Sample UI or 3rd party UI Kit like JSQMessagesViewController) Layer.com: Atlas 5.Number of Members in a Group: Quickblox: Thousands (you may need to host Quickblox BaaS at a dedicated AWS infrastructure for better performance) SendBird: Thousands (no need for an extra infrastructure) Layer.com: limited to 25 per group 6.The ability to host the BaaS/CaaS at your own IaaS: Quickblox: Yes (setup cost starts from $599) SendBird: Yes (limited to Enterprise plans only) Layer.com: No 7.Custom Objects Backend (the need for extra infrastructure): Quickblox: Included in Quickblox BaaS SendBird: Partial support (Key/value custom object stores for channels to be released in March) Layer.com: No 8.BaaS/CaaS Admin Panel/Dashboard: Quickblox: Basic with Custom Dashboard when subscribed to the enterprise plan, starts from $599/month (Classic UI) SendBird: Advanced (Modern UI) Layer.com: Basic (Modern UI) 9.Attachment max file size: Quickblox: Unknown SendBird: 25MB per file (custom limit for Enterprise plans) Layer.com: 2GB (be aware that their pricing is based on the data transfer) 10.Availability SLA: Quickblox: Based on AWS EC2 SLA (99.95%) SendBird: 99.9% Layer.com: 99.9% 11.Pricing (per month): Quickblox: Mainly based on the number of messengers per second (/s) and monthly active users: Free-$49-$214-$599-$1,199-$2,399 (Plans) SendBird: Mainly based on the number of monthly active users (MAU): Free-$59-$179-$599-Custom (https://sendbird.com/pricing) Layer.com: Mainly based on the monthly data transfer and monthly users: Free-$599 per month-Custom (https://layer.com/plans) 12.Number of freelancers at UpWork.com who have this Baas/CaaS as one of their skill set: Quickblox: 547 (keyword: “Quickblox”) SendBird: 0 (keyword: “SendBird” or “JIVER”) « new to the market Layer: 13 (keyword: “Layer.com” not Layer) 2.3 更多比较：https://www.quora.com/Quickblox-vs-SendBird-vs-Layer-com-Do-I-need-to-have-my-own-backend http://stackoverflow.com/questions/37678528/comparing-layer-applozic-quickblox-sendbird-for-quick-whatsapp-like-messagin https://www.applozic.com/blog/applozic-vs-sendbird-vs-layer-vs-quickblox-alternatives/ https://siftery.com/product-comparison/sendbird-vs-quickblox-vs-layer https://stackshare.io/stackups/sendbird-vs-sinch-vs-layer https://www.quora.com/What-SDKs-APIs-are-viable-for-implementing-instant-messaging-between-clients-Android-iOS-and-web 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2017/01/13/abroad-IM-service-company/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"IM Company","slug":"im-company","permalink":"http://agehua.github.io/tags/im-company/"}]},{"title":"Android 增量更新整理","slug":"Android-patch-update","date":"2016-12-19T16:00:00.000Z","updated":"2017-04-11T06:17:40.000Z","comments":true,"path":"2016/12/20/Android-patch-update/","link":"","permalink":"http://agehua.github.io/2016/12/20/Android-patch-update/","excerpt":"背景在前几年，整体移动网络环境相比现在差很多，加之流量费用又相对较高，因此每当我们发布新版本的时候，一些用户升级并不是很积极，这就造成了新版本的升级率并不高。而google为了解决了这个问题，提出了Smart App Update，即增量更新（也叫做差分升级）。 增量更新与热修复完全不是一个东西。增量更新需要重新安装apk，而热修复不需要。热修复也能完成部分增量更新的功能。 增量更新的流程增量更新的具体流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的，当然部分应用市场有root权限你可能感知不到）。","text":"背景在前几年，整体移动网络环境相比现在差很多，加之流量费用又相对较高，因此每当我们发布新版本的时候，一些用户升级并不是很积极，这就造成了新版本的升级率并不高。而google为了解决了这个问题，提出了Smart App Update，即增量更新（也叫做差分升级）。 增量更新与热修复完全不是一个东西。增量更新需要重新安装apk，而热修复不需要。热修复也能完成部分增量更新的功能。 增量更新的流程增量更新的具体流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的，当然部分应用市场有root权限你可能感知不到）。 增量更新的原理增量更新的原理也很简单，就是将手机上已安装的旧版本apk与服务器端新版本apk进行二进制对比，并得到差分包（patch），用户在升级更新应用时，只需要下载差分包，然后在本地使用差分包与旧版的apk合成新版apk，然后进行安装。差分包文件的大小，那就远比APK小得多了，这样也便于用户进行应用升级。 那么增量更新的流程可以细化为几个关键点： 1.用户手机上提取当前安装应用的apk 2.如何利用old.apk和new.apk生成增量文件（差分包） 3.增加文件与1.中的old.apk合并，然后安装 旧版的APK可以在/data/app/%packagename%/下找到。 也可以参考下面的代码： public class ApkExtract &#123; public static String extract(Context context) &#123; context = context.getApplicationContext(); ApplicationInfo applicationInfo = context.getApplicationInfo(); String apkPath = applicationInfo.sourceDir; Log.d(\"hongyang\", apkPath); return apkPath; &#125;&#125; 这部分可以参考张鸿洋的博客 关于生成差分包制作差分包的工具为bsdiff， 网址： http://www.daemonology.net/bsdiff/ 下载地址： http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz 这是一个非常牛的二进制查分工具，bsdiff源代码在Android的源码目录下 ”\\external\\bsdiff“”这边也可以找到。另外还需要依赖bzlib来进行打包。在安全性方面，补丁和新旧版APK最好都要进行MD5验证，以免被篡改。 关于这个工具可以使用别人编译好的so库，这里；熟悉NDK开发的也可以自己编译，请看这里。这里就不在考虑这个工具问题了。 生成增量文件./bsdiff old.apk new.apk old-to-new.patch 这样就生成了一个增量文件old-to-new.patch 关于合并差分包生成差分包肯定是在服务端，合并差分包才是Android客户端需要做的： 增量文件和old.apk合并成新的apk./bspatch old.apk new2.apk old-to-new.patch 这样就生成一个new2.apk 生成后，要查看下两个文件的md5值。如果两个文件md5值一致，那么几乎可以肯定两个文件时一模一样的。 增量更新存在的不足 1、增量升级是以两个应用版本之间的差异来生成补丁的，但是我们无法保证用户每次的及时升级到最新，也就是在更新前，新版和旧版只差一个版本，所以必须对你所发布的每一个版本都和最新的版本作差分，以便使所有版本的用户都可以差分升级，这样相对就比较繁琐了。解决方法也有，可以通过Shell脚本来实现批量生成。 2.增量升级能成功的前提是，从手机端能够获得旧版APK，并且与服务端的APK签名是一样的，所以像那些破解的APP就无法实现更新。前面也提到了，为了安全性，防止补丁合成错误，最好在补丁合成前对旧版本的apk进行sha1或者MD5校验，保证基础包的一致性，这样才能顺利的实现增量升级。 想要封装一套增量更新的工具，请看这篇文章：打造Android万能的软件更新库，修改只要一点点 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/20/Android-patch-update/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Android Patch Update","slug":"android-patch-update","permalink":"http://agehua.github.io/tags/android-patch-update/"}]},{"title":"ThreadLocal一个使用——SimpleDateFormat","slug":"ThreadLocal-usage","date":"2016-12-10T16:00:00.000Z","updated":"2017-01-03T08:49:25.000Z","comments":true,"path":"2016/12/11/ThreadLocal-usage/","link":"","permalink":"http://agehua.github.io/2016/12/11/ThreadLocal-usage/","excerpt":"背景之前写过一篇文章：《ThreadLocal、HandlerThread、Lopper区别》，其中简单提及了ThreadLocal的解释。本篇文章主要结合具体应用场景——SimpleDateFormat，和大家来一起学习ThreadLocal的原理，并对ThreadLocal进行一个详细的介绍。 下面是本文的参考资料： java学习记录–ThreadLocal使用案例——SimpleDateFormat：http://blog.csdn.net/u012706811/article/details/53231598 SimpleDateFormat的线程安全问题与解决方案：http://www.cnblogs.com/zemliu/archive/2013/08/29/3290585.html 前言Thread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals。 这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。 我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（ThreadLocal用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。 ThreadLocal为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。 本篇文章结合具体应用场景，来分析ThreadLocal为什么可以实现不同线程之间不会互相干扰。","text":"背景之前写过一篇文章：《ThreadLocal、HandlerThread、Lopper区别》，其中简单提及了ThreadLocal的解释。本篇文章主要结合具体应用场景——SimpleDateFormat，和大家来一起学习ThreadLocal的原理，并对ThreadLocal进行一个详细的介绍。 下面是本文的参考资料： java学习记录–ThreadLocal使用案例——SimpleDateFormat：http://blog.csdn.net/u012706811/article/details/53231598 SimpleDateFormat的线程安全问题与解决方案：http://www.cnblogs.com/zemliu/archive/2013/08/29/3290585.html 前言Thread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals。 这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。 我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（ThreadLocal用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。 ThreadLocal为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。 本篇文章结合具体应用场景，来分析ThreadLocal为什么可以实现不同线程之间不会互相干扰。 应用场景那么，在什么场景下比较适合使用ThreadLocal呢？ stackoverflow上有人给出了还不错的回答： When and how should I use a ThreadLocal variable?One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object (I’m looking at you, SimpleDateFormat). Instead, give each thread its own instance of the object. SimpleDateFormat为什么线程不安全SimpleDateFormat类内部持有一个Calendar对象引用， 如果你的工具类里，SimpleDateFormat是个static的，那么多个thread之间就会共享这个SimpleDateFormat，同时也会共享这个Calendar引用。 查看下源码中的SimpleDateFormat.parse()方法，你会发现有如下的调用: protected Calendar calendar;Date parse() &#123; calendar.clear(); // 清理calendar ... // 执行一些操作, 设置 calendar 的日期什么的 calendar.getTime(); // 获取calendar的时间&#125; 这里calendar.clear()方法是线程不安全的，不同thread调用parse()方法，会导致结果不可预期 问题重现可以看：这篇博客 解决方案最简单的解决方案我们可以把static去掉，这样每个新的线程都会有一个自己的SimpleDateFormat实例，从而避免线程安全的问题 但是，使用这种方法，在高并发的情况下会大量的new SimpleDateFormat以及销毁SimpleDateFormat，这样是非常耗费资源的 下面是一个从网上找的使用ThreadLocal解决SimpleDateFormat线程不安全问题的例子： import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;public class DateUtil &#123; /** 锁对象 */ private static final Object lockObj = new Object(); /** 存放不同的日期模板格式的SimpleDateFormat的Map */ private static Map&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt; sdfMap = new HashMap&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt;(); /** * 返回一个ThreadLocal的SimpleDateFormat,每个线程只会new一次SimpleDateFormat * * @param pattern * @return */ private static SimpleDateFormat getSdf(final String pattern) &#123; ThreadLocal&lt;SimpleDateFormat&gt; tl = sdfMap.get(pattern); // 此处的双重判断和同步是为了防止sdfMap这个单例被多次put重复的sdf if (tl == null) &#123; synchronized (lockObj) &#123; tl = sdfMap.get(pattern); if (tl == null) &#123; // 只有Map中还没有这个pattern的sdf才会生成新的sdf并放入map System.out.println(\"put new sdf of pattern \" + pattern + \" to map\"); // 这里是关键,使用ThreadLocal&lt;SimpleDateFormat&gt;替代原来直接new SimpleDateFormat tl = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; @Override protected SimpleDateFormat initialValue() &#123; System.out.println(\"thread: \" + Thread.currentThread() + \" init pattern: \" + pattern); return new SimpleDateFormat(pattern); &#125; &#125;; sdfMap.put(pattern, tl); &#125; &#125; &#125; return tl.get(); &#125; /** * 是用ThreadLocal&lt;SimpleDateFormat&gt;来获取SimpleDateFormat,这样每个线程只会有一个SimpleDateFormat * * @param date * @param pattern * @return */ public static String format(Date date, String pattern) &#123; return getSdf(pattern).format(date); &#125; public static Date parse(String dateStr, String pattern) throws ParseException &#123; return getSdf(pattern).parse(dateStr); &#125;&#125; 实现原理那为什么ThreadLocal为变量在每个线程都保存了一个副本呢？ 下面部分内容来自博文，http://www.jianshu.com/p/33c5579ef44f (深入浅出ThreadLocal) 先看一下Thread和ThreadLocal两个类的具体结构，如下： 从线程Thread的角度来看，每个线程内部都会持有一个对ThreadLocalMap实例的引用（也就是threadLocals变量），ThreadLocalMap是TThreadLocal的静态内部类。而Entry则是ThreadLocalMap的静态内部类。ThreadLocalMap实例相当于线程的局部变量空间，由Entry[] table存储着线程的私有数据。 EntryEntry继承自WeakReference类，是存储线程私有变量的数据结构。ThreadLocal实例作为引用，意味着如果ThreadLocal实例为null，就可以从table中删除对应的Entry。 class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; ThreadLocalMap内部使用table数组存储Entry，默认大小INITIAL_CAPACITY(16)，先介绍几个参数： size：table中元素的数量。 threshold：table大小的2/3，当size &gt;= threshold时，遍历table并删除key为null的元素，如果删除后size &gt;= threshold*3/4时，需要对table进行扩容。 ThreadLocal.set()实现/** * ThreadLocal.set() */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 从上面代码中看出来： 1.从当前线程Thread中获取ThreadLocalMap实例。 2.ThreadLocal实例和value封装成Entry。 ThreadLocal.get() 实现public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 从上面代码中可以看出， ThreadLocal.get()方法，如果是不同线程ThreadLocalMap为null，最终会调用initialValue()方法，这个方法也是我们给出的解决方案中重载的方法。最后得到的结果是，不同线程ThreadLocal只有一个，而SimpleDateFormat则每个线程都有一个。 但当同一线程有了一个SimpleDateFormat了，会是什么情况呢？看下面代码： //同一线程中再次执行ThreadLocal.get()public T get() &#123; Thread t = Thread.currentThread();//得到当前子线程 ThreadLocalMap map = getMap(t); //同一个线程，map不为空 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;ThreadLocalMap getMap(Thread t) &#123; //同一线程Thread，变量threadLocals经过初始化了，则不为空 return t.threadLocals;&#125; ThreadLocalMap.getEntry()是如何实现的呢？先看下Entry是如何存入table数组的 Entry存入table数组如何实现的：/** * static class ThreadLocalMap.set()方法 */private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 1.通过ThreadLocal的nextHashCode方法生成hash值。 threadLocalHashCode，由nextHashCode()方法得到/** * 对应上面代码的key.threadLocalHashCode * 在ThreadLocal 类中 */private final int threadLocalHashCode = nextHashCode(); 2.通过 key.threadLocalHashCode &amp; (len -1) 定位到table的位置i，假设table中i位置的元素为f。 3.如果f != null，假设f中的引用为k： 如果k和当前ThreadLocal实例一致，则修改value值，返回。 如果k为null，说明这个f已经是stale(陈旧的)的元素。调用replaceStaleEntry方法删除table中所有陈旧的元素（即entry的引用为null）并插入新元素，返回。 否则通过nextIndex方法找到下一个元素f，继续进行步骤3。 4.如果f == null，则把Entry加入到table的i位置中。 5.通过cleanSomeSlots删除陈旧的元素，如果table中没有元素删除，需判断当前情况下是否要进行扩容。 /** * ThreadLocal 类中 */private static AtomicInteger nextHashCode = new AtomicInteger();private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 从nextHashCode方法可以看出，ThreadLocal每实例化一次，其hash值就原子增加HASH_INCREMENT。 Entry从table数组中取出在回看getEntry()方法，就简单多了：/** * ThreadLocalMap的getEntry()方法 */private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125; 1.通过key.threadLocalHashCode &amp; (len -1)定位到table的位置i，假设table中i位置的元素为g。 2.如果g不为null，且和当前ThreadLocal实例一致，则返回这个Entry。 在看一遍ThreadLocal.get()的代码：//同一线程中再次执行ThreadLocal.get()public T get() &#123; Thread t = Thread.currentThread();//得到当前子线程 ThreadLocalMap map = getMap(t); //同一个线程，map不为空 if (map != null) &#123; //当前ThreadLocal实例一致，则Entry不为null ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 所以，同一个线程，ThreadLocalMap不为空，Entry不为null，则返回table中保存的result。不会执行到setInitialValue()。所以，而SimpleDateFormat则会每一个线程只有一个。 由此，就可以得出结论了，确实可以使用ThreadLocal解决SimpleDateFormat的线程安全问题。 p.s. 感兴趣的可以结合ThreadLocal源码继续研究下面的内容： 获取当前的线程的threadLocals。 如果threadLocals不为null，则通过ThreadLocalMap.getEntry方法找到对应的entry，如果其引用和当前key一致，则直接返回，否则在table剩下的元素中继续匹配。 如果threadLocals为null，则通过setInitialValue方法初始化，并返回。private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; table扩容如果table中的元素数量达到阈值threshold的3/4，会进行扩容操作，过程很简单： /** * 在ThreadLocalMap类中 */private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab;&#125; 新建新的数组newTab，大小为原来的2倍。 复制table的元素到newTab，忽略陈旧的元素，假设table中的元素e需要复制到newTab的i位置，如果i位置存在元素，则找下一个空位置进行插入。 文章到这里就结束了，没有更多了:） 文章内容部分来自互联网，部分为自己整理，最后感谢耐心看到这里的人， 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/11/ThreadLocal-usage/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"ThreadLocal","slug":"threadlocal","permalink":"http://agehua.github.io/tags/threadlocal/"}]},{"title":"Hexo 模板学习——Hexo 结构","slug":"hexo-learning1","date":"2016-12-05T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/12/06/hexo-learning1/","link":"","permalink":"http://agehua.github.io/2016/12/06/hexo-learning1/","excerpt":"起步Hexo会读取根目录下的_config.yml里面的theme属性, 从而采用对应的主题。而主题都是放在themes/目录下面的，然后你会发现他里面有个landscape的目录，这个就是默认主题啦。 接着，我们查看themes/landscape/目录，以及根据文档docs-themes，我们很容易得出：一个主题其实由4部分组成。 _config.yml: 主题的配置文件 source/: 放我们的CSS文件以及图片 layout/: 模板文件 scripts: 放JavaScript文件，他们会自动加载 根据文档docs-templates，下面表格中每个页面都有一个可用的模板，可以没有这些模板，但至少要有一个index模板。","text":"起步Hexo会读取根目录下的_config.yml里面的theme属性, 从而采用对应的主题。而主题都是放在themes/目录下面的，然后你会发现他里面有个landscape的目录，这个就是默认主题啦。 接着，我们查看themes/landscape/目录，以及根据文档docs-themes，我们很容易得出：一个主题其实由4部分组成。 _config.yml: 主题的配置文件 source/: 放我们的CSS文件以及图片 layout/: 模板文件 scripts: 放JavaScript文件，他们会自动加载 根据文档docs-templates，下面表格中每个页面都有一个可用的模板，可以没有这些模板，但至少要有一个index模板。 Template Page Fallback index Home page post Posts index page Pages index archive Archives index category Category archives archive tag Tag archives archive 每次当我们在浏览器访问时，Hexo都会去解析sources目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以EJS为例) 无论URL是什么，Hexo先读取layout.ejs，然后里面的body变量会替换成上面表格里的模板：(Fallback的意思是如果访问/archives时，我们的archives.ejs不存在的话，就会返回index.ejs) 布局编写布局文件(layout.ejs)模板文件在layout文件夹下，文件名对应Hexo中的模板名，有index,post,page,archive,category,tag几种，对于普通的header + content + footer的页面结构，header和footer往往是可以复用的，因此我们可以使用layout.ejs进行布局，动态的内容使用body变量去动态渲染，所以我的layout.ejs大概长这样: &lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/&gt; &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt; &lt;%- css('css/style') %&gt;&lt;/head&gt;&lt;body&gt; &lt;%- partial('_partial/header') %&gt; &lt;div class=\"main\"&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;%- partial('_partial/footer') %&gt; &lt;%- js('js/index.js') %&gt;&lt;/body&gt;&lt;/html&gt; partial,js和css是Hexo提供的辅助函数，后面再说。 其他模板文件每一个模板文件对应的是一种布局，当你使用hexo new 的时候，其实忽略了一个参数，完整的命令是hexo new [layout] ，这个layout就决定了文章使用何种方式布局，比如创建一个自己简介的About页面，hexo new page “about”其实就是使用了page布局。每种布局对应到我们的模板文件上就是index.ejs(首页),post.ejs(文章),archive.ejs(归档),tag.ejs(标签归档),page.ejs(分页)。 index.ejs首页一般是一些博文的摘要和一个分页器，通过Hexo的page变量拿到页面的数据渲染即可，这里我们不直接在index.ejs中写HTML结构，新建一个_partial/article.ejs，将文章数据传给子模板渲染，然后再额外传入一个参数{index: true}，对后面的post.ejs和page.ejs加以区分，让子模板能正确渲染。最后，index.ejs大致是这样的: //index.ejs&lt;% page.posts.each(function(post, index)&#123; %&gt; &lt;%- partial('_partial/article', &#123;index: true, post: post&#125;) %&gt;&lt;% &#125;) %&gt;&lt;div class=\"pagination\"&gt; &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt;&lt;/div&gt; post.ejs文章模板和首页差不多，只是对应的是一篇具体的文章，所以就把文章传入，再额外传入{index: false}告诉子模板不要按首页的方式去渲染就好了。就一行代码(因为都在子模板里 XD //post.ejs&lt;%- partial('_partial/article', &#123;index: false, post: page&#125;) %&gt; page.ejs我个人对Page模板其实是有点懵逼的，在我自己的实践中是添加about(hexo new page “about”)页面后，访问/about会走分页布局，实际上这个页面对应的内容是/source/about里的index.md，也相当于对文章的渲染，因此我把Page模板也写成了和文章模板一样: //page.ejs&lt;%- partial('_partial/article', &#123;index: false, post: page&#125;) %&gt;_partial/article.ejs 前面一共有三处共用了article模板，另外page和post的一样的，所以实际上只有两种情况:主页(index: true)和非主页(index: false)。对应的_partial/article.ejs里只要判断这个值就可以正确渲染了，基本结构如下： //_partial/article.ejs&lt;% if(index)&#123; %&gt; //index logic...&lt;% &#125;else&#123; %&gt; //post or page logic...&lt;% &#125; %&gt; tag.ejs标签归档页内容很少，直接用Hexo的辅助函数list_tags生成一个标签的列表就ok了: //tag.ejs&lt;%- list_tags() %&gt; 归档页模板和首页差不多，归档页只需要展示文章标题和最后的分页器就好: //archive.ejs&lt;div class=\"archive\"&gt; &lt;% var lastyear; %&gt; &lt;% page.posts.each(function(post)&#123; %&gt; &lt;% var year = post.date.year() %&gt; &lt;% if(lastyear !== year)&#123; %&gt; &lt;h4 class=\"year\"&gt;&lt;%= year %&gt;&lt;/h4&gt; &lt;% lastyear = year %&gt; &lt;% &#125; %&gt; &lt;div class=\"archive_item\"&gt; &lt;a class=\"title\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;span class=\"date\"&gt;&lt;%= post.date.format('YYYY-MM-DD') %&gt;&lt;/span&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;div class=\"pagination\"&gt; &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt; &lt;/div&gt;&lt;/div&gt; 至此，模板文件就写好了，对于category模板就放弃了，感觉比较鸡肋。。。 变量其实在模板文件中我们已经看到了page.post,site.posts.length,config.per_page等等，页面的内容就是根据这些变量获取的，由Hexo提供，拿来直接用，Hexo提供了很多变量，但不是都很常用，一般就用到以下变量: site: 对应整个网站的变量，一般会用到site.posts.length制作分页器 page: 对应当前页面的信息，例如我在index.ejs中使用page.posts获取了当前页面的所有文章而不是使用site.posts。 config: 博客的配置信息，博客根目录下的_config.yml。 theme: 主题的配置信息，对于主题根目录下的_config.yml。 辅助函数(Helper)制作一个分页器，我们需要知道文章的总数和每页展示的文章数，然后通过循环生成每个link标签，还要根据当前页面判断link标签的active状态，但是在Hexo中这些都不用我们自己来做了!Hexo提供了paginator这一辅助函数帮助我们生成分页器，只需要将文章总数site.posts.length和每页文章数config.per_page传入就可以生成了。 其他的Helper: list_tags([options]): 快速生成标签列表 js(path/to/js), css(path/to/css) 用来载入静态资源，path可以是字符串或数组(载入多个资源)，默认会去source文件夹下去找。 partial(path/to/partial) 引用字模板，默认会去layout文件夹下找。 样式知道了Hexo的渲染方式，我们就可以使用HTML标签+CSS样式个性化我们的主题了，推荐大家使用CSS预处理语言的一种来写样式，这样就可以通过预处理语言自身的特点让样式更灵活。 其他添加对多说和Disqus的支持评论是很常用的功能，不如就直接在我们的主题里支持了，然后通过配置变量决定是否开启，评论区跟在文章内容下面，对于这种三方的代码块，最好也以partial的方式提取出来，方便移除或是替换。 //_partial/article.ejs&lt;section class='post-content'&gt; &lt;%- post.content %&gt;&lt;/section&gt;//评论部分，post.comments判断是否开启评论，config.duoshuo_shortname和config.disqus_shortname来判断启用那种评论插件，这里优先判断了多说&lt;% if(post.comments)&#123; %&gt; &lt;section id=\"comments\"&gt; &lt;% if (config.duoshuo_shortname)&#123; %&gt; &lt;%- partial('_partial/duoshuo') %&gt; &lt;% &#125;else if(config.disqus_shortname)&#123; %&gt; &lt;%- partial('_partial/disqus') %&gt; &lt;% &#125; %&gt; &lt;/section&gt;&lt;% &#125; %&gt; 再将多说和Disqus提供的js脚本代码放在_partial/duoshuo.ejs和_partial/disqus.ejs下就ok了~ 使用highlight.js提供代码高亮highlight.js提供了多种语言的支持和多种皮肤，用法也很简单，载入文件后调用初始化方法，一切都帮你搞定，对于使用那种皮肤，喜好因人而异，我们干脆在主题的配置文件中做成配置项让用户自己选择: //showonne/_config.yml...other configs# highlight.jshighlight_theme: zenburn 对应的layout.ejs中: &lt;link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/&lt;%= theme.highlight_theme %&gt;.min.css\"&gt; 样式文件通过CDN引入，因为不同皮肤对应不同的文件名，所以十分灵活。 最后当初是对应着landscape照葫芦画瓢写的，最近回头来发现一些不合理的地方，所以就又改了改，也对应着写了这么一篇总结，接下来准备再把样式划分一下，对于颜色这类样式通过变量的方式提取出来，也变得可配置，能让主题更灵活一些。 参考资源 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/06/hexo-learning1/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"http://agehua.github.io/tags/hexo/"}]},{"title":"Hexo 模板学习——EJS介绍","slug":"hexo-learning0","date":"2016-12-03T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/12/04/hexo-learning0/","link":"","permalink":"http://agehua.github.io/2016/12/04/hexo-learning0/","excerpt":"什么是EJS？EJS是JavaScript模板库，用来从JSON数据中生成HTML字符串 EJS的语法和功能：1、缓存功能，能够缓存已经解析好的html模版2、&lt;% code %&gt;用于执行其中javascript代码。&lt;% alert('hello world') %&gt; 3、&lt;%= code =%&gt;会对code进行html转义；","text":"什么是EJS？EJS是JavaScript模板库，用来从JSON数据中生成HTML字符串 EJS的语法和功能：1、缓存功能，能够缓存已经解析好的html模版2、&lt;% code %&gt;用于执行其中javascript代码。&lt;% alert('hello world') %&gt; 3、&lt;%= code =%&gt;会对code进行html转义； &lt;h1&gt;&lt;%=title %&gt;&lt;/h1&gt; 注：会把title里面存的值给显示出来在h1中。&lt;p&gt;&lt;%= 'hello world' %&gt;&lt;/p&gt; 注：会把hello world显示在h1中。&lt;h1&gt;&lt;%= '&lt;b&gt;hello world&lt;/b&gt;' %&gt;&lt;/h1&gt; 注：会把hello world变粗，然后显示在h1中。~~~ javascript#### 4、&lt;%- code %&gt;将不会进行转义；，这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。~~~ javascript&lt;h1&gt;&lt;%-title %&gt;asd&lt;/h1&gt; 最后显示asd，及显示原网页&lt;p&gt;&lt;%# 'hello world' %&gt;asd&lt;/p&gt; 最后显示asd，及显示原网页 5、支持自定义标签，比如’&lt;%’可以使用’NaN‘代替；ejs 里，默认的闭合标记是 &lt;% .. %&gt;，我们也可以定义自己的标签。例如： app.set(\"view options\",&#123; \"open\":\"&#123;&#123;\", \"close\":\"&#125;&#125;\"&#125;); 6、提供一些辅助函数，用于模版中使用 1)、first，返回数组的第一个元素； 2)、last，返回数组的最后一个元素； 3)、capitalize，返回首字母大写的字符串； 4)、downcase，返回字符串的小写； 5)、upcase，返回字符串的大写； 6)、sort，排序（Object.create(obj).sort()？）； 7)、sort_by:’prop’，按照指定的prop属性进行升序排序； 8)、size，返回长度，即length属性，不一定非是数组才行； 9)、plus:n，加上n，将转化为Number进行运算； 10)、minus:n，减去n，将转化为Number进行运算； 11)、times:n，乘以n，将转化为Number进行运算； 12)、divided_by:n，除以n，将转化为Number进行运算； 13)、join:’val’，将数组用’val’最为分隔符，进行合并成一个字符串； 14)、truncate:n，截取前n个字符，超过长度时，将返回一个副本 15)、truncate_words:n，取得字符串中的前n个word，word以空格进行分割； 16)、replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串； 17)、prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面； 18)、append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面； 19)、map:’prop’，返回对象数组中属性为prop的值组成的数组； 20)、reverse，翻转数组或字符串； 21)、get:’prop’，取得属性为’prop’的值； 22)、json，转化为json格式字符串 利用&lt;%- include filename %&gt;加载其他页面模版； ejs我的总结：ejs 写法： 1.普通传入并使用变量： &lt;%= title %&gt; 2.普通for执行js代码（for中间的代码一定可以执行到）： &lt;% for(var i=0; i&lt;headerNavbar.length; i++) &#123;%&gt; &lt;li&gt;&lt;a href=\"/reg\"&gt;&lt;%= headerNavbar[i].name %&gt;&lt;/a&gt;&lt;/li&gt;&lt;% &#125; %&gt; 3.特殊if语句的js代码（if中间的额代码不一定可以执行到）： &lt;% if(active=='index')&#123;%&gt;class=\"active\" &lt;% &#125;%&gt; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/04/hexo-learning0/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"EJS","slug":"ejs","permalink":"http://agehua.github.io/tags/ejs/"}]},{"title":"nodejs入门","slug":"nodejs-learning-getting-started","date":"2016-12-02T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/12/03/nodejs-learning-getting-started/","link":"","permalink":"http://agehua.github.io/2016/12/03/nodejs-learning-getting-started/","excerpt":"本文是我自己的学习笔记，整理自《Node入门》 Node入门作者： Manuel Kiessling翻译： goddyzhao &amp; GrayZhang &amp; MondayChen 本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。 服务端JavaScriptJavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。 Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。","text":"本文是我自己的学习笔记，整理自《Node入门》 Node入门作者： Manuel Kiessling翻译： goddyzhao &amp; GrayZhang &amp; MondayChen 本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。 服务端JavaScriptJavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。 Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。 要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。 除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。 因此，Node.js事实上既是一个运行时环境，同时又是一个库。 要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考官方的安装指南。安装完成后，继续回来阅读本书下面的内容。 “Hello World”好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。 打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码： console.log(\"Hello World\"); 保存该文件，并通过Node.js来执行：node helloworld.js 正常的话，就会在终端输出Hello World 。 好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。 一个完整的基于Node.js的web应用用例我们来把目标设定得简单点，不过也要够实际才行： 用户可以通过浏览器使用我们的应用。当用户请求http://domain/start 时，可以看到一个欢迎页面，页面上有一个文件上传的表单。用户可以选择一个图片并提交表单，随后文件将被上传到http://domain/upload ，该页面完成上传后会把图片显示在页面上。差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。 更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。 应用不同模块分析我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？ 我们需要提供Web页面，因此需要一个HTTP服务器对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（request handler）当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。 不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。 听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。 现在我们就来开始实现之路，先从第一个部分–HTTP服务器着手。 构建应用的模块一个基础的HTTP服务器当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？ 实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。 这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。 那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。 在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。 让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码： var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888); 搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本： node server.js 接下来，打开浏览器访问http://localhost:8888/ ，你会看到一个写着“Hello World”的网页。 这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。 分析HTTP服务器那么接下来，让我们分析一下这个HTTP服务器的构成。 第一行请求（require）Node.js自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用http模块提供的函数： createServer 。这个函数会返回一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。 咱们暂时先不管 http.createServer 的括号里的那个函数定义。 我们本来可以用这样的代码来启动服务器并侦听8888端口：var http = require(\"http\");var server = http.createServer();server.listen(8888); 这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。 最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 createServer() 的第一个参数，一个函数定义。 实际上，这个函数定义是 createServer() 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。 进行函数传递举例来说，你可以这样做： function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, \"Hello\"); 请仔细阅读这段代码！在这里，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！ 这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。 当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数： function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word)&#123; console.log(word) &#125;, \"Hello\"); 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。 用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 匿名函数 。 这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 函数传递是如何让HTTP服务器工作的带着这些知识，我们再来看看我们简约而不简单的HTTP服务器： var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888); 现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。 用这样的代码也可以达到同样的目的： var http = require(\"http\");function onRequest(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;http.createServer(onRequest).listen(8888); 也许现在我们该问这个问题了：我们为什么要用这种方式呢？ 基于事件驱动的回调这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。 你也许会想花点时间读一下Felix Geisendörfer的大作Understanding node.js，它介绍了一些背景知识。 这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。 当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。 问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。 写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。 那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？ 嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。 我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。 我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。 这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。 至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。 让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个： var http = require(\"http\");function onRequest(request, response) &#123; console.log(\"Request received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;http.createServer(onRequest).listen(8888);console.log(\"Server has started.\"); 注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。 当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问http://localhost:8888/ ），“Request received.”这条消息就会在命令行中出现。 这就是事件驱动的异步服务器端JavaScript和它的回调啦！ （请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分浏览器都会在你访问 http://localhost:8888/ 时尝试读取 http://localhost:8888/favicon.ico ) 服务器是如何处理请求的好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 onRequest() 的主体部分。 当回调启动，我们的 onRequest() 函数被触发的时候，有两个参数被传入： request 和 response 。 它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。 所以我们的代码就是：当收到请求时，使用 response.writeHead() 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 response.write() 函数在HTTP相应主体中发送文本“Hello World”。 最后，我们调用 response.end() 完成响应。 目前来说，我们对请求的细节并不在意，所以我们没有使用 request 对象。 服务端的模块放在哪里 OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 server.js 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 index.js 的文件去调用应用的其他模块（比如 server.js 中的HTTP服务器模块）来引导和启动应用。 我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 index.js 主文件使用。 也许你已经注意到，我们已经在代码中使用了模块了。像这样： var http = require(\"http\");...http.createServer(...); Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。 这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。 给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来： var foo = require(\"http\");...foo.createServer(...); 很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？ 等我们把 server.js 变成一个真正的模块，你就能搞明白了。 事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本。 目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。 我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。 var http = require(\"http\");function start() &#123; function onRequest(request, response) &#123; console.log(\"Request received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。 创建 index.js 文件并写入以下内容： var server = require(\"./server\");server.start(); 正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。 好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子： node index.js 非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。 我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。 对于一个非常简单的应用来说，你可以直接在回调函数 onRequest() 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。 处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做路由的模块吧。 如何来进行请求的“路由”我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。 因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。 我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。 url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring(string)[\"foo\"] | | querystring(string)[\"hello\"] 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。 现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径： var http = require(\"http\");var url = require(\"url\");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。 在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。 现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容： function route(pathname) &#123; console.log(\"About to route a request for \" + pathname);&#125;exports.route = route; 如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。 我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读Martin Fowlers关于依赖注入的大作来作为背景知识）。 首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去： var http = require(\"http\");var url = require(\"url\");function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(pathname); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：var server = require(\"./server\");var router = require(\"./router\");server.start(router.route); 在这里，我们传递的函数依旧什么也没做。 如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由： bash$ node index.jsRequest for /foo received.About to route a request for /foo （以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。 行为驱动执行请允许我再次脱离主题，在这里谈一谈函数式编程。 将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。 就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。 嗨那个叫路由的东西，能帮我把这个路由一下吗？ 但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。 理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。 我是在读了Steve Yegge的大作名词王国中的死刑之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。 路由给真正的请求处理程序回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。 当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。 在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。 我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。 应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出： function start() &#123; console.log(\"Request handler 'start' was called.\");&#125;function upload() &#123; console.log(\"Request handler 'upload' was called.\");&#125;exports.start = start;exports.upload = upload; 这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。 在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。 这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。 那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆if request == x then call handler y也使得系统丑陋不堪。 仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎关联数组（associative array） 能完美胜任。 不过结果有点令人失望，JavaScript没提供关联数组 – 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。 在这方面，http://msdn.microsoft.com/en-us/magazine/cc163419.aspx 有一个不错的介绍，我在此摘录一段： 在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 – 你可以把JavaScript的对象想象成一个键为字符串类型的字典。 但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！ 好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。 我们先将这个对象引入到主文件index.js中： var server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = &#123;&#125;handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;server.start(router.route, handle); 虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。 正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为”/“的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。 在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(handle, pathname); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。 然后我们相应地在route.js文件中修改route()函数： function route(handle, pathname) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; handle[pathname](); &#125; else &#123; console.log(\"No request handler found for \" + pathname); &#125;&#125;exports.route = route; 通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handlepathname;的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。 有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序： Server has started.Request for /start received.About to route a request for /startRequest handler 'start' was called. 并且在浏览器中打开http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了： Request for / received.About to route a request for /Request handler 'start' was called. 让请求处理程序作出响应很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。 这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们server.js文件中的onRequest函数。 其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。 不好的实现方式对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。 这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。 我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。 让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式： function start() &#123; console.log(\"Request handler 'start' was called.\"); return \"Hello Start\";&#125;function upload() &#123; console.log(\"Request handler 'upload' was called.\"); return \"Hello Upload\";&#125;exports.start = start;exports.upload = upload; 好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式： function route(handle, pathname) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; return handle[pathname](); &#125; else &#123; console.log(\"No request handler found for \" + pathname); return \"404 Not found\"; &#125;&#125;exports.route = route; 正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。 最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); var content = route(handle, pathname) response.write(content); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 如果我们运行重构后的应用，一切都会工作的很好：请求http://localhost:8888/start, 浏览器会输出“Hello Start”，请求http://localhost:8888/upload 会输出“Hello Upload”,而请求http://localhost:8888/foo 会输出“404 Not found”。 好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。 没理解？没关系，下面就来详细解释下。 阻塞与非阻塞正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。 我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。 这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。 让我们将requestHandlers.js修改成如下形式： function start() &#123; console.log(\"Request handler 'start' was called.\"); function sleep(milliSeconds) &#123; var startTime = new Date().getTime(); while (new Date().getTime() &lt; startTime + milliSeconds); &#125; sleep(10000); return \"Hello Start\";&#125;function upload() &#123; console.log(\"Request handler 'upload' was called.\"); return \"Hello Upload\";&#125;exports.start = start;exports.upload = upload; 上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。 （当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。） 接下来就让我们来看看，我们的改动带来了哪些变化。 如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入http://localhost:8888/start， 但是先不要打开它！ 在第二个浏览器窗口的地址栏中输入http://localhost:8888/upload， 同样的，先不要打开它！ 接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。 注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！ 这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。 这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。 这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。 然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。 对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！” （如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——理解node.js的事件轮询。） 接下来，我们会介绍一种错误的使用非阻塞操作的方式。 和上次一样，我们通过修改我们的应用来暴露问题。 这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式： var exec = require(\"child_process\").exec;function start() &#123; console.log(\"Request handler 'start' was called.\"); var content = \"empty\"; exec(\"ls -lah\", function (error, stdout, stderr) &#123; content = stdout; &#125;); return content;&#125;function upload() &#123; console.log(\"Request handler 'upload' was called.\"); return \"Hello Upload\";&#125;exports.start = start;exports.upload = upload; 上述代码中，我们引入了一个新的Node.js模块，child_process。之所以用它，是为了实现一个既简单又实用的非阻塞操作：exec()。 exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。 上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。 和往常一样，我们启动服务器，然后访问“http://localhost:8888/start” 。 之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？ 这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。 （如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。 然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？ 好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。 问题就在于，为了进行非阻塞工作，exec()使用了回调函数。 在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数： function (error, stdout, stderr) &#123; content = stdout;&#125; 现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。 我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。 为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。 那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？ 好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。 以非阻塞操作进行请求响应我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。 不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。 到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。 现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。 原理就是如此，接下来让我们来一步步实现这种方案。 先从server.js开始： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(handle, pathname, response); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。 下面就来看看我们的router.js: function route(handle, pathname, response) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; handle[pathname](response); &#125; else &#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; 同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。 如果没有对应的请求处理器处理，我们就直接返回“404”错误。 最后，我们将requestHandler.js修改为如下形式： var exec = require(\"child_process\").exec;function start(response) &#123; console.log(\"Request handler 'start' was called.\"); exec(\"ls -lah\", function (error, stdout, stderr) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(stdout); response.end(); &#125;);&#125;function upload(response) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello Upload\"); response.end();&#125;exports.start = start;exports.upload = upload; 我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。 start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。 这时再次我们启动应用（node index.js），一切都会工作的很好。 如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式： var exec = require(\"child_process\").exec;function start(response) &#123; console.log(\"Request handler 'start' was called.\"); exec(\"find /\", &#123; timeout: 10000, maxBuffer: 20000*1024 &#125;, function (error, stdout, stderr) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(stdout); response.end(); &#125;);&#125;function upload(response) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello Upload\"); response.end();&#125;exports.start = start;exports.upload = upload; 这样一来，当请求http://localhost:8888/start 的时候，会花10秒钟的时间才载入，而当请求http://localhost:8888/upload 的时候，会立即响应，纵然这个时候/start响应还在处理中。 更有用的场景到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。 服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。 好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。 要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。 第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。 处理POST请求考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。 /start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式： function start(response) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" method=\"post\"&gt;'+ '&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'+ '&lt;input type=\"submit\" value=\"Submit text\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello Upload\"); response.end();&#125;exports.start = start;exports.upload = upload; 好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问http://localhost:8888/start 就可以看到简单的表单了，要记得重启服务器哦！ 你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。 余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。 现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。 这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。 为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。 我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。 如下所示： request.addListener(\"data\", function(chunk) &#123; // called when a new chunk of data was received&#125;);request.addListener(\"end\", function() &#123; // called when all chunks of data have been received&#125;); 问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。 在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。 因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。 还等什么，马上来实现。先从server.js开始： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var postData = \"\"; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); request.setEncoding(\"utf8\"); request.addListener(\"data\", function(postDataChunk) &#123; postData += postDataChunk; console.log(\"Received POST data chunk '\"+ postDataChunk + \"'.\"); &#125;); request.addListener(\"end\", function() &#123; route(handle, pathname, response, postData); &#125;); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。 上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。 我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。 再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式： function route(handle, pathname, response, postData) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; handle[pathname](response, postData); &#125; else &#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; 然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中： function start(response, postData) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" method=\"post\"&gt;'+ '&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'+ '&lt;input type=\"submit\" value=\"Submit text\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, postData) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"You've sent: \" + postData); response.end();&#125;exports.start = start;exports.upload = upload; 好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。 我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。 我们可以使用此前介绍过的querystring模块来实现： var querystring = require(\"querystring\");function start(response, postData) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" method=\"post\"&gt;'+ '&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'+ '&lt;input type=\"submit\" value=\"Submit text\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, postData) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"You've sent the text: \"+ querystring.parse(postData).text); response.end();&#125;exports.start = start;exports.upload = upload; 好了，以上就是关于处理POST数据的全部内容。 处理文件上传最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。 回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。 这里我们要用到的外部模块是Felix Geisendörfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。 使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装： npm install formidable 如果终端输出如下内容： npm info build Success: formidable@1.0.9npm ok 就说明模块已经安装成功了。 现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可： var formidable = require(\"formidable\"); 这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。 node-formidable官方的例子展示了这两部分是如何融合在一起工作的： var formidable = require('formidable'), http = require('http'), util = require('util');http.createServer(function(req, res) &#123; if (req.url == '/upload' &amp;&amp; req.method.toLowerCase() == 'post') &#123; // parse a file upload var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) &#123; res.writeHead(200, &#123;'content-type': 'text/plain'&#125;); res.write('received upload:\\n\\n'); res.end(util.inspect(&#123;fields: fields, files: files&#125;)); &#125;); return; &#125; // show a file upload form res.writeHead(200, &#123;'content-type': 'text/html'&#125;); res.end( '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"text\" name=\"title\"&gt;&lt;br&gt;'+ '&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;&lt;br&gt;'+ '&lt;input type=\"submit\" value=\"Upload\"&gt;'+ '&lt;/form&gt;' );&#125;).listen(8888); 如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示： received upload:&#123; fields: &#123; title: 'Hello World' &#125;, files: &#123; upload: &#123; size: 1558, path: '/tmp/1c747974a27a6292743669e91f29350b', name: 'us-flag.png', type: 'image/png', lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT, _writeStream: [Object], length: [Getter], filename: [Getter], mime: [Getter] &#125; &#125; &#125; 为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。 我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？ 显然，我们需要将该文件读取到我们的服务器中，使用一个叫fs的模块。 我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。 将requestHandlers.js修改为如下形式： var querystring = require(\"querystring\"), fs = require(\"fs\");function start(response, postData) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" '+ 'content=\"text/html; charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" method=\"post\"&gt;'+ '&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'+ '&lt;input type=\"submit\" value=\"Submit text\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, postData) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"You've sent the text: \"+ querystring.parse(postData).text); response.end();&#125;function show(response, postData) &#123; console.log(\"Request handler 'show' was called.\"); fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) &#123; if(error) &#123; response.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(error + \"\\n\"); response.end(); &#125; else &#123; response.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); response.write(file, \"binary\"); response.end(); &#125; &#125;);&#125;exports.start = start;exports.upload = upload;exports.show = show; 我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中： var server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = &#123;&#125;handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;handle[\"/show\"] = requestHandlers.show;server.start(router.route, handle); 重启服务器之后，通过访问http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。 好，最后我们要的就是： 在/start表单中添加一个文件上传元素 将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png 将上传的图片内嵌到/uploadURL输出的HTML中 第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示： var querystring = require(\"querystring\"), fs = require(\"fs\");function start(response, postData) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" '+ 'content=\"text/html; charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"file\" name=\"upload\"&gt;'+ '&lt;input type=\"submit\" value=\"Upload file\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, postData) &#123; console.log(\"Request handler 'upload' was called.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"You've sent the text: \"+ querystring.parse(postData).text); response.end();&#125;function show(response, postData) &#123; console.log(\"Request handler 'show' was called.\"); fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) &#123; if(error) &#123; response.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(error + \"\\n\"); response.end(); &#125; else &#123; response.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); response.write(file, \"binary\"); response.end(); &#125; &#125;);&#125;exports.start = start;exports.upload = upload;exports.show = show; 很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。 但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。 到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存） 我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式： var http = require(\"http\");var url = require(\"url\");function start(route, handle) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(handle, pathname, response, request); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象： function route(handle, pathname, response, request) &#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === 'function') &#123; handle[pathname](response, request); &#125; else &#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; 现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。 这里采用fs.renameSync(path1,path2)来实现。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。 接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示： var querystring = require(\"querystring\"), fs = require(\"fs\"), formidable = require(\"formidable\");function start(response) &#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '+ 'charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;'+ '&lt;input type=\"submit\" value=\"Upload file\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(body); response.end();&#125;function upload(response, request) &#123; console.log(\"Request handler 'upload' was called.\"); var form = new formidable.IncomingForm(); console.log(\"about to parse\"); form.parse(request, function(error, fields, files) &#123; console.log(\"parsing done\"); fs.renameSync(files.upload.path, \"/tmp/test.png\"); response.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); response.write(\"received image:&lt;br/&gt;\"); response.write(\"&lt;img src='/show' /&gt;\"); response.end(); &#125;);&#125;function show(response) &#123; console.log(\"Request handler 'show' was called.\"); fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) &#123; if(error) &#123; response.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(error + \"\\n\"); response.end(); &#125; else &#123; response.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); response.write(file, \"binary\"); response.end(); &#125; &#125;);&#125;exports.start = start;exports.upload = upload;exports.show = show; 好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。 总结与展望恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。 当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。 但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/12/03/nodejs-learning-getting-started/","categories":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/categories/read/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://agehua.github.io/tags/nodejs/"}]},{"title":"JAVA泛型通配符T，E，K，V区别，T以及Class<T>，Class<?>的区别","slug":"Difference_between-T-E-K-V","date":"2016-11-20T16:00:00.000Z","updated":"2017-03-28T01:18:38.000Z","comments":true,"path":"2016/11/21/Difference_between-T-E-K-V/","link":"","permalink":"http://agehua.github.io/2016/11/21/Difference_between-T-E-K-V/","excerpt":"文章转载自《JAVA泛型通配符T，E，K，V区别，T以及Class，Class&lt;?&gt;的区别》 1. 先解释下泛型概念泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。Java语言引入泛型的好处是安全简单。 在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。","text":"文章转载自《JAVA泛型通配符T，E，K，V区别，T以及Class，Class&lt;?&gt;的区别》 1. 先解释下泛型概念泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。Java语言引入泛型的好处是安全简单。 在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。 泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。 以上内容摘自百度百科 举个栗子:Box类定义为一个泛型类public class Box&lt;T&gt; &#123; private T object; public void set(T object) &#123; this.object = object; &#125; public T get() &#123; return object; &#125;&#125; 创建一个Box对象，不带泛型参数，发现获取对象的时候需要强制转换 Box box2 = new Box();box2.set(new Apple());Apple apple = (Apple) box2.get(); 创建一个Box对象，带泛型参数，获取对象的时候就不需要强制转换 Box&lt;Apple&gt; box = new Box&lt;Apple&gt;();box.set(new Apple());Apple apple = box.get(); 总结下泛型的好处就是： 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上 但是我们定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符T，E，K，V等等，这些通配符又都是什么意思呢？继续往下看 2. 下来说说泛型通配符T，E，K，V区别这些全都属于java泛型的通配符，刚开始我看到这么多通配符，一下晕了，这几个其实没什么区别，只不过是一个约定好的代码，也就是说使用大写字母A,B,C,D……X,Y,Z定义的，就都是泛型，把T换成A也一样，这里T只是名字上的意义而已 ？ 表示不确定的java类型 T (type) 表示具体的一个java类型 K V (key value) 分别代表java键值中的Key Value E (element) 代表Element 举个栗子：public class Test&lt;T&gt; &#123; public List&lt;T&gt; list = new ArrayList&lt;T&gt;(); public static void main(String[] args) &#123; Test&lt;String&gt; test = new Test&lt;String&gt;(); test.list.add(\"hello\"); System.out.println(test.list);&#125;&#125; 和public class Test&lt;A&gt; &#123; public List&lt;A&gt; list = new ArrayList&lt;A&gt;(); public static void main(String[] args) &#123; Test&lt;String&gt; test = new Test&lt;String&gt;(); test.list.add(\"hello\"); System.out.println(test.list);&#125;&#125; 将T换成了A，在执行效果上是没有任何区别的，只不过我们约定好了T代表type，所以还是按照约定规范来比较好，增加了代码的可读性。 如果要定义多个泛型参数，比如说两个泛型参数，很典型的一个栗子是Map的key,value泛型，我们也可以定义一个这样的public interface Mymap&lt;K, V&gt; &#123; public K getKey(); public V getValue();&#125;public class MymapImpl&lt;K, V&gt; implements Mymap&lt;K, V&gt; &#123; private K key; private V value; public MymapImpl(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125;&#125; 下来就可以传入任意类型，创建实例了，不用转化类型Mymap&lt;String, Integer&gt; mp1= new MymapImpl&lt;String, Integer&gt;(\"Even\", 8);Mymap&lt;String, String&gt; mp2= new MymapImpl&lt;String, String&gt;(\"hello\", \"world\");Mymap&lt;Integer, Integer&gt; mp3= new MymapImpl&lt;Integer, Integer&gt;(888, 888); 如果要定义超过两个，三个或三个以上的泛型参数可以使用T1, T2, …, Tn，像这样子public class Test&lt;T1,T2,T3&gt; &#123; public void print(T1 t1,T2 t2,T3 t3)&#123; System.out.println(t1.getClass()); System.out.println(t2.getClass()); System.out.println(t3.getClass()); &#125;&#125; 3. 下来说说T，Class，Class&lt;?&gt;区别T是一种具体的类，例如String,List,Map……等等，这些都是属于具体的类，这个比较好理解 Class是什么呢，Class也是一个类，但Class是存放上面String,List,Map……类信息的一个类，有点抽象，我们一步一步来看 。 如何获取到Class类呢，有三种方式： 调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。例如：List list = null;Class clazz = list.getClass(); 使用Class类的中静态forName()方法获得与字符串对应的Class对象。例如： Class clazz = Class.forName(\"com.lyang.demo.fanxing.People\"); 3.获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。Class clazz = List.class; 那么问题来了？Class类是创建出来了，但是Class和Class&lt;?&gt;适用于什么时候呢？？？ 使用Class和Class&lt;?&gt;多发生在反射场景下，先看看如果我们不使用泛型，反射创建一个类是什么样的。People people = (People) Class.forName(\"com.lyang.demo.fanxing.People\").newInstance(); 看到了么，需要强转，如果反射的类型不是People类，就会报java.lang.ClassCastException错误。 使用Class泛型后，不用强转了public class Test &#123; public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws IllegalAccessException, InstantiationException &#123; return clazz.newInstance(); &#125; public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123; Fruit fruit= createInstance(Fruit .class); People people= createInstance(People.class); &#125;&#125; 那Class和Class&lt;?&gt;有什么区别呢？ Class在实例化的时候，T要替换成具体类 Class&lt;?&gt;它是个通配泛型，?可以代表任何类型，主要用于声明时的限制情况 例如可以声明一个public Class&lt;?&gt; clazz; 但是你不能声明一个public Class&lt;T&gt; clazz; 因为T需要指定类型 所以当不知道定声明什么类型的Class的时候可以定义一个Class&lt;?&gt;,Class&lt;?&gt;可以用于参数类型定义，方法返回值定义等。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/11/21/Difference_between-T-E-K-V/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"svn server","slug":"svn-server","permalink":"http://agehua.github.io/tags/svn-server/"}]},{"title":"Hexo 出错情况收集","slug":"hexo-mac-module-not-found","date":"2016-11-02T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/11/03/hexo-mac-module-not-found/","link":"","permalink":"http://agehua.github.io/2016/11/03/hexo-mac-module-not-found/","excerpt":"Error: Cannot find module ‘./build/Release/DTraceProviderBindings’我在更新hexo，准备安装别的module时，不小心按到了 ctrl+c，结果发现使用hexo命令会报如下错误：&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; &#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;","text":"Error: Cannot find module ‘./build/Release/DTraceProviderBindings’我在更新hexo，准备安装别的module时，不小心按到了 ctrl+c，结果发现使用hexo命令会报如下错误：&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; &#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; 网上一大堆的解决办法都不好用，这里特别记录下我找到的一个解决办法，亲测可用 1. 重新安装Hexo，需要手动删除隐藏的hexo文件 需要删除 /usr/local/lib/node_modules/ 目录下的hexo文件夹 /usr/local/bin/ 下的hexo文件. 直接删掉就好了. 注意这两个都是隐藏文件，要想在finder中显示隐藏文件，需要在Terminal中执行：defaults write com.apple.finder AppleShowAllFiles -bool true 2. 重新执行命令：npm install -g hexo –save 这样就可以了 :) 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/11/03/hexo-mac-module-not-found/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"http://agehua.github.io/tags/hexo/"}]},{"title":"gradle 学习2——生成指定文件名的apk","slug":"gradle-learning2","date":"2016-10-12T16:00:00.000Z","updated":"2017-03-08T07:56:18.000Z","comments":true,"path":"2016/10/13/gradle-learning2/","link":"","permalink":"http://agehua.github.io/2016/10/13/gradle-learning2/","excerpt":"上一篇Gradle学习了解了Gradle的基本结构和依赖关系，这篇文章介绍下怎么在Android上使用Gradle生成指定包名的APK 需求场景在我们Android开发基本进入测试阶段后，会根据后台的不同环境，打包出对应不同环境（如SIT、UAT、PRD等）的APK安装包。 每次去手动修改Java类改变后台环境太麻烦还容易忘记修改。打包成功后，还需要手动将默认的包名app-release.apk改成我们需要的包名，也是非常麻烦，有没有直接指定环境，生成指定文件名的安装包呢？ 方法是有的，就是利用gradle的分渠道打包特性，下面上代码分别解释。 主要在这两个个地方修改： buildType（构建类型） productFlavors （不同定制的产品）","text":"上一篇Gradle学习了解了Gradle的基本结构和依赖关系，这篇文章介绍下怎么在Android上使用Gradle生成指定包名的APK 需求场景在我们Android开发基本进入测试阶段后，会根据后台的不同环境，打包出对应不同环境（如SIT、UAT、PRD等）的APK安装包。 每次去手动修改Java类改变后台环境太麻烦还容易忘记修改。打包成功后，还需要手动将默认的包名app-release.apk改成我们需要的包名，也是非常麻烦，有没有直接指定环境，生成指定文件名的安装包呢？ 方法是有的，就是利用gradle的分渠道打包特性，下面上代码分别解释。 主要在这两个个地方修改： buildType（构建类型） productFlavors （不同定制的产品） buildType（构建类型）介绍默认情况下，Android Plugin会自动给项目设置同时构建应用程序的debug和release版本。 两个版本之间的不同主要围绕着能否在一个安全设备上调试，以及APK如何签名。 可以创建一个新的构建类型就是简单的在buildType标签下添加一个新的元素，并且可以使用initWith()或者直接使用闭包来配置它。 以下是一些可能使用到的属性和默认值： Property name Default values for debug Default values for release / other debuggable true false jniDebugBuild false false renderscriptDebugBuild false false renderscriptOptimLevel 3 3 applicationIdSuffix null null versionNameSuffix null null signingConfig android.signingConfigs.debug null zipAlign false true runProguard false false proguardFile N/A (set only) N/A (set only) proguardFiles N/A (set only) N/A (set only) 上面介绍摘选自Gralde plugin User Guide 中文版 Product flavors（不同定制的产品）介绍一个product flavor定义了从项目中构建了一个应用的自定义版本。一个单一的项目可以同时定义多个不同的flavor来改变应用的输出。 这个新的设计概念是为了解决不同的版本之间的差异非常小的情况。虽然最项目终生成了多个定制的版本，但是它们本质上都是同一个应用，那么这种做法可能是比使用库项目更好的实现方式。 Product flavor需要在productFlavors这个DSL容器中声明： android &#123; .... productFlavors &#123; flavor1 &#123; ... &#125; flavor2 &#123; ... &#125; &#125;&#125; 这里创建了两个flavor，名为flavor1和flavor2。 注意：flavor的命名不能与已存在的Build Type或者androidTest这个sourceSet有冲突。 Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）正如前面章节所提到的，每一个Build Type都会生成一个新的APK。 Product Flavor同样也会做这些事情：项目的输出将会拼接所有可能的Build Type和Product Flavor（如果有Flavor定义存在的话）的组合。 每一种组合（包含Build Type和Product Flavor）就是一个Build Variant（构建变种版本）。 例如，在上面的Flavor声明例子中与默认的debug和release两个Build Type将会生成4个Build Variant： Flavor1 - debug Flavor1 - release Flavor2 - debug Flavor2 - release 项目中如果没有定义flavor同样也会有Build Variant，只是使用的是默认的flavor和配置。default(默认)的flavor/config是没有名字的，所以生成的Build Variant列表看起来就跟Build Type列表一样。 具体使用我们的需求就要用到Build Type和Product Flavor我在项目中Build Type的使用，先看代码： buildTypes &#123; release &#123; buildConfigField \"boolean\", \"LEO_DEBUG\", \"false\" minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' debuggable false jniDebuggable false &#125; debug &#123; buildConfigField \"int\", \"buildType\", \"2\" buildConfigField \"boolean\", \"LEO_DEBUG\", \"true\" &#125; &#125; 和Product Flavor的使用 productFlavors&#123; kaifa&#123; buildConfigField \"int\", \"buildType\", \"1\" &#125; ceshi &#123; buildConfigField \"int\", \"buildType\", \"2\" &#125; SIT &#123; buildConfigField \"int\", \"buildType\", \"3\" &#125; UAT &#123; buildConfigField \"int\", \"buildType\", \"4\" &#125; PRD &#123; buildConfigField \"int\", \"buildType\", \"5\" &#125;&#125; 每一个构建过的productFlavors都会在app-&gt;build-&gt;generated-&gt;source-&gt;buildConfig目录下创建自己对应的一个flavor目录，如下图： 而，buildConfigField会在指定的目录，flavor-&gt;release/debug-&gt;包名，下生成一个BuildConfig.java文件，我的代码在BuildConfig.java中定义了一个int类型的buildType和boolean类型的LEO_DEBUG。要使用这两个字段只需要: if (BuildConfig.LEO_DEBUG)&#123; //用来控制本地Log日志&#125;if (Environment ==BuildConfig.buildType)&#123; //用来控制开发环境&#125; gradle中修改apk生成名字的方法这个方法是定义在productFlavors同一层级的 android.applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; //这里修改apk文件名 def flavorname =variant.productFlavors[0].name if (flavorname.equals('kaifa')) flavorname = 'debug' else if (flavorname.equals('ceshi')) flavorname = 'release' def fileName = \"app-$&#123;flavorname&#125;-$&#123;defaultConfig.versionName&#125;-$&#123;releaseTime() &#125;.apk\" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; 这个方法要定义在最外层def releaseTime() &#123; return new Date().format(\"MMdd\", TimeZone.getTimeZone(\"UTC\"))&#125; 最后生成的apk名字 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/10/13/gradle-learning2/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://agehua.github.io/tags/gradle/"}]},{"title":"gradle 学习","slug":"gradle-learning","date":"2016-10-11T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/10/12/gradle-learning/","link":"","permalink":"http://agehua.github.io/2016/10/12/gradle-learning/","excerpt":"Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库 Gradle的基本组成 项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。","text":"Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库 Gradle的基本组成 项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。 项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。 任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。 每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试） 一个工程的Build，是由多个Project组成，而一个Project又是由task组成的 任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。 Gradle构建系统的组成Gradle的构建系统是由以下几个文件组成 build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的 settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的 gradle.properties 用来配置构建属性，这个不是必须的 Gradle插件Gradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 apply plugin: ‘java’ 这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task: 1.gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等 2.gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试 3.gradle clean：删除 build 生成的目录和所有生成的文件 4.gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs Gradle各个task的关系图： 从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。 外部依赖通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。 首先，指定maven的仓库地址： repositories &#123; mavenCentral()&#125; mavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。 dependencies &#123; compile group: 'commons-collections', name: 'commons-collections', version: '3.2' // 简化写法 // compile 'commons-collections:commons-collections:3.2'&#125; 引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。 本地依赖Gradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包 dependencies &#123; compile files('dir/file.jar') compile fileTree(dir: 'libs', include: '*.jar')&#125; 项目依赖往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。 include 'sub-project1', 'sub-project2', 'sub-project3' 如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可： dependencies &#123; compile project(':sub-project2')&#125; 依赖关系管理从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。 例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如： apply plugin: 'java'repositories &#123; mavenCentral()&#125;dependencies &#123; compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final' testCompile group: 'junit', name: 'junit', version: '4.+'&#125; 在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活 Java 插件中定义了许多标准的配置，例如如下： compile 用来编译项目源代码的 runtime 在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。 testCompile 编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。 testRuntime 运行测试所需要的依赖。 默认的, 包含上面三个依赖。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/10/12/gradle-learning/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://agehua.github.io/tags/gradle/"}]},{"title":"Android面试知识点整理","slug":"Android-interview-questions","date":"2016-09-27T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/09/28/Android-interview-questions/","link":"","permalink":"http://agehua.github.io/2016/09/28/Android-interview-questions/","excerpt":"只整理android面试中涉及到的知识点。不断补充中。。。 1.Android事件传递机制下面内容摘选自《Android开发艺术探索》 (1) 当一个点击事件发生之后，传递过程遵循如下顺序：Activity -&gt; Window -&gt; View。如果一个view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent方法将会被调用，依此类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理(调用Activity的onTouchEvent方法)。","text":"只整理android面试中涉及到的知识点。不断补充中。。。 1.Android事件传递机制下面内容摘选自《Android开发艺术探索》 (1) 当一个点击事件发生之后，传递过程遵循如下顺序：Activity -&gt; Window -&gt; View。如果一个view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent方法将会被调用，依此类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理(调用Activity的onTouchEvent方法)。 (2) 正常情况下，一个事件序列只能被一个view拦截并消耗，因为一旦某个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，并且该元素的onInterceptTouchEvent方法不会再被调用了。 (3) 某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，并且事件将重新交给它的父容器去处理(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，当前view依然可以收到后续的事件，但是这些事件最后都会传递给Activity处理。 (4) ViewGroup默认不拦截任何事件，因为它的onInterceptTouchEvent方法默认返回false。view没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。 (5) View的onTouchEvent默认都会消耗事件(返回true)，除非它是不可点击的(clickable和longClickable都为false)。view的longClickable默认是false的，clickable则不一定，Button默认是true，而TextView默认是false。 (6) View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。 (7) 事件传递过程总是先传递给父元素，然后再由父元素分发给子view，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外，即当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。ViewGroup的dispatchTouchEvent方法中有一个标志位FLAG_DISALLOW_INTERCEPT，这个标志位就是通过子view调用requestDisallowInterceptTouchEvent方法来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。 (8) 以上结论均可以在书中的源码解析部分得到解释。Window的实现类为PhoneWindow，获取Activity的contentView的方法 ((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); 2.OnTouchListener、onTouchEvent、OnClickListener优先级顺序如果给一个view设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，那么当前view的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。在onTouchEvent方法中，如果当前view设置了OnClickListener，那么它的onClick方法会被调用，所以OnClickListener的优先级最低。 3.AsyncTask的方法介绍4.项目中Handler怎么使用？5.项目中图片的适配问题怎么解决？6.Android存储敏感信息的方式有？7.自定义广播 继承自BroadcastReceiver 重写onReceive(Context,Intent)Intent.getAction 动态注册（Context.registerReceiver()），静态注册（使用IntentFilter指定action） 8.加分项 JNI开发 性能优化 优秀作品 9.Sqlite数据库更新并保留升级前的数据我们知道在SQLiteOpenHelper的构造方法: super(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) 中最后一个参数表示数据库的版本号.当新的版本号大于当前的version时会调用方法: onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) 所以我们的重点是在该方法中实现SQLite数据库版本升级的管理 对于保留升级前的数据，有两种解决办法： SQLite提供了ALTER TABLE命令，允许用户重命名或添加新的字段到已有表中，但是不能从表中删除字段。并且只能在表的末尾添加字段，比如，为Subscription添加两个字段： ALTER TABLE Subscription ADD COLUMN Activation BLOB; ALTER TABLE Subscription ADD COLUMN Key BLOB; 注释：Sqlite支持BLOB(二进制大对象)数据类型 保留数据删除原表创建新表，具体思路是： 1：将表A重新命名：例如重新命名为：temp_A 2：创建新表A 3：将temp_A中的数据【也就是更新前的数据】插入到新表A 具体操作如下： //重命名原来的数据表public static final String TEMP_SQL_CREATE_TABLE_SUBSCRIBE = \"alter table \" + A + \" rename to temp_A\";//然后把备份表temp_A中的数据copy到新创建的数据库表A中，这个表A没发生结构上的变化public static final String INSERT_SUBSCRIBE = \"select 'insert into A (code,name,username,tablename) values (\"code\",\"name\",\"cnki\",\"tablename\")' as insertSQL from temp_A\";//删除备份表public static final String DELETE_TEMP_SUBSCRIBE = \"delete from temp_A \";public static final String DROP_TEMP_SUBSCRIBE = \"drop table if exists temp_A\";@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; for (int j = oldVersion; j &lt;= newVersion; j++) &#123; switch (j) &#123; case 2: //创建临时表 db.execSQL(TEMP_SQL_CREATE_TABLE_SUBSCRIBE); //执行OnCreate方法，这个方法中放的是表的初始化操作工作，比如创建新表之类的 onCreate(db); //删除之前的表里面的默认数据 for (int i = 0; i &lt; arrWhereAct.length; i++) &#123; db.execSQL(DELETE_TEMP_SUBSCRIBE + arrWhereAct[i]); &#125; //将临时表中的数据放入表A Cursor cursor = db.rawQuery(INSERT_SUBSCRIBE, null); if (cursor.moveToFirst()) &#123; do &#123; db.execSQL(cursor.getString(cursor .getColumnIndex(\"insertSQL\"))); &#125; while (cursor.moveToNext()); &#125; cursor.close(); //将临时表删除掉 db.execSQL(DROP_TEMP_SUBSCRIBE); break; default: break; &#125; &#125;&#125; 注意，为什么要在方法里写for循环，主要是考虑到跨版本升级，比如有的用户一直不升级版本，数据库版本号一直是1，而客户端最新版本其实对应的数据库版本已经是4了，那么我中途可能对数据库做了很多修改，通过这个for循环，可以迭代升级，不会发生错误。 10.AIDL支持的数据类型其实AIDL这门语言非常的简单，基本上它的语法和 Java 是一样的，只是在一些细微处有些许差别——毕竟它只是被创造出来简化Android程序员工作的，太复杂不好——所以在这里我就着重的说一下它和 Java 不一样的地方。主要有下面这些点： 文件类型：用AIDL书写的文件的后缀是 .aidl，而不是 .java。 数据类型：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，就算目标文件与当前正在编写的 .aidl 文件在同一个包下——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文件，一个叫做Book.java ，另一个叫做 BookManager.aidl，它们都在 com.lypeer.aidldemo 包下 ，现在我们需要在 .aidl 文件里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 import com.lypeer.aidldemo.Book; 哪怕 .java 文件和 .aidl 文件就在一个包下。 默认支持的数据类型包括： Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char。 String 类型。 CharSequence类型。 List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable（下文关于这个会有详解）。List可以使用泛型。 Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的。 定向tag：这是一个极易被忽略的点——这里的“被忽略”指的不是大家都不知道，而是很少人会正确的使用它。在我的理解里，定向tag是这样的：AIDL中的定向tag表示了在跨进程通信中数据的流向，其中in表示数据只能由客户端流向服务端，out表示数据只能由服务端流向客户端，而inout则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。in为定向tag的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；out的话表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；inout为定向tag的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。 另外，Java 中的基本类型和String，CharSequence的定向tag默认且只能是in。还有，请注意，请不要滥用定向tag，而是要根据需要选取合适的——要是不管三七二十一，全都一上来就用inout，等工程大了系统的开销就会大很多——因为排列整理参数的开销是很昂贵的。 两种AIDL文件：在我的理解里，所有的AIDL文件大致可以分为两类。一类是用来定义parcelable对象，以供其他AIDL文件使用AIDL中非默认支持的数据类型的。一类是用来定义方法接口，以供系统使用来完成跨进程通信的。可以看到，两类文件都是在“定义”些什么，而不涉及具体的实现，这就是为什么它叫做“Android接口定义语言”。注：所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。 下面是两个例子，对于常见的AIDL文件都有所涉及： // Book.aidl//第一类AIDL文件的例子//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用//注意：Book.aidl与Book.java的包名应当是一样的package com.lypeer.ipcclient;//注意parcelable是小写parcelable Book;// BookManager.aidl//第二类AIDL文件的例子package com.lypeer.ipcclient;//导入所需要使用的非默认支持数据类型的包import com.lypeer.ipcclient.Book;interface BookManager &#123; //所有的返回值前都不需要加任何东西，不管是什么数据类型 List&lt;Book&gt; getBooks(); Book getBook(); int getBookCount(); //传参时除了Java基本类型以及String，CharSequence之外的类型 //都需要在前面加上定向tag，具体加什么量需而定 void setBookPrice(in Book book , int price) void setBookName(in Book book , String name) void addBookIn(in Book book); void addBookOut(out Book book); void addBookInout(inout Book book);&#125; 11.Android布局的优化方案 层级观察器(Hierarchy Viewer)： 使用layoutopt工具输出 重用布局文件： 使用&lt; merge /&gt;标签减少布局的嵌套层次； 仅在需要时才加载布局，ViewStub 12.Android性能调优 UI卡顿 ANR异常 内存性能优化 Android API使用：StringBuffer/String、HashMap/ArrayMap/SparseArray 性能调优参考这篇博客Andoid应用开发性能优化完全分析 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/28/Android-interview-questions/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"使用JNI获取publickey实现","slug":"JNI-get-publickey","date":"2016-09-21T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/09/22/JNI-get-publickey/","link":"","permalink":"http://agehua.github.io/2016/09/22/JNI-get-publickey/","excerpt":"1.前言之前写过一篇文件是关于JNI学习和积累的文章。这篇文章主要讲在使用JNI取得Publickey过程中遇到的问题和一些总结。 2.JNI获取Publickey实现在上篇文章中，最终采用的加密方法来自github项目。 但该项目中在4.0.4版本的手机上，取得publickey遇到兼容性问题。","text":"1.前言之前写过一篇文件是关于JNI学习和积累的文章。这篇文章主要讲在使用JNI取得Publickey过程中遇到的问题和一些总结。 2.JNI获取Publickey实现在上篇文章中，最终采用的加密方法来自github项目。 但该项目中在4.0.4版本的手机上，取得publickey遇到兼容性问题。 正常的Publickey字段样式是这样的： OpenSSLRSAPublicKey&#123;modulus=a0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb26a73305eea631ab18ec3ce746eb253e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9480cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a312c73cf0b98e0ce9a8cf6a682fa,publicExponent=10001&#125; 但是某些低版本手机上（我遇到的是三星GT-S7568 Android版本4.0.4）的Publickey字段样式是： RSA Public Key modulus: a0d169cedabdaac3527c2099eeaca0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb6a73305eea631ab18ec3ce746eb23e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9410cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a313c73cf0b98e0ce9a8cf6a682aff0b98e0ce9a8cf6a682fa public exponent: 10001 第一个字段modulus是一致的，第二个字段一个是“publicExponent”，另一个是“public exponent”。 所以我在代码中的处理是这样的 jmethodID substring_mid = env-&gt;GetMethodID(string_cls,\"substring\", \"(II)Ljava/lang/String;\");jmethodID indexOf_mid = env-&gt;GetMethodID(string_cls,\"indexOf\", \"(Ljava/lang/String;)I\");jint bb = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param2);jstring publicKey2_str =NULL;if (bb ==-1)&#123; jstring param3 = env-&gt;NewStringUTF(\"public exponent\"); jint cc = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param3); __android_log_print(ANDROID_LOG_ERROR, TAG, \"CC value is %d\", cc); publicKey2_str= static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+8,cc-1));&#125;else &#123; publicKey2_str = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+8,bb-1));&#125; 2.1 在JNI native代码中打印日志上面提供的JNI方法中涉及到了JNI日志打印（“__android_log_print”） __android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey value is %s\", jstringTostring(env,publicKey2_str)); 该方法第一个参数以日志级别，有：ANDROID_LOG_INFO，ANDROID_LOG_DEBUG和ANDROID_LOG_ERROR 第二个参数设置过滤的标签，可以在LogCat视图中过滤。 后面参数是具体的日志内容 jstringTostring是将jstring转换成char*的方法： char* jstringTostring(JNIEnv* env, jstring jstr)&#123; char* rtn = NULL; jclass clsstring = env-&gt;FindClass(\"java/lang/String\"); jstring strencode = env-&gt;NewStringUTF(\"utf-8\"); jmethodID mid = env-&gt;GetMethodID(clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\"); jbyteArray barr= (jbyteArray)env-&gt;CallObjectMethod(jstr, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) &#123; rtn = (char*)malloc(alen + 1); memcpy(rtn, ba, alen); rtn[alen] = 0; &#125; env-&gt;ReleaseByteArrayElements(barr, ba, 0); return rtn;&#125; jstring是Java提供的一个本地类型（Native Type），对应Java语言中的string类型 想了解JNI其他数据类型的，请看这里JNI学习积累之二 —- 数据类型映射、域描述符说明 要使用JNI日志打印还需要： 1.导入.h文件及定义宏在输出日志的.c文件中加入: #include &lt;android/log.h&gt;#define LOG_TAG \"From JNI ===&gt;&gt;\" 2.在Android.mk中引用日志库加入下面这行代码: LOCAL_LDLIBS := -lm -llog -ljnigraphics 具体学习可以移步这两篇文章： JNI的native代码中打印日志到eclipse的logcat中 JNI中使用LOGCAT 进行Debug 2.2 完整代码下面是我修改后的完整代码 jstring getPublicKey(JNIEnv* env, jobject thiz,jobject context) &#123; jclass context_cls = env-&gt;GetObjectClass(context); jmethodID get_package_manager_mid = env-&gt;GetMethodID(context_cls, \"getPackageManager\", \"()Landroid/content/pm/PackageManager;\"); jmethodID get_package_name_mid = env-&gt;GetMethodID(context_cls, \"getPackageName\", \"()Ljava/lang/String;\"); env-&gt;DeleteLocalRef(context_cls); jobject pm_obj = env-&gt;CallObjectMethod(context, get_package_manager_mid); jclass pm_cls = env-&gt;FindClass(\"android/content/pm/PackageManager\"); jmethodID get_package_info_mid = env-&gt;GetMethodID(pm_cls, \"getPackageInfo\", \"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\"); jstring package_name = reinterpret_cast&lt;jstring&gt;(env-&gt;CallObjectMethod( context, get_package_name_mid)); jfieldID flag_fid = env-&gt;GetStaticFieldID(pm_cls, \"GET_SIGNATURES\", \"I\"); jint flag = env-&gt;GetStaticIntField(pm_cls, flag_fid); env-&gt;DeleteLocalRef(pm_cls); jobject pi_obj = env-&gt;CallObjectMethod(pm_obj, get_package_info_mid, package_name, flag); env-&gt;DeleteLocalRef(package_name); jclass pi_cls = env-&gt;FindClass(\"android/content/pm/PackageInfo\"); jfieldID signatures_fid = env-&gt;GetFieldID(pi_cls, \"signatures\", \"[Landroid/content/pm/Signature;\"); env-&gt;DeleteLocalRef(pi_cls); jobject sig_obj = env-&gt;GetObjectField(pi_obj, signatures_fid); env-&gt;DeleteLocalRef(pi_obj); jobjectArray sigs = reinterpret_cast&lt;jobjectArray&gt;(sig_obj); jclass signature_cls = env-&gt;FindClass(\"android/content/pm/Signature\"); jmethodID to_byte_array_mid = env-&gt;GetMethodID(signature_cls, \"toByteArray\", \"()[B\"); jbyteArray sig_bytes = reinterpret_cast&lt;jbyteArray&gt;(env-&gt;CallObjectMethod( env-&gt;GetObjectArrayElement(sigs, 0), to_byte_array_mid)); jclass certificate_factory_cls = env-&gt;FindClass( \"java/security/cert/CertificateFactory\"); jmethodID get_certificate_instance_mid = env-&gt;GetStaticMethodID( certificate_factory_cls, \"getInstance\", \"(Ljava/lang/String;)Ljava/security/cert/CertificateFactory;\"); jobject certificate_factory_obj = env-&gt;CallStaticObjectMethod( certificate_factory_cls, get_certificate_instance_mid, env-&gt;NewStringUTF(\"X509\")); jmethodID generate_certificate_mid = env-&gt;GetMethodID( certificate_factory_cls, \"generateCertificate\", \"(Ljava/io/InputStream;)Ljava/security/cert/Certificate;\"); env-&gt;DeleteLocalRef(certificate_factory_cls); jclass certificate_cls = env-&gt;FindClass(\"java/security/cert/Certificate\"); jclass byte_input_stream_cls = env-&gt;FindClass( \"java/io/ByteArrayInputStream\"); jmethodID new_sig_bytes_is_mid = env-&gt;GetMethodID(byte_input_stream_cls, \"&lt;init&gt;\", \"([B)V\"); jobject sig_bytes_is = env-&gt;NewObject(byte_input_stream_cls, new_sig_bytes_is_mid, sig_bytes); env-&gt;DeleteLocalRef(sig_bytes); env-&gt;DeleteLocalRef(byte_input_stream_cls); jobject cert = env-&gt;CallObjectMethod(certificate_factory_obj, generate_certificate_mid, sig_bytes_is); env-&gt;DeleteLocalRef(sig_bytes_is); env-&gt;DeleteLocalRef(certificate_factory_obj); jmethodID get_pubic_key_mid = env-&gt;GetMethodID(certificate_cls, \"getPublicKey\", \"()Ljava/security/PublicKey;\"); env-&gt;DeleteLocalRef(certificate_cls); jobject publicKey = env-&gt;CallObjectMethod(cert, get_pubic_key_mid); jclass publicKey_cls = env-&gt;GetObjectClass(publicKey); jmethodID toString_mid = env-&gt;GetMethodID(publicKey_cls,\"toString\", \"()Ljava/lang/String;\"); jstring publicKey_str = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey,toString_mid)); env-&gt;DeleteLocalRef(cert); env-&gt;DeleteLocalRef(publicKey_cls); env-&gt;DeleteLocalRef(publicKey); jclass string_cls = env-&gt;GetObjectClass(publicKey_str); jmethodID indexOf_mid = env-&gt;GetMethodID(string_cls,\"indexOf\", \"(Ljava/lang/String;)I\"); jstring param = env-&gt;NewStringUTF(\"modulus\"); jint aa = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param); jstring param2 = env-&gt;NewStringUTF(\"publicExponent\"); jmethodID substring_mid = env-&gt;GetMethodID(string_cls,\"substring\", \"(II)Ljava/lang/String;\"); __android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey String is %s\", jstringTostring(env,publicKey_str)); jint bb = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param2); jstring publicKey2_str =NULL; if (bb ==-1)&#123; jstring param3 = env-&gt;NewStringUTF(\"public exponent\"); jint cc = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param3); __android_log_print(ANDROID_LOG_ERROR, TAG, \"CC value is %d\", cc); publicKey2_str= static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+8,cc-1)); &#125;else &#123; publicKey2_str = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+8,bb-1)); &#125; __android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey value is %s\", jstringTostring(env,publicKey2_str)); return publicKey2_str;&#125; 3.附赠版本兼容的方法问题（随时更新）低于Jellybean版本报如下错误： 01-20 08:53:00.141: E/AndroidRuntime(24005): java.lang.NoSuchMethodError: android.view.ViewTreeObserver.removeOnGlobalLayoutListener 正确调用方式应该是： if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123; ViewTreeObserver.removeGlobalOnLayoutListener(this);&#125;else ViewTreeObserver.removeOnGlobalLayoutListener(this); 还有一个setBackground方法： if(Build.VERSION.SzDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; View.setBackground(new ColorDrawable(Color.parseColor(\"#CCCCCC\")));&#125; else &#123; View.setBackgroundColor(Color.parseColor(\"#CCCCCC\"));&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/22/JNI-get-publickey/","categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"Android JNI","slug":"android-jni","permalink":"http://agehua.github.io/tags/android-jni/"}]},{"title":"Android 退出整个应用程序解决方案","slug":"quit-whole-application","date":"2016-09-21T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/09/22/quit-whole-application/","link":"","permalink":"http://agehua.github.io/2016/09/22/quit-whole-application/","excerpt":"关于这个功能，每个公司项目都有自己的解决方案 搜索了一下，网上大概有以下几种方法解决这个问题： (1)System.exit(0); (2)Process.killProcess(Process.myPid()); (3)ActivityManager activityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE); activityManager.restartPackage(“packagename”); 但这些貌似不是万能的，有的说在2.2版本后就失效了，那我们怎么办呢？","text":"关于这个功能，每个公司项目都有自己的解决方案 搜索了一下，网上大概有以下几种方法解决这个问题： (1)System.exit(0); (2)Process.killProcess(Process.myPid()); (3)ActivityManager activityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE); activityManager.restartPackage(“packagename”); 但这些貌似不是万能的，有的说在2.2版本后就失效了，那我们怎么办呢？ 1、通过广播在起初的一个项目里我用了一个比较笨的方法，我用一个类来专门管理所有的Activity。这个类里有一个List，每打开一个Activity我就把这个Activity放到这个List中，当退出时再将List中所有的Activity一个一个的关闭。 在后来的项目中发现了一个更好地方法，就是通过广播来完成退出功能，具体实现过程是这样的：在每个Activity创建时（onCreate时）给Activity注册一个广播接收器，当退出时发送该广播即可。大概的代码如下： @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); IntentFilter filter = new IntentFilter(); filter.addAction(\"finish\"); registerReceiver(mFinishReceiver, filter); ……&#125;private BroadcastReceiver mFinishReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if(\"finish\".equals(intent.getAction())) &#123; Log.e(\"#########\", \"I am \" + getLocalClassName() + \",now finishing myself...\"); finish(); &#125; &#125;&#125;; 相信聪明的大家会把上面的代码写在一个基类里面，因为如果你的项目中Activity很多的话，写起来很麻烦，而且也不符合代码规范。 在退出时执行以下代码即可关闭所有界面完全退出程序： getApplicationContext().sendBroadcast(new Intent(“finish”)); 转载：http://www.cnblogs.com/wader2011/archive/2011/10/10/2205161.html 2、使用退出类public class CloseActivity&#123; private static LinkedList&lt;Activity&gt; acys = new LinkedList&lt;Activity&gt;(); public static Activity curActivity; public static void add(Activity acy) &#123; acys.add(acy); &#125; public static void remove(Activity acy) &#123; acys.remove(acy); &#125; public static void close() &#123; Activity acy; while (acys.size() != 0) &#123; acy = acys.poll(); if (!acy.isFinishing()) &#123; acy.finish(); &#125; &#125;// android.os.Process.killProcess(android.os.Process.myPid()); &#125;&#125; 3.利用activity stack的原理我们知道Android的窗口类提供了历史栈，我们可以通过stack的原理来巧妙的实现，这里我们在D窗口打开A窗口时在Intent中直接加入标志Intent.FLAG_ACTIVITY_CLEAR_TOP，再次开启A时将会清除该进程空间的所有Activity。 在D中使用下面的代码: Intent intent = new Intent();intent.setClass(D.this, A.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //注意本行的FLAG设置startActivity(intent);finish(); 关掉自己，在A中加入代码： @Overrideprotected void onNewIntent(Intent intent) &#123; // TODO Auto-generated method stub super.onNewIntent(intent); //退出 if ((Intent.FLAG_ACTIVITY_CLEAR_TOP &amp; intent.getFlags()) != 0) &#123; finish(); &#125;&#125; A的Manifest.xml配置成android:launchMode=&quot;singleTop&quot; 原理总结： 一般A是程序的入口点，从D起一个A的activity，加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP这个过程中会把栈中B，C，都清理掉。因为A是android:launchMode=”singleTop” 不会调用oncreate(),而是响应onNewIntent（）这时候判断Intent.FLAG_ACTIVITY_CLEAR_TOP，然后把A finish（）掉。 栈中A,B,C,D全部被清理。所以整个程序退出了。 4.JNI实现守护进程请看这篇博客Android 通过JNI实现守护进程 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/22/quit-whole-application/","categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/tags/technology/"}]},{"title":"apk中含有admob广告插件","slug":"AVG-unwanted-software","date":"2016-09-19T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/09/20/AVG-unwanted-software/","link":"","permalink":"http://agehua.github.io/2016/09/20/AVG-unwanted-software/","excerpt":"问题出现使用这个杀毒软件antivirus-for-android，检测我们团队的apk后，AVG提示警告unwanted software。 生成的报告说是：Beware of Adware! 1 Types of Adware DetectedLast reported adware activity: Sep 16Days with adware in last 30: 1 days 见下图：","text":"问题出现使用这个杀毒软件antivirus-for-android，检测我们团队的apk后，AVG提示警告unwanted software。 生成的报告说是：Beware of Adware! 1 Types of Adware DetectedLast reported adware activity: Sep 16Days with adware in last 30: 1 days 见下图： 排查使用这个广告插件检测工具全能工具箱，检测后，确实提示我们的apk含有广告“admob” 但是这个apk是我们团队自己开发的，有项目源码，AndroidManifest文件中没有网络上说的Google AdMob注册，更没有com.google.ads.AdView这个布局文件 代码中没有，可能在第三方库中？ 结果就是在排查第三方库的过程中，发现google service的jar包中有名字是ads的文件夹。如下图： 删除后上图中的两个ads文件夹，再打包apk后，用软件检测，果然没有admob插件了。哈哈，恼人的问题解决了。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/20/AVG-unwanted-software/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"ANDROID设计模式之单例模式","slug":"android-design-pattern-singleton","date":"2016-09-19T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/09/20/android-design-pattern-singleton/","link":"","permalink":"http://agehua.github.io/2016/09/20/android-design-pattern-singleton/","excerpt":"向大神致敬本文转载自stormzhang ANDROID设计模式之单例模式 ，稍有修改 常用单例模式什么是设计模式？其实简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式的意思，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，但是我只会针对Android平台上常用的一些设计模式做分享，今天就先来分享下最常用的单例模式。","text":"向大神致敬本文转载自stormzhang ANDROID设计模式之单例模式 ，稍有修改 常用单例模式什么是设计模式？其实简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式的意思，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，但是我只会针对Android平台上常用的一些设计模式做分享，今天就先来分享下最常用的单例模式。 饿汉式public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton newInstance()&#123; return instance; &#125;&#125; 饿汉式 是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用饿汉式的单例模式就是不合适的，这时候就需要用到懒汉式的方式去按需延迟加载单例。 懒汉式public class Singleton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton newInstance()&#123; if(null == instance)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式与饿汉式的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用懒汉式就是非常不错的选择。 多线程下的单例模式上面介绍了一些单例模式的基本应用方法，但是上面所说的那些使用方式都是有一个隐含的前提，那就是他们都是应用在单线程条件下，一旦换成了多线程就有出错的风险。 如果在多线程的情况下，饿汉式不会出现问题，因为JVM只会加载一次单例类，但是懒汉式可能就会出现重复创建单例对象的问题。为什么会有这样的问题呢？因为懒汉式在创建单例时是 线程不安全的，多个线程可能会并发调用他的newInstance方法导致多个线程可能会创建多份相同的单例出来。 那有没有办法，使懒汉式的单利模式也是线程安全的呢？答案肯定是有的，就是使用加同步锁的方式去实现。 懒汉式同步锁public class Singleton &#123; private static Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 这种是最常见的解决同步问题的一种方式，使用同步锁synchronized (Singleton.class)防止多线程同时进入造成instance被多次实例化。举个在Android使用这种方式的例子： InputMethodManager示例public final class InputMethodManager &#123; //内部全局唯一实例 static InputMethodManager sInstance; //对外api public static InputMethodManager getInstance() &#123; synchronized (InputMethodManager.class) &#123; if (sInstance == null) &#123; IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE); IInputMethodManager service = IInputMethodManager.Stub.asInterface(b); sInstance = new InputMethodManager(service, Looper.getMainLooper()); &#125; return sInstance; &#125; &#125;&#125; 以上是Android源码中输入法类相关的单例使用方式。 但其实还有一种更好的方式如下： 双重校验锁public class Singleton &#123; private static volatile Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; // if already inited, no need to get lock everytime if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 可以看到上面在synchronized (Singleton.class)外又添加了一层if，这是为了在instance已经实例化后下次进入不必执行synchronized (Singleton.class)获取对象锁，从而提高性能。 以上两种方式还是挺麻烦的，我们不禁要问，有没有更好的实现方式呢？答案是肯定的。 我们可以利用JVM的类加载机制去实现。在很多情况下JVM已经为我们提供了同步控制，比如： 在static{}区块中初始化的数据访问final字段时等等因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现： 采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载和线程安全。 实现代码如下： 静态内部类public class Singleton&#123; //内部类，在装载该内部类时才会去创建单利对象 private static class SingletonHolder&#123; public static Singleton instance = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton newInstance()&#123; return SingletonHolder.instance; &#125; public void doSomething()&#123; //do something &#125;&#125; 这样实现出来的单例类就是线程安全的，而且使用起来很简洁，麻麻再也不用担心我的单例不是单例了。 然而这还不是最简单的方式，Effective Java中推荐了一种更简洁方便的使用方式，就是使用枚举。 枚举类型单例模式public enum Singleton&#123; //定义一个枚举的元素，它就是Singleton的一个实例 instance; public void doSomething()&#123; // do something ... &#125; &#125; 使用方法如下： public static void main(String[] args)&#123; Singleton singleton = Singleton.instance; singleton.doSomething();&#125; 默认枚举实例的创建是线程安全的(创建枚举类的单例在JVM层面也是能保证线程安全的), 所以不需要担心线程安全的问题，所以理论上枚举类来实现单例模式是最简单的方式。 总结一般单例模式包含了5种写法，分别是饿汉、懒汉、双重校验锁、静态内部类和枚举。相信看完之后你对单例模式有了充分的理解了，根据不同的场景选择最你最喜欢的一种单例模式吧！ 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/20/android-design-pattern-singleton/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Android design pattern","slug":"android-design-pattern","permalink":"http://agehua.github.io/tags/android-design-pattern/"}]},{"title":"ThreadLocal、HandlerThread、Looper区别","slug":"ThreadLocal-HandlerThread-Looper","date":"2016-09-04T16:00:00.000Z","updated":"2017-02-15T01:37:11.000Z","comments":true,"path":"2016/09/05/ThreadLocal-HandlerThread-Looper/","link":"","permalink":"http://agehua.github.io/2016/09/05/ThreadLocal-HandlerThread-Looper/","excerpt":"1.前言Android中非UI线程（WorkThread）不能操作UI线程（MainThread） handler 发送Message 给MessageQueue，Looper 来轮询消息，如果有Message，然后再发送给Handler，Handler 拿到消息就可以所在的线程执行了。 2.ThreadLocalThread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals ，这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。","text":"1.前言Android中非UI线程（WorkThread）不能操作UI线程（MainThread） handler 发送Message 给MessageQueue，Looper 来轮询消息，如果有Message，然后再发送给Handler，Handler 拿到消息就可以所在的线程执行了。 2.ThreadLocalThread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals ，这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。 简单理解就是每个线程维护一个map，然后可以用一定的关键字取出这个map里的目标类（比如一个bean），这个“一定的关键字”说的就是这个ThreadLocal 。 ThreadLocal隔离了各个线程，让各线程之间没有什么共享的问题。 参考：Android 中 Handler，Looper，HandlerThread 的使用 3.LooperLooper是Android handler机制的重要组成部分，Looper这个名字起的很形象，翻译过来是：打环的人，就是维护一个循环的人。Looper里有一个静态变量：private static final ThreadLocal sThreadLocal = new ThreadLocal();这是典型的Android里用到ThreadLocal的一个情况，调用Looper.prepare的时候，唯一做的事情就是把sThreadLocal作为key，把一个new出来的looper对象作为value put到相应线程的map里。然后以后用到Looper.loop的时候，就从这个sThreadLocal里取出这个Looper，然后死循环（阻塞循环）MessageQueue，取出Message并执行message指向的Handler。 4.HandlerSDK中关于Handler的说明如下： A Handler allows you to sendand process Messageand Runnable objects associated with a thread’s MessageQueue.Each Handler instance is associated with a single thread and that thread’smessage queue. When you create a new Handler, it is bound to the thread /message queue of the thread that is creating it – from that point on, it willdeliver messages and runnables to that message queue and execute them as theycome out of the message queue. 4.1 Handler的作用 There are two main uses for aHandler: (1) to schedule messages and runnables to be executed as some point inthe future; and (2) to enqueue an action to be performed on a different thread than your own. 在线程中实例化Handler需要保证线程当中包含Looper(注意：UI-Thread默认包含Looper)。 4.2 不是所有的Handler都能更新UIHandler处理消息总是在创建Handler的线程里运行。而我们的消息处理中，不乏更新UI的操作，不正确的线程直接更新UI将引发异常。因此，需要时刻关心Handler在哪个线程里创建的。如何更新UI才能不出异常呢？SDK告诉我们，有以下4种方式可以从其它线程访问UI线程(也即线程间通信)： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) 在UI线程中创建的Handler 几点小结 Handler的处理过程运行在创建Handler的线程里 一个Looper对应一个MessageQueue，一个线程对应一个Looper，一个Looper可以对应多个Handler 不确定当前线程时，更新UI时尽量调用View.post方法 handler应该由处理消息的线程创建。 handler与创建它的线程相关联，而且也只与创建它的线程相关联。handler运行在创建它的线程中，所以，如果在handler中进行耗时的操作，会阻塞创建它的线程。 Android的线程分为有消息循环的线程和没有消息循环的线程，有消息循环的线程一般都会有一个Looper。主线程（UI线程）就是一个消息循环的线程。 Looper.myLooper(); //获得当前的LooperLooper.getMainLooper() //获得UI线程的Looper Handle的初始化函数（构造函数），如果没有参数，那么他就默认使用的是当前的Looper，如果有Looper参数，就是用对应的线程的Looper。 如果一个线程中调用Looper.prepare()，那么系统就会自动的为该线程建立一个消息队列，然后调用Looper.loop();之后就进入了消息循环，这个之后就可以发消息、取消息、和处理消息。 5.消息的发送与处理我们简单地看一下消息的循环过程： 5.1 消息的生成Message msg =mHandler.obtainMessage();msg.what = what;msg.sendToTarget(); 5.2 消息的发送MessageQueue queue= mQueue; if (queue != null)&#123; msg.target =this; sent =queue.enqueueMessage(msg, uptimeMillis);&#125; 在Handler.java的sendMessageAtTime(Messagemsg, long uptimeMillis)方法中，我们看到，它找到它所引用的MessageQueue，然后将Message的target设定成自己（目的是为了在处理消息环节，Message能找到正确的Handler），再将这个Message纳入到消息队列中。 5.3 消息的抽取Looper me =myLooper();MessageQueue queue= me.mQueue;while (true) &#123; Message msg =queue.next(); // might block if (msg !=null) &#123; if(msg.target == null) &#123; // Notarget is a magic identifier for the quit message. return; &#125; msg.target.dispatchMessage(msg); msg.recycle(); &#125;&#125; 在Looper.java的loop()函数里，我们看到，这里有一个死循环，不断地从MessageQueue中获取下一个（next方法）Message，然后通过Message中携带的target信息，交由正确的Handler处理（dispatchMessage方法）。 5.4 消息的处理if (msg.callback!= null) &#123; handleCallback(msg);&#125; else &#123; if (mCallback!= null) &#123; if(mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg);&#125; 在Handler.java的dispatchMessage(Messagemsg)方法里，其中的一个分支就是调用handleMessage方法来处理这条Message，而这也正是我们在职责处描述使用Handler时需要实现handleMessage(Messagemsg)的原因。至于dispatchMessage方法中的另外一个分支，我将会在后面的内容中说明。至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。 参考上面的消息的发送与处理，这里再解释一下View.post(Runnable)方法。 在post(Runnableaction)方法里，View获得当前线程（即UI线程）的Handler，然后将action对象post到Handler里。 在Handler里，它将传递过来的action对象包装成一个Message（Message的callback为action），然后将其投入UI线程的消息循环中。 在 Handler再次处理该Message时，有一条分支就是为它所设，直接调用mCallback.handleMessage的方法，返回到runnable的run方法。 而此时，已经路由到UI线程里，因此，我们可以毫无顾虑的来更新UI。 5.HandlerThreadHandlerThread就是在普通的Thread基础上加上了Looper的支持，让用户不必自己去创建Looper了，同时方便了Handler的使用。 创建HandlerThread时需要把它启动了，即调用start()方法。然后创建Handler时将HandlerThread中的looper对象传入。 HandlerThread thread = new HandlerThread(\"MyHandlerThread\");thread.start();mHandler = new Handler(thread.getLooper());mHandler.post(new Runnable()&#123;...&#125;); 那么这个Handler对象就是与HandlerThread这个线程绑定了（这时就不再是与UI线程绑定了，这样在Handler中处理耗时操作将不会阻塞UI）。 如果想让HandlerThread退出，则需要调用handlerThread.quit()。 具体可以看下面代码： public class HandlerThreadActivity extends Activity &#123; private static final String TAG = \"HandlerThreadActivity\"; private HandlerThreadmHandlerThread; private MyHandler mMyHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generatedmethod stub super.onCreate(savedInstanceState); TextView text = new TextView(this); text.setText(\"HandlerThreadActivity\"); setContentView(text); Log.d(TAG, \"The mainthread id = \" + Thread.currentThread().getId()); //生成一个HandlerThread对象，实现了使用Looper来处理消息队列的功能， //这个类由Android应用程序框架提供 mHandlerThread = new HandlerThread(\"handler_thread\"); //在使用HandlerThread的getLooper()方法之前，必须先调用该类的start(); mHandlerThread.start(); //即这个Handler是运行在mHandlerThread这个线程中 mMyHandler = new MyHandler(mHandlerThread.getLooper()); mMyHandler.sendEmptyMessage(1); &#125; private class MyHandler extends Handler &#123; public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; Log.d(TAG, \"MyHandler--&gt;handleMessage--&gt;threadid = \" + Thread.currentThread().getId()); super.handleMessage(msg); &#125; &#125;&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/09/05/ThreadLocal-HandlerThread-Looper/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"RxJava 学习","slug":"RxAndroid-Learning","date":"2016-08-15T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/08/16/RxAndroid-Learning/","link":"","permalink":"http://agehua.github.io/2016/08/16/RxAndroid-Learning/","excerpt":"1.向前辈致敬给Android开发者的RxJava详解，这篇文章讲解详细，如果耐心看完，相信肯定收获不小 本篇博文用作学习RxJava过程中，记录知识和心得，如有冒犯还请见谅！ 2.简单介绍RxJava是通过一种扩展的观察者模式来实现的。RxJava有四个基本概念：Observable(可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。","text":"1.向前辈致敬给Android开发者的RxJava详解，这篇文章讲解详细，如果耐心看完，相信肯定收获不小 本篇博文用作学习RxJava过程中，记录知识和心得，如有冒犯还请见谅！ 2.简单介绍RxJava是通过一种扩展的观察者模式来实现的。RxJava有四个基本概念：Observable(可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。 与传统观察者模式不同， RxJava 的事件回调方法除了普通事件onNext()（相当于onClick()/onEvent()）之外，还定义了两个特殊的事件：onCompleted()和onError()。 RxJava的基本实现主要有三点：Observer的创建、Observable的创建、Scheduler线程控制 3.Observer的创建方法Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式： Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 除了 Observer 接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber。 Subscriber对Observer接口进行了一些扩展，但他们的基本使用方式是完全一样的： Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; Observer和Subscriber区别对于使用者来说主要有两点： onStart(): 这是Subscriber增加的方法。 它会在subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。 需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart()就不适用了，因为它总是在subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法。 unsubscribe(): 这是Subscriber所实现的另一个接口Subscription的方法，用于取消订阅。 在这个方法被调用后，Subscriber将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 unsubscribe()这个方法很重要，因为在subscribe()之后，Observable会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 4.Observable的几种创建方法：1.Observable.just(T…)和from(T[])/from(Iterable&lt;? extends T&gt;) 1). just(T…): 将传入的参数依次发送出来 2). from(T[])/from(Iterable&lt;? extends T&gt;): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 3). 由这两个方法创建的Observable对象的特点是：所有Observer一旦订阅这个Observable就会立即调用onNext()方法并传入Observable.just()/from()的参数，而后因为Observable没有数据可以发送了，onComplete()方法会被调用。 Observable&lt;List&lt;String&gt;&gt; listObservable = Observable.just(getColorList()); 注意，如果just()中传入的是耗时方法，该方法会被立即执行并阻塞UI线程。这里的getColorList()是一个不耗时的方法. 下一步，我们写一个Observer来观察Observable。 listObservable.subscribe(new Observer&lt;List&lt;String&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;String&gt; colors) &#123; mSimpleStringAdapter.setStrings(colors); &#125;&#125;); 在这个例子中我们不关心Observable何时完成数据的传输，所以我们不用在onComplete()方法里写代码。而且在这里不会有异常抛出，所以我们也不用管onError()方法 2.Observable.fromCallable() 先看代码： Observable&lt;List&lt;String&gt;&gt; tvShowObservable = Observable.fromCallable(new Callable&lt;List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; call() &#123; return mRestClient.getFavoriteTvShows(); &#125;&#125;); 使用Observable.fromCallable()方法有两点好处： 1).获取要发送的数据的代码只会在有Observer订阅之后执行。 2).获取数据的代码（指的是call()方法）可以在子线程中执行。对比just()中传入的方法只能运行在主线程。 这两点好处有时可能非常重要。 现在让我们订阅这个Observable。 mTvShowSubscription = tvShowObservable .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;String&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;String&gt; tvShows)&#123; displayTvShows(tvShows); &#125;&#125;); 上面代码逐一介绍： 1).subscribeOn() 指定事件发生的线程 在默认情况下Observable的所有代码，都会在执行subscribe()方法的线程中运行。而通过subscribeOn()方法，这些代码可以在其他线程中执行。在上面的例子中，我们让代码在”IO Scheduler”中执行（Schedulers.io()）。现在我们可以只把Scheduler当做一个可以工作的子线程。 2).observeOn() 会指定onNext()方法发生的线程 通过在observeOn()方法中指定另一个Scheduler来完成onNext()的内容，在这里也就是AndroidSchedules.mainThread()所返回的Scheduler(UI线程的Scheduler)。 3).subscribe() Callable只会在有在Observable调用subscribe()后执行。 Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）： // 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public Subscription subscribe(Subscriber subscriber) &#123; subscriber.onStart(); onSubscribe.call(subscriber); return subscriber;&#125; 可以看到，subscriber()做了3件事： ①.调用Subscriber.onStart()。这个方法在前面已经介绍过，是一个可选的准备方法。 ②.调用Observable中的OnSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在RxJava中， Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。 ③.将传入的Subscriber作为Subscription返回。这是为了方便unsubscribe(). 4).mTvShowSubscription 每当Observer订阅Observable时就会生成一个Subscription对象。一个Subscription代表了一个Observer与Observable之间的连接。有时我们需要操作这个连接，这里拿在Activity的onDestroy()方法中的代码举个例子： if (mTvShowSubscription != null &amp;&amp; !mTvShowSubscription.isUnsubscribed()) &#123; mTvShowSubscription.unsubscribe(); //取消订阅&#125; unsubscribe()方法告诉Observable它所发送的数据不再被Observer所接收。在调用unsubscribe()方法后，我们创建的Observer就不再会收到数据了，以免Observable异步加载数据时发生意外。 3.使用SingleSingle是Observable的精简版，一种特殊的只发射单个值的Observable，几乎和Observable一模一样，但其回调方法不是onComplete()/onNext()/onError()，而是onSuccess()/onError()。 我们现在把刚才写过的Observable用Single重写一遍。首先我们要创建一个Single: Single&lt;List&lt;String&gt;&gt; tvShowSingle = Single.fromCallable(new Callable&lt;List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; call() throws Exception &#123; mRestClient.getFavoriteTvShows(); &#125;&#125;); 然后订阅一下 mTvShowSubscription = tvShowSingle .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new SingleSubscriber&lt;List&lt;String&gt;&gt;() &#123; @Override public void onSuccess(List&lt;String&gt; tvShows) &#123; displayTvShows(tvShows); &#125; @Override public void onError(Throwable error) &#123; displayErrorMessage(); &#125;&#125;); 但这次我们不再使用Observer，而是使用一个叫SingleSubscriber的类。这个类和Observer非常像，只不过它只有上述两个方法：onSuccess()和onError()。SingleSubscriber之于Single就如Observer之于Observable。 订阅一个Single的同时也会自动创建一个Subscription对象。这里的Subscription和上面的例子没有区别，一定要在onDestroy()中解除订阅。 5.线程控制——Scheduler RxJava已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： 1.Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 2.Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 3.Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 4.Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 5.另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 6.特殊的情况1.Subject Observable和Observer的复合体，也是二者的桥梁 Subjects = Observable + Observer，Subject继承自Observable实现了Observer Rxjava提供的四种Subject: ①PublishSubject ： subject的基础子类。 ②BehaviorSubject : 会首先向它的订阅者发送截止订阅前最新的一个数据，然后正常发送订阅后的数据流。 ③ReplaySubject ： 会缓存它所订阅的所有数据，向所有订阅它的观察者重发。 ④AsyncSubject ： 只会发布最后一个数据给已经订阅的每一个观察者。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/08/16/RxAndroid-Learning/","categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"RxJava","slug":"rxjava","permalink":"http://agehua.github.io/tags/rxjava/"}]},{"title":"Android手机定位服务","slug":"android-LocationListener","date":"2016-08-02T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/08/03/android-LocationListener/","link":"","permalink":"http://agehua.github.io/2016/08/03/android-LocationListener/","excerpt":"1.LocationListener使用优先使用网络定位服务，当GPS服务不可用则跳转到手机位置服务设置页面","text":"1.LocationListener使用优先使用网络定位服务，当GPS服务不可用则跳转到手机位置服务设置页面 代码收集： /** * 使用手机定位服务 */private void startLocationService()&#123; locationListener = new LocationListener() &#123; @Override public void onStatusChanged(String provider, int status, Bundle extras) &#123; &#125; @Override public void onProviderEnabled(String provider) &#123; // 当GPS LocationProvider可用时，更新位置 location = locManager.getLastKnownLocation(provider); &#125; @Override public void onProviderDisabled(String provider) &#123; isLocatedSuccess = false; if (provider.equals(\"network\")) &#123; locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3 * 1000, 8,locationListener); &#125;else if(provider.equals(\"gps\"))&#123;//GPS服务不可用，跳到位置服务设置页面 startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS)); &#125;else &#123; updateToNewLocation(null); &#125; &#125; @Override public void onLocationChanged(Location location) &#123; // 当定位信息发生改变时，更新位置 isLocatedSuccess = true; updateToNewLocation(location); locManager.removeUpdates(this); &#125; &#125;; if (locManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) locManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 3 * 1000, 8,locationListener); else if (locManager.getProvider(LocationManager.GPS_PROVIDER) != null) locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3 * 1000, 8,locationListener); else Toast.makeText(mActivity(), \"获取手机位置信息错误\", Toast.LENGTH_SHORT).show();&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/08/03/android-LocationListener/","categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/tags/technology/"}]},{"title":"Android Webview总结，不断更新中 :(","slug":"android-webview-summary","date":"2016-07-24T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/07/25/android-webview-summary/","link":"","permalink":"http://agehua.github.io/2016/07/25/android-webview-summary/","excerpt":"1.Android Webview的坑 1.webview再次加载页面空白 1.可以关闭掉硬件加速 2.不关闭硬件加速的情况下：在关闭Acivity之前手动调用下面方法，","text":"1.Android Webview的坑 1.webview再次加载页面空白 1.可以关闭掉硬件加速 2.不关闭硬件加速的情况下：在关闭Acivity之前手动调用下面方法， public void goFinish()&#123; isLoadWithError =false; if (null!=jsCallBack) mWebView.removeJavascriptInterface(\"XXX\"); mWebView.setFocusable(true); mWebView.removeAllViews(); try &#123; mWebView.clearHistory(); //webview没有历史记录，这里会抛出异常 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; mWebView.destroy(); try &#123; //mWebView为WebView所在类的全局变量名，不可以混淆 Field fieldWebView = this.getClass().getDeclaredField(\"mWebView\"); fieldWebView.setAccessible(true); WebView webView = (WebView) fieldWebView.get(this); webView.removeAllViews(); webView.destroy(); &#125;catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125;catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125;catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; this.finish(); &#125; 注意：因为用到了反射去清理webview，所以混淆时，这个方法所在的类不能混淆 2.部分手机h5 game屏幕闪烁 在小米的某些手机上，会出现这种情况。抱歉，还没有好的解决办法。谁有好的解决办法可以邮件告知，多谢 :) 3.android Webview替代品Crosswalk Crosswalk解决4,2以下的手机浏览器的兼容性问题。对html5的支持更好 Crosswalk官网 但Crosswalk也有缺点，将Crosswalk嵌入App中，会使APK增加大约20M。具体可以看这个知乎提问 4.腾讯浏览服务 官网地址 2.WebView防止远程代码攻击 1.使用Android4.2以上的系统，通过在Java的远程方法上面声明一个@JavascriptInterface，可以预防改安全漏洞 2.低于Android4.2的系统，如果系统自己添加了一个叫searchBoxJavaBridge_的Js接口，则需要把这个接口删除 详情参见这篇文章：Android WebView的Js对象注入漏洞解决方案 这里贴一个自己整理的webview类：BaseWebView 3.Android中WebView的JavaScript代码和本地代码交互的三种方式来自姜维的博客:Android中WebView的JavaScript代码和本地代码交互的三种方式 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/07/25/android-webview-summary/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"Gson解析使用总结","slug":"gson-summary","date":"2016-06-07T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/06/08/gson-summary/","link":"","permalink":"http://agehua.github.io/2016/06/08/gson-summary/","excerpt":"1.Gson解析总结，就两种情况Gson 是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个JSON字符串转成一个Java对象，或者将Java对象转成一个JSON字符串。使用Gson来解析时，总结一下，就两句话： 1.遇到“{”字符，表示单个对象，直接用XXXBean.class类去映射 2.遇到“[”字符，表示对象数组，要用XXXBean[].class或list去映射","text":"1.Gson解析总结，就两种情况Gson 是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个JSON字符串转成一个Java对象，或者将Java对象转成一个JSON字符串。使用Gson来解析时，总结一下，就两句话： 1.遇到“{”字符，表示单个对象，直接用XXXBean.class类去映射 2.遇到“[”字符，表示对象数组，要用XXXBean[].class或list去映射 2.第一种情况，举例 json字符串是： &#123; \"items\": [ &#123; \"key\": \"H60-L12__1464938219953__346589_483\", \"hash\": \"Fip_In4BhB5syoZ28W3l_eb6rBDU\", \"fsize\": 348120, \"mimeType\": \"image/jpeg\", \"putTime\": 14649382507765902 &#125;, &#123; \"key\": \"H60-L12__1465352164202__397253_2946\", \"hash\": \"Fs-UwiosdckN9kVY01GrOYC-b7a9\", \"fsize\": 938413, \"mimeType\": \"image/jpeg\", \"putTime\": 14653521712332144 &#125;, &#123; \"key\": \"H60-L12__1465352548728__322577_4114\", \"hash\": \"Frga_QiMJVb9caiuwMlJABCsu1rc\", \"fsize\": 506921, \"mimeType\": \"image/jpeg\", \"putTime\": 14653525989907168 &#125; ]&#125; 分析 最开始是一个“{”字符，所以需要用gson.fromJson(jsonstring, XXXBean.class)来解析。同时，XXXBean中只有一个字段items。items里面是一个“[”字符，表示items里面是数组，可以用list去映射。 解析时， 最后对应的Gson对象就是： public class XXXBean &#123; public List&lt;XXXItem&gt; items; public List&lt;XXXItem&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;XXXItem&gt; items) &#123; this.items = items; &#125; public static class XXXItem &#123; private String key; private String hash; private String fsize; private String mimeType; private String putTime; ... &#125;&#125;Gson gson = new Gson();List&lt;XXXBean.XXXItem&gt; list = gson.fromJson(jsonstring,XXXBean.class).getItems(); 3.第二种情况，举例json字符串以“[”开头。 例如，json==[{“id”:1,”name”:”李坤”,”birthDay”:”Jun 22, 2012 8:28:52 AM”},{“id”:2,”name”:”曹贵生”,”birthDay”:”Jun 22, 2012 8:28:52 AM”},{“id”:3,”name”:”柳波”,”birthDay”:”Jun 22, 2012 8:28:52 AM”}] 解析时，需要使用list来接收。 List&lt;Student&gt; retList = gson.fromJson(jsonstring2, new TypeToken&lt;List&lt;Student&gt;&gt;()&#123;&#125;.getType()); 也可以这样 Student[] students= gson.fromJson(jsonstring2,new Student[].class); 对应list为什么要使用TypeToken？ TypeToken是Gson提供的，来实现对泛型的支持 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/06/08/gson-summary/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"七牛android使用总结","slug":"qiniu-android-summary","date":"2016-05-27T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/05/28/qiniu-android-summary/","link":"","permalink":"http://agehua.github.io/2016/05/28/qiniu-android-summary/","excerpt":"1.在android上实现对七牛空间操作 在android上实现对七牛空间的各种操作，包括list，delete，upload，download。支持私有空间 注意：官方不建议开发者把AccessKey和SecretKey放在前端的java文件里，最好还是有一台应用服务器 如果只是想尝试一下，好吧:) 代码中都有说明，直接上代码","text":"1.在android上实现对七牛空间操作 在android上实现对七牛空间的各种操作，包括list，delete，upload，download。支持私有空间 注意：官方不建议开发者把AccessKey和SecretKey放在前端的java文件里，最好还是有一台应用服务器 如果只是想尝试一下，好吧:) 代码中都有说明，直接上代码 2.代码一共有三个类： 工具类： package com.qiniu.ui.utils;import android.graphics.Bitmap;import android.graphics.Bitmap.CompressFormat;import android.os.Environment;import android.util.Log;import com.loopj.android.http.AsyncHttpClient;import com.loopj.android.http.AsyncHttpResponseHandler;import com.loopj.android.http.RequestParams;import com.qiniu.android.storage.UpProgressHandler;import com.qiniu.android.storage.UploadManager;import com.qiniu.android.storage.UploadOptions;import com.qiniu.android.utils.UrlSafeBase64;import com.qiniu.api.auth.AuthException;import com.qiniu.api.auth.digest.Mac;import com.qiniu.api.rs.PutPolicy;import com.qiniu.ui.SHA;import com.qiniu.ui.contains.QiNiuConfig;import org.apache.http.Header;import org.json.JSONException;import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.util.Random;import static com.qiniu.ui.SHA.hMacSHA1Encrypt;/** * @date 2016年5月26日 上午11:00:43 * @author lijixin * @web https://agehua.github.io * @Description: 七牛云图片操作 */public class QiniuUitls &#123; private static final String fileName = \"temp.jpg\"; private static final String tempJpeg = Environment.getExternalStorageDirectory().getPath() + \"/\" + fileName; private static int maxWidth = 720; private static int maxHeight = 1080; public interface QiniuUploadUitlsListener &#123; void onSucess(String fileUrl); void onError(int errorCode, String msg); void onProgress(int progress); &#125; public interface QiniuRequestListener &#123; void onSucceed(byte[] bytes); void onFailed(byte[] bytes); &#125; /** * 将bitmap转换成jpeg，控制图片大小不大于720*1080，可以指定图片压缩质量 * @param bitmap * @param filePath * @param quality * @return */ public static boolean saveBitmapToJpegFile(Bitmap bitmap, String filePath, int quality) &#123; try &#123; FileOutputStream fileOutStr = new FileOutputStream(filePath); BufferedOutputStream bufOutStr = new BufferedOutputStream(fileOutStr); resizeBitmap(bitmap).compress(CompressFormat.JPEG, quality, bufOutStr); bufOutStr.flush(); bufOutStr.close(); &#125; catch (Exception exception) &#123; return false; &#125; return true; &#125; /** * 缩小图片 * * @param bitmap * @return */ public static Bitmap resizeBitmap(Bitmap bitmap) &#123; if (bitmap != null) &#123; int width = bitmap.getWidth(); int height = bitmap.getHeight(); //宽度大于720 if (width &gt; maxWidth) &#123; //按宽度等比例压缩图片 int pWidth = maxWidth; int pHeight = maxWidth * height / width; Bitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, false); bitmap.recycle(); return result; &#125; if (height &gt; maxHeight) &#123; //按高度等比例缩小图片 int pHeight = maxHeight; int pWidth = maxHeight * width / height; Bitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, false); bitmap.recycle(); return result; &#125; &#125; return bitmap; &#125; public static void uploadImage(Bitmap bitmap, QiniuUploadUitlsListener listener) &#123; saveBitmapToJpegFile(bitmap, tempJpeg,100); uploadImage(tempJpeg, listener); &#125; /** * 上传图片选择jpg格式，七牛图片api目前支持对jpg格式进行指定图片质量请求 * @param filePath * @param listener */ public static void uploadImage(String filePath, final QiniuUploadUitlsListener listener) &#123; final String fileUrlUUID = getFileUrlUUID(); String token = getToken(); if (token == null) &#123; if (listener != null) &#123; listener.onError(-1, \"token is null\"); &#125; return; &#125; UploadManager uploadManager = new UploadManager(); uploadManager.put(filePath, fileUrlUUID, token, (key, info, response) -&gt; &#123; System.out.println(\"debug:info = \" + info + \",response = \" + response); if (info != null &amp;&amp; info.statusCode == 200) &#123;// 上传成功 String fileRealUrl = getRealUrl(fileUrlUUID); System.out.println(\"debug:fileRealUrl = \" + fileRealUrl); if (listener != null) &#123; listener.onSucess(fileRealUrl); &#125; &#125; else &#123; if (listener != null) &#123; listener.onError(info.statusCode, info.error); &#125; &#125; &#125;, new UploadOptions(null, null, false, new UpProgressHandler() &#123; public void progress(String key, double percent) &#123; if (listener != null) &#123; listener.onProgress((int) (percent * 100)); &#125; &#125; &#125;, null)); &#125; /** * 生成远程文件路径（全局唯一） * &lt;p&gt;格式类似： H60-L12__1464851303930__156750_1884&lt;/p&gt; * @return */ private static String getFileUrlUUID() &#123; String filePath = android.os.Build.MODEL + \"__\" + System.currentTimeMillis() + \"__\" + (new Random().nextInt(500000)) + \"_\" + (new Random().nextInt(10000)); return filePath.replace(\".\", \"0\"); &#125; private static String getRealUrl(String fileUrlUUID) &#123; String filePath = \"http://\" + QiNiuConfig.QINIU_BUCKNAME + \".qiniudn.com/\" + fileUrlUUID; return filePath; &#125; /** * 获取token 本地生成 * * @return */ private static String getToken() &#123; Mac mac = new Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK); PutPolicy putPolicy = new PutPolicy(QiNiuConfig.QINIU_BUCKNAME); putPolicy.returnBody = \"&#123;\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)&#125;\"; try &#123; String uptoken = putPolicy.token(mac); System.out.println(\"debug:uptoken = \" + uptoken); return uptoken; &#125; catch (AuthException e) &#123; e.printStackTrace(); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 根据host和文件名，生成file的url下载地址，支持私有空间 * @param domain host：七牛的私有空间域名 * @param imgKey file key：空间里的文件名 * @return url下载地址 */ public static String downloadFile(String domain,String imgKey)&#123; //密钥配置 //构造私有空间的需要生成的下载的链接// String domain =\"http://example.xxx.clouddn.com/\";// String path =\"H60-L12__1464917382714__36888_5255\"; StringBuilder sb =new StringBuilder(); //加上过期时间戳字段 String url = sb.append(domain).append(imgKey).append(\"?e=1478365261\").toString(); Log.e(\"encodedEntryURI\",url); byte[] sign =null; try &#123; sign = SHA.hMacSHA1Encrypt(url,QiNiuConfig.QINIU_SK); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; String encodedSign = UrlSafeBase64.encodeToString(sign); sb.append(\"&amp;token=\").append(QiNiuConfig.QINIU_AK).append(\":\").append(encodedSign); Log.e(\"download token\",sb.toString()); return sb.toString(); &#125; /** * 列出空间中指定格式的文件 * @param bucket 空间名 * @param prefix 要指定的格式（前缀） * @param listener * @return */ public static void listFile(String bucket, String prefix,final QiniuRequestListener listener)&#123; try&#123; StringBuilder sb = new StringBuilder(); String entryUrl = sb.append(\"bucket=\").append(bucket) .append(\"&amp;prefix=\").append(prefix).toString(); String host = \"http://rsf.qbox.me\"; String path = \"/list?\" +entryUrl; String url = host+path; Log.e(\"AAAAAAA\", url); byte[] sign = SHA.hMacSHA1Encrypt(path+\"\\n\", QiNiuConfig.QINIU_SK); String encodedSign = UrlSafeBase64.encodeToString(sign); String authorization = QiNiuConfig.QINIU_AK + ':' + encodedSign; AsyncHttpClient client = new AsyncHttpClient(); client.addHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); client.addHeader(\"Authorization\", \"QBox \"+authorization); RequestParams params = new RequestParams(); client.post(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int i, Header[] headers, byte[] bytes) &#123; if (null!=listener) listener.onSucceed(bytes); &#125; @Override public void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) &#123; if (null!=listener) listener.onFailed(bytes); &#125; &#125;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return ; &#125; /** * 删除空间中的文件 * @param bucket 删除文件的空间 * @param fileName 删除的文件 * */ public static boolean deleteFile(String bucket,String fileName,final QiniuRequestListener listener)&#123; try&#123; String entryUrl = bucket+\":\"+fileName; String encodedEntryURI = UrlSafeBase64.encodeToString(entryUrl.getBytes()); String host = \"http://rs.qiniu.com\"; String path = \"/delete/\"+encodedEntryURI; String url = host+path; Log.e(\"AAAAAAA\", url); byte[] sign = hMacSHA1Encrypt(path+\"\\n\", QiNiuConfig.QINIU_SK); String encodedSign = UrlSafeBase64.encodeToString(sign); String authorization = QiNiuConfig.QINIU_AK + ':' + encodedSign; AsyncHttpClient client = new AsyncHttpClient(); client.addHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); client.addHeader(\"Authorization\", \"QBox \"+authorization); RequestParams params = new RequestParams(); client.post(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int i, Header[] headers, byte[] bytes) &#123; if (null!=listener) listener.onSucceed(bytes); &#125; @Override public void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) &#123; if (null!=listener) listener.onFailed(bytes); if (null!=bytes) &#123; String s = new String(bytes); &#125; &#125; &#125;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return false; &#125;&#125; HMAC-SHA1签名加密类 使用下面方法生成对应七牛资源管理里用到的管理凭证 /** * 对外提供HMAC-SHA1签名方法 * @author agehua * */public class SHA &#123; private static final String MAC_NAME = \"HmacSHA1\"; private static final String ENCODING = \"UTF-8\"; /** * * 使用 HMAC-SHA1 签名方法对对encryptText进行签名 * @param encryptText 被签名的字符串 * @param encryptKey 密钥 * @return * @throws Exception */ public static byte[] hMacSHA1Encrypt(String encryptText, String encryptKey) throws Exception &#123; byte[] data = encryptKey.getBytes(ENCODING); // 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称 SecretKey secretKey = new SecretKeySpec(data, MAC_NAME); // 生成一个指定 Mac 算法 的 Mac 对象 Mac mac = Mac.getInstance(MAC_NAME); // 用给定密钥初始化 Mac 对象 mac.init(secretKey); byte[] text = encryptText.getBytes(ENCODING); // 完成 Mac 操作 return mac.doFinal(text); &#125;&#125; ~~~ - 还有一个Config文件~~~ Javapublic final class QiNiuConfig &#123; public static final String token = getToken(); public static final String QINIU_AK = \"Your_AccessKey\"; public static final String QINIU_SK = \"Your_SecretKey\"; public static final String QINIU_BUCKNAME = \"你的私有空间\"; public static String getToken() &#123; Mac mac = new Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK); PutPolicy putPolicy = new PutPolicy(QiNiuConfig.QINIU_BUCKNAME); putPolicy.returnBody = \"&#123;\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)&#125;\"; try &#123; String uptoken = putPolicy.token(mac); System.out.println(\"debug:uptoken = \" + uptoken); return uptoken; &#125; catch (AuthException e) &#123; e.printStackTrace(); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 点击在Gist上查看上面这些代码 最后，如果有问题欢迎讨论，我的邮箱简介里有 :) 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/28/qiniu-android-summary/","categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/tags/technology/"}]},{"title":"android JNI学习① 基础知识","slug":"JNI-Learning","date":"2016-05-23T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/05/24/JNI-Learning/","link":"","permalink":"http://agehua.github.io/2016/05/24/JNI-Learning/","excerpt":"本文只是用来记录，写的不好还请见谅。 1.JNI介绍JNI概念 : Java本地接口,Java Native Interface, 它是一个协议, 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码; C和Java的侧重 : C语言 : C语言中最重要的是 函数 function; Java语言 : Java中最重要的是 JVM, class类, 以及class中的方法; C与Java如何交流 : JNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范; C语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法; Java语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上; JNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍;","text":"本文只是用来记录，写的不好还请见谅。 1.JNI介绍JNI概念 : Java本地接口,Java Native Interface, 它是一个协议, 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码; C和Java的侧重 : C语言 : C语言中最重要的是 函数 function; Java语言 : Java中最重要的是 JVM, class类, 以及class中的方法; C与Java如何交流 : JNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范; C语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法; Java语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上; JNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍; JNI中的一些概念 : native : Java语言中修饰本地方法的修饰符, 被该修饰符修饰的方法没有方法体; Native方法 : 在Java语言中被native关键字修饰的方法是Native方法; JNI层 : Java声明Native方法的部分; JNI函数 : JNIEnv提供的函数, 这些函数在jni.h中进行定义; JNI方法 : Native方法对应的JNI层实现的 C/C++方法, 即在jni目录中实现的那些C语言代码; 2.NDK简单介绍C代码执行 : C代码被编译成库文件之后, 才能执行, 库文件分为动态库 和静态库 两种; 动态库 : unix环境下.so后缀的是动态库, windows环境下.dll 后缀的是动态库; 动态库可以依赖静态库加载一些可执行的C代码; 静态库 :.a后缀是静态库的扩展名; 库文件来源 : C代码 进行 编译 链接操作之后, 才会生成库文件, 不同类型的CPU 操作系统 生成的库文件是不一样; CPU分类 : arm结构, 嵌入式设备处理器; x86结构, pc服务器处理器; 不同的CPU指令集不同; 交叉编译 :windows x86编译出来的库文件可以在arm平台运行的代码; 交叉编译工具链 : Google提供的 NDK 就是交叉编译工具链, 可以在linux环境下编译出在arn平台下执行的二进制库文件; NDK作用 : 是Google提供了交叉编译工具链, 能够在linux平台编译出在arm平台下执行的二进制库文件; NDK版本介绍 : android-ndk-windows 是在windows系统中的cygwin使用的, android-ndk-linux 是在linux下使用的; 想深入了解NDK开发的同学，可以去安装一下cygwin，本文只涉及简单的C语言代码，不需要使用cygwin。 3.环境准备，使用android studio还是Eclipse推荐使用Eclipse，这篇文章讲了使用Eclipse生成.h文件和生成so文件的配置过程。配置成功后可以远离命令行Eclipse ADT插件生成.h/.so文件 3.1 Java调用C流程 a. 定义 Native 方法 : 比如在com.packagename.jni.JNITest.java 类中定义 Native 方法 public native int add(int x, int y); b. 生成方法签名 : 进入 AndroidProject/bin/classes 目录, 使用 javah com.packagename.jni.JNITest 命令, 便生成了头文件, 该头文件引用了 jni.h, 以及定义好了对应的 Native 方法, 生成 JNIEXPORT jint JNICALL Java_com_packagename_jni_JNITest_add (JNIEnv *, jobject, jint, jint); Java中定义的方法 : //将Java中的两个int值 传给C语言, 进行相加后, 返回java语言 shuliang.han.ndkparameterpassing.DataProvider public native int add(int x, int y); 对应C语言中定义的方法 : #include &lt;jni.h&gt; //方法签名, Java环境和调用native方法的类必不可少, 后面的参数就是native方法的参数 jint Java_com_packagename_jni_JNITest_add(JNIEnv * env, jobject obj, jint x, jint y) &#123; return x + y; &#125; 3.2 生成.so文件Android.mk 文件： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := hello-jni LOCAL_SRC_FILES := hello-jni.c include $(BUILD_SHARED_LIBRARY) 文件内容解释： 获取当前文件内容 : $(call my-dir) 是编译器中的宏方法, 调用该宏方法, 就会返回前的目录路径; 赋值符号 : “ := “ 是赋值符号, 第一句话 是 返回当前文件所在的当前目录, 并将这个目录路径赋值给 LOCAL_PATH; 初始化编译模块参数 : $(CLEAR_VARS) 作用是将编译模块的参数初始化, LOCAL_MODULE LOCAL_SRC_FILES 也是这样的参数; 指定编译模块 : LOCAL_MODULE := hello-jni , 指定编译后的 so 文件名称, 编译好之后系统会在该名称前面加上 “lib”, 后缀加上 “.so”; 指定编译源文件 : LOCAL_SRC_FILES := hello-jni.c 告诉编译系统源文件, 如果有多个文件那么就依次写在后面即可; 编译成静态库 : include $(BUILD_SHARED_LIBRARY), 作用是告诉系统, 将编译的结果编译成.so后缀的静态库; 静态库引入 : NDK的platform中有很多 “.a” 结尾的动态库, 我们编译动态库的时候, 可以将一些静态库引入进来; 生成 动态库 so 文件 : 进入 Android.mk 所在目录, 在该目录执行ndk下的ndk-build命令; Java代码加载动态库 : 在 Java 代码中调用该类的类前面, 在类的一开始, 不在方法中, 加入 static&#123; System.loadLibrary(\"hello\"); &#125; ; Application.mk 文件内容为（不写这个文件也可以）: APP_STL := stlport_staticAPP_ABI := all 这篇文章是使用javah导出头文件过程中，常见错误和解决办法，这里做一个记录。 4.字符串的处理 Java中的String转为C语言中的char字符串下面的工具方法可以在C程序中解决这个问题： // java中的jstring, 转化为c的一个字符数组 char* Jstring2CStr(JNIEnv* env, jstring jstr) &#123; //声明了一个字符串变量 rtn char* rtn = NULL; //找到Java中的String的Class对象 jclass clsstring = (*env)-&gt;FindClass(env, \"java/lang/String\"); //创建一个Java中的字符串 \"GB2312\" jstring strencode = (*env)-&gt;NewStringUTF(env, \"GB2312\"); /* * 获取String中定义的方法 getBytes(), 该方法的参数是 String类型的, 返回值是 byte[]数组 * \"(Ljava/lang/String;)[B\" 方法前面解析 : * -- Ljava/lang/String; 表示参数是String字符串 * -- [B : 中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组 */ jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\"); //调用Java中的getBytes方法, 传入参数介绍 参数②表示调用该方法的对象, 参数③表示方法id , 参数④表示方法参数 jbyteArray barr = (jbyteArray)(*env)-&gt;CallObjectMethod(env, jstr, mid, strencode); // String .getByte(\"GB2312\"); //获取数组的长度 jsize alen = (*env)-&gt;GetArrayLength(env, barr); //获取数组中的所有的元素 , 存放在 jbyte*数组中 jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE); //将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 '\\0' if (alen &gt; 0) &#123; rtn = (char*) malloc(alen + 1); //new char[alen+1]; \"\\0\" memcpy(rtn, ba, alen); rtn[alen] = 0; &#125; (*env)-&gt;ReleaseByteArrayElements(env, barr, ba, 0); //释放内存 return rtn; &#125; Jstring2CStr方法讲解 : a. 获取Java中String类型的class对象 : 参数 : 上下文环境 env, String类完整路径 ; jclass clsstring = (*env)-&gt;FindClass(env, \"java/lang/String\"); b.创建Java字符串 : 使用 NewStringUTF 方法; jstring strencode = (*env)-&gt;NewStringUTF(env, \"GB2312\"); ~~~ - c.获取String中的getBytes()方法 : 参数介绍 ① env 上下文环境 ② 完整的类路径 ③ 方法名 ④ 方法签名, 方法签名 Ljava/lang/String; 代表参数是String字符串, [B 中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组;~~~ JavascriptjmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\"); ~~~ - d. 获取数组的长度 :~~~ Javascriptjsize alen = (*env)-&gt;GetArrayLength(env, barr); e. 获取数组元素 : 获取数组中的所有的元素 , 存放在 jbyte*数组中; jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE); f.数组拷贝: 将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 ‘\\0’; if (alen &gt; 0) &#123; rtn = (char*) malloc(alen + 1); //new char[alen+1]; \"\\0\" memcpy(rtn, ba, alen); rtn[alen] = 0; &#125; g.释放内存 : (*env)-&gt;ReleaseByteArrayElements(env, barr, ba, 0); //释放内存 5.JNI方法命名规则(标准JNI规范) JNI实现的方法与Java中Native方法的映射关系 : 使用方法名进行映射, 可以使用javah工具进入bin/classes目录下执行命令, 即可生成头文件; JNI方法参数介绍: 参数① : 第一个参数是JNI接口指针JNIEnv; 参数② : 如果Native方法是非静态的, 那么第二个参数就是对Java对象的引用, 如果Native方法是静态的, 那么第二个参数就是对Java类的Class对象的引用; JNI方法名规范: 返回值+Java前缀+全路径类名+方法名+参数① JNIEnv+参数② jobject+其它参数; 注意分隔符 : Java前缀 与 类名 以及类名之间的包名 和 方法名之间 使用 “_“ 进行分割; 声明 非静态 方法: Native方法 : public int hello (String str, int i); JNI方法: jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject obj, jstring str, jint i); 声明 静态 方法 : Native方法 : public static int hello (String str, int i); JNI方法 : jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject clazz, jstring str, jint i); 两种规范 : 以上是Java的标准JNI规范, 在Android中还有一套自定义的规范, 该规范是Android应用框架层 和 框架层交互使用的JNI规范, 依靠方法注册 映射 Native方法 和 JNI方法; JNIEnv作用 : JNIEnv 是一个指针,指向了一组JNI函数, 这些函数可以在jni.h中查询到,通过这些函数可以实现 Java层 与 JNI层的交互 , 通过JNIEnv 调用JNI函数 可以访问java虚拟机, 操作java对象; JNI线程相关性 : JNIEnv只在当前的线程有效,JNIEnv不能跨线程传递, 相同的Java线程调用本地方法, 所使用的JNIEnv是相同的, 一个Native方法不能被不同的Java线程调用; JNIEnv结构体系 : JNIEnv指针指向一个线程相关的结构,线程相关结构指向一个指针数组,指针数组中的每个元素最终指向一个JNI函数. 6.AES加密实现网上有几种AES实现的方式： 1.这个是我现在项目中使用的方法，在Github上有这个工程，这种方式是使用JNI生成一个与设备相关的密码，可以将该密码作为AES的密钥。链接地址 2.网上还有一种方式是由JNI生成keyValue和iv，Java层使用：链接地址 主要代码： static &#123; System.loadLibrary(\"cwtlib\"); keyValue = getKeyValue(); iv = getIv(); if(null != keyValue &amp;&amp; null != iv) &#123; KeyGenerator kgen; try &#123; kgen = KeyGenerator.getInstance(\"AES\"); kgen.init(128, new SecureRandom(keyValue)); key = kgen.generateKey(); paramSpec = new IvParameterSpec(iv); ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); &#125; catch (NoSuchAlgorithmException e) &#123; &#125; catch (NoSuchPaddingException e) &#123; &#125; &#125;&#125; public static native byte[] getKeyValue();public static native byte[] getIv(); 这种方式，在android app程序完全退出后，再进入该app时，之前加密好的字符串无法解密。 3.还有一种是直接由C或C++实现AES整个算法，直接使用网上代码并不知道靠不靠谱 所以，我们项目最终使用了第一种方法 7.JNI混淆问题 检查下 C/C++代码中没有直接访问Java代码的类或者类的成员变量、类的成员函数。 如果有的话，这些就不能混淆 //保留jni的回调类-keep class com.your.jnicallback.class &#123; *; &#125;//这个不用更改，直接复制就可以-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; 8.总结android 实现JNI入门并不难，笔者也刚刚入门，但要深入了解还是需要很长的路要走。 8.1 更新内容，JNI获取publickey实现在本文中最终使用第6点中的第一种方式，但原方法在4.0.4手机上遇到兼容性问题，详情请看我的这篇博客使用JNI获取publickey实现 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/24/JNI-Learning/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Android JNI","slug":"android-jni","permalink":"http://agehua.github.io/tags/android-jni/"}]},{"title":"android JNI学习② JNI调用过程","slug":"JNI-Learning0","date":"2016-05-23T16:00:00.000Z","updated":"2017-05-08T07:53:30.000Z","comments":true,"path":"2016/05/24/JNI-Learning0/","link":"","permalink":"http://agehua.github.io/2016/05/24/JNI-Learning0/","excerpt":"1.Android JNI调用过程1.1 由Android系统加载的JNIAndroid系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会AndroidRuntime.cpp中的startVm创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。","text":"1.Android JNI调用过程1.1 由Android系统加载的JNIAndroid系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会AndroidRuntime.cpp中的startVm创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。 在AndroidRuntime.cpp中： int AndroidRuntime::startReg(JNIEnv* env)&#123; //设置线程创建方法为javaCreateThreadEtc androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); env-&gt;PushLocalFrame(200); //进程NI方法的注册 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); return 0;&#125; register_jni_procs(gRegJNI, NELEM(gRegJNI), env)这行代码的作用就是就是循环调用gRegJNI数组成员所对应的方法。 static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)&#123; for (size_t i = 0; i &lt; count; i++) &#123; if (array[i].mProc(env) &lt; 0) &#123; return -1; &#125; &#125; return 0;&#125; gRegJNI数组，有100多个成员变量，定义在AndroidRuntime.cpp： static const RegJNIRec gRegJNI[] = &#123; REG_JNI(register_android_os_MessageQueue), REG_JNI(register_android_os_Binder), ...&#125;; 该数组的每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，该宏的作用就是调用相应的方法。 比如MessageQueue和Binder方法都是Android系统启动时就已经注册，所以在AndroidRuntime.cpp中可以找到相应的native方法，见AndroidRuntime.cpp的gRegJNI数组。这些注册方法命令格式为： register_[包名]_[类名] 示例一：以MessageQueue.java中的nativePollOnce方法为例，private native void nativePollOnce(long ptr, int timeoutMillis); 方法名：android.os.MessageQueue.nativePollOnce()，而相对应的native层方法名只是将点号替换为下划线，可得android_os_MessageQueue_nativePollOnce()。 前面说MessageQueue.java所定义的jni注册方法名应该是register_android_os_MessageQueue，的确存在于gRegJNI数组，说明这次JNI注册过程是有开机过程完成的。该方法在AndroidRuntime.cpp申明为extern方法： extern int register_android_os_MessageQueue(JNIEnv* env); 这些extern方法绝大多数位于/framework/base/core/jni/目录，大多数情况下native文件命名方式： [包名]_[类名].cpp[包名]_[类名].h Tips： MessageQueue.java ==&gt; android_os_MessageQueue.cpp 打开android_os_MessageQueue.cpp文件，搜索android_os_MessageQueue_nativePollOnce方法，这便找到了目标方法： static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 示例二：对于native文件命名方式，有时并非[包名]_[类名].cpp，比如Binder.javaBinder.java所对应的native文件：android_util_Binder.cpp public static final native int getCallingPid(); 根据示例一方式，找到getCallingPid ==&gt; android_os_Binder_getCallingPid()，并且在AndroidRuntime.cpp中的gRegJNI数组中找到register_android_os_Binder。 按实例(一)方式则native文名应该为android_os_Binder.cpp，可是在/framework/base/core/jni/目录下找不到该文件，这是例外的情况。其实真正的文件名为android_util_Binder.cpp，这就是例外，这一点有些费劲，不明白为何google要如此打破规律的命名。 static jint android_os_Binder_getCallingPid(JNIEnv* env, jobject clazz)&#123; return IPCThreadState::self()-&gt;getCallingPid();&#125; 有人可能好奇，既然如何遇到打破常规的文件命令，怎么办？这个并不难，首先，可以尝试在/framework/base/core/jni/中搜索，对于binder.java，可以直接搜索binder关键字，其他也类似。如果这里也找不到，可以通过grep全局搜索android_os_Binder_getCallingPid这个方法在哪个文件。 jni存在的常见目录： /framework/base/core/jni/ /framework/base/services/core/jni/ /framework/base/media/jni/ 1.2 加载自定义的JNI方法前面两种都是在Android系统启动之初，便已经注册过JNI所对应的方法。 那么如果程序自己定义的jni方法，该如何查看jni方法所在位置呢？下面以MediaPlayer.java为例，其包名为android.media： public class MediaPlayer&#123; static &#123; System.loadLibrary(\"media_jni\"); native_init(); &#125; private static native final void native_init(); ...&#125; 通过static静态代码块中System.loadLibrary方法来加载动态库，库名为media_jni, Android平台则会自动扩展成所对应的libmedia_jni.so库 接下来便要查看libmedia_jni.so库定义所在文件，一般都是通过Android.mk文件定义LOCAL_MODULE:= libmedia_jni，可以采用grep或者mgrep来搜索包含libmedia_jni字段的Android.mk所在路径。 搜索可知，libmedia_jni.so位于/frameworks/base/media/jni/Android.mk。用前面实例(一)中的知识来查看相应的文件和方法名分别为： android_media_MediaPlayer.cppandroid_media_MediaPlayer_native_init() 再然后，你会发现果然在该Android.mk所在目录/frameworks/base/media/jni/中找到android_media_MediaPlayer.cpp文件，并在文件中存在相应的方法： static voidandroid_media_MediaPlayer_native_init(JNIEnv *env)&#123; jclass clazz; clazz = env-&gt;FindClass(\"android/media/MediaPlayer\"); fields.context = env-&gt;GetFieldID(clazz, \"mNativeContext\", \"J\"); ...&#125; Tips：MediaPlayer.java中的native_init方法所对应的native方法位于/frameworks/base/media/jni/目录下的android_media_MediaPlayer.cpp文件中的android_media_MediaPlayer_native_init方法。 总结：System.loadLibrary()的作用就是调用相应库中的JNI_OnLoad()方法。 1.3 说说JNI_OnLoad()过程。[-&gt; android_media_MediaPlayer.cpp] jint JNI_OnLoad(JavaVM* vm, void* reserved)&#123; JNIEnv* env = NULL; if (register_android_media_MediaPlayer(env) &lt; 0) &#123; goto bail; &#125; ...&#125; 详细说一下register_android_media_MediaPlayer [-&gt; android_media_MediaPlayer.cpp] static int register_android_media_MediaPlayer(JNIEnv *env)&#123; //【见3.4】 return AndroidRuntime::registerNativeMethods(env, \"android/media/MediaPlayer\", gMethods, NELEM(gMethods));&#125; 虚拟机相关的变量中有两个非常重要的量JavaVM和JNIEnv: 1.JavaVM：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例 2.JNIEnv：是指线程上下文环境，每个线程有且只有一个JNIEnv实例 其中gMethods，记录java层和C/C++层方法的一一映射关系。 static JNINativeMethod gMethods[] = &#123; &#123;\"prepare\", \"()V\", (void *)android_media_MediaPlayer_prepare&#125;, &#123;\"_start\", \"()V\", (void *)android_media_MediaPlayer_start&#125;, &#123;\"_stop\", \"()V\", (void *)android_media_MediaPlayer_stop&#125;, &#123;\"seekTo\", \"(I)V\", (void *)android_media_MediaPlayer_seekTo&#125;, &#123;\"_release\", \"()V\", (void *)android_media_MediaPlayer_release&#125;, &#123;\"native_init\", \"()V\", (void *)android_media_MediaPlayer_native_init&#125;, ...&#125;; 这里涉及到结构体JNINativeMethod，其定义在jni.h文件： typedef struct &#123; const char* name; //Java层native函数名 const char* signature; //Java函数签名，记录参数类型和个数，以及返回值类型 void* fnPtr; //Native层对应的函数指针&#125; JNINativeMethod; 2.JNI资源JNINativeMethod结构体中有一个字段为signature(签名)，再介绍signature格式之前需要掌握各种数据类型在Java层、Native层以及签名所采用的签名格式。 2.1 数据类型 基本数据类型 Signature格式 Java Native B byte jbyte C char jchar D double jdouble F float jfloat I int jint S short jshort J long jlong Z boolean jboolean V void void 数组数据类型 数组简称则是在前面添加[： Signature格式 Java Native [B byte[] jbyteArray [C char[] jcharArray [D double[] jdoubleArray [F float[] jfloatArray [I int[] jintArray [S short[] jshortArray [J long[] jlongArray [Z boolean[] jbooleanArray 复杂数据类型 对象类型简称：L+classname +; Signature格式 Java Native Ljava/lang/String; String jstring L+classname +; 所有对象 jobject [L+classname +; Object[] jobjectArray Ljava.lang.Class; Class jclass Ljava.lang.Throwable; Throwable jthrowable Signature 有了前面的铺垫，那么再来通过实例说说函数签名： (输入参数…)返回值参数，这里用到的便是前面介绍的Signature格式。 Java函数 对应的签名 void foo() ()V float foo(int i) (I)F long foo(int[] i) ([I)J double foo(Class c) (Ljava/lang/Class;)D boolean foo(int[] i,String s) ([ILjava/lang/String;)Z String foo(int i) (I)Ljava/lang/String; 2.2 其他 (一)垃圾回收对于Java开发人员来说无需关系垃圾回收，完全由虚拟机GC来负责垃圾回收，而对于JNI开发人员，对于内存释放需要谨慎处理，需要的时候申请，使用完记得释放内容，以免发生内存泄露。在JNI提供了三种Reference类型，Local Reference(本地引用)， Global Reference（全局引用）， Weak Global Reference(全局弱引用)。其中Global Reference如果不主动释放，则一直不会释放；对于其他两个类型的引用都是释放的可能性，那是不是意味着不需要手动释放呢？答案是否定的，不管是这三种类型的那种引用，都尽可能在某个内存不再需要时，立即释放，这对系统更为安全可靠，以减少不可预知的性能与稳定性问题。 另外，ART虚拟机在GC算法有所优化，为了减少内存碎片化问题，在GC之后有可能会移动对象内存的位置，对于Java层程序并没有影响，但是对于JNI程序可要小心了，对于通过指针来直接访问内存对象是，Dalvik能正确运行的程序，ART下未必能正常运行。 (二)异常处理Java层出现异常，虚拟机会直接抛出异常，这是需要try..catch或者继续往外throw。但是对于JNI出现异常时，即执行到JNIEnv中某个函数异常时，并不会立即抛出异常来中断程序的执行，还可以继续执行内存之类的清理工作，直到返回到Java层时才会抛出相应的异常。 另外，Dalvik虚拟机有些情况下JNI函数出错可能返回NULL，但ART虚拟机在出错时更多的是抛出异常。这样导致的问题就可能是在Dalvik版本能正常运行的程序，在ART虚拟机上由于没有正确处理异常而崩溃。 3.JNI知识积累JNI学习积累之一 —- 常用函数大全http://blog.csdn.net/qinjuning/article/details/7595104 JNI学习积累之二 —- 数据类型映射、域描述符说明http://blog.csdn.net/qinjuning/article/details/7599796 JNI学习积累之三 —- 操作JNI函数以及复杂对象传递http://blog.csdn.net/qinjuning/article/details/7607214 JNI 实战全面解析http://blog.csdn.net/banketree/article/details/40535325 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/24/JNI-Learning0/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"Android JNI","slug":"android-jni","permalink":"http://agehua.github.io/tags/android-jni/"}]},{"title":"Java String与C/C++中byte[]","slug":"javaString-and-bytes","date":"2016-05-17T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/05/18/javaString-and-bytes/","link":"","permalink":"http://agehua.github.io/2016/05/18/javaString-and-bytes/","excerpt":"做JAVA经常会碰到中文乱码问题，还有各种编码的问题，特别是String类的内容需要重新编码的问题。要解决这些问题，必须了解清楚JAVA对于字符串是怎么处理的。 1，“字符”是由数字来表示的 先来重新了解一下计算机是如何处理“字符”的，这个原理是大家必须记住的，特别是在用JAVA写程序的时候，万万不可模糊。我们知道，计算机把任何东西都用数字来表示，“字符”也不例外。比如我们要显示一个阿拉伯数字“3”，在我们的PC里，其实并不是仅仅用一个数字3来代表我们要写的“3”，而是以十六进制的0x33来代表，包括放在内存或者是写到文件里，其实都是写着0x33的，不信你可以编辑一个文本文件，写一个“3”，然后用ultraEdit看他的原始码。","text":"做JAVA经常会碰到中文乱码问题，还有各种编码的问题，特别是String类的内容需要重新编码的问题。要解决这些问题，必须了解清楚JAVA对于字符串是怎么处理的。 1，“字符”是由数字来表示的 先来重新了解一下计算机是如何处理“字符”的，这个原理是大家必须记住的，特别是在用JAVA写程序的时候，万万不可模糊。我们知道，计算机把任何东西都用数字来表示，“字符”也不例外。比如我们要显示一个阿拉伯数字“3”，在我们的PC里，其实并不是仅仅用一个数字3来代表我们要写的“3”，而是以十六进制的0x33来代表，包括放在内存或者是写到文件里，其实都是写着0x33的，不信你可以编辑一个文本文件，写一个“3”，然后用ultraEdit看他的原始码。 2，一切“字符”都必定用数字+编码表表示。 这时候，有一个问题：为什么一定要用0x33来代表“3”呢？而不用0x43来代表呢？或者是直接用0x03来代替？其实用什么来代表都可以，只不过大家都习惯了用ASCII编码表（是美国国家信息交换表）来确定各字符应该是用什么数字代表的。同样，为了表示中国字，我国也指定了中文的编码表，其中最广泛使用的是GB2312。比如中文的“当”字，就是用0xB5, 0xB1这两个八位的数字来表示的。所以 如果显示字符的程序不知道一列数字到底是按什么编码表编码的，他也无法去判断到底这些是什么文字。如果随便用一个不对的编码表来处理这些数字，处理出来的字符很可能完全是错的。比如在英文系统上，没有GB2312编码表，送给他一个0xB5,0xB1，他就傻傻的当作ASCII来处理（操作系统通常都有自己默认的编码表），结果显示出来就是两个奇怪的符号，因为这两个字在ASCII表里就是那两个符号。同样在繁体中文系统里，他的编码表是BIG5，显示出来也是一个奇怪的中文，不是“当”字。 3，UNICODE让全世界都说一种语言 看完上面的文字，是否觉得，世界有那么多语言，每个都有自己的一套编码表，很麻烦呢？就算是中文，也有两套流行的编码表，一个是GB2312，一个是BIG5。要使用不同中文的编码的字符时，还要转来转去，的确很麻烦。不光这个，如果想要写一篇包含很多过国文字的文章，就麻烦了，必须要让处理这个文章的程序知道，哪个字是什么编码标准的。如果你想要在文章里找一个字，也必须指定你要找的是哪种编码的哪个字。否则，你要找一个0xB5,0xB1的中文“当”字，很可能把同样数字表示的日文、波兰文这些不相干的字一起给你找出来，够麻烦的吧！ 所以人们想，不如大家都用同一个编码标准吧，各种文字都在编码表里有一席之地，处理文字的程序只需要都按这个编码表来处理就可以了。不过要一个编码表里包含所有的文字，这张表就大了，本来英文字+数字一共只有128个以内。但加上中文后，忽然就多了数万个，所以存放一个字符需要的大小也大了很多。现在 UNICODE规定了一个字符必须由2个8位数字来表示，想想，8x8x8x8x = 65536，是多大的一个数字啊！所以全世界的文字才能都包含进去。当然拉，也有人说中国字可能都不止6万个拉，还要包括别的文字，但人家外国人觉得你们中国人常用的也没那么多，所以就这么定了，我们也没办法。需要注意的是GB2312和UNICODE虽然都是用两个8位数来代表一个中文字，但具体的规格可不一样，比如0xB5,0xB1在UNICODE里面可不是“当”字，而是另外一国的文字来的。 4，C是如何简洁的处理字符的 我们来谈谈C的字符串。C语言诞生在JAVA之前，C语言的基本数据类型是没有字符串这个类型的，它只有char[]。也就是C把字符顺序放入一个字节数组就完了。而且C也不管放在数组里的是什么文字，也不管那些字是按什么编码标准的。而且他的char的大小也不一定是8位数字，有时候是16位也可能，这要看具体的机器和操作系统。所以写程序的人必须要知道正在处理的char[]的内容到底是按什么编码表表示的字符串，要知道如果比较两国文字是否相同，可是没任何意义的哦！ 5，JAVA是是如何处理字符的。 世界总会进步的，JAVA就是一个例子。JAVA终于有了String类了，它是解决字符问题的最好工具。在JAVA里，一个基本的要点是：String类对象是不需要指定编码表的！ 为什么它会自己知道一堆数字各代表什么字符呢？就是因为 String里的字符信息是用UNICODE编码存放的。而JAVA为了表示字符（注意是单个字符），也有char这个数据类型，而且他的大小是固定2个8位16进制数字长度，也就是0~65535罗。为的就是对应UNICODE里面的一个字符。大家如果想取一个String里的按UNICODE数字，可以用getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 方法取得一个char[]，这个char[]里就是表示String字符的，按UNICODE编码表编码的数字。 可惜现在绝大多数的系统和程序都不是按UNICODE来处理字符，而JAVA程序总是要和别的程序和系统交换数据的，所以在接收一个字符，或者是发送一个字符的时候，就必须要留意当前系统和UNICODE的关系了。比如你从网络或者文件接受到一数字：0xB5,0xB1，JAVA程序并不知道这两个字到底是中文呢？还是日文，或者英文。你如果不指明这个两个数字的编码表，JAVA就会按当前系统默认的编码表来处理。如果这两个数字是从中文WIN98发出去的，JAVA程序又是在英文LINUX上运行的，那就出现了所谓的乱码问题了。也就是JAVA按英文的编码表ASCII来处理这两个数字，当通过new String({0xB5,0xB1})得到的String的时候，这个String代表的已经不是中文的“当”字，而是两个英文的奇怪字符了。不过如果你知道这两个数字一定是中文的话，就可以指定用new String({0xB5,0xB1},”GB2312”)来处理，这时候新建立的String才真的是一个“当”字。当然拉，如果你要把一个“当”字的JAVA的String显示在中文WIN98上，必须把这个字输出成两个8位数字：0xB5,0xB1，不管是写成文件还是输出到浏览器上，都必须是0xB5,0xB1。如何把“当”字用GB2312输出？String.getBytes(“GB2312”) 就可以拉！所以有一点要记住：和外界交换任何信息都是以byte[]来进行的！。你可以留意一下JAVA大多数的I/O类，都有以byte[]作为参数和返回值的方法。不过，也有很多写的比较糊涂的程序，没有提供byte[]交换信息的方法，害的不同文字平台的程序员很头疼。Servlet的HttpRequest.getParameter()就是这样。好在有的JSP/SERVLET容易还提供先指定编码表的方法，才能比较简单的解决这个问题。 6，网上关于JAVA中文问题的一些错误处理方法。 一个是最常见的，不管什么内容，都用new String(…,”ISO-8859-1”)来建立字符串，然后使用的时候按默认的编码格式（通常在服务器上都是英文系统）输出字符串。这样其实你使用的String并不是按UNICODE来代表真正的字符，而是强行把BYTE数组复制到String的char[]里，一旦你的运行环境改变，你就被迫要修改一大堆的代码。而且也无法在同一个字符串里处理几种不同编码的文字。 另一个是把一种编码格式的字符串，比如是GB2312，转换成另一种格式的字符串，比如UTF-8，然后不指明是UTF-8编码，而直接用new String(…)来建立String，这样放在String里面的字符也是无法确定的，它在不同的系统上代表不同的字符。如果要求别人用“UTF-8格式”的String来交换信息的时候，其实已经破坏了JAVA为了兼容各种语言所做的规定。这种错误的本质思想是还按写C语言的方式，把字符串纯粹当作可以自己自由编码的存储器使用，而忽略了JAVA字符串只有一种编码格式。如果真的想自由编码，用byte[]或者char[]就完全了解决问题的了。 7，其他资料字符，字节和编码 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/18/javaString-and-bytes/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"google cloud message（GCM）和Azure实现Notification总结","slug":"GCM-Azure_summary","date":"2016-05-11T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/05/12/GCM-Azure_summary/","link":"","permalink":"http://agehua.github.io/2016/05/12/GCM-Azure_summary/","excerpt":"1.相关资料我也是一知半解，基本上就是根据官方教程来实现，但microsoft的azure文档我找了好久，英文不好，汗。。。 gcm start: https://developers.google.com/cloud-messaging/android/start azure start: https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/ gcm official demo: https://github.com/google/gcm gcm personal demo: https://github.com/iammert/FastGCM","text":"1.相关资料我也是一知半解，基本上就是根据官方教程来实现，但microsoft的azure文档我找了好久，英文不好，汗。。。 gcm start: https://developers.google.com/cloud-messaging/android/start azure start: https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/ gcm official demo: https://github.com/google/gcm gcm personal demo: https://github.com/iammert/FastGCM 2.遇到的问题 1.手机运行官方demo时，发送消息，消息收不到必须切换一下网络才可以 stackoverflow上有人问过这个问题：http://stackoverflow.com/questions/13835676/google-cloud-messaging-messages-sometimes-not-received-until-network-state-cha 3.onActivityResult()和onResume()调用顺序API中这样描述：当你一个Activity是以请求码开始，结束时返回给前页面结果码，页面根据结果码进行相应的信息处理。我们会在返回的页面先接受结果码，然后才调用onResume()。 通常我们还会遇到这样一个问题：在处理返回页面的数据问题1.需要从服务器上刷新数据时我们会在onResume()方法里处理2.而刷新从结束界面返回的数据我们会在onAcitviyResult()方法里面处理 为了避免二者在同一块控件上对数据处理，我们只需加个标识符，在两个方法里进行判断，要用哪个方法进行刷新 4.Android4.4以上系统根据Uri正确获取文件路径的方法public static String getPhotoPathFromContentUri(Context context, Uri uri) &#123; String photoPath = \"\"; if(context == null || uri == null) &#123; return photoPath; &#125; if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123; String docId = DocumentsContract.getDocumentId(uri); if(isExternalStorageDocument(uri)) &#123; String [] split = docId.split(\":\"); if(split.length &gt;= 2) &#123; String type = split[0]; if(\"primary\".equalsIgnoreCase(type)) &#123; photoPath = Environment.getExternalStorageDirectory() + \"/\" + split[1]; &#125; &#125; &#125; else if(isDownloadsDocument(uri)) &#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.valueOf(docId)); photoPath = getDataColumn(context, contentUri, null, null); &#125; else if(isMediaDocument(uri)) &#123; String[] split = docId.split(\":\"); if(split.length &gt;= 2) &#123; String type = split[0]; Uri contentUris = null; if(\"image\".equals(type)) &#123; contentUris = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; &#125; else if(\"video\".equals(type)) &#123; contentUris = MediaStore.Video.Media.EXTERNAL_CONTENT_URI; &#125; else if(\"audio\".equals(type)) &#123; contentUris = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; &#125; String selection = MediaStore.Images.Media._ID + \"=?\"; String[] selectionArgs = new String[] &#123; split[1] &#125;; photoPath = getDataColumn(context, contentUris, selection, selectionArgs); &#125; &#125; &#125; else if(\"file\".equalsIgnoreCase(uri.getScheme())) &#123; photoPath = uri.getPath(); &#125; else &#123; photoPath = getDataColumn(context, uri, null, null); &#125; return photoPath;&#125;private static boolean isExternalStorageDocument(Uri uri) &#123; return \"com.android.externalstorage.documents\".equals(uri.getAuthority());&#125;private static boolean isDownloadsDocument(Uri uri) &#123; return \"com.android.providers.downloads.documents\".equals(uri.getAuthority());&#125;private static boolean isMediaDocument(Uri uri) &#123; return \"com.android.providers.media.documents\".equals(uri.getAuthority());&#125;private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123; Cursor cursor = null; String column = MediaStore.Images.Media.DATA; String[] projection = &#123; column &#125;; try &#123; cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; int index = cursor.getColumnIndexOrThrow(column); return cursor.getString(index); &#125; &#125; finally &#123; if (cursor != null &amp;&amp; !cursor.isClosed()) cursor.close(); &#125; return null;&#125; 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/05/12/GCM-Azure_summary/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"《android开发艺术探索》读书笔记","slug":"android-books-reading-","date":"2016-03-19T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/03/20/android-books-reading-/","link":"","permalink":"http://agehua.github.io/2016/03/20/android-books-reading-/","excerpt":"第1章 Activity的生命周期和启动模式本节和《Android群英传》中的第8章Activity和Activity调用栈分析有关系，建议先阅读该章的总结 第1章 Activity的生命周期和启动模式 1.1 Activity生命周期全面分析1.1.1 典型情况下生命周期分析 (1)一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart方法就会被调用。 (2)当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新Activity采用了透明主题，那么onStop方法不会被回调。当用户再次回到原来的Activity时，回调如下：onRestart -&gt; onStart -&gt; onResume。","text":"第1章 Activity的生命周期和启动模式本节和《Android群英传》中的第8章Activity和Activity调用栈分析有关系，建议先阅读该章的总结 第1章 Activity的生命周期和启动模式 1.1 Activity生命周期全面分析1.1.1 典型情况下生命周期分析 (1)一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart方法就会被调用。 (2)当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新Activity采用了透明主题，那么onStop方法不会被回调。当用户再次回到原来的Activity时，回调如下：onRestart -&gt; onStart -&gt; onResume。 (3)onStart和onStop对应，它们是从Activity是否可见这个角度来回调的；onPause和onResume方法对应，它们是从Activity是否位于前台这个角度来回调的。 (4)从Activity A进入到Activity B，回调顺序是onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)，所以不能在onPause方法中做重量级的操作。 1.1.2 异常情况下生命周期分析 (1)onSaveInstanceState方法只会出现在Activity被异常终止的情况下，它的调用时机是在onStop之前，它和onPause方法没有既定的时序关系，可能在它之前，也可能在它之后。 当Activity被重新创建的时候，onRestoreInstanceState会被回调，它的调用时机是onStart之后。 系统只会在Activity即将被销毁并且有机会重新显示的情况下才会去调用onSaveInstanceState方法。 当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据，比如文本框中用户输入的数据、listview滚动的位置等，这些view相关的状态系统都会默认为我们恢复。具体针对某一个view系统能为我们恢复哪些数据可以查看view的源码中的onSaveInstanceState和onRestoreInstanceState方法。 (2)Activity按优先级的分类 前台Activity；可见但非前台Activity；后台Activity (3)android:configChanges=”xxx”属性，常用的主要有下面三个选项： local：设备的本地位置发生了变化，一般指切换了系统语言； keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘； orientation：屏幕方向发生了变化，比如旋转了手机屏幕。 配置了android:configChanges=”xxx”属性之后，Activity就不会在对应变化发生时重新创建，而是调用Activity的onConfigurationChanged方法。 1.2 Activity的启动模式1.2.1 启动模式 (1)当任务栈中没有任何Activity的时候，系统就会回收这个任务栈。 (2)从非Activity类型的Context(例如ApplicationContext、Service等)中以standard模式启动新的Activity是不行的，因为这类context并没有任务栈，所以需要为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标志位。 (3)任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。 (4)参数TaskAffinity用来指定Activity所需要的任务栈，意为任务相关性。 默认情况下，所有Activity所需的任务栈的名字为应用的包名。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。 当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中； 当TaskAffinity和allowTaskReparenting结合的时候，当一个应用A启动了应用B的某个Activity C后，如果Activity C的allowTaskReparenting属性设置为true的话，那么当应用B被启动后，系统会发现Activity C所需的任务栈存在了，就将Activity C从A的任务栈中转移到B的任务栈中。 (5)singleTask模式的具体分析： 当一个具有singleTask启动模式的Activity请求启动之后，系统首先会寻找是否存在A想要的任务栈， 如果不存在，就重新创建一个任务栈，然后创建Activity的实例把它放到栈中；如果存在Activity所需的任务栈，这时候要看栈中是否有Activity实例存在. 如果有，那么系统就会把该Activity实例调到栈顶，并调用它的onNewIntent方法(它之上的Activity会被迫出栈，所以singleTask模式具有FLAG_ACTIVITY_CLEAR_TOP效果)；如果Activity实例不存在，那么就创建Activity实例并把它压入栈中。 (6)设置启动模式既可以使用xml属性android:launchMode，也可以使用代码intent.addFlags()。区别在于限定范围不同，前者无法直接为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，而后者无法为Activity指定singleInstance模式。 1.2.2 Activity的FlagsFLAG_ACTIVITY_NEW_TASK,FLAG_ACTIVITY_SINGLE_TOP,FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用，它等同于属性设置android:excludeFromRecents=”true”。 1.3 IntentFilter的匹配规则 (1)IntentFilter中的过滤信息有action、category、data，为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。 一个过滤列表中的action、category、data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别和data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。此外，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intenf-filter即可成功启动对应的Activity。 &lt;intent-filter&gt; &lt;action android:name=\"com.ryg.charpter_1.c\" /&gt; &lt;action android:name=\"com.ryg.charpter_1.d\" /&gt; &lt;category android:name=\"com.ryg.category.c\" /&gt; &lt;category android:name=\"com.ryg.category.d\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:mimeType=\"text/plain\" /&gt;&lt;/intent-filter&gt;~~~ - (2)action匹配规则 只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，action匹配区分大小写。- (3)category匹配规则 Intent中如果有category那么所有的category都必须和过滤规则中的其中一个category相同，如果没有category的话那么就是默认的category，即android.intent.category.DEFAULT，所以为了Activity能够接收隐式调用，配置多个category的时候必须加上默认的category。- (4)data匹配规则 data的结构很复杂，语法大致如下：~~~ Javascript&lt;data android:scheme=\"string\" android:host=\"string\" android:port=\"string\" android:path=\"string\"` android:pathPattern=\"string\" android:pathPrefix=\"string\" android:mimeType=\"string\" /&gt; 主要由mimeType和URI组成，其中mimeType代表媒体类型，而URI的结构也复杂，大致如下： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;]|[&lt;pathPrefix&gt;]|[pathPattern] 例如content://com.example.project:200/folder/subfolder/etc scheme、host、port分别表示URI的模式、主机名和端口号，其中如果scheme或者host未指定那么URI就无效。 path、pathPattern、pathPrefix都是表示路径信息，其中path表示完整的路径信息，pathPrefix表示路径的前缀信息；pathPattern表示完整的路径，但是它里面包含了通配符(*)。 data匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。 URI有默认的scheme！ 如果过滤规则中的mimeType指定为image/*或者text/*等这种类型的话，那么即使过滤规则中没有指定URI，URI有默认的scheme是content和file！如果过滤规则中指定了scheme的话那就不是默认的scheme了。 //URI有默认值&lt;intent-filter&gt; &lt;data android:mimeType=\"image/*\"/&gt; ...&lt;/intent-filter&gt; //URI默认值被覆盖&lt;intent-filter&gt; &lt;data android:mimeType=\"image/*\" android:scheme=\"http\" .../&gt; ...&lt;/intent-filter&gt; 如果要为Intent指定完整的data，必须要调用setDataAndType方法！ 不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。intent.setDataAndType(Uri.parse(\"file://abc\"), \"image/png\"); data的下面两种写法作用是一样的： &lt;intent-filter&gt; &lt;data android:scheme=\"file\" android:host=\"www.github.com\"/&gt;&lt;/intent-filter&gt;&lt;intent-filter&gt; &lt;data android:scheme=\"file\"/&gt; &lt;data android:host=\"www.github.com\"/&gt;&lt;/intent-filter&gt; 如何判断是否有Activity能够匹配我们的隐式Intent？ (1)PackageManager的resolveActivity方法或者Intent的resolveActivity方法：如果找不到就会返回null (2)PackageManager的queryIntentActivities方法：它返回所有成功匹配的Activity信息针对Service和BroadcastReceiver等组件，PackageManager同样提供了类似的方法去获取成功匹配的组件信息，例如queryIntentServices、queryBroadcastReceivers等方法 有一类action和category比较重要，它们在一起用来标明这是一个入口Activity，并且会出现在系统的应用列表中。 &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;&lt;/intent-filter&gt; 第2章 IPC机制2.1 Android IPC简介(1)任何一个操作系统都需要有相应的IPC机制，Linux上可以通过命名通道、共享内存、信号量等来进行进程间通信。Android系统不仅可以使用了Binder机制来实现IPC，还可以使用Socket实现任意两个终端之间的通信。 2.2 Android中的多进程模式 (1)通过给四大组件指定android:process属性就可以开启多进程模式. 默认进程的进程名是包名packageName，进程名以:开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以:开头的进程属于全局进程，其他应用通过ShareUID方法可以和它跑在同一个进程中。 android:process=”:xyz” //进程名是 packageName:xyz android:process=”aaa.bbb.ccc” //进程名是 aaa.bbb.ccc (2)Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。 两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。 在这种情况下，它们可以相互访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。如果它们跑在同一个进程中，还可以共享内存数据，它们看起来就像是一个应用的两个部分。 (3)android系统会为每个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，所以不同的虚拟机中访问同一个类的对象会产生多个副本。 (4)使用多进程容易造成以下几个问题： 1.静态成员和单例模式完全失效； 2.线程同步机制完全失效：无论锁对象还是锁全局对象都无法保证线程同步； 3.SharedPreferences的可靠性下降：SharedPreferences不支持并发读写； 4.Application会多次创建：当一个组件跑在一个新的进程的时候，系统要在创建新的进程的同时分配独立的虚拟机，应用会重新启动一次，也就会创建新的Application。运行在同一个进程中的组件是属于同一个虚拟机和同一个Application。 同一个应用的不同组件，如果它们运行在不同进程中，那么和它们分别属于两个应用没有本质区别。 2.3 IPC基础概念介绍 (1)Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口。 (2)serialVersionUId是一串long型数字，主要是用来辅助序列化和反序列化的，原则上序列化后的数据中的serialVersionUId只有和当前类的serialVersionUId相同才能够正常地被反序列化。 serialVersionUId的详细工作机制：序列化的时候系统会把当前类的serialVersionUId写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUId，看它是否和当前类的serialVersionUId一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUId的值。 1.静态成员变量属于类不属于对象，所以不参与序列化过程； 2.声明为transient的成员变量不参与序列化过程。 (3)Parcelable接口内部包装了可序列化的数据，可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例 public class Book implements Parcelable &#123; public int bookId; public String bookName; public Book() &#123; &#125; public Book(int bookId, String bookName) &#123; this.bookId = bookId; this.bookName = bookName; &#125; //“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0 public int describeContents() &#123; return 0; &#125; //实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0 public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(bookId); out.writeString(bookName); &#125; //实现反序列化操作 public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Parcelable.Creator&lt;Book&gt;() &#123; //从序列化后的对象中创建原始对象 public Book createFromParcel(Parcel in) &#123; return new Book(in); &#125; public Book[] newArray(int size) &#123;//创建指定长度的原始对象数组 return new Book[size]; &#125; &#125;; private Book(Parcel in) &#123; bookId = in.readInt(); bookName = in.readString(); &#125;&#125; (4)Binder是Android中的一个类，它实现了IBinder接口。 从IPC角度看，Binder是Android中一种跨进程通信的方式；Binder还可以理解为虚拟的物理设备，它的设备驱动是/dev/binder； 从Framework层角度看，Binder是ServiceManager连接各种Manager和相应的ManagerService的桥梁； 从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。 在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。 (5)aidl工具根据aidl文件自动生成的java接口的解析： 首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法； 接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。 所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法： 1.asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。 2.asBinder：返回当前Binder对象。 3.onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。 这个方法的原型是public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags) 服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。 4.Proxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是： 首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。 如果搞清楚了自动生成的接口文件的结构和作用之后，其实是可以不用通过AIDL而直接实现Binder的，主席写的示例代码 (6)Binder的两个重要方法linkToDeath和unlinkToDeath Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。 如何给Binder设置死亡代理呢？ 1.声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。 private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; if (mRemoteBookManager == null) return; mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0); mRemoteBookManager = null; // TODO:这里重新绑定远程Service &#125;&#125;; 2.在客户端绑定远程服务成功之后，给binder设置死亡代理 mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, 0); 2.4 Android中的IPC方式 (1)使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。 (2)使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。 SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。 (3)使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形，详细的示例见原书。 (4)使用AIDL 大致流程：首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。 1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL； 2.某些类即使和AIDL文件在同一个包中也要显式import进来； 3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout； 4.AIDL接口中支持方法，不支持声明静态变量； 5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。 6.RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。 (5)使用ContentProvider 1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表； 2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider； 3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行； 4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者； (6)使用Socket Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。 2.5 Binder连接池 (1)当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。 整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。 Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。 (2)作者实现的Binder连接池BinderPool的实现源码，建议在AIDL开发工作中引入BinderPool机制。 2.6 选用合适的IPC方式 第9章 四大组件的工作过程本篇摘选自amurocrash的专栏 9.1 四大组件的运行状态 (1)四大组件中只有BroadcastReceiver既可以在AndroidManifest文件中注册，也可以在代码中注册，其他三个组件都必须在AndroidManifest文件中注册；ContentProvider的调用不需要借助Intent，其他三个组件都需要借助Intent。 (2)Activity是一种展示型组件，用于向用户展示界面，可由显式或者隐式Intent来启动。 (3)Service是一种计算型组件，用于在后台执行计算任务。尽管service是用于后台执行计算的，但是它本身是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。Service组件有两种状态：启动状态和绑定状态。当service处于绑定状态时，外界可以很方便的和service进行通信，而在启动状态中是不可与外界通信的。 (4)BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息，它工作在系统内部。广播有两种注册方式：静态注册和动态注册。静态注册是在AndroidManifest中注册，在应用安装的时候会被系统解析，这种广播不需要应用启动就可以收到相应的广播。动态注册需要通过Context.registerReceiver()来注册，这种广播需要应用启动才能注册并接收广播。BroadcastReceiver组件一般来说不需要停止，它也没有停止的概念。 (5)ContentProvider是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。ContentProvider中的insert、delete、update、query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的，另外ContentProvider组件也不需要手动停止。 9.2 Activity的工作过程(1)Activity启动的大致流程 (2)ApplicationThread是ActivityThread的一个内部类，它继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口，ApplicationThreadNative的作用其实就和系统为AIDL文件生成的类是一样的。(3)ActivityManagerService(AMS)继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。(4)一个应用只有一个Application对象，它的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。(5)ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当window接收到外部输入事件后就可以将事件传递给Activity。 [这里可能有误，应该是Activity将事件传递给window] 9.3 Service的工作过程(1)Service有两种状态：启动状态和绑定状态，两种状态是可以共存的。启动过程： 绑定过程： 9.4 BroadcastReceiver的工作过程(1)BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。注册过程：静态注册的时候是由PackageManagerService来完成整个注册过程，下面是动态注册的过程发送和接收： (2)广播的发送有几种类型：普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是发送和接收过程是类似的。 (3)一个应用处于停止状态分为两种情况：一是应用安装后未运行；二是应用被手动或者其他应用强停了。从Android 3.1开始，处于停止状态的应用无法接受到开机广播。 9.5 ContentProvider的工作过程(1)当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。(2)ContentProvider的启动过程： 1.当一个应用启动时，入口方法是ActivityThread的main方法，其中创建ActivityThread的实例并创建主线程的消息队列； 2.ActivityThread的attach方法中会远程调用ActivityManagerService的attachApplication，并将ApplicationThread提供给AMS，ApplicationThread主要用于ActivityThread和AMS之间的通信； 3.ActivityManagerService的attachApplication会调用ApplicationThread的bindApplication方法，这个方法会通过H切换到ActivityThread中去执行，即调用handleBindApplication方法； 4.handleBindApplication方法会创建Application对象并加载ContentProvider，注意是先加载ContentProvider，然后调用Application的onCreate方法。 (3)ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。(4)当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程： 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/03/20/android-books-reading-/","categories":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/categories/read/"}],"tags":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/tags/read/"}]},{"title":"android新特性新知识点总结","slug":"android-new-knowledge-summary","date":"2016-03-19T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/03/20/android-new-knowledge-summary/","link":"","permalink":"http://agehua.github.io/2016/03/20/android-new-knowledge-summary/","excerpt":"一、mipmap 目录和drawable 目录有什么区别Nexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap： 二、setTranslucentStatus()方法在Android4.4之后使用沉浸式状态栏，需要用到这个方法","text":"一、mipmap 目录和drawable 目录有什么区别Nexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap： 二、setTranslucentStatus()方法在Android4.4之后使用沉浸式状态栏，需要用到这个方法 public class MainActivity extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //首先检测当前的版本是否是api&gt;=19的 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; setTranslucentStatus(true); &#125; SystemBarTintManager tintManager = new SystemBarTintManager(this); tintManager.setStatusBarTintEnabled(true); tintManager.setStatusBarTintColor(Color.parseColor(\"#FFC1E0\")); &#125; @TargetApi(19) private void setTranslucentStatus(boolean on) &#123; Window win = getWindow(); WindowManager.LayoutParams winParams = win.getAttributes(); final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS; if (on) &#123; winParams.flags |= bits; &#125; else &#123; winParams.flags &amp;= ~bits; &#125; win.setAttributes(winParams); &#125;&#125; 布局设置 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &lt;!--这两行是必须设置的--&gt; android:fitsSystemWindows=&quot;true&quot; android:clipToPadding=&quot;true&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#FFD9EC&quot; &gt; &lt;TextView android:text=&quot;沉浸式状态栏&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:textSize=&quot;23dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:gravity=&quot;center&quot; android:background=&quot;#FFD9EC&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/darker_gray&quot;/&gt;&lt;/LinearLayout&gt; 三、获取Bitmap图片大小的代码public int getBitmapSize(Bitmap bitmap)&#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123; //API 19 return bitmap.getAllocationByteCount(); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1)&#123;//API 12 return bitmap.getByteCount(); &#125; return bitmap.getRowBytes() * bitmap.getHeight(); //earlier version&#125; 四、Activity横竖屏切换生命周期总结： 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 验证： 1、新建一个Activity，并把各个生命周期打印出来 2、运行Activity，得到如下信息 onCreate--&gt;onStart--&gt;onResume--&gt; 3、按crtl+f12切换成横屏时 onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt; 4、再按crtl+f12切换成竖屏时，发现打印了两次相同的log onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt;onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt; 5、修改AndroidManifest.xml，把该Activity添加 android:configChanges=”orientation”，执行步骤3 onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt; 6、再执行步骤4，发现不会再打印相同信息，但多打印了一行onConfigChanged onSaveInstanceState--&gt;onPause--&gt;onStop--&gt;onDestroy--&gt;onCreate--&gt;onStart--&gt;onRestoreInstanceState--&gt;onResume--&gt;onConfigurationChanged--&gt; 7、把步骤5的android:configChanges=”orientation” 改成android:configChanges=”orientation|keyboardHidden”，执行步骤3，就只打印onConfigChanged onConfigurationChanged--&gt; 8、执行步骤4 onConfigurationChanged--&gt;onConfigurationChanged--&gt; 总结一下整个Activity的生命周期 1.补充一点，当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变 2.Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState –&gt; onPause –&gt; onStop onRestart –&gt;onStart—&gt;onResume 3.Activity未被完全覆盖只是失去焦点：onPause—&gt;onResume 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/03/20/android-new-knowledge-summary/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"近期总结facebook google+ Twitter sign-in fragment使用","slug":"facebook-google+signin","date":"2016-03-14T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/03/15/facebook-google+signin/","link":"","permalink":"http://agehua.github.io/2016/03/15/facebook-google+signin/","excerpt":"1.相关资料blog: 关于Google+以及Facebook第三方登录实现的一点总结 g+官方教程: G+ start facebook官方教程: Facebook start iCCP: Not recognizing known sRGB profile","text":"1.相关资料blog: 关于Google+以及Facebook第三方登录实现的一点总结 g+官方教程: G+ start facebook官方教程: Facebook start iCCP: Not recognizing known sRGB profile 今天做分享的时候遇到了这个问题： [2016-04-01 11:24:04 - Dex Loader] Unable to execute dex: method ID not in [0, 0xffff]: 65536 [2016-04-01 11:24:04 - VIVAT_SHARESDK] Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536 大项目中遇到的问题看这个博客 iCCP: Not recognizing known sRGB profile 删除png图片内嵌的iCCP profile sRGB报错 今天有碰见一个坑，改其他代码，然后在编译的时候就出现这个问题，对就是这个问题。网上查了资料，也就这个资料最全面，大家可以去看见http://my.oschina.net/1pei/blog/479162?fromerr=ARrUPlGS 处理这个问题我使用了一种方法，记录下来以便以后使用 步骤1:下载Image Magick http://www.imagemagick.com.cn/download.html.如果是windows的，请下载含dll的 步骤2： 在要处理的文件夹使用如下命令 ，一定要在要处理的文件夹使用 //WINDOWS使用set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe for /f \"tokens=*\" %i in ('dir/s/b *.png') do \"%fn%\" \"%i\" -strip \"%i\"（因为是window的，所以把%%i改为%i） //LINUX使用 set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe for /f \"tokens=*\" %%i in ('dir/s/b *.png') do \"%fn%\" \"%%i\" -strip \"%%i\" 2.遇到问题 1.“This client application’s callback url has been locked”. 使用Twitter signin时遇到了这个问题，这个错误信息是在logcat中找到的，原因是在Twitter的Settings里勾选了“Enable Callback Locking (It is recommended to enable callback locking to ensure apps cannot overwrite the callback url)”选项，这个选项表示不允许app本地更改callback url。也可看这个页面 3.add() vs. replace() 只有在Fragment数量大于等于2的时候，调用add()还是replace()的区别才能体现出来。 当通过add()连续两次添加Fragment的时候，每个Fragment生命周期中的onAttach()-onResume()都会被各调用一次，而且两个Fragment的View会被同时attach到containerView。 同样，退出Activty时，每个Fragment生命周期中的onPause()-onDetach()也会被各调用一次。 但当使用replace()来添加Fragment的时候，第二次添加会导致第一个Fragment被销毁，即执行第二个Fragment的onAttach()方法之前会先执行第一个Fragment的onPause()-onDetach()方法，同时containerView会detach第一个Fragment的View。 调用show() &amp; hide()方法时. Fragment的生命周期方法并不会被执行，仅仅是Fragment的View被显示或者​隐藏。而且，尽管Fragment的View被隐藏，但它在父布局中并未被detach，仍然是作为containerView的childView存在着。相比较下，attach() &amp; detach()做的就更彻底一些。一旦一个Fragment被detach()，它的onPause()-onDestroyView()周期都会被执行。 同时Fragment的View也会被detach。在重新调用attach()后，onCreateView()-onResume()周期也会被再次执行。 remove() 其实看完上面的分析，remove()方法基本也就明白了。相对应add()方法执行onAttach()-onResume()的生命周期，remove()就是完成剩下的onPause()-onDetach()周期。 4.FragmentTransaction add 和 replace 区别使用 FragmentTransaction 的时候，它提供了这样两个方法，一个 add ， 一个 replace .add 和 replace 影响的只是界面，而控制回退的，是事务。 add 是把一个fragment添加到一个容器 container 里。 Add a fragment to the activity state. This fragment may optionally also have its view (if Fragment.onCreateView returns non-null) into a container view of the activity. public abstract FragmentTransaction add (int containerViewId, Fragment fragment, String tag) replace 是先remove掉相同id的所有fragment，然后在add当前的这个fragment。 Replace an existing fragment that was added to a container. This is essentially the same as calling remove(Fragment) for all currently added fragments that were added with the same containerViewId and then add(int, Fragment, String) with the same arguments given here. public abstract FragmentTransaction replace (int containerViewId, Fragment fragment, String tag) 在大部分情况下，这两个的表现基本相同。因为，一般，咱们会使用一个FrameLayout来当容器，而每个Fragment被add 或者 replace 到这个FrameLayout的时候，都是显示在最上层的。所以你看到的界面都是一样的。但是，使用add的情况下，这个FrameLayout其实有2层，多层肯定要比一层的来得浪费，所以还是推荐使用replace。当然有时候还是需要使用add的。比如要实现轮播图的效果，每个轮播图都是一个独立的Fragment，而他的容器FrameLayout需要add多个Fragment，这样他就可以根据提供的逻辑进行轮播了。 而至于返回键的时候，这个跟事务有关，跟使用add还是replace没有任何关系。 5.要想fragment完整地执行生命周期fragment跳转是要使用replace()方法，并一定要指定tag，否则有些方法不会执行（比如onResume），例如： getFragmentManager() .beginTransaction() .replace(R.id.base_container, inputVerifyCodeFragment,\"tag_code\") .addToBackStack(null).commit(); 6.fragment事件穿透如果发现fragment2的点击事件可以被fragment栈下一层的fragment1获取到，可以在fragment2布局的根部加上：android:clickable=”true”。问题解决 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/03/15/facebook-google+signin/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"android Google map使用总结","slug":"android-googlemap-summary","date":"2016-02-29T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2016/03/01/android-googlemap-summary/","link":"","permalink":"http://agehua.github.io/2016/03/01/android-googlemap-summary/","excerpt":"1.在代码中编译google map要想编译编译google map必须使用Google map api。并在自己的工程中引入google-play-services_lib。两个都需要在SDK Manager中下载。前者要在对应android api中勾选，后者要勾选在Extras下的Google Play Service。 要注意的是map2.0要使用com.google.android.gms包名下的类 Google Maps Android API 使用OpenGL ES第2版来渲染地图。如果未安装OpenGL ES第2版，地图将不会出现。可以在 AndroidManifest.xml 中添加以下元素作为元素的子元素来过滤不能支持的手机： &lt;uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\"/&gt;","text":"1.在代码中编译google map要想编译编译google map必须使用Google map api。并在自己的工程中引入google-play-services_lib。两个都需要在SDK Manager中下载。前者要在对应android api中勾选，后者要勾选在Extras下的Google Play Service。 要注意的是map2.0要使用com.google.android.gms包名下的类 Google Maps Android API 使用OpenGL ES第2版来渲染地图。如果未安装OpenGL ES第2版，地图将不会出现。可以在 AndroidManifest.xml 中添加以下元素作为元素的子元素来过滤不能支持的手机： &lt;uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\"/&gt; 2.在编码中遇到的问题1.可以实现OnCameraChangeListener接口，来实现对相机状态的监听，比如我就记录下了地图缩放的大小 @Overridepublic void onCameraChange(CameraPosition arg0) &#123; // TODO Auto-generated method stub zoom = arg0.zoom;&#125; 2.向将处理地图的 Activity 添加 Fragment 对象。 最简单的实现方式是，向Activity 的布局文件添加 元素。 3.实现 OnMapReadyCallback 接口，并使用onMapReady(GoogleMap)回调方法获取GoogleMap对象的句柄。GoogleMap对象是对地图本身的内部表示。如需设置地图的视图选项，可以使用UiSettings设置地图的样式。 4.调用Fragment上的getMapAsync()以注册回调。 5.使用手机定位，定位成功后再map上显示标记： MarkerOptions markerOpt = new MarkerOptions(); markerOpt.position(new LatLng(geoLat, geoLng)); markerOpt.draggable(false); markerOpt.visible(true); markerOpt.anchor(0.5f, 0.5f);//设为图片中心 markerOpt.icon(BitmapDescriptorFactory .fromResource(R.drawable.sos_location_38x53)); mMap.addMarker(markerOpt); //将摄影机移动到指定的地理位置 cameraPosition = new CameraPosition.Builder() .target(new LatLng(geoLat, geoLng)) // Sets the center of the map to ZINTUN .zoom(zoom) // 缩放比例 .bearing(0) // Sets the orientation of the camera to east .build(); // Creates a CameraPosition from the builder mMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition));~~~ 6.实现地图圆角效果：使用圆角.9图片，中间透明，圆角四周不透明&lt;br&gt;详细可以看这个提问：[Is there a way to implement rounded corners to a Mapfragment?](http://stackoverflow.com/questions/14469208/is-there-a-way-to-implement-rounded-corners-to-a-mapfragment)7.去掉google地图自带的蓝色圆点GoogleMap.setMyLocationEnabled(false);8.解决mapview与scrollview嵌套滑动的问题：思路就是使用getParent().requestDisallowInterceptTouchEvent(true);方法，让子类接收到touch事件~~~ Javapublic class MyMapView extends MapView &#123; private ViewParent mViewParent; public MyMapView(Context context) &#123; super(context); &#125; public MyMapView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyMapView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; public MyMapView(Context context, GoogleMapOptions options) &#123; super(context, options); &#125; public void setViewParent(@Nullable final ViewParent viewParent) &#123; //any ViewGroup mViewParent = viewParent; &#125; @Override public boolean onInterceptTouchEvent(final MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (null == mViewParent) &#123; //设置父类不拦截touch事件，子view可以接收到touch事件 getParent().requestDisallowInterceptTouchEvent(true); &#125; else &#123; mViewParent.requestDisallowInterceptTouchEvent(true); &#125; break; case MotionEvent.ACTION_UP: if (null == mViewParent) &#123; //让父类拦截touch事件 getParent().requestDisallowInterceptTouchEvent(false); &#125; else &#123; mViewParent.requestDisallowInterceptTouchEvent(false); &#125; break; default: break; &#125; return super.onInterceptTouchEvent(event); &#125;&#125; 9.LocationListener，一直回调到onProviderDisabled 有可能是因为手机没有开启定位服务，解决办法是： @Overridepublic void onProviderDisabled(String provider) &#123; isLocatedSuccess = false; if (provider.equals(\"network\")) //跳到位置服务设置页面 startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));&#125; 3.在真机上测试效果需要在真机上安装这两个包：com.android.vending.apk（Google play store）和com.google.android.gms.apk（Google play services）可以在国内应用市场上去搜索最新版本，也可以使用我上传的文件： 链接：http://pan.baidu.com/s/1i5q8jo5 密码：solm 安装成功以后，再运行自己的程序，查看效果了 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2016/03/01/android-googlemap-summary/","categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"2015阅读书单","slug":"book-list-of-2015","date":"2015-11-05T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":true,"path":"2015/11/06/book-list-of-2015/","link":"","permalink":"http://agehua.github.io/2015/11/06/book-list-of-2015/","excerpt":"","text":"本文链接：http://agehua.github.io/2015/11/06/book-list-of-2015/","categories":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/categories/read/"}],"tags":[{"name":"read","slug":"read","permalink":"http://agehua.github.io/tags/read/"}]},{"title":"java多线程和并发面试问答","slug":"java-multithreading-concurrent","date":"2015-03-15T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2015/03/16/java-multithreading-concurrent/","link":"","permalink":"http://agehua.github.io/2015/03/16/java-multithreading-concurrent/","excerpt":"本文基于酷勤网关于java多线程和并发面试题的文章，进行了少量的整理和补充。原文在这。 以下是正文： 多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。","text":"本文基于酷勤网关于java多线程和并发面试题的文章，进行了少量的整理和补充。原文在这。 以下是正文： 多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。 Java多线程面试问题1. 什么是进程和线程？进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。 2. 进程和线程之间有什么不同？一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 形象的讲，进程就是一个项目组，每个程序员就是里面的线程呀！当然一个程序员也可以叫做一个项目组，对应的就是一个进程只有一个线程。公司里面的任务是分配给项目组级别的，干活的就是其中的程序员。总的意思就是，进程和线程没有什么区别。吐槽的话：我的意思就是进程干不过来了，那就多开几个线程呀！from JacobK 3. 多线程编程的好处是什么？ 在进程内创建、终止线程比创建、终止进程要快； 同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。 在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。 4. 用户线程和守护线程有什么区别？当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出（与守护线程是否在运行没有关系）。一个守护线程创建的子线程依然是守护线程。守护线程应用背景：后台线程，比如可以收集某些系统状态的线程，发送email的线程，等不希望影响JVM的事情。 5. 我们如何创建一个线程？有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。Read more… 6. 有哪些不同的线程生命周期？当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked和Dead。Read more… 新建（new Thread）：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：Thread t1=new Thread(); 就绪（runnable）：线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start(); 运行（running）：线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。 死亡（dead）：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。 自然终止：正常运行run()方法后终止 异常终止：调用stop()方法让一个线程终止运行 堵塞（blocked）：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。 正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。 正在等待：调用wait()方法。（调用motify()方法回到就绪状态） 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复） 7. 可以直接调用Thread类的run()方法么？可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread。start()方法。 8. 如何让正在运行的线程暂停一段时间？我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。 9. 你对线程优先级的理解是什么？线程的优先级越高，那么就可以分占相对多的CPU时间片。每个进程都有相应的优先级，线程优先级决定它何时运行和占用CPU时间。最终的优先级共分32级。是从0到31的数值，称为 基本优先级别。OS调度的是线程，真正具有优先级的是线程，而进程优先级是作为一个优先级Class存在。一个线程创建的时候，会继承进程的优先级。 外线程优先级可以用SetThreadPriority来进行微调。常用的桌面系统，都是分时操调度，根据线程的优先级来分配调度时间。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。 10. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 11. 在多线程中，什么是上下文切换(context-switching)？上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。 12. 你如何确保main()方法所在的线程是Java程序最后结束的线程？我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。Read more… 线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。在join()方法内设定超时，使得join()方法的影响在特定超时后无效。当超时时，主方法和任务线程申请运行的时候是平等的。然而，当涉及sleep时，join()方法依靠操作系统计时，所以你不应该假定join()方法将会等待你指定的时间。 13.线程之间是如何通信的？线程间通信有三种方式： a. 使用全局变量。进程中的线程间内存共享，这是比较常用的通信方式和交互方式。主要由于多个线程可能更改全局变量，因此全局变量最好声明为violate b. 使用消息实现通信。在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。 1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20; 2)添加消息函数声明afx_msg int OnTSendmsg();3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)4)添加OnTSM()的实现函数；5)在线程函数中添加PostMessage消息Post函数 c. 使用事件CEvent类实现线程间通信。Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。 1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；2)threadStart.SetEvent();使其处于通信状态；3)调用WaitForSingleObject()来监视CEvent对象 当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()notify()notifyAll()方法可以用于线程间通信关于资源的锁的状态。Read more 14. 进程间通信方式及特点？进程是转入内存并准备执行的程序，每个程序都有私有的虚拟地址空间，由代码，数据以及它可利用的系统资源(如文件，管道)组成。多进程/多线程是windows操作系统的一个基本特征。Linux系统一般都统称为进程。 由于不同的进程运行在各自不同的内存空间中，其中一个进程对于变量的修改另一方是无法感知的，因此，进程之间的消息传递不能通过变量或其他数据结构直接进行，只能通过进程间通信来完成。进程间通信是指不同进程间进行数据共享和数据交换。 进程间通信方式：文件和记录锁定，管道，有名管道，FIFO，信号量，信号，消息队列，共享内存，套接字。[^14] Read Read Read… 15. 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法 16. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 17. 为什么Thread类的sleep()和yield()方法是静态的？Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。 18. 如何确保线程安全？在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。Read more 19. volatile关键字在Java中有什么作用？当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。 20. 同步方法和同步块，哪个是更好的选择？同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 21. 如何创建守护线程？使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。 22. 什么是ThreadLocal?ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。 每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。Read more。 23. 什么是死锁(Deadlock)？如何避免死锁？死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。死锁的四个必要条件： 互斥（Mutual exclusion）：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用； 持有（Hold and wait）：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源； 不可剥夺（No preemption）：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源； 环形等待（Circular wait）：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。 在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁。目前处理死锁的方法可归结为四种 24. 什么是线程池？如何创建一个Java线程池？一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。 java.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。如何创建和使用线程池 Java并发面试问题1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。Read more。 2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有： 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 3. 什么是Executors框架？Executor框架同java.util.concurrent.Executor 接口在Java5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。Read more 4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。 阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。 阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。 BlockingQueue接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。使用阻塞队列实现生产者-消费者问题。 5. 什么是并发容器的实现？Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。 并发容器支持并发的遍历和并发的更新。 主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet。 6. Executors类是什么？Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。 Executors可以用于方便的创建线程池。 好文推荐秒杀多线程面试题系列进程通信方式及特点 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2015/03/16/java-multithreading-concurrent/","categories":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/categories/technology/"}],"tags":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/tags/accumulation/"}]},{"title":"Android优秀开源项目【持续更新】","slug":"android-open-sources","date":"2015-01-26T16:00:00.000Z","updated":"2017-03-02T03:28:04.000Z","comments":true,"path":"2015/01/27/android-open-sources/","link":"","permalink":"http://agehua.github.io/2015/01/27/android-open-sources/","excerpt":"一直想找些Android经典的开源项目学习一下，大健发现了这么一篇帖子，不少好东西，分享在此。希望能够对Android开发的同学有所帮助。感谢作者的整理和分享。tisa007原帖在这里。 项目篇： Apollo音乐播放器：就一个播放器，但是实现的很好 oschina客户端：oschina网站的客户端哦，wp版，iOS版都有开源 xabber实时聊天工具（基于xmpp协议）：不评价了，反正算是同类中比较好的了 四次元新浪微博客户端：今天才知道是开源的，赶紧收藏 Google IO：谷歌开发者大会应用，虽然有点难懂，还是很有参考价值（比如其中的图片加载） eoe客户端：eoe网站Android客户端也开源咯，嘿嘿","text":"一直想找些Android经典的开源项目学习一下，大健发现了这么一篇帖子，不少好东西，分享在此。希望能够对Android开发的同学有所帮助。感谢作者的整理和分享。tisa007原帖在这里。 项目篇： Apollo音乐播放器：就一个播放器，但是实现的很好 oschina客户端：oschina网站的客户端哦，wp版，iOS版都有开源 xabber实时聊天工具（基于xmpp协议）：不评价了，反正算是同类中比较好的了 四次元新浪微博客户端：今天才知道是开源的，赶紧收藏 Google IO：谷歌开发者大会应用，虽然有点难懂，还是很有参考价值（比如其中的图片加载） eoe客户端：eoe网站Android客户端也开源咯，嘿嘿 软件篇： Android-Flip：可以实现类似FlipBoard那种华丽丽的翻页 Drag-Sort-Listview：可以拖动item重新排序的listview，效果非常赞 HoloEveryWhere：咳咳，有些同学非常喜欢Android的holo风格，这个项目绝对让你happy Universal-ImageLoader：这个经典的异步图片加载，不多说了 JazzyViewPager：这玩意可以让ViewPager翻起来更酷，谁用谁知道~~ SlidingMenu：这个是抽屉界面（就是facebook那种）的各种实现版本中，最好的，木有之一！ StickyListHeaders：iPhone上经常有这个，就是listview的……不知道怎么解释，自己下载看看吧 Android-PullToRefresh：下拉刷新，挺常用的一个组件 StaggeredGridView：这是一个瀑布流布局的实现，还不是很完善，但作为学习的案例或者在其基础上扩展还是不错的 android-async-http：android的异步请求组件，我个人习惯使用asynctask，不过这个实现还是很优秀的，也推荐给大家 ActionBarSherlock：大家熟知的ActionBar在2.x上的兼容性方案；类似的兼容性组件还有许多，有时间为大家一一列出； facebook-android-sdk：不止是一个SDK那么简单哦，比某浪和某人的SDK强几个数量级； NineOldAndroids：想在2.xSDK上使用Android 3.0新增的动画API，那就是它了；没用过的同学一定要试试哦，非常方便~ android-swipelistview：让listview的item可以向右滑动，新版Gmail和Pocket里面有用到哦~ DataDroid：Android的RESTful封装，没听过RESTful？你去死吧 EventBus：和上面的DataDroid同样属于美化底层代码的，这个lib简化了不同组件之间的事件传递 android-switch-backport：Android3.0以上才有的switch，有好心人给迁移到2.x上了，哈 PagerSlidingTabStrip：最新版的GooglePlay的那个tab效果，可炫可炫了 chromeview：我们都知道webview，也知道Android的chrome又自己的内核，这个项目就是把chrome的内核给导出来做成一个chromeview了，大家可以在自己的项目里用，有兴趣的可以玩玩 picasso：来自square的图片异步加载，好像是最近才开源的，API风格很独特，哥很喜欢~ 顺便推荐大家几个网站： github：各种项目很多，就是不容易挖掘，但是开发者必备 oschina：曾经一般，现在越做越好了，很多开源项目； eoeandroid：经过一番整理，现在非常强大；小作品居多； AndroidViews：我曾经想做这么一个网站来着，很多开源组件的集合，嘿嘿 vogella:国外的一个教程网站，不是逗小孩玩的那种哦~ 大家都说github上面的项目不容易发现，但其实还是有办法的，比如：关注java项目排名：大家戳 这个网址搜索“Android”，并按star排序：戳 这里 直达最后，还有一招，就是关注些牛人，他们通常会关注或fork一些很有水平的项目。 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2015/01/27/android-open-sources/","categories":[{"name":"accumulation","slug":"accumulation","permalink":"http://agehua.github.io/categories/accumulation/"}],"tags":[{"name":"technology","slug":"technology","permalink":"http://agehua.github.io/tags/technology/"}]},{"title":"Hello World","slug":"hello-world","date":"2014-12-22T16:00:00.000Z","updated":"2017-02-15T01:26:00.000Z","comments":true,"path":"2014/12/23/hello-world/","link":"","permalink":"http://agehua.github.io/2014/12/23/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 本文采用知识共享署名 2.5 中国大陆许可协议进行许可，欢迎转载，但转载请注明来自Agehua’s Blog，并保持转载后文章内容的完整。本人保留所有版权相关权利。 本文链接：http://agehua.github.io/2014/12/23/hello-world/","categories":[],"tags":[]}]}