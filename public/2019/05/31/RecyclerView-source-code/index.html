<!DOCTYPE html>
<html lang=en>
<head>
    <meta name="google-site-verification" content="TYEtqE2Xc2ZonkJumwKut0-iq4RVbEc8o5Y8HpmZ-eo" />
    <meta name="baidu-site-verification" content="8WKGBCPPKp" />
    <meta charset="utf-8">
    
    <title>RecyclerView 源码分析 | Agehua</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本文承接上文《RecyclerView 中的设计模式》，结合源码分析Recyclerview绘制、滑动、和缓存等逻辑">
<meta name="keywords" content="RecyclerView">
<meta property="og:type" content="article">
<meta property="og:title" content="RecyclerView 源码分析">
<meta property="og:url" content="http://agehua.github.io/2019/05/31/RecyclerView-source-code/index.html">
<meta property="og:site_name" content="Agehua">
<meta property="og:description" content="本文承接上文《RecyclerView 中的设计模式》，结合源码分析Recyclerview绘制、滑动、和缓存等逻辑">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://cdn.conorlee.top/Farmhouse%20in%20a%20Wheat%20Field.jpg">
<meta property="og:updated_time" content="2020-09-01T07:45:18.919Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RecyclerView 源码分析">
<meta name="twitter:description" content="本文承接上文《RecyclerView 中的设计模式》，结合源码分析Recyclerview绘制、滑动、和缓存等逻辑">
<meta name="twitter:image" content="http://cdn.conorlee.top/Farmhouse%20in%20a%20Wheat%20Field.jpg">
    

    
        <link rel="alternate" href="/" title="Agehua" type="application/atom+xml" />
    

    
        <link rel="icon" href="/images/favicon.ico" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    




    <link rel="icon" sizes="192x192" href="images/icon.png">
    <meta name="theme-color" content="#f9de6b">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-39647668-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-39647668-2');
    </script>
    <!--text spacing-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/3.3.0/pangu.min.js"></script>

</head>



<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Agehua</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                

                <a class="main-nav-link" href='javascript:(
        /*
         * Copyright (C) 2015 Rocko (rocko.xyz) <rocko.zxp@gmail.com>
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *      http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        function go() {


        var songs = [
                    "https://static.rocko.xyz/audio/Music-Wake-Live.mp3",
                    "https://static.rocko.xyz/audio/Music-Fashion_Show.mp3",
                    "https://static.rocko.xyz/audio/Music-outside.mp3",
                    "https://static.rocko.xyz/audio/Music-sunburst.mp3"
        ];


        function c() {
            var e = document.createElement("link");
            e.setAttribute("type", "text/css");
            e.setAttribute("rel", "stylesheet");
            e.setAttribute("href", f);
            e.setAttribute("class", l);
            document.body.appendChild(e)
        }

        function h() {
            var e = document.getElementsByClassName(l);
            for (var t = 0; t < e.length; t++) {
                document.body.removeChild(e[t])
            }
        }

        function p() {
            var e = document.createElement("div");
            e.setAttribute("class", a);
            document.body.appendChild(e);
            setTimeout(function() {
                document.body.removeChild(e)
            }, 100)
        }

        function d(e) {
            return {
                height : e.offsetHeight,
                width : e.offsetWidth
            }
        }

        function v(i) {
            var s = d(i);
            return s.height > e && s.height < n && s.width > t && s.width < r
        }

        function m(e) {
            var t = e;
            var n = 0;
            while (!!t) {
                n += t.offsetTop;
                t = t.offsetParent
            }
            return n
        }

        function g() {
            var e = document.documentElement;
            if (!!window.innerWidth) {
                return window.innerHeight
            } else if (e && !isNaN(e.clientHeight)) {
                return e.clientHeight
            }
            return 0
        }

        function y() {
            if (window.pageYOffset) {
                return window.pageYOffset
            }
            return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
        }

        function E(e) {
            var t = m(e);
            return t >= w && t <= b + w
        }

        function S() {
            var e = document.getElementById("audio_element_id");
            if(e != null){
                var index = parseInt(e.getAttribute("curSongIndex"));
                if(index > songs.length - 2) {
                    index = 0;
                } else {
                    index++;
                }
                e.setAttribute("curSongIndex", index);
                N();
            }

            e.src = i;
            e.play()
        }

        function x(e) {
            e.className += " " + s + " " + o
        }

        function T(e) {
            e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
        }

        function N() {
            var e = document.getElementsByClassName(s);
            var t = new RegExp("\\b" + s + "\\b");
            for (var n = 0; n < e.length; ) {
                e[n].className = e[n].className.replace(t, "")
            }
        }

        function initAudioEle() {
            var e = document.getElementById("audio_element_id");
            if(e === null){
                e = document.createElement("audio");
                e.setAttribute("class", l);
                e.setAttribute("curSongIndex", 0);
                e.id = "audio_element_id";
                e.loop = false;
                e.bgcolor = 0;
                e.addEventListener("canplay", function() {
                setTimeout(function() {
                    x(k)
                }, 500);
                setTimeout(function() {
                    N();
                    p();
                    for (var e = 0; e < O.length; e++) {
                        T(O[e])
                    }
                }, 15500)
            }, true);
            e.addEventListener("ended", function() {
                N();
                h();
                go();
            }, true);
            e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
            document.body.appendChild(e);
            }
        }

        initAudioEle();
        var e = 30;
        var t = 30;
        var n = 350;
        var r = 350;

        var curSongIndex = parseInt(document.getElementById("audio_element_id").getAttribute("curSongIndex"));
        var i = songs[curSongIndex];

        var s = "mw-harlem_shake_me";
        var o = "im_first";
        var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
        var a = "mw-strobe_light";

        /* harlem-shake-style.css，替换成你的位置，也可以直接使用：//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css */
        var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";

        var l = "mw_added_css";
        var b = g();
        var w = y();
        var C = document.getElementsByTagName("*");
        var k = null;
        for (var L = 0; L < C.length; L++) {
            var A = C[L];
            if (v(A)) {
                if (E(A)) {
                    k = A;
                    break
                }
            }
        }
        if (A === null) {
            console.warn("Could not find a node of the right size. Please try a different page.");
            return
        }
        c();
        S();
        var O = [];
        for (var L = 0; L < C.length; L++) {
            var A = C[L];
            if (v(A)) {
                O.push(A)
            }
        }
        })()'>High一下</a>
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="http://cdn.conorlee.top/profile.jpeg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            

            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>


        </div>
    </div>


    <div id="main-nav-mobile" class="header-sub header-inner">

        <table class="menu outer">


            <tr>
                
                    <td><a class="main-nav-link" href="/">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>

    
</header>

        <div class="outer">
            
                


<aside id="profile">
    <div class="inner profile-inner" id="profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="http://cdn.conorlee.top/profile.jpeg" />
            <h2 id="name">Conor Lee</h2>
            <h3 id="title">Android Developer &amp; Web Enthusiast</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Beijing, China</span>
            <a id="follow" target="_blank" href="https://github.com/agehua/">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                76
                <span>posts</span>
            </div>
            <div class="article-info-block">
                90
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="http://github.com/agehua" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="twitter" class=tooltip>
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        

        <a href="https://github.com/agehua" class="github-corner" aria-label="View source on Github">
          <svg width="64" height="64" viewBox="0 0 250 250" style="fill:#cba11f; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
          </svg>
        </a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

<div id='toc-col' class="toc-col">
    
          <div id='toc-wrap' class="toc-wrap">
              <strong class="toc-title">文章目录</strong>
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#绘制详情"><span class="toc-number">1.</span> <span class="toc-text">绘制详情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#补充MeasureSpect三种模式"><span class="toc-number">1.1.</span> <span class="toc-text">补充MeasureSpect三种模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatchLayoutStep1"><span class="toc-number">1.2.</span> <span class="toc-text">dispatchLayoutStep1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatchLayoutStep2"><span class="toc-number">1.3.</span> <span class="toc-text">dispatchLayoutStep2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatchLayoutStep3"><span class="toc-number">1.4.</span> <span class="toc-text">dispatchLayoutStep3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setAdapter-适配器模式"><span class="toc-number">1.5.</span> <span class="toc-text">setAdapter(适配器模式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#滑动"><span class="toc-number">1.6.</span> <span class="toc-text">滑动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存逻辑"><span class="toc-number">1.7.</span> <span class="toc-text">缓存逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与AdapterView比较"><span class="toc-number">2.</span> <span class="toc-text">与AdapterView比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#点击事件"><span class="toc-number">2.1.</span> <span class="toc-text">点击事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分割线"><span class="toc-number">2.2.</span> <span class="toc-text">分割线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#布局类型"><span class="toc-number">2.3.</span> <span class="toc-text">布局类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存方式"><span class="toc-number">2.4.</span> <span class="toc-text">缓存方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#局部刷新"><span class="toc-number">2.5.</span> <span class="toc-text">局部刷新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动画"><span class="toc-number">2.6.</span> <span class="toc-text">动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套布局"><span class="toc-number">2.7.</span> <span class="toc-text">嵌套布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#头部与尾部的支持"><span class="toc-number">2.8.</span> <span class="toc-text">头部与尾部的支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多选"><span class="toc-number">2.9.</span> <span class="toc-text">多选</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">2.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计精巧的类"><span class="toc-number">3.</span> <span class="toc-text">设计精巧的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bucket"><span class="toc-number">3.1.</span> <span class="toc-text">Bucket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pools"><span class="toc-number">3.2.</span> <span class="toc-text">Pools</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
          </div>
    
</div>
</aside>

<script type="text/javascript">
/*
    滚动函数
    接收三个参数,
        1 接收一个DOM对象
        2 给目标对象切换class
        3 触发的高度 (可选项,如果不指定高度,会将DOM的高度作为触发高度)
*/
function scrollCheck(scrollTarget, toggleClass, scrollHeight){
    document.addEventListener('scroll',function(){
    var currentTop = window.pageYOffset;
        currentTop > (scrollHeight||scrollTarget.clientHeight)
        ?scrollTarget.classList.add(toggleClass)
        :scrollTarget.classList.remove(toggleClass)
    })
}

(function(){
      try {
        document.getElementById("toc-wrap").style.width= document.getElementById("profile-inner").offsetWidth+ "px";
        var introHeader = document.querySelector('.inner.profile-inner').offsetHeight;
        var toc = document.querySelector('.toc-wrap');
        scrollCheck(toc,'toc-fixed',introHeader+40+64);
      }catch(err){

      }
        // var node = document.querySelector('.profile-inner');
        // scrollCheck(node,'profile-inner-fixed',64);
})();
</script>

            
            <section id="main"><article id="post-RecyclerView-source-code" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-inner">
        
            
	
		<img src="http://cdn.conorlee.top/Farmhouse%20in%20a%20Wheat%20Field.jpg" class="article-banner" />
	



        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            RecyclerView 源码分析
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/05/31/RecyclerView-source-code/">
            <time datetime="2019-05-30T16:00:00.000Z" itemprop="datePublished">2019-05-31</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/accumulation/">accumulation</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/recyclerview/">RecyclerView</a>
    </div>


                        <div style="color:#cba11f;float:right">30 min read , Words: 5864</div>                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        

            <blockquote>
<p>本文承接上文<a href="/2019/05/30/RecyclerView-Design-Pattern/">《RecyclerView 中的设计模式》</a>，结合源码分析Recyclerview绘制、滑动、和缓存等逻辑</p>
</blockquote>
<a id="more"></a>
<p>RecyclerView的代码设计结构，如下面两张图：</p>
<p><img src="/images/blogimages/2019/Recyclerview-source-code.png" alt="RecyclerView的代码设计结构"><br><img src="/images/blogimages/2019/Recyclerview-source-code1.png" alt="RecyclerView的代码设计结构"></p>
<ul>
<li>RecyclerViewDataObserver 数据观察器</li>
<li>Recycler View循环复用系统，核心部件</li>
<li>SavedState RecyclerView状态</li>
<li>AdapterHelper 适配器更新</li>
<li>ChildHelper 管理子View</li>
<li>ViewInfoStore 存储子VIEW的动画信息</li>
<li>Adapter 数据适配器</li>
<li>LayoutManager 负责子VIEW的布局，核心部件</li>
<li>ItemAnimator Item动画</li>
<li>ViewFlinger 快速滑动管理</li>
<li>NestedScrollingChildHelper 管理子VIEW嵌套滑动</li>
</ul>
<h3 id="绘制详情"><a href="#绘制详情" class="headerlink" title="绘制详情"></a>绘制详情</h3><p>可见RecyclerView涉及的类相当多，所以看代码的时候很容易迷失。因此我们需要抽丝剥茧，按照主线来进行分析。一般我们使用的时候是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">recyclerView = (RecyclerView) findViewById(R.id.recyclerView);  </span><br><span class="line">LinearLayoutManager layoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);  </span><br><span class="line"><span class="comment">//设置布局管理器  </span></span><br><span class="line">recyclerView.setLayoutManager(layoutManager);  </span><br><span class="line"><span class="comment">//设置为垂直布局，这也是默认的  </span></span><br><span class="line">layoutManager.setOrientation(OrientationHelper. VERTICAL);  </span><br><span class="line"><span class="comment">//设置Adapter  </span></span><br><span class="line">recyclerView.setAdapter( recycleAdapter);  </span><br><span class="line"> <span class="comment">//设置分隔线  </span></span><br><span class="line">recyclerView.addItemDecoration( <span class="keyword">new</span> DividerGridItemDecoration(<span class="keyword">this</span> ));  </span><br><span class="line"><span class="comment">//设置增加或删除条目的动画  </span></span><br><span class="line">recyclerView.setItemAnimator( <span class="keyword">new</span> DefaultItemAnimator());</span><br></pre></td></tr></table></figure>
<p>首先recyclerView = (RecyclerView) findViewById(R.id.recyclerView);会执行其构造方法,我们看一下干了些什么事:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RecyclerView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">    setScrollContainer(<span class="keyword">true</span>);</span><br><span class="line">    setFocusableInTouchMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> version = Build.VERSION.SDK_INT;</span><br><span class="line">    mPostUpdatesOnAnimation = version &gt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</span><br><span class="line">    mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line">    mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line">    mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line">    setWillNotDraw(ViewCompat.getOverScrollMode(<span class="keyword">this</span>) == ViewCompat.OVER_SCROLL_NEVER);</span><br><span class="line">    mItemAnimator.setListener(mItemAnimatorListener);</span><br><span class="line">    initAdapterManager();</span><br><span class="line">    initChildrenHelper();</span><br><span class="line">    <span class="comment">// If not explicitly specified this view is important for accessibility.</span></span><br><span class="line">    <span class="keyword">if</span> (ViewCompat.getImportantForAccessibility(<span class="keyword">this</span>)</span><br><span class="line">            == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</span><br><span class="line">        ViewCompat.setImportantForAccessibility(<span class="keyword">this</span>,</span><br><span class="line">                ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);</span><br><span class="line">    &#125;</span><br><span class="line">    mAccessibilityManager = (AccessibilityManager) getContext()</span><br><span class="line">            .getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class="line">    setAccessibilityDelegateCompat(<span class="keyword">new</span> RecyclerViewAccessibilityDelegate(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// Create the layoutManager if specified.</span></span><br><span class="line">    <span class="keyword">boolean</span> nestedScrollingEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> defStyleRes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取布局属性值</span></span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,</span><br><span class="line">                defStyle, defStyleRes);</span><br><span class="line">        String layoutManagerName = a.getString(R.styleable.RecyclerView_layoutManager);</span><br><span class="line">        a.recycle();</span><br><span class="line">        createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            a = context.obtainStyledAttributes(attrs, NESTED_SCROLLING_ATTRS,</span><br><span class="line">                    defStyle, defStyleRes);</span><br><span class="line">            nestedScrollingEnabled = a.getBoolean(<span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">            a.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Re-set whether nested scrolling is enabled so that it is set on all API levels</span></span><br><span class="line">    setNestedScrollingEnabled(nestedScrollingEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码进行了一系列的初始化工作,关键是createLayoutManager,创建了一个布局管理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createLayoutManager</span><span class="params">(Context context, String className, AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果布局属性存在</span></span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">        className = className.trim();</span><br><span class="line">        <span class="keyword">if</span> (className.length() != <span class="number">0</span>) &#123;  <span class="comment">// Can't use isEmpty since it was added in API 9.</span></span><br><span class="line">            className = getFullClassName(context, className);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ClassLoader classLoader;</span><br><span class="line">                <span class="keyword">if</span> (isInEditMode()) &#123;</span><br><span class="line">                    <span class="comment">// Stupid layoutlib cannot handle simple class loaders.</span></span><br><span class="line">                    classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    classLoader = context.getClassLoader();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据布局属性值设置的layoutManager通过反射实例化layoutManager</span></span><br><span class="line">                Class layoutManagerClass =</span><br><span class="line">                        classLoader.loadClass(className).asSubclass(LayoutManager.class);</span><br><span class="line">                Constructor constructor;</span><br><span class="line">                Object[] constructorArgs = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    constructor = layoutManagerClass</span><br><span class="line">                            .getConstructor(LAYOUT_MANAGER_CONSTRUCTOR_SIGNATURE);</span><br><span class="line">                    constructorArgs = <span class="keyword">new</span> Object[]&#123;context, attrs, defStyleAttr, defStyleRes&#125;;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        constructor = layoutManagerClass.getConstructor();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e1) &#123;</span><br><span class="line">                        e1.initCause(e);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(attrs.getPositionDescription() +</span><br><span class="line">                                <span class="string">": Error creating LayoutManager "</span> + className, e1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                setLayoutManager(constructor.newInstance(constructorArgs));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(attrs.getPositionDescription()</span><br><span class="line">                        + <span class="string">": Unable to find LayoutManager "</span> + className, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(attrs.getPositionDescription()</span><br><span class="line">                        + <span class="string">": Could not instantiate the LayoutManager: "</span> + className, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(attrs.getPositionDescription()</span><br><span class="line">                        + <span class="string">": Could not instantiate the LayoutManager: "</span> + className, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(attrs.getPositionDescription()</span><br><span class="line">                        + <span class="string">": Cannot access non-public constructor "</span> + className, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(attrs.getPositionDescription()</span><br><span class="line">                        + <span class="string">": Class is not a LayoutManager "</span> + className, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在布局文件里面设置了布局管理器的类型，那么这里会通过反射的方式实例化出对应的布局管理器。最后将实例化出的布局管理器设置到当前的RecyclerView,参考文章在创建实例时候<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutManager</span><span class="params">(LayoutManager layout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (layout == mLayout) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stopScroll();</span><br><span class="line">    <span class="comment">// TODO We should do this switch a dispachLayout pass and animate children. There is a good</span></span><br><span class="line">    <span class="comment">// chance that LayoutManagers will re-use views.</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsAttached) &#123;</span><br><span class="line">            mLayout.dispatchDetachedFromWindow(<span class="keyword">this</span>, mRecycler);</span><br><span class="line">        &#125;</span><br><span class="line">        mLayout.setRecyclerView(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mRecycler.clear();</span><br><span class="line">    mChildHelper.removeAllViewsUnfiltered();</span><br><span class="line">    mLayout = layout;</span><br><span class="line">    <span class="keyword">if</span> (layout != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layout.mRecyclerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"LayoutManager "</span> + layout +</span><br><span class="line">                    <span class="string">" is already attached to a RecyclerView: "</span> + layout.mRecyclerView);</span><br><span class="line">        &#125;</span><br><span class="line">        mLayout.setRecyclerView(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mIsAttached) &#123;</span><br><span class="line">            mLayout.dispatchAttachedToWindow(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置布局管理器之前会先清空所有之前的缓存VIEW。最后通知VIEW刷新,requestLayout可见要绘制了<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Only trigger request-during-layout logic if this is the view requesting it,</span></span><br><span class="line">        <span class="comment">// not the views in its parent hierarchy</span></span><br><span class="line">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">        <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为当前view设置标记位 PFLAG_FORCE_LAYOUT</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        <span class="comment">//向父容器请求布局</span></span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/blogimages/2019/view-requestlayout.jpg" alt=""></p>
<blockquote>
<p>在requestLayout方法中，首先先判断当前View树是否正在布局流程，接着为当前子View设置标记位，该标记位的作用就是标记了当前的View是需要进行重新布局的，接着调用mParent.requestLayout方法，这个十分重要，因为这里是向父容器请求布局，即调用父容器的requestLayout方法，为父容器添加PFLAG_FORCE_LAYOUT标记位，而父容器又会调用它的父容器的requestLayout方法，即requestLayout事件层层向上传递，直到DecorView，即根View，而根View又会传递给ViewRootImpl，也即是说子View的requestLayout事件，最终会被ViewRootImpl接收并得到处理。<br>纵观这个向上传递的流程，其实是采用了责任链模式，即不断向上传递该事件，直到找到能处理该事件的上级，在这里，只有ViewRootImpl能够处理requestLayout事件。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        performTraversals();</span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，调用了scheduleTraversals方法，这个方法是一个异步方法，最终会调用到ViewRootImpl#performTraversals方法，这也是View工作流程的核心方法，在这个方法内部，分别调用measure、layout、draw方法来进行View的三大工作流程<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">        <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);  <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!skipDraw || mReportNextDraw) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            performDraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里很熟悉了吧,view,viewgroup的绘制,如果这里有问题的,自己百度吧,所以会最终调用到recyclerview的onMeature</p>
<p>recyclerView.setLayoutManager(layoutManager)就是桥接模式的体现，因为layoutManager的实现可以有多种,即桥接模式具体实现化逻辑ConcreteImplementor</p>
<ul>
<li>ListView功能 recyclerView.setLayoutManager(new LinearLayoutManager(this));</li>
<li>GridView功能 recyclerView.setLayoutManager(new GridLayoutManager(this,3));</li>
<li>瀑布流形式功能 recyclerView.setLayoutManager(new StaggeredGridLayoutManager(2,StaggeredGridLayoutManager.VERTICAL));</li>
<li>横向ListView的功能 recyclerView.setLayoutManager(new LinearLayoutManager(this)); layoutManager.setOrientation(…);</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinearLayoutManager</span><span class="params">(Context context, <span class="keyword">int</span> orientation, <span class="keyword">boolean</span> reverseLayout)</span> </span>&#123;</span><br><span class="line">    setOrientation(orientation);</span><br><span class="line">    setReverseLayout(reverseLayout);</span><br><span class="line">    setAutoMeasureEnabled(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StaggeredGridLayoutManager</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    Properties properties = getProperties(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    setOrientation(properties.orientation);</span><br><span class="line">    setSpanCount(properties.spanCount);</span><br><span class="line">    setReverseLayout(properties.reverseLayout);</span><br><span class="line">    setAutoMeasureEnabled(mGapStrategy != GAP_HANDLING_NONE);</span><br><span class="line">    mLayoutState = <span class="keyword">new</span> LayoutState();</span><br><span class="line">    createOrientationHelpers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GridLayoutManager继承LinearLayoutManager</code></p>
<p>可见其初始化时候会设置AutoMeasurEnabled,前面说过，RecyclerView会将测量与布局交给LayoutManager来做，并且LayoutManager有一个叫做mAutoMeasure的属性，这个属性用来控制LayoutManager是否开启自动测量，开启自动测量的话布局就交由RecyclerView使用一套默认的测量机制，否则，自定义的LayoutManager需要重写onMeasure来处理自身的测量工作。RecyclerView目前提供的几种LayoutManager都开启了自动测量，所以这里我们关注一下自动测量部分的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mLayout.mAutoMeasure) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> skipMeasure = widthMode == MeasureSpec.EXACTLY</span><br><span class="line">                &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">if</span> (skipMeasure || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            mLayout.setMeasureSpecs(</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动测量的原理如下:当RecyclerView的宽高都为EXACTLY时，可以直接设置对应的宽高，然后返回，结束测量。</p>
<h4 id="补充MeasureSpect三种模式"><a href="#补充MeasureSpect三种模式" class="headerlink" title="补充MeasureSpect三种模式"></a>补充MeasureSpect三种模式</h4><p>三种模式是EXACTLY,UNSPECIFIED,AT_MOST,分别代表精确大小,不精确大小,最大值;通过MeasureSpect.getMode就可以获得该值,那么MeasureSpect到底是由什么决定的呢?MeasureSpect是由LayoutParameter通过父容器的施加的规则产生的下面我们来看一看三种模式产生的情况.</p>
<ul>
<li>MeasureSpec.EXACTLY父容器已经精确的检测出了子View的大小,子view的大小就是MeasureSpect.getSize()的值.适用情况:<ul>
<li>a.子View的LayoutParameter使用具体的值(如:宽高为100dp),不管父容器的spectMode为什么,系统返回给子View的mode为EXACTLY,系统返回给子View的大小为子V诶额外自己指定的大小(100dp)    </li>
<li>b.子View的LayoutParams采用match_parent并且父容器的mode为EXACTLY,那么子View的mode即为EXACTLY,子View大小为父容器剩余的大小</li>
</ul>
</li>
<li>MeasureSpec.AT_MOST父容器期望对子View的最大值做了限定适用情况:    <ul>
<li>c.子View的LayoutParams采用match_parent并且父容器的mode为AT_MOST,那么子View的mode即为AT_MOST,子View大小为父容器剩余的大小    </li>
<li>d.当子View的LayoutParams采用wrap_content时并且父容器的mode为EXACTLY或者AT_MOST时,子View的Mode就为AT_MOST，子View的specSize就为该父容器剩余的大小</li>
</ul>
</li>
<li>MeasureSpec.UNSPECIFIED父容器不限定大小,子View想多大就多大适应情况:    <ul>
<li>e.当子View的LayoutParams采用wrap_content时并且父容器的mode为UNSPECIFIED时,子View的Mode就为UNSPECIFIED，子View的大小不做限制</li>
</ul>
</li>
</ul>
<p>如果宽高的测量规则不是EXACTLY的,则会在onMeasure()中开始布局的处理，这里首先要介绍一个很重要的类：</p>
<p><strong>RecyclerView.State</strong> ，这个类封装了当前RecyclerView的有用信息。State的一个变量mLayoutStep表示了RecyclerView当前的布局状态，包括STEP_START、STEP_LAYOUT 、 STEP_ANIMATIONS三个，而RecyclerView的布局过程也分为三步，其中，STEP_START表示即将开始布局，需要调用dispatchLayoutStep1来执行第一步布局，接下来，布局状态变为STEP_LAYOUT，表示接下来需要调用dispatchLayoutStep2里进行第二步布局，同理，第二步布局后状态变为STEP_ANIMATIONS，需要执行第三步布局dispatchLayoutStep3。</p>
<p>这三个步骤的工作也各不相同，step1负责记录状态，step2负责布局，step3则与step1进行比较，根据变化来触发动画。</p>
<p>RecyclerView将布局划分的如此细致必然是有其原因的，在开启自动测量模式的情况，RecyclerView是支持WRAP_CONTENT属性的，比如我们可以很容易的在RecyclerView的下面放置其它的View，RecyclerView会根据子View所占大小动态调整自己的大小，这时候，RecyclerView就会将子控件的measure与layout提前到Recycler的onMeasure中，因为它需要确定子空间的大小与位置后，再来设置自己的大小。所以这时候就会在onMeasure中完成step1与step2。否则，就需要在onLayout中去完成整个布局过程。</p>
<p>综上，整个mLayout.mAutoMeasure就是在做前两步的布局，可见RecylerView的measure与layout是紧密相关的，所以我们来赶快瞧一瞧RecyclerView是如何layout的。</p>
<p>我们直接看下onLayout的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接追进dispatchLayout：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() ||mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span></span><br><span class="line">        <span class="comment">// changed size.</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过查看dispatchLayout的代码正好验证了我们前文关于RecyclerView的layout三步走原则，如果在onMeasure中已经完成了step1与step2，则只会执行step3，否则三步会依次触发。接下来我们一步一步的进行分析</p>
<h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">          <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">              <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">              <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                      .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                              ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                              holder.getUnmodifiedPayloads());</span><br><span class="line">              mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewInfoStore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="keyword">final</span> ArrayMap mLayoutHolderMap = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="keyword">final</span> LongSparseArray mOldChangedHolders = <span class="keyword">new</span> LongSparseArray&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mLayoutHolderMap.clear();</span><br><span class="line">      mOldChangedHolders.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemHolderInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bottom;</span><br><span class="line">    <span class="meta">@AdapterChanges</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> changeFlags;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemHolderInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>step的第一步目的就是在记录View的状态，首先遍历当前所有的View依次进行处理，mItemAnimator会根据每个View的信息封装成一个ItemHolderInfo，这个ItemHolderInfo中主要包含的就是当前View的位置状态等。然后ItemHolderInfo 就被存入mViewInfoStore中,由代码可见被存在ArrayMap和LongSparseArray中,其是对HashMap的android优化,是用两个数组来完成存储,arraymap的key可以是任意值,SparseArray的key只能为int,其核心是折半查找</p>
<p>注意这里调用的是mViewInfoStore的addToPreLayout方法，我们追进：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPreLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.preInfo = info;</span><br><span class="line">    record.flags |= FLAG_PRE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>addToPreLayout方法中会根据holder来查询InfoRecord信息，如果没有，则生成，然后将info信息赋值给InfoRecord的preInfo变量。最后标记FLAG_PRE信息，如此，完成函数。所以纵观整个layout的第一步，就是在记录当前的View信息，因为进入第二步后，View的信息就将被改变了。我们来看第二步：</p>
<h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">     ...</span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>layout的第二步主要就是真正的去布局View了，前面也说过，RecyclerView的布局是由LayoutManager负责的，所以第二步的主要工作也都在LayoutManager中，由于每种布局的方式不一样，这里我们以常见的<strong>LinearLayoutManager</strong>为例。我们看其onLayoutChildren方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION ||</span><br><span class="line">            mPendingSavedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL :</span><br><span class="line">                LayoutState.ITEM_DIRECTION_HEAD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD :</span><br><span class="line">                LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">          ...     </span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">          ...</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个onLayoutChildren过程还是很复杂的，这里我尽量省略了一些与流程关系不大的细节处理代码。整个onLayoutChildren过程可以大致整理如下：</p>
<ul>
<li>找到anchor点</li>
<li>根据anchor一直向前布局，直至填充满anchor点前面的所有区域</li>
<li>根据anchor一直向后布局，直至填充满anchor点后面的所有区域这里我以垂直布局来说明，mAnchorInfo为布局锚点信息，包含了子控件在Y轴上起始绘制偏移量（coordinate），ItemView在Adapter中的索引位置（position）和布局方向（mLayoutFromEnd）——这里是指start、end方向。</li>
</ul>
<p>这部分代码的功能就是：确定布局锚点，以此为起点向开始和结束方向填充ItemView，如图所示：</p>
<p><img src="/images/blogimages/2019/Recyclerview-find_anchor.png" alt="onLayoutChildren"></p>
<p>anchor点的寻找是由updateAnchorInfoForLayout函数负责的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateAnchorInfoForLayout</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AnchorInfo anchorInfo)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (updateAnchorFromChildren(recycler, state, anchorInfo)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    anchorInfo.assignCoordinateFromPadding();</span><br><span class="line">    anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数内首先通过子view来获取anchor，如果没有获取到，就根据就取头/尾点来作为anchor。所以这里我们主要关注updateAnchorFromChildren函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateAnchorFromChildren</span><span class="params">(RecyclerView.Recycler recycler,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         RecyclerView.State state, AnchorInfo anchorInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getChildCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> View focused = getFocusedChild();</span><br><span class="line">    <span class="keyword">if</span> (focused != <span class="keyword">null</span> &amp;&amp; anchorInfo.isViewValidAsAnchor(focused, state)) &#123;</span><br><span class="line">        anchorInfo.assignFromViewAndKeepVisibleRect(focused);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLastStackFromEnd != mStackFromEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    View referenceChild = anchorInfo.mLayoutFromEnd</span><br><span class="line">            ? findReferenceChildClosestToEnd(recycler, state)</span><br><span class="line">            : findReferenceChildClosestToStart(recycler, state);</span><br><span class="line">    <span class="keyword">if</span> (referenceChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">        anchorInfo.assignFromView(referenceChild);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateAnchorFromChildren内部做的事情也很容易理解，首先寻找被focus的child，找到的话以此child作为anchor，否则根据布局的方向寻找最合适的child来作为anchor，如果找到则将child的信息赋值给anchorInfo，其实anchorInfo主要记录的信息就是view的物理位置与在adapter中的位置。找到后返回true，否则返回false则交由上一步的函数做处理。</p>
<p>综上，刚刚的所追踪的代码都是在寻找anchor点。在我们寻找后，LinearLayoutManager还给了我们更改anchor的时机，就是 onAnchorReady 函数，我们可以继承LinearLayoutManager 来重写onAnchorReady方法，就可以实现某些特定的功能，比如进入RecyclerView时定位在某一项等等。</p>
<p>总之，我们现在找到了anchor信息，接下来就是根据anchor来布局了。无论从上到下还是从下到上布局，都调用的是fill方法，我们进入fill方法来查看一番：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span></span><br><span class="line"><span class="function"><span class="params">        RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;</span><br><span class="line">    <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">        recycleByLayoutState(recycler, layoutState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">    <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里同样省略了很多代码，我们关注重点：</p>
<p>首先比较重要的函数是recycleByLayoutState，这个函数就厉害了，它会根据当前信息对不需要的View进行回收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleByLayoutState</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">            ...</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续追进recycleViewsFromStart：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleViewsFromStart</span><span class="params">(RecyclerView.Recycler recycler, <span class="keyword">int</span> dt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> limit = dt;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">if</span> (mShouldReverseLayout) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">                    || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">                recycleChildren(recycler, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的作用就是遍历所有的子View，找出逃离边界的View进行回收，回收函数我们锁定在recycleChildren里，而这个函数最后又会调到removeAndRecycleViewAt：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAndRecycleViewAt</span><span class="params">(<span class="keyword">int</span> index, Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View view = getChildAt(index);</span><br><span class="line">    removeViewAt(index);</span><br><span class="line">    recycler.recycleView(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数首先调用removeViewAt函数，这个函数的作用是将View从RecyclerView中移除， 紧接着我们看到，是recycler执行了view的回收逻辑。这里我们暂且打住，关于recycler我们会单独进行说明，这里我们只需要理解，在fill函数的一开始会去回收逃离出屏幕的view。我们再次回到fill函数，关注这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">      layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很容易理解，只要还有剩余空间，就会执行layoutChunk方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">        LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    ...</span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">                == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们首先看到，layoutState的next方法返回了一个View，凭空变出一个View，好神奇，追进去看一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，view的获取逻辑也由recycler来负责，所以，这里我们同样打住，只需要清楚recycler可以根据位置返回一个view即可。</p>
<p>再回到layoutChunk看一下对刚刚生成的view作何处理：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">            == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">        addView(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addView(view, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显调用了addView方法，虽然这个方法是LayoutManager的，但这个方法最终会多次辗转调用到RecyclerView的addView方法，将view添加在RecyclerView中。综上，我们就梳理了整个第二步布局的过程，此过程完成了子View的测量与布局，任务还是相当繁重。</p>
<h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><p>接下来，就到了布局的最后一步了，我们直接看下dispatchLayoutStep3方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mChildHelper.getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPostLayoutInformation(mState, holder);</span><br><span class="line">                mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一步是与第一步呼应的的，此时由于子View都已完成布局，所以子View的信息都发生了变化。我们会看到第一步出现的mViewInfoStore和mItemAnimator再次登场，这次mItemAnimator调用的是recordPostLayoutInformation方法，而mViewInfoStore调用的是addToPostLayout方法，还记得刚刚我强调的吗，之前是pre，也就是真正布局之前的状态，而现在要记录布局之后的状态，我们追进addToPostLayout：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToPostLayout</span><span class="params">(ViewHolder holder, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">    InfoRecord record = mLayoutHolderMap.get(holder);</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        record = InfoRecord.obtain();</span><br><span class="line">        mLayoutHolderMap.put(holder, record);</span><br><span class="line">    &#125;</span><br><span class="line">    record.postInfo = info;</span><br><span class="line">    record.flags |= FLAG_POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和第一步的addToPreLayout类似，不过这次info信息被赋值给了record的postInfo变量，这样，一个record中就包含了布局前后view的状态。</p>
<p>最后，mViewInfoStore调用了process方法，这个方法就是根据mViewInfoStore中的View信息，来执行动画逻辑，这又是一个可以展看很多的点，这里不做探讨，感兴趣的可以深入的看一下，会对动画流程有更直观的体会。</p>
<p>接下来就是onDraw,RecyclerView的draw过程可以分为２部分来看：RecyclerView负责绘制所有decoration；ItemView的绘制由ViewGroup处理，这里的绘制是android常规绘制逻辑，本文就不再阐述了。下面来看看RecyclerView的draw()和onDraw()方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.draw(c);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDrawOver(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了,测量,布局,绘制都大体讲了一下,回到我们开头,setLayoutManager已经完成。接下来是setAdapter(适配器模式),我们一起结合动画的实现(观察者模式)来解读,先看一下adapter类</p>
<h4 id="setAdapter-适配器模式"><a href="#setAdapter-适配器模式" class="headerlink" title="setAdapter(适配器模式)"></a>setAdapter(适配器模式)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdapterDataObservable mObservable = <span class="keyword">new</span> AdapterDataObservable();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAdapterDataObserver</span><span class="params">(AdapterDataObserver observer)</span> </span>&#123;</span><br><span class="line">        mObservable.registerObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterAdapterDataObserver</span><span class="params">(AdapterDataObserver observer)</span> </span>&#123;</span><br><span class="line">        mObservable.unregisterObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyItemInserted</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        mObservable.notifyItemRangeInserted(position, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RecyclerView的Adapter，这个控件需要的是View(dst),而我们有的一般是datas(src),所以适配器Adapter就是完成了数据源datas 转化成 ItemView的工作。带入src-&gt;Adapter-&gt;dst中，即datas-&gt;Adapter-&gt;View. </p>
<p>通过public abstract void onBindViewHolder(VH holder, int position);将datas绑定到view然后返回ViewHolder我们可以看到Adapter中包含一个AdapterDataObservable的对象mObservable，这个是一个可观察者，在可观察者中可以注册一系列的观察者AdapterDataObserver。在我们调用的notify函数的时候，就是可观察者发出通知，这时已经注册的观察者都可以收到这个通知，然后依次进行处理。哈哈,是不是我们前面的Subject…那么我们看一下注册观察者的地方。</p>
<p>注册观察者的地方就是在RecyclerView的这个函数中。这个是setAdapter方法最终调用的地方。它主要做了：</p>
<p>如果之前存在Adapter，先移除原来的，注销观察者，和从RecyclerView Detached。<br>然后根据参数，决定是否清除原来的ViewHolder<br>然后重置AdapterHelper，并更新Adapter，注册观察者。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(Adapter adapter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bail out if layout is frozen</span></span><br><span class="line">    setLayoutFrozen(<span class="keyword">false</span>);</span><br><span class="line">    setAdapterInternal(adapter, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一看setAdapterInternal<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAdapterInternal</span><span class="params">(Adapter adapter, <span class="keyword">boolean</span> compatibleWithPrevious,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> removeAndRecycleViews)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAdapter.unregisterAdapterDataObserver(mObserver);</span><br><span class="line">        mAdapter.onDetachedFromRecyclerView(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!compatibleWithPrevious || removeAndRecycleViews) &#123;</span><br><span class="line">        <span class="comment">// end all running animations</span></span><br><span class="line">        <span class="keyword">if</span> (mItemAnimator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mItemAnimator.endAnimations();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Since animations are ended, mLayout.children should be equal to</span></span><br><span class="line">        <span class="comment">// recyclerView.children. This may not be true if item animator's end does not work as</span></span><br><span class="line">        <span class="comment">// expected. (e.g. not release children instantly). It is safer to use mLayout's child</span></span><br><span class="line">        <span class="comment">// count.</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLayout.removeAndRecycleAllViews(mRecycler);</span><br><span class="line">            mLayout.removeAndRecycleScrapInt(mRecycler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we should clear it here before adapters are swapped to ensure correct callbacks.</span></span><br><span class="line">        mRecycler.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    mAdapterHelper.reset();</span><br><span class="line">    <span class="keyword">final</span> Adapter oldAdapter = mAdapter;</span><br><span class="line">    mAdapter = adapter;</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line">        adapter.onAttachedToRecyclerView(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLayout.onAdapterChanged(oldAdapter, mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">    mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);</span><br><span class="line">    mState.mStructureChanged = <span class="keyword">true</span>;</span><br><span class="line">    markKnownViewsInvalid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里我们可以看出，mObserver这个成员变量就是注册的观察者，那么我们去看看这个成员变量的内容。</p>
<p>该成员变量是一个RecyclerViewDataObserver的实例，那么RecyclerViewDataObserver实现了AdapterDataObserver中的方法。其中onItemRangeInserted(int positionStart, int itemCount)就是观察者接受到有数据插入通知的方法。那么我们来分析这个方法。看注释。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RecyclerViewDataObserver mObserver = <span class="keyword">new</span> RecyclerViewDataObserver();</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewDataObserver</span> <span class="keyword">extends</span> <span class="title">AdapterDataObserver</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mPostUpdatesOnAnimation = version &gt;= <span class="number">16</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemRangeInserted</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1) 断言不在布局或者滚动过程中，其实就是如果在布局或者滚动过程中，则不会执</span></span><br><span class="line">        <span class="comment">// 行下面的内容</span></span><br><span class="line">        assertNotInLayoutOrScroll(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 2) 这里小型，不要小看if括号中的内容，这是关键。我们去看看这个方法的实现。</span></span><br><span class="line">        <span class="comment">// 见下面注释 3)，在 3) 返回true之后执行triggerUpdateProcessor方法，</span></span><br><span class="line">        <span class="comment">// triggerUpdateProcessor方法分析请看注释 4)。</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) &#123;</span><br><span class="line">            triggerUpdateProcessor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AdapterHelper中onItemRangeInserted函数即相关内容，请看注释 <code>3)</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapterHelper</span> <span class="keyword">implements</span> <span class="title">OpReorderer</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个待处理更新操作的列表，该列表中存放所有等待处理的操作信息。</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList mPendingUpdates = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">// 3) 该方法将插入操作的信息存储到一个UpdateOp中，并添加到待处理更新操作列表中，</span></span><br><span class="line">    <span class="comment">// 如果操作列表中的值是1，就返回真表示需要处理操作，等于1的判断避免重复触发处理操作。</span></span><br><span class="line">    <span class="comment">// obtainUpdateOp内部是通过池来得到一个UpdateOp对象。那么下面回去看我们注释 4)。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onItemRangeInserted</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (itemCount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingUpdates.add(obtainUpdateOp(UpdateOp.ADD, positionStart, itemCount, <span class="keyword">null</span>));</span><br><span class="line">        mExistingUpdateTypes |= UpdateOp.ADD;</span><br><span class="line">        <span class="keyword">return</span> mPendingUpdates.size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4) 触发更新处理操作，分为两种情况，在 版本大于16 且 已经Attach 并且 设置了大小固定 的情况下，</span></span><br><span class="line"><span class="comment">// 进行mUpdateChildViewsRunnable中的操作。否则请求布局。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triggerUpdateProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPostUpdatesOnAnimation &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123;</span><br><span class="line">        ViewCompat.postOnAnimation(RecyclerView.<span class="keyword">this</span>, mUpdateChildViewsRunnable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAdapterUpdateDuringMeasure = <span class="keyword">true</span>;</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5) 其中核心代码是consumePendingUpdateOperations()那么继续往下看。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mUpdateChildViewsRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        consumePendingUpdateOperations();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumePendingUpdateOperations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mAdapterHelper.hasAnyUpdateTypes(UpdateOp.UPDATE) &amp;&amp; !mAdapterHelper</span><br><span class="line">            .hasAnyUpdateTypes(UpdateOp.ADD | UpdateOp.REMOVE | UpdateOp.MOVE)) &#123;</span><br><span class="line">        <span class="comment">// 6) 如果只有更新类型的操作(这里指内容的更新，不影响View位置的改变)的情况下，</span></span><br><span class="line">        <span class="comment">// 先进行预处理，然后在没有View更新的情况下消耗延迟的更新操作，否则调用</span></span><br><span class="line">        <span class="comment">// dispatchLayout方法对RecyclerView中的View重新布局。那么接下来分析</span></span><br><span class="line">        <span class="comment">// preProcess()方法。</span></span><br><span class="line">        mAdapterHelper.preProcess();</span><br><span class="line">        <span class="keyword">if</span> (!mLayoutRequestEaten) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasUpdatedView()) &#123;</span><br><span class="line">                dispatchLayout();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mAdapterHelper.consumePostponedUpdates();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resumeRequestLayout(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasPendingUpdates()) &#123;</span><br><span class="line">        <span class="comment">// 7) 在既有更新操作又有添加或者删除或者移动中任意一个的情况下，调用</span></span><br><span class="line">        <span class="comment">// dispatchLayout方法对RecyclerView中的View重新布局</span></span><br><span class="line">        dispatchLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8) 预处理做了以下几件事情，&lt;1&gt; 先将待处理操作重排。&lt;2&gt; 应用所有操作 &lt;3&gt; 清空待处理操作列表，</span></span><br><span class="line"><span class="comment">// 以ADD为例分析流程。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mOpReorderer.reorderOps(mPendingUpdates);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mPendingUpdates.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        UpdateOp op = mPendingUpdates.get(i);</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.ADD:</span><br><span class="line">                applyAdd(op);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.REMOVE:</span><br><span class="line">                applyRemove(op);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.UPDATE:</span><br><span class="line">                applyUpdate(op);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UpdateOp.MOVE:</span><br><span class="line">                applyMove(op);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOnItemProcessedCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mOnItemProcessedCallback.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingUpdates.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9) 直接看postponeAndUpdateViewHolders</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyAdd</span><span class="params">(UpdateOp op)</span> </span>&#123;</span><br><span class="line">    postponeAndUpdateViewHolders(op);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10) 先将操作添加到推迟的操作列表中。然后将操作的内容交给回调处理。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postponeAndUpdateViewHolders</span><span class="params">(UpdateOp op)</span> </span>&#123;</span><br><span class="line">    mPostponedList.add(op);</span><br><span class="line">    <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> UpdateOp.ADD:</span><br><span class="line">            mCallback.offsetPositionsForAdd(op.positionStart, op.itemCount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UpdateOp.MOVE:</span><br><span class="line">            mCallback.offsetPositionsForMove(op.positionStart, op.itemCount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UpdateOp.REMOVE:</span><br><span class="line">            mCallback.offsetPositionsForRemovingLaidOutOrNewView(op.positionStart,</span><br><span class="line">                    op.itemCount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UpdateOp.UPDATE:</span><br><span class="line">            mCallback.markViewHoldersUpdated(op.positionStart, op.itemCount, op.payload);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown update op type for "</span> + op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 11) 直接看offsetPositionRecordsForInsert</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offsetPositionsForAdd</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">    offsetPositionRecordsForInsert(positionStart, itemCount);</span><br><span class="line">    mItemsAddedOrRemoved = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 12) 该方法主要是便利所有的ViewHolder，然后把在插入位置之后的ViewHolder的位置</span></span><br><span class="line"><span class="comment">// 向后移动插入的个数，最后在对Recycler中缓存的ViewHolder做同样的操作，最后申请重新布局。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">offsetPositionRecordsForInsert</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = mChildHelper.getUnfilteredChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span> &amp;&amp; !holder.shouldIgnore() &amp;&amp; holder.mPosition &gt;= positionStart) &#123;</span><br><span class="line">            holder.offsetPosition(itemCount, <span class="keyword">false</span>);</span><br><span class="line">            mState.mStructureChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRecycler.offsetPositionRecordsForInsert(positionStart, itemCount);</span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面讲过ViewInfoStore这个类是用来追踪View所要做的动画的。其中有一个内部类InfoRecord，该类用来存储ViewHolder前后的信息，以及ViewHolder状态的flag。其中还有一个非常重要的方法，process，该方法会处理所有的mLayoutHolderMap中的值，并根据其flag和前后的信息来判断ViewHolder的动作，并将这个动作反应给ProcessCallback。分别有4种行为：消失，出现，一直存在，为使用。然后交给外面去处理。</p>
<p>前面说过 dispatchLayoutStep3mViewInfoStore.process(mViewInfoProcessCallback);,之后我们看一下mViewInfoStore的ProcessCallback的实现mViewInfoProcessCallback，这里只拿processAppeared做分析：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ViewInfoStore.ProcessCallback mViewInfoProcessCallback =</span><br><span class="line">            <span class="keyword">new</span> ViewInfoStore.ProcessCallback() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAppeared</span><span class="params">(ViewHolder viewHolder,</span></span></span><br><span class="line"><span class="function"><span class="params">            ItemHolderInfo preInfo, ItemHolderInfo info)</span> </span>&#123;</span><br><span class="line">        animateAppearance(viewHolder, preInfo, info);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后看一下animateAppearance方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateAppearance</span><span class="params">(@NonNull ViewHolder itemHolder,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span> </span>&#123;</span><br><span class="line">    itemHolder.setIsRecyclable(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (mItemAnimator.animateAppearance(itemHolder, preLayoutInfo, postLayoutInfo)) &#123;</span><br><span class="line">        postAnimationRunner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法中不要忽略if中的内容：<code>mItemAnimator.animateAppearance(itemHolder, preLayoutInfo, postLayoutInfo)</code>那么进入该方法：看注释。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateAppearance</span><span class="params">(@NonNull ViewHolder viewHolder,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法通过前后的布局信息来判断是移动还是添加。下面我们以添加为例分析</span></span><br><span class="line">    <span class="keyword">if</span> (preLayoutInfo != <span class="keyword">null</span> &amp;&amp; (preLayoutInfo.left != postLayoutInfo.left</span><br><span class="line">            || preLayoutInfo.top != postLayoutInfo.top)) &#123;</span><br><span class="line">        <span class="keyword">return</span> animateMove(viewHolder, preLayoutInfo.left, preLayoutInfo.top,</span><br><span class="line">                postLayoutInfo.left, postLayoutInfo.top);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> animateAdd(viewHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正实现是在DefaultItenAnimator中：这里做了三件事情，重置holder的动画，设置显示属性，然后添加到mPendingAdditions中，mPendingAdditions是一个存储添加ViewHolder的List，表示待处理的添加动画的ViewHolder。同样在DefaultItenAnimator总也有，移动的，移除的列表。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateAdd</span><span class="params">(<span class="keyword">final</span> ViewHolder holder)</span> </span>&#123;</span><br><span class="line">    resetAnimation(holder);</span><br><span class="line">    ViewCompat.setAlpha(holder.itemView, <span class="number">0</span>);</span><br><span class="line">    mPendingAdditions.add(holder);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后返回true，进入if，执行postAnimationRunner方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postAnimationRunner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPostedAnimatorRunner &amp;&amp; mIsAttached) &#123;</span><br><span class="line">        ViewCompat.postOnAnimation(<span class="keyword">this</span>, mItemAnimatorRunner);</span><br><span class="line">        mPostedAnimatorRunner = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>去看mItemAnimatorRunner，其中调用的ItemAnimator的runPendingAnimations方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable mItemAnimatorRunner = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mItemAnimator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mItemAnimator.runPendingAnimations();</span><br><span class="line">        &#125;</span><br><span class="line">        mPostedAnimatorRunner = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后分析runPendingAnimations方法：该方法并不难，按照移除，移动，改变，添加，依次处理之前的待处理列表中的内容。这里还是以添加的做为例子来分析，看注释。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runPendingAnimations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removalsPending = !mPendingRemovals.isEmpty();</span><br><span class="line">    <span class="keyword">boolean</span> movesPending = !mPendingMoves.isEmpty();</span><br><span class="line">    <span class="keyword">boolean</span> changesPending = !mPendingChanges.isEmpty();</span><br><span class="line">    <span class="keyword">boolean</span> additionsPending = !mPendingAdditions.isEmpty();</span><br><span class="line">    <span class="keyword">if</span> (!removalsPending &amp;&amp; !movesPending &amp;&amp; !additionsPending &amp;&amp; !changesPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ViewHolder holder : mPendingRemovals) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingRemovals.clear();</span><br><span class="line">    <span class="keyword">if</span> (movesPending) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (changesPending) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (additionsPending) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList additions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        additions.addAll(mPendingAdditions);</span><br><span class="line">        mAdditionsList.add(additions);</span><br><span class="line">        mPendingAdditions.clear();</span><br><span class="line">        <span class="comment">// 重要的是这个adder。其中重要的是 animateAddImpl(holder) 方法。那么来分析这个方法。</span></span><br><span class="line">        Runnable adder = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (ViewHolder holder : additions) &#123;</span><br><span class="line">                    animateAddImpl(holder);</span><br><span class="line">                &#125;</span><br><span class="line">                additions.clear();</span><br><span class="line">                mAdditionsList.remove(additions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (removalsPending || movesPending || changesPending) &#123;</span><br><span class="line">            <span class="keyword">long</span> removeDuration = removalsPending ? getRemoveDuration() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> moveDuration = movesPending ? getMoveDuration() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> changeDuration = changesPending ? getChangeDuration() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> totalDelay = removeDuration + Math.max(moveDuration, changeDuration);</span><br><span class="line">            View view = additions.get(<span class="number">0</span>).itemView;</span><br><span class="line">            ViewCompat.postOnAnimationDelayed(view, adder, totalDelay);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            adder.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法其实就是通过属性动画对ViewHolder中的View做渐变动画。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateAddImpl</span><span class="params">(<span class="keyword">final</span> ViewHolder holder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View view = holder.itemView;</span><br><span class="line">    <span class="keyword">final</span> ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</span><br><span class="line">    mAddAnimations.add(holder);</span><br><span class="line">    animation.alpha(<span class="number">1</span>).setDuration(getAddDuration()).</span><br><span class="line">            setListener(<span class="keyword">new</span> VpaListenerAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                    dispatchAddStarting(holder);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                    ViewCompat.setAlpha(view, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                    animation.setListener(<span class="keyword">null</span>);</span><br><span class="line">                    dispatchAddFinished(holder);</span><br><span class="line">                    mAddAnimations.remove(holder);</span><br><span class="line">                    dispatchFinishedWhenDone();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，终于是触发了我们的动画。其它的动作，流程类似，细节不同而已。那么通过流程我们可以深入理解以下2点：</p>
<p>如果我们的RecyclerView的高度和宽度不变，那么通过手动执行setHasFixedSize(true)，可以在一定程度上减少计算，提高性能。可以在 <code>4)</code> 步的时候绕过requestLayout，只走自身的布局流程。而requestLayout是申请父控件重新布局流程，两者的计算量是不一样的。<br>自定义ItemAnimator的时候，如果在animateAppearance，animateDisappearance……方法中直接运行了动画，就返回false，如果是暂存起来，就返回true，然后将真正执行动画的操作放在runPendingAnimations方法中。</p>
<h4 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h4><p>RecyclerView的滑动过程可以分为2个阶段：手指在屏幕上移动，使RecyclerView滑动的过程，可以称为scroll；手指离开屏幕，RecyclerView继续滑动一段距离的过程，可以称为fling。现在先看看RecyclerView的触屏事件处理onTouchEvent()方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) (MotionEventCompat.getX(e, index) + <span class="number">0.5f</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) (MotionEventCompat.getY(e, index) + <span class="number">0.5f</span>);</span><br><span class="line">            <span class="keyword">int</span> dx = mLastTouchX - x;</span><br><span class="line">            <span class="keyword">int</span> dy = mLastTouchY - y;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (mScrollState != SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        dy -= mTouchSlop;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dy += mTouchSlop;</span><br><span class="line">                    &#125;</span><br><span class="line">                    startScroll = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (startScroll) &#123;</span><br><span class="line">                    setScrollState(SCROLL_STATE_DRAGGING);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mScrollState == SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                mLastTouchX = x - mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                mLastTouchY = y - mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (scrollByInternal(</span><br><span class="line">                        canScrollHorizontally ? dx : <span class="number">0</span>,</span><br><span class="line">                        canScrollVertically ? dy : <span class="number">0</span>,</span><br><span class="line">                        vtev)) &#123;</span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> yvel = canScrollVertically ?</span><br><span class="line">                    -VelocityTrackerCompat.getYVelocity(mVelocityTracker, mScrollPointerId) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!((xvel != <span class="number">0</span> || yvel != <span class="number">0</span>) &amp;&amp; fling((<span class="keyword">int</span>) xvel, (<span class="keyword">int</span>) yvel))) &#123;</span><br><span class="line">                setScrollState(SCROLL_STATE_IDLE);</span><br><span class="line">            &#125;</span><br><span class="line">            resetTouch();</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我以垂直方向的滑动来说明。当RecyclerView接收到ACTION_MOVE事件后，会先计算出手指移动距离（dy），并与滑动阀值（mTouchSlop）比较，当大于此阀值时将滑动状态设置为SCROLL_STATE_DRAGGING，而后调用scrollByInternal()方法，使RecyclerView滑动，这样RecyclerView的滑动的第一阶段scroll就完成了；当接收到ACTION_UP事件时，会根据之前的滑动距离与时间计算出一个初速度yvel，这步计算是由VelocityTracker实现的，然后再以此初速度，调用方法fling()，完成RecyclerView滑动的第二阶段fling。显然滑动过程中关键的方法就2个：scrollByInternal()与fling()。接下来同样以垂直线性布局来说明。先来说明scrollByInternal()，跟踪进入后，会发现它最终会调用到LinearLayoutManager.scrollBy()方法，这个过程很简单，我就不列出源码了，但是分析到这里先暂停下，去看看fling()方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mViewFlinger.fling(velocityX, velocityY);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有用的就这一行，其它乱七八糟的不看也罢。mViewFlinger是一个Runnable的实现ViewFlinger的对象，就是它来控件着ReyclerView的fling过程的算法的。下面来看下类ViewFlinger的一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOnAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEatRunOnAnimationRequest) &#123;</span><br><span class="line">        mReSchedulePostAnimationCallback = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        removeCallbacks(<span class="keyword">this</span>);</span><br><span class="line">        ViewCompat.postOnAnimation(RecyclerView.<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY)</span> </span>&#123;</span><br><span class="line">    setScrollState(SCROLL_STATE_SETTLING);</span><br><span class="line">    mLastFlingX = mLastFlingY = <span class="number">0</span>;</span><br><span class="line">    mScroller.fling(<span class="number">0</span>, <span class="number">0</span>, velocityX, velocityY,</span><br><span class="line">            Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    postOnAnimation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，其实RecyclerView的fling是借助Scroller实现的；然后postOnAnimation()方法的作用就是在将来的某个时刻会执行我们给定的一个Runnable对象，在这里就是这个mViewFlinger对象，这部分原理我就不再深入分析了，它已经不属于本文的范围了。并且，关于Scroller的作用及原理，本文也不会作过多解释。对于这两点各位可以自行查阅，有很多文章对于作过详细阐述的。接下来看看ViewFlinger.run()方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (scroller.computeScrollOffset()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> x = scroller.getCurrX();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> y = scroller.getCurrY();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dx = x - mLastFlingX;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dy = y - mLastFlingY;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">                vresult = mLayout.scrollVerticallyBy(dy, mRecycler, mState);</span><br><span class="line">                overscrollY = dy - vresult;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            invalidate();<span class="comment">//刷新界面</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (scroller.isFinished() || !fullyConsumedAny) &#123;</span><br><span class="line">            setScrollState(SCROLL_STATE_IDLE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本段代码中有个方法mLayout.scrollVerticallyBy()，跟踪进入你会发现它最终也会走到LinearLayoutManager.scrollBy()，这样虽说RecyclerView的滑动可以分为两阶段，但是它们的实现最终其实是一样的。这里我先解释下上段代码。第一，dy表示滑动偏移量，它是由Scroller根据时间偏移量（Scroller.fling()开始时间到当前时刻）计算出的，当然如果是RecyclerView的scroll阶段，这个偏移量也就是手指滑动距离。第二，上段代码会多次执行，至到Scroller判断滑动结束或已经滑动到边界。再多说一下，postOnAnimation()保证了RecyclerView的滑动是流畅，这里涉及到著名的“android 16ms”机制，简单来说理想状态下，上段代码会以16毫秒一次的速度执行，这样其实，Scroller每次计算的滑动偏移量是很小的一部分，而RecyclerView就会根据这个偏移量，确定是平移ItemView，还是除了平移还需要再创建新ItemView。</p>
<p><img src="/images/blogimages/2019/recyclerview-flip.png" alt="RecyclerView滑动"></p>
<p>现在就来看看LinearLayoutManager.scrollBy()方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> dy, RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> absDy = Math.abs(dy);</span><br><span class="line">    updateLayoutState(layoutDirection, absDy, <span class="keyword">true</span>, state);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> consumed = mLayoutState.mScrollingOffset</span><br><span class="line">            + fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrolled = absDy &gt; consumed ? layoutDirection * consumed : dy;</span><br><span class="line">    mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上文所讲到的fill()方法，作用就是向可绘制区间填充ItemView，那么在这里，可绘制区间就是滑动偏移量！再看方法mOrientationHelper.offsetChildren()作用就是平移ItemView。好了整个滑动过程就分析完成了，当然RecyclerView的滑动还有个特性叫平滑滑动（smooth scroll），其实它的实现就是一个fling滑动，所以就不再赘述了。</p>
<h4 id="缓存逻辑"><a href="#缓存逻辑" class="headerlink" title="缓存逻辑"></a>缓存逻辑</h4><p>前面的章节对于Recycler这个类相关的操作我们都直接进行了忽略，这里我们好好的来看下RecylerView是如何工作的。</p>
<p>与ListView不同，RecyclerView的缓存是分为多级的，但其实整个的缓存逻辑还是很容易理解的，Recycler的作用就是重用ItemView。在填充ItemView的时候，ItemView是从它获取的；滑出屏幕的ItemView是由它回收的。对于不同状态的ItemView存储在了不同的集合中，比如有scrapped、cached、exCached、recycled，当然这些集合并不是都定义在同一个类里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Recycler</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一级缓存</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 二级缓存</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">        <span class="comment">// 三级缓存</span></span><br><span class="line">        <span class="keyword">private</span> ViewCacheExtension mViewCacheExtension;</span><br><span class="line">        <span class="comment">// 四级缓存</span></span><br><span class="line">        RecycledViewPool mRecyclerPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到之前的layoutChunk方法中，有行代码layoutState.next(recycler)，它的作用自然就是获取ItemView，我们进入这个方法查看，最终它会调用到RecyclerView.Recycler.getViewForPosition()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getViewForPosition 可以看到其实每次 rv 取出要显示的一个item本质上就是取出一个viewholder，根据viewholder上关联的<strong>itemview</strong>来展示这个item。而取出viewholder最核心的方法就是 <strong>tryGetViewHolderForPositionByDeadline</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">boolean</span> fromScrapOrHiddenOrCache = <span class="keyword">false</span>;</span><br><span class="line">    ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 0) 先从 mChangedScrap 取viewholder（一级缓存）</span></span><br><span class="line">    <span class="keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">        fromScrapOrHiddenOrCache = holder != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1) 从mAttachedScrap(一级缓存) 或 mCachedViews（二级缓存）中取viewholder</span></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class="line">                <span class="comment">// recycle holder (and unscrap if relevant) since it can't be used</span></span><br><span class="line">                <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                    <span class="comment">// we would like to recycle this but need to make sure it is not used by</span></span><br><span class="line">                    <span class="comment">// animation logic etc.</span></span><br><span class="line">                    holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                    <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                        removeDetachedView(holder.itemView, <span class="keyword">false</span>);</span><br><span class="line">                        holder.unScrap();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                        holder.clearReturnedFromScrapFlag();</span><br><span class="line">                    &#125;</span><br><span class="line">                    recycleViewHolderInternal(holder);</span><br><span class="line">                &#125;</span><br><span class="line">                holder = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ... stable ids的逻辑</span></span><br><span class="line">        <span class="comment">// 3) 三级缓存</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></span><br><span class="line">            <span class="comment">// know it.</span></span><br><span class="line">            <span class="keyword">final</span> View view = mViewCacheExtension</span><br><span class="line">                    .getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                holder = getChildViewHolder(view);</span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"getViewForPositionAndType returned"</span></span><br><span class="line">                            + <span class="string">" a view which does not have a ViewHolder"</span></span><br><span class="line">                            + exceptionLabel());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"getViewForPositionAndType returned"</span></span><br><span class="line">                            + <span class="string">" a view that is ignored. You must call stopIgnoring before"</span></span><br><span class="line">                            + <span class="string">" returning this view."</span> + exceptionLabel());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; <span class="comment">// fallback to pool</span></span><br><span class="line">            <span class="comment">// 4) 四级缓存</span></span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                <span class="keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成LayoutParams的代码 ...</span></span><br><span class="line">    <span class="keyword">return</span> holder.itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取View的逻辑可以整理成如下：<br>根据列表位置获取ItemView，先后从scrapped、cached、exCached、recycled集合中查找相应的ItemView，如果没有找到，就创建（ <strong>Adapter.createViewHolder()</strong> ），最后与数据集绑定。</p>
<p>其中scrapped、cached和exCached集合定义在RecyclerView.Recycler中，分别表示将要在RecyclerView中删除的ItemView、一级缓存ItemView和二级缓存ItemView，cached集合的大小默认为２，exCached是需要我们通过RecyclerView.ViewCacheExtension自己实现的，默认没有；</p>
<p>recycled集合其实是一个Map,private SparseArray<arraylist<viewholder>&gt; mScrap = new SparseArray<arraylist<viewholder>&gt;();，定义在RecyclerView.RecycledViewPool中，将ItemView以ItemType分类保存了下来，这里算是RecyclerView设计上的亮点，通过RecyclerView.RecycledViewPool可以实现在<strong>不同的RecyclerView之间共享ItemView</strong>，只要为这些不同RecyclerView设置同一个RecyclerView.RecycledViewPool就可以了。</arraylist<viewholder></arraylist<viewholder></p>
<p>上面解释了ItemView从不同集合中获取的方式，那么RecyclerView又是在什么时候向这些集合中添加ItemView的呢？下面我逐个介绍下。scrapped集合中存储的其实是正在执行REMOVE操作的ItemView，这部分会在后文进一步描述。在fill()方法的循环体中有行代码recycleByLayoutState(recycler, layoutState);，最终这个方法会执行到RecyclerView.Recycler.recycleViewHolderInternal()方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleViewHolderInternal</span><span class="params">(ViewHolder holder)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (holder.isRecyclable()) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED</span><br><span class="line">               | ViewHolder.FLAG_UPDATE)) &#123;</span><br><span class="line">           <span class="keyword">int</span> cachedViewSize = mCachedViews.size();</span><br><span class="line">           <span class="keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">               cachedViewSize --;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (cachedViewSize &lt; mViewCacheMax) &#123;</span><br><span class="line">               mCachedViews.add(holder);</span><br><span class="line">               cached = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!cached) &#123;</span><br><span class="line">           addViewHolderToRecycledViewPool(holder);</span><br><span class="line">           recycled = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>View的回收并不像View的创建那么复杂，这里只涉及了两层缓存mCachedViews与mRecyclerPool，mCachedViews相当于一个先进先出的数据结构，每当有新的View需要缓存时都会将新的View存入mCachedViews，而mCachedViews则会移除头元素，并将头元素放入mRecyclerPool，所以mCachedViews相当于一级缓存，mRecyclerPool则相当于二级缓存，并且mRecyclerPool是可以多个RecyclerView共享的，这在类似于多Tab的新闻类应用会有很大的用处，因为多个Tab下的多个RecyclerView可以共用一个二级缓存。减少内存开销。</p>
<p>RecyclerView定义了4种针对数据集的操作，分别是ADD、REMOVE、UPDATE、MOVE，封装在了AdapterHelper.UpdateOp类中，并且所有操作由一个大小为30的对象池管理着。当我们要对数据集作任何操作时，都会从这个对象池中取出一个UpdateOp对象，放入一个等待队列中，最后调用RecyclerView.RecyclerViewDataObserver.triggerUpdateProcessor()方法，根据这个等待队列中的信息，对所有子控件重新测量、布局并绘制且执行动画。以上就是我们调用Adapter.notifyItemXXX()系列方法后发生的事。显然当我们对某个ItemView做操作时，它很有可以会影响到其它ItemView。下面我以REMOVE为例来梳理下这个流程。</p>
<p><img src="/images/blogimages/2019/design_pattern_bridge_uml.png" alt=""></p>
<p>首先调用Adapter.notifyItemRemove()，追溯到方法RecyclerView.RecyclerViewDataObserver.onItemRangeRemoved()：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemRangeRemoved</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">    assertNotInLayoutOrScroll(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的mAdapterHelper.onItemRangeRemoved()就是向之前提及的等待队列添加一个类型为REMOVE的UpdateOp对象， triggerUpdateProcessor()方法就是调用View.requestLayout()方法，这会导致界面重新布局，也就是说方法RecyclerView.onLayout()会随后调用，这之后的流程就和在绘制流程一节中所描述的一致了。</p>
<h3 id="与AdapterView比较"><a href="#与AdapterView比较" class="headerlink" title="与AdapterView比较"></a>与AdapterView比较</h3><p>谈到RecyclerView，总避免不了与它的前辈AdapterView家族进行一撕，这里我整理了一下RecylerView与AdapterView的各自特点：</p>
<p><img src="/images/blogimages/2019/design_pattern_bridge_uml.png" alt=""></p>
<p>前面四点两位都提供了各自的实现，但也各有各自的特点：</p>
<h4 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h4><p>ListView原生提供Item单击、长按的事件, 而RecyclerView则需要使用onTouchListener，相对自己实现会比较复杂。</p>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>ListView可以很轻松的设置divider属性来显示Item之间的分割线，RecyclerView需要我们自己实现ItemDecoration，前者使用简单，后者可定制性强。</p>
<h4 id="布局类型"><a href="#布局类型" class="headerlink" title="布局类型"></a>布局类型</h4><p>AdapterView提供了ListView与GridView两种类型，分别对应流式布局与网格式布局。RecyclerView提供了LinearLayoutManager、GridLayoutManager与之抗衡，相对而言，使用RecyclerView来进行更换布局方式更为轻松。只需要更换一个变量即可，而对于AdapterView而言则是需要更换一个View了。</p>
<h4 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h4><p>ListView使用了一个名为RecyclerBin的类负责试图的缓存，而Recycler则使用Recycler来进行缓存，原理上两者基本一致。RecyclerView：里面存储的不是View，而是ViewHolder</p>
<h4 id="局部刷新"><a href="#局部刷新" class="headerlink" title="局部刷新"></a>局部刷新</h4><p>这是一个很有用的功能，在ListView中我们想局部刷新某个Item需要自己来编写刷新逻辑，而在RecyclerView中我们可以通过 notifyItemChanged(position) 来刷新单个Item，甚至可以通过 notifyItemChanged(position, payload) 来传入一个payload信息来刷新单个Item中的特定内容。</p>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>作为视觉动物，我相信很多人喜欢RecylerView都和它简单的动画API有关，因为之前对ListView做动画比较困难，并且不舒服。</p>
<h4 id="嵌套布局"><a href="#嵌套布局" class="headerlink" title="嵌套布局"></a>嵌套布局</h4><p>嵌套布局也是最近比较火的一个概念，RecyclerView实现了 NestedScrollingChild 接口，使得它可以和一些嵌套组件很好的工作。我们再来看ListView原生独有的几个特点：</p>
<h4 id="头部与尾部的支持"><a href="#头部与尾部的支持" class="headerlink" title="头部与尾部的支持"></a>头部与尾部的支持</h4><p>ListView原生支持添加头部与尾部，虽然RecyclerView可以通过定义不同的Type来做支持，但实际应用中，如果封装的不好，是很容易出问题的，因为Adapter中的数据位置与物理数据位置发生了偏移。</p>
<h4 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h4><p>支持多选、单选也是ListView的一大长处，其实如果要我们自己在RecyclerView中去做支持还是需要不少代码量的。多数据源的支持ListView提供了CursorAdapter、ArrayAdapter，可以让我们很方便的从数据库或者数组中获取数据，这在测试的时候很有用。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上，我们会发现RecycerView的最大特点就是灵活，正因为这种灵活，因此会牺牲了某些便利性。而AdapterView相对来讲就比较刻板，但它原生为我们提供了很多有用的方法来便于我们快速开发。ListView并不像当年的ActivityGroup，在Fragment出来后就被标记为Deprecated。两者目前还是一种互补的关系，起码在短时间内RecyclerView还并不能完全替代AdapterView，个人感觉原因有两个，一是目前太多的应用使用了ListView，并且ListView向RecyclerView转变也没有无损的方法。第二点，比如我就是想添加个头部，每个item带个点击事件这类简单的需求，ListView完全可以很轻松的胜任，没必要舍近求远来使用RecyclerView。因此，在实际应用中选择更适合自己的就好。</p>
<p>当然，从Google最近几次的更新来看，RecyclerView的进化还是很迅速的，而ListView则几乎没什么变动，所以RecyclerView绝对是大大的潜力股呀。</p>
<h3 id="设计精巧的类"><a href="#设计精巧的类" class="headerlink" title="设计精巧的类"></a>设计精巧的类</h3><p>在翻看RecycleView源码的过程中也遇见了许多之前没有注意过的类，这些类都可以复用在我们的日常工作当中。这里列举出其中具有代表性的几位。</p>
<h4 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h4><p>如果一个对象有大量的是与非的状态需要表示，通常我们会使用BitMask 技术来节省内存，在 Java 中，一个 byte 类型，有 8 位（bit），可以表达 8 个不同的状态，而 int 类型，则有 32 位，可以表达 32 种状态。再比如Long类型，有64位，则可以表达64中状态。一般情况下使用一个Long已经足够我们使用了。但如果有不设上限的状态需要我们表示呢？在ChildHelper里有一个静态内部类Bucket，基本源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> BITS_PER_WORD = Long.SIZE;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> LAST_BIT = <span class="number">1L</span> &lt;&lt; (Long.SIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> mData = <span class="number">0</span>;</span><br><span class="line">    Bucket next;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= BITS_PER_WORD) &#123;</span><br><span class="line">            ensureNext();</span><br><span class="line">            next.set(index - BITS_PER_WORD);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mData |= <span class="number">1L</span> &lt;&lt; index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，Bucket是一个链表结构，当index大于64的时候，它便会去下一个Bucket去寻找，所以，Bucket可以不设上限的表示状态。</p>
<h4 id="Pools"><a href="#Pools" class="headerlink" title="Pools"></a>Pools</h4><p>熟悉Message回收机制的朋友可能了解，在使用Message对象时最好通过 Message.obtain() 方法来获取，这样可以在很多情况下避免创建新对象。在使用完之后调用 message.recycle() 来回收消息。谷歌为这种机制也提供了抽象的实现,就是位于v4包下Pools类, 内部接口Pool提供了 acquire 与 release 两个方法,不过需要注意的是这个 acquire 方法可能返回空,毕竟Pools不是业务类,它不应该清楚对象的具体创建逻辑.还有一点是Pools与Message类的实现机制不同,每个Message对象内部都持有一个引用下一个message的指针,相当于一个链表结构,而Pool的实现类 SimplePool 中使用的是数组.Pool机制在 RecycleView 中有如下几处应用：</p>
<p>RecycleView将item的增删改封装为 UpdateOp 类。<br>ViewInfoStore 类中静态内部类 InfoRecord 。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>RecyclerView也不是万能的，它的灵活性也是有一定限制的，比如我就遇到了一不是很好解决的问题：Recyler的缓存级别是一个Item的整个View，而我们没办法自定义缓存级别，这样说比较抽象，举个例子，我的某些Item的某个子View加载很耗时，所以我希望我在上下滑动的时候，Item的其它View是可以被回收利用的，但这个加载很耗时的View是不要重复使用的。即我希望用空间换取时间来获取滑动的流畅性。当然，这样的需求不常见，RecyclerView也不能很好的满足这一点。</p>
<p>RecyclerView也应该算作一个明星控件了，自从其诞生开始就备受欢迎，仔细的学习也能让我们在工作中更容易的、更恰当的使用。本文也只是分析了RecyclerView的一部分，关于动画、滑动、嵌套滑动等等还需要大家自行去研究。有兴趣的可以看看<a href="https://www.jianshu.com/p/f592f3715ae2?utm_campaign=haruki&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin&amp;from=singlemessage&amp;isappinstalled=1" target="_blank" rel="noopener">RecyclerView 和 ListView 使用对比分析</a></p>
<hr>
<div style="width:690.45px"><div style="display:inline-block;width:110px"><a rel="noopener" href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank"><img style="border-width:0" src="http://blog.conorlee.top/blogimages/attribution_88x31.png"></a></div><div style="display:inline-block;width:580px;"><br>    本文采用<a rel="noopener" href="http://creativecommons.org/licenses/by/2.5/cn/" target="_blank">知识共享署名 2.5 中国大陆许可协议</a>进行许可，欢迎转载，但转载请注明来自<a href="http://conorlee.top/" target="_blank" rel="noopener">Agehua’s Blog</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。</div></div>

<p>本文链接：<a href="http://agehua.github.io/2019/05/31/RecyclerView-source-code/">http://agehua.github.io/2019/05/31/RecyclerView-source-code/</a></p>


            
  <!-- donate css -->
  <style type="text/css">
      .center {
          text-align: center;
      }
      .hidden {
          display: none;
      }
         
    .donate_bar a.btn_donate{
      display: inline-block;
      width: 82px;
      height: 82px;
      background: url("http://cdn.conorlee.top/btn_reward.gif") no-repeat;
      _background: url("http://cdn.conorlee.top/btn_reward.gif") no-repeat;
      -webkit-transition: background 0s;
      -moz-transition: background 0s;
      -o-transition: background 0s;
      -ms-transition: background 0s;
      transition: background 0s;

    }

    .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
    .donate_bar .donate_txt {
      display: block;
      color: #9d9d9d;
      font: 14px/2 "Microsoft Yahei";
    }
    .bold{ font-weight: bold; }
  </style>
  <!-- /css -->

<!-- Donate Module -->
<div id="donate_module">

  <!-- btn_donate & tips -->
  <div id="donate_board" class="donate_bar center">
      <br>
      ------------------------------------------------------------------------------------------------------------------------------
      <br>
    <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
    <span class="donate_txt">
      Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！
    </span>
  </div>
  <!-- /btn_donate & tips -->

  <!-- donate guide -->

  <div id="donate_guide" class="donate_bar center hidden" >
        <br>
      ------------------------------------------------------------------------------------------------------------------------------
      <br>
      <div class="donate_wechat" style="background:#9d9d9d;display:inline;margin:auto; " >
        <a href="http://cdn.conorlee.top/weixin_charge.png" title="用微信扫一扫哦~" class="fancybox" rel="article0">
          <img src="http://cdn.conorlee.top/weixin_charge.png" title="微信打赏 Colin" height="auto" width="50%"
          style="float:left;"/>
        </a>
        <a href="http://cdn.conorlee.top/zhifubao_charge.png" title="用支付宝扫一扫即可~" class="fancybox" rel="article0">
          <img src="http://cdn.conorlee.top/zhifubao_charge.png" title="支付宝打赏 Colin" height="auto" width="50%"
          style="float:left;"/>
        </a>
      </div>
      <div style="display:inline-block;">
          &nbsp;
          <span class="donate_txt">
              Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！
          </span>
      </div>

  </div>
  <!-- /donate guide -->

  <!-- donate script -->
  <script type="text/javascript">
    document.getElementById('btn_donate').onclick = function() {
      $('#donate_board').addClass('hidden');
      $('#donate_guide').removeClass('hidden');
    }

    function donate_on_web(){
      $('#donate').submit();
        }

    var original_window_onload = window.onload;
        window.onload = function () {
            if (original_window_onload) {
                original_window_onload();
            }
            document.getElementById('donate_board_wdg').className='hidden';
    }
  </script>
  <!-- /donate script -->
</div>
<!-- /Donate Module -->

            
        
        </div>

        <footer class="article-footer">
          

          

          <div class="share-container">



</div>

    <a data-url="http://agehua.github.io/2019/05/31/RecyclerView-source-code/" data-id="cketmkxfh00berjvdeeec1yfb" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

          
    
        <a href="http://agehua.github.io/2019/05/31/RecyclerView-source-code/#comments" class="article-comment-link">Comments</a>
    


        </footer>

    </div>
    
        
<nav id="article-nav">
    
        <a href="/2019/07/17/RecyclerView-pre-initiate/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    RecyclerView预加载机制源码分析
                
            </div>
        </a>
    
    
        <a href="/2019/05/30/RecyclerView-Design-Pattern/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">RecyclerView 中的设计模式</div>
        </a>
    
</nav>


    
    <script>
        pangu.spacingPage();
    </script>


    
    <section id="comments" class="comments">
    
        
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '2019/05/31/RecyclerView-source-code/', // 可选。默认为 location.href
  title: 'RecyclerView 源码分析',
  owner: 'agehua',
  repo: 'agehua.me',
  oauth: {
    client_id: '08e030c9191b13da9adb' , //'你的 client ID'
    client_secret: 'bddb8106ceb73823fe1a6f7ab8d1b91957715d5e', //'你的 client secret'
  },
})
gitment.render('comments')
</script>

    
  </section>



</article>


</section>
            
                <aside id="sidebar">
    <!-- 在_config.yml中配置了widgets，来决定widgets的顺序 -->
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/09/07/Kotlin-DSL/" class="thumbnail">
    
    
        <span style="background-image:url(http://cdn.conorlee.top/Fish-Drying%20Barn%2C%20Seen%20From%20a%20Height.jpg)" alt="Kotlin DSL 语法糖" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/accumulation/">accumulation</a></p>
                            <p class="item-title"><a href="/2020/09/07/Kotlin-DSL/" class="title">Kotlin DSL 语法糖</a></p>
                            <p class="item-date"><time datetime="2020-09-06T16:00:00.000Z" itemprop="datePublished">2020-09-07</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/31/JVM-stack-and_heap/" class="thumbnail">
    
    
        <span style="background-image:url(http://cdn.conorlee.top/First%20Steps%20after%20Millet.jpg)" alt="JVM 堆和栈知识点积累" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/accumulation/">accumulation</a></p>
                            <p class="item-title"><a href="/2020/08/31/JVM-stack-and_heap/" class="title">JVM 堆和栈知识点积累</a></p>
                            <p class="item-date"><time datetime="2020-08-30T16:00:00.000Z" itemprop="datePublished">2020-08-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/07/10/profile_analysis/" class="thumbnail">
    
    
        <span style="background-image:url(http://cdn.conorlee.top/Field%20with%20Wheat%20Stacks.jpg)" alt="Android Studio CPU Profiler使用" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/accumulation/">accumulation</a></p>
                            <p class="item-title"><a href="/2020/07/10/profile_analysis/" class="title">Android Studio CPU Profiler使用</a></p>
                            <p class="item-date"><time datetime="2020-07-09T16:00:00.000Z" itemprop="datePublished">2020-07-10</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/05/26/download-function-analysis/" class="thumbnail">
    
    
        <span style="background-image:url(http://cdn.conorlee.top/Field%20with%20Two%20Rabbits.jpg)" alt="分析下载功能源码和实现" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/accumulation/">accumulation</a></p>
                            <p class="item-title"><a href="/2020/05/26/download-function-analysis/" class="title">分析下载功能源码和实现</a></p>
                            <p class="item-date"><time datetime="2020-05-25T16:00:00.000Z" itemprop="datePublished">2020-05-26</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/12/09/Android-Measure/" class="thumbnail">
    
    
        <span style="background-image:url(http://cdn.conorlee.top/Field%20with%20Stacks%20of%20Wheat.jpg)" alt="从FrameLayout分析View测量原理" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/accumulation/">accumulation</a></p>
                            <p class="item-title"><a href="/2019/12/09/Android-Measure/" class="title">从FrameLayout分析View测量原理</a></p>
                            <p class="item-date"><time datetime="2019-12-08T16:00:00.000Z" itemprop="datePublished">2019-12-09</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/investigation/">Investigation</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">Mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/accumulation/">accumulation</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/english/">english</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/read/">read</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a><span class="category-list-count">5</span></li></ul>
        </div>
    </div>


    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/aac/" style="font-size: 10px;">AAC</a> <a href="/tags/aes/" style="font-size: 10px;">AES</a> <a href="/tags/aidl/" style="font-size: 12px;">AIDL</a> <a href="/tags/ams/" style="font-size: 10px;">AMS</a> <a href="/tags/android/" style="font-size: 20px;">ANDROID</a> <a href="/tags/aosp/" style="font-size: 12px;">AOSP</a> <a href="/tags/alfred-workflow/" style="font-size: 10px;">Alfred Workflow</a> <a href="/tags/android-app-bundles/" style="font-size: 10px;">Android APP Bundles</a> <a href="/tags/android-framework/" style="font-size: 10px;">Android Framework</a> <a href="/tags/android-system-service/" style="font-size: 10px;">Android system service</a> <a href="/tags/annotation/" style="font-size: 12px;">Annotation</a> <a href="/tags/asynctask/" style="font-size: 10px;">AsyncTask</a> <a href="/tags/audiorecord/" style="font-size: 10px;">AudioRecord</a> <a href="/tags/basic-knowledge/" style="font-size: 18px;">Basic Knowledge</a> <a href="/tags/binder/" style="font-size: 16px;">Binder</a> <a href="/tags/cmd/" style="font-size: 10px;">CMD</a> <a href="/tags/coordinatorlayout/" style="font-size: 10px;">CoordinatorLayout</a> <a href="/tags/eit/" style="font-size: 10px;">EIT</a> <a href="/tags/ejs/" style="font-size: 10px;">EJS</a> <a href="/tags/electron/" style="font-size: 10px;">Electron</a> <a href="/tags/framelayout/" style="font-size: 10px;">FrameLayout</a> <a href="/tags/gc/" style="font-size: 10px;">GC</a> <a href="/tags/gcm/" style="font-size: 10px;">GCM</a> <a href="/tags/hook/" style="font-size: 10px;">HOOK</a> <a href="/tags/https/" style="font-size: 10px;">HTTPS</a> <a href="/tags/handler/" style="font-size: 10px;">Handler</a> <a href="/tags/handlerthread/" style="font-size: 10px;">HandlerThread</a> <a href="/tags/hexo/" style="font-size: 14px;">Hexo</a> <a href="/tags/hexo-structure/" style="font-size: 10px;">Hexo structure</a> <a href="/tags/im-company/" style="font-size: 10px;">IM Company</a> <a href="/tags/intentservice/" style="font-size: 10px;">IntentService</a> <a href="/tags/interview-knowledge/" style="font-size: 16px;">Interview Knowledge</a> <a href="/tags/jni/" style="font-size: 14px;">JNI</a> <a href="/tags/jvm/" style="font-size: 12px;">JVM</a> <a href="/tags/java/" style="font-size: 16px;">Java</a> <a href="/tags/javascript/" style="font-size: 12px;">JavaScript</a> <a href="/tags/kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/leakcanary/" style="font-size: 10px;">LeakCanary</a> <a href="/tags/locationlistener/" style="font-size: 10px;">LocationListener</a> <a href="/tags/looper/" style="font-size: 12px;">Looper</a> <a href="/tags/measure/" style="font-size: 10px;">Measure</a> <a href="/tags/memory-leaks/" style="font-size: 10px;">Memory leaks</a> <a href="/tags/messagequeue/" style="font-size: 10px;">MessageQueue</a> <a href="/tags/object-oriented/" style="font-size: 10px;">Object-oriented</a> <a href="/tags/open-souces/" style="font-size: 10px;">Open souces</a> <a href="/tags/pboc/" style="font-size: 12px;">PBOC</a> <a href="/tags/pboc-2-0/" style="font-size: 12px;">PBOC 2.0</a> <a href="/tags/patch-update/" style="font-size: 10px;">Patch Update</a> <a href="/tags/profiler/" style="font-size: 10px;">Profiler</a> <a href="/tags/python/" style="font-size: 10px;">Python</a> <a href="/tags/recyclerview/" style="font-size: 14px;">RecyclerView</a> <a href="/tags/relativelayout/" style="font-size: 10px;">RelativeLayout</a> <a href="/tags/rxandroid/" style="font-size: 10px;">RxAndroid</a> <a href="/tags/rxjava/" style="font-size: 10px;">RxJava</a> <a href="/tags/singleton/" style="font-size: 10px;">Singleton</a> <a href="/tags/tcp/" style="font-size: 10px;">TCP</a> <a href="/tags/threadlocal/" style="font-size: 12px;">ThreadLocal</a> <a href="/tags/timertask/" style="font-size: 10px;">TimerTask</a> <a href="/tags/android-source-code/" style="font-size: 10px;">android source code</a> <a href="/tags/assertion/" style="font-size: 10px;">assertion</a> <a href="/tags/azure/" style="font-size: 10px;">azure</a> <a href="/tags/bits-operation/" style="font-size: 10px;">bits operation</a> <a href="/tags/byte/" style="font-size: 10px;">byte[]</a> <a href="/tags/download/" style="font-size: 10px;">download</a> <a href="/tags/exitapplication/" style="font-size: 10px;">exitApplication</a> <a href="/tags/genericity/" style="font-size: 12px;">genericity</a> <a href="/tags/google-map/" style="font-size: 10px;">google map</a> <a href="/tags/gradle/" style="font-size: 12px;">gradle</a> <a href="/tags/gson/" style="font-size: 10px;">gson</a> <a href="/tags/handler/" style="font-size: 10px;">handler</a> <a href="/tags/iterm/" style="font-size: 10px;">iterm</a> <a href="/tags/linux/" style="font-size: 12px;">linux</a> <a href="/tags/multi-process/" style="font-size: 10px;">multi-process</a> <a href="/tags/multi-thread/" style="font-size: 10px;">multi-thread</a> <a href="/tags/net-request/" style="font-size: 10px;">net request</a> <a href="/tags/new-features/" style="font-size: 10px;">new features</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/notification/" style="font-size: 10px;">notification</a> <a href="/tags/publickey/" style="font-size: 10px;">publickey</a> <a href="/tags/qiniu/" style="font-size: 10px;">qiniu</a> <a href="/tags/read/" style="font-size: 12px;">read</a> <a href="/tags/reading/" style="font-size: 10px;">reading</a> <a href="/tags/remove-admob/" style="font-size: 10px;">remove admob</a> <a href="/tags/scp/" style="font-size: 10px;">scp</a> <a href="/tags/sdk-compile/" style="font-size: 10px;">sdk compile</a> <a href="/tags/self-introduction/" style="font-size: 10px;">self-introduction</a> <a href="/tags/svn-server/" style="font-size: 10px;">svn server</a> <a href="/tags/third-party-signin/" style="font-size: 10px;">third-party signin</a> <a href="/tags/toastmaster/" style="font-size: 14px;">toastmaster</a> <a href="/tags/webview/" style="font-size: 10px;">webview</a>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
                    <li>
                        <a href="http://conorlee.top">我的阿里云博客(求赞助)</a>
                    </li>
                
                    <li>
                        <a href="https://agehua.github.io/">My Github Pages</a>
                    </li>
                
                    <li>
                        <a href="http://invitation.conorlee.top/MrLiAndTeacherTian_WeddingInvitation.html">Wedding Invitation(手机观看最佳)</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 Jixin Li<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '2019/05/31/RecyclerView-source-code/', // 可选。默认为 location.href
  title: 'RecyclerView 源码分析',
  owner: 'agehua',
  repo: 'agehua.me',
  oauth: {
    client_id: '08e030c9191b13da9adb' , //'你的 client ID'
    client_secret: 'bddb8106ceb73823fe1a6f7ab8d1b91957715d5e', //'你的 client secret'
  },
})
gitment.render('comments')
</script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

<script>
    var bigfa_scroll = {
        drawCircle: function(id, percentage, color) {
            var width = jQuery(id).width();
            var height = jQuery(id).height();
            var radius = parseInt(width / 2.20);
            var position = width;
            var positionBy2 = position / 2;
            var bg = jQuery(id)[0];
            id = id.split("# ");
            var ctx = bg.getContext("2d");
            var imd = null;
            var circ = Math.PI * 2;
            var quart = Math.PI / 2;
            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineCap = "square";
            ctx.closePath();
            ctx.fill();
            ctx.lineWidth = 3;
            imd = ctx.getImageData(0, 0, position, position);
            var draw = function(current, ctxPass) {
                ctxPass.putImageData(imd, 0, 0);
                ctxPass.beginPath();
                ctxPass.arc(positionBy2, positionBy2, radius, -(quart), ((circ) * current) - quart, false);
                ctxPass.stroke();
            }
            draw(percentage / 100, ctx);
        },
        backToTop: function($this) {
            $this.click(function() {
                jQuery("body,html").animate({
                    scrollTop: 0
                },
                800);
                return false;
            });
        },
        scrollHook: function($this, color) {
            color = color ? color: "# 000000";
            $this.scroll(function() {
                var docHeight = (jQuery(document).height() - jQuery(window).height()),
                $windowObj = $this,
                $per = jQuery(".per"),
                percentage = 0;
                defaultScroll = $windowObj.scrollTop();
                percentage = parseInt((defaultScroll / docHeight) * 100);
                var backToTop = jQuery("# backtoTop");
                if (backToTop.length > 0) {
                    if ($windowObj.scrollTop() > 200) {
                        backToTop.addClass("button--show");
                    } else {
                        backToTop.removeClass("button--show");
                    }
                    $per.attr("data-percent", percentage);
                    bigfa_scroll.drawCircle("# backtoTopCanvas", percentage, color);
                }
            });
        }
    }

</script>


    </div>
    <!-- <script src="http://cdn.maxjia.com/js/particles.min.js"></script> -->
  
  
    <canvas class="fireworks" style="position: fixed; left: 0px; top: 0px; z-index: 1; pointer-events: none; width: 1440px; height: 416px;" width="2880" height="832"></canvas>
    

      <script type="text/javascript" src="/js/anime.min.js"></script>
      <script type="text/javascript" src="/js/firework.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/33.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
