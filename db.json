{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":0},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"source/images/blogimages/2016/androidart_broadcastreceiver1.png","path":"images/blogimages/2016/androidart_broadcastreceiver1.png","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/avg_warning.PNG","path":"images/blogimages/2016/avg_warning.PNG","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/google_servcie_ads.PNG","path":"images/blogimages/2016/google_servcie_ads.PNG","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/gradle_structure1.png","path":"images/blogimages/2016/gradle_structure1.png","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/gradle_structure2.png","path":"images/blogimages/2016/gradle_structure2.png","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/jni_structure.png","path":"images/blogimages/2016/jni_structure.png","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/gradle_task.png","path":"images/blogimages/2016/gradle_task.png","modified":1,"renderable":0},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar0.png","path":"css/images/avatar0.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar1.png","path":"css/images/avatar1.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/styles.css","path":"libs/open-sans/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":1,"renderable":1},{"_id":"source/images/blogimages/2016/androidart_broadcastreceiver2.png","path":"images/blogimages/2016/androidart_broadcastreceiver2.png","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/androidart_service1.png","path":"images/blogimages/2016/androidart_service1.png","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/androidart_activity.png","path":"images/blogimages/2016/androidart_activity.png","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/androidart_contentprovider.png","path":"images/blogimages/2016/androidart_contentprovider.png","modified":1,"renderable":0},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":1,"renderable":1},{"_id":"source/images/blogimages/2016/androidart_ipc.png","path":"images/blogimages/2016/androidart_ipc.png","modified":1,"renderable":0},{"_id":"source/images/blogimages/2016/androidart_service2.png","path":"images/blogimages/2016/androidart_service2.png","modified":1,"renderable":0},{"_id":"themes/icarus/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","path":"libs/jquery/2.1.3/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"93a8a2453fe941ffa7e5edf46a656657160bc78d","modified":1482902484000},{"_id":"themes/icarus/LICENSE","hash":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1480496898000},{"_id":"themes/icarus/README.md","hash":"25c75503f044b817297995a96621c92ce037a098","modified":1480496898000},{"_id":"themes/icarus/_config.yml","hash":"6492899ea7aaed43766aae6fcdbc8de7fd8ff4e0","modified":1481251538000},{"_id":"themes/icarus/package.json","hash":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1480496898000},{"_id":"source/_posts/2014-12-23-hello-world.md","hash":"14e73ec4f51204aecf89a403e295e519364da0da","modified":1482748875000},{"_id":"source/_posts/2015-03-16-java-multithreading-concurrent.md","hash":"3ff5b5cd0ff8d9d991f79e4159aff514a0dd7c38","modified":1482748875000},{"_id":"source/_posts/2015-11-06-book-list-of-2015.md","hash":"8197f40fe16803ebd29ce8213f63b58103256706","modified":1482748875000},{"_id":"source/_posts/2016-03-01-android-googlemap-summary.md","hash":"4097f39ed30a4dd02a71b56afbe16c3ff8a63a42","modified":1482748875000},{"_id":"source/_posts/2016-03-15-facebook-google+signin.md","hash":"bcd1f441eae56af97d9266b5c12e1cb976e74297","modified":1482748875000},{"_id":"source/_posts/2016-03-20-android-new-knowledge-summary.md","hash":"1268ebe726043ce7e17712404ceccc6b36ae49eb","modified":1482748875000},{"_id":"source/_posts/2016-03-20-android-books-reading-.md","hash":"b573f4c3ec8e881e89d94e999b3a892e1fdd1ece","modified":1482748875000},{"_id":"source/_posts/2016-05-12-GCM-Azure_summary.md","hash":"bfc816e17c5cecd84c286d7026bccd378c7cc8e6","modified":1482748875000},{"_id":"source/_posts/2016-05-18-javaString-and-bytes.md","hash":"c4836163e8d719d91e76b8e90e89d6c60e652c25","modified":1482748875000},{"_id":"source/_posts/2016-05-24-JNI-Learning.md","hash":"dc894650e5307bb5cc9faa671401f00216acb714","modified":1482748875000},{"_id":"source/_posts/2016-05-24-JNI-Learning0.md","hash":"7161734ef221c30e124abd749126e45b4f48f8f5","modified":1482748875000},{"_id":"source/_posts/2016-05-28-qiniu-android-summary.md","hash":"787d164c97b87f7352f913af76b186118a95a1bc","modified":1482748875000},{"_id":"source/_posts/2016-06-08-gson-summary.md","hash":"e497d1049dd01fadb664a052816b22b7627af84b","modified":1482748875000},{"_id":"source/_posts/2016-07-25-android-webview-summary.md","hash":"ec74bde691db77f42f4f696f0f3ca4d70f6cd91d","modified":1482748875000},{"_id":"source/_posts/2016-08-03-android-LocationListener.md","hash":"0f86fb2d917ec1de83a9995a9c302c388b72f1b0","modified":1482748875000},{"_id":"source/_posts/2016-08-16-RxAndroid-Learning.md","hash":"66d2cd257bb0bf61ba90407450edd85db1d81ec9","modified":1482748875000},{"_id":"source/_posts/2016-09-05-ThreadLocal-HandlerThread-Lopper.md","hash":"224c4785e02e74fd5412d084ada1b879b0e8f058","modified":1482748875000},{"_id":"source/_posts/2016-09-20-AVG-unwanted-software.md","hash":"90b8bbc941dd651eb1de031c2ac67d96c210fb1f","modified":1482748875000},{"_id":"source/_posts/2016-09-20-android-design-pattern-singleton.md","hash":"ef8aee864a0d9cac7ea47acd6ed0013f01d8baa2","modified":1482748875000},{"_id":"source/_posts/2016-09-22-JNI-get-publickey.md","hash":"96248dc16a30318006e11131d84170d43a4024a5","modified":1482748875000},{"_id":"source/_posts/2016-09-22-quit-whole-application.md","hash":"b75d86c3031cf9cb37552fb4639c70e73235c5a5","modified":1482748875000},{"_id":"source/_posts/2016-09-28-Android-interview-questions.md","hash":"21ed041a16060f1eef2344364b34b11778c15ded","modified":1482748875000},{"_id":"source/_posts/2016-10-12-gradle-learning.md","hash":"e40dd7449678ba4c9809803ad4623f36e56347b0","modified":1482748875000},{"_id":"source/_posts/2016-10-13-gradle-learning2.md","hash":"a96c217e9abd2d430b35469670063422fa589566","modified":1482748875000},{"_id":"source/_posts/2016-11-03-hexo-mac-module-not-found.md","hash":"92855ffda65b1ad2056d8d740b16ab30015367f6","modified":1482894843000},{"_id":"source/_posts/2016-12-06-hexo-learning1.md","hash":"d36fb9657067d8b64cb5e322039d9c0d8fac7931","modified":1482894910000},{"_id":"source/_posts/2016-12-04-hexo-learning0.md","hash":"704f5ad794363361cffc7acc0553785fb1074d78","modified":1482894506000},{"_id":"source/_posts/2016-12-20-Android-patch-update.md","hash":"8e45f4ad974224815d3c0ecf9ee25947b4fdb305","modified":1482906501000},{"_id":"source/about/index.md","hash":"5ad7719fd53c52ae9a9e96afc5a8932f3152fd5b","modified":1482748875000},{"_id":"source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1482748875000},{"_id":"source/images/avatar.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1482748875000},{"_id":"source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1482748875000},{"_id":"themes/icarus/_source/.DS_Store","hash":"7c14450e2464624999afc5b65240575c1b443fae","modified":1482902584000},{"_id":"themes/icarus/gallery/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1480595851000},{"_id":"themes/icarus/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1480496898000},{"_id":"themes/icarus/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1480496898000},{"_id":"themes/icarus/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1480496898000},{"_id":"themes/icarus/languages/id.yml","hash":"70ec9ab2ac04cf882e81377ca5ad15bf8adceca8","modified":1480496898000},{"_id":"themes/icarus/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1480496898000},{"_id":"themes/icarus/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1480496898000},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1480496898000},{"_id":"themes/icarus/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1480496898000},{"_id":"themes/icarus/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1480496898000},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1480496898000},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1480496898000},{"_id":"themes/icarus/layout/.DS_Store","hash":"05a9e5dcee6b45cca2d8467dbd41c8ab0eb6fb44","modified":1482902609000},{"_id":"themes/icarus/layout/archive.ejs","hash":"c1ecf667f40f34d61ab33eed46bab143eb1af36d","modified":1480496898000},{"_id":"themes/icarus/layout/categories.ejs","hash":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1480496898000},{"_id":"themes/icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1480496898000},{"_id":"themes/icarus/layout/index.ejs","hash":"43e971ebc35657b18e08a049559790348a16666f","modified":1480496898000},{"_id":"themes/icarus/layout/layout.ejs","hash":"88186b8e3ab6ffdd1808b59132b4062ac6a7442b","modified":1481013080000},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1480496898000},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1480496898000},{"_id":"themes/icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1480496898000},{"_id":"themes/icarus/layout/tags.ejs","hash":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1480496898000},{"_id":"themes/icarus/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1480496898000},{"_id":"themes/icarus/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1480496898000},{"_id":"themes/icarus/source/.DS_Store","hash":"14293605e17d49aaf5f85225f1b4fc759688b948","modified":1482902630000},{"_id":"source/_posts/2016-12-03-nodejs-learning-getting-started.md","hash":"406f6c4896c3ccb5213f4e45d9028bc6e8ffcf6c","modified":1482894442000},{"_id":"themes/icarus/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1480496898000},{"_id":"themes/icarus/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1480496898000},{"_id":"themes/icarus/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1480496898000},{"_id":"themes/icarus/layout/comment/counter.ejs","hash":"e109d3256b004b027d029bd5bd67feeb72dc5388","modified":1480496898000},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"1b32a90f400dc580f4b8298de75b94429ca6de68","modified":1480496898000},{"_id":"themes/icarus/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1480496898000},{"_id":"themes/icarus/layout/comment/index.ejs","hash":"d45635e78a3fc40e424a401e983f2c8eef6ebcfd","modified":1480496898000},{"_id":"themes/icarus/layout/comment/scripts.ejs","hash":"8a9a20f72ba0923afa776396fb67d8c5d446a666","modified":1480496898000},{"_id":"themes/icarus/layout/comment/youyan.ejs","hash":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1480496898000},{"_id":"themes/icarus/layout/common/.DS_Store","hash":"fe3a1b2077d038bf1c41e6251a1ecc40f9440fd1","modified":1482902599000},{"_id":"themes/icarus/layout/common/article.ejs","hash":"7aad35baff09a0444e699f81f4c4939b01a2c913","modified":1482903471000},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"cbfe560fcab445d42ceeb5d1beba5957d5be5eaa","modified":1480496898000},{"_id":"themes/icarus/layout/common/head.ejs","hash":"44f30945882afd27c89da2173da501fb1b531488","modified":1480496898000},{"_id":"themes/icarus/layout/common/header.ejs","hash":"738c6a923b2a6de6a81c4892c8a47e03d8b34f88","modified":1480496898000},{"_id":"themes/icarus/layout/common/profile.ejs","hash":"0d5a9622d490652599e3ba3e4077a7d6bb2eb38e","modified":1481252238000},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1480496898000},{"_id":"themes/icarus/layout/common/sidebar.ejs","hash":"6e80fa52d23c9c39bfa357a1e00c26fc8b851b82","modified":1480496898000},{"_id":"themes/icarus/layout/common/thumbnail.ejs","hash":"1b70f8a98cd8650b159bda858dbee38dbdb7f0c5","modified":1480496898000},{"_id":"themes/icarus/layout/common/timeline.ejs","hash":"6420e34e0332c9b6670011519f341340db989343","modified":1480496898000},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1480496898000},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1480496898000},{"_id":"themes/icarus/layout/plugin/scripts.ejs","hash":"4fdb85e6730530f2d262041b41d1ead1b87dfd88","modified":1480496898000},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1480496898000},{"_id":"themes/icarus/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1480496898000},{"_id":"themes/icarus/layout/search/index.ejs","hash":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1480496898000},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"130fe3d33ac71da0b50f7fee6a87979f30938a1b","modified":1480496898000},{"_id":"themes/icarus/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1480496898000},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1480496898000},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1480496898000},{"_id":"themes/icarus/layout/share/default.ejs","hash":"ebfb919dc525b3ed61a6a5ee05ee71410eedc541","modified":1480496898000},{"_id":"themes/icarus/layout/share/index.ejs","hash":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1480496898000},{"_id":"themes/icarus/layout/share/jiathis.ejs","hash":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1480496898000},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1480496898000},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1480496898000},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"aad118699718b62c0d3f3cfd6f17a181139a76af","modified":1480496898000},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"2ca923465275fb38a7ac7d67211d6e94a977e957","modified":1480496898000},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"3b8ae5953990436893da9d68f910ebe592005659","modified":1480496898000},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1480496898000},{"_id":"themes/icarus/source/css/.DS_Store","hash":"3399f1cc05511d38c954f9357ab3d0a99ece2147","modified":1482902640000},{"_id":"themes/icarus/source/css/_extend.styl","hash":"9a5c72663c0da1b32ecb6a75773a5ccfb8c467ca","modified":1480496898000},{"_id":"themes/icarus/source/css/_variables.styl","hash":"d62af931be6612ec8c3a917836379a8cd92fbce1","modified":1480496898000},{"_id":"themes/icarus/source/css/style.styl","hash":"82aa42f9826dc14e9e0d6443af6e253029e7fee6","modified":1480496898000},{"_id":"themes/icarus/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1482718102000},{"_id":"themes/icarus/source/images/avatar.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1480497902000},{"_id":"themes/icarus/source/images/favicon.ico","hash":"e64542caa1b7a07484925304cd99c93129dfce8e","modified":1482718701000},{"_id":"themes/icarus/source/js/insight.js","hash":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3","modified":1480496898000},{"_id":"themes/icarus/source/js/main.js","hash":"1faffdc7aa7f0d28e85edbf49c99de3ad0b65753","modified":1480496898000},{"_id":"themes/icarus/source/libs/.DS_Store","hash":"236986aa277e10799780787fa3f9cbbb3796cd0d","modified":1482902630000},{"_id":"source/images/blogimages/2016/androidart_broadcastreceiver1.png","hash":"dc4a97d2b8ef1f6592717204788d9f716117fdee","modified":1482748875000},{"_id":"source/images/blogimages/2016/avg_warning.PNG","hash":"1b8817b076f48cf8217439e0265cb4216abb3d17","modified":1482748875000},{"_id":"source/images/blogimages/2016/google_servcie_ads.PNG","hash":"10c107e578bcfb28ee9f38c247f62cb99f14ea1a","modified":1482748875000},{"_id":"source/images/blogimages/2016/gradle_structure1.png","hash":"0b8c1f213bb88852ecb0fd8a50b60f310d6a23e8","modified":1482748875000},{"_id":"source/images/blogimages/2016/gradle_structure2.png","hash":"6a8aefb3577950beeba2900f507e749dd518345e","modified":1482748875000},{"_id":"source/images/blogimages/2016/jni_structure.png","hash":"312696c9a056a734ff63d9457ff0bb83f356f057","modified":1482748875000},{"_id":"source/images/blogimages/2016/gradle_task.png","hash":"6890da207d5772a6f141024267547db56e9bec38","modified":1482748875000},{"_id":"themes/icarus/layout/common/post/banner.ejs","hash":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1480496898000},{"_id":"themes/icarus/layout/common/post/category.ejs","hash":"75c9dda2e7ec041943855ca163a6b1c4c8b4f260","modified":1480496898000},{"_id":"themes/icarus/layout/common/post/date.ejs","hash":"45cb0bcad461036cdd1fe2e3fbb5f2f19940025c","modified":1480496898000},{"_id":"themes/icarus/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1480496898000},{"_id":"themes/icarus/layout/common/post/nav.ejs","hash":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1480496898000},{"_id":"themes/icarus/layout/common/post/tag.ejs","hash":"2e966216256321aa0c76fe1b9be689601c76ef31","modified":1480496898000},{"_id":"themes/icarus/layout/common/post/title.ejs","hash":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1480496898000},{"_id":"themes/icarus/layout/common/post/toc.ejs","hash":"29d6f391553b26e1d7c89525d9e8dbd1b278e2bd","modified":1481011928000},{"_id":"themes/icarus/source/css/_partial/archive.styl","hash":"d35088c83ddd7a197d6d94e16a2ce3a7e29fa1dc","modified":1480496898000},{"_id":"themes/icarus/source/css/_partial/article.styl","hash":"5dda40a3767646502722bcf810e289f89f1fd998","modified":1480496898000},{"_id":"themes/icarus/source/css/_partial/comment.styl","hash":"784646796184d4f27918c22395288a2fafbf9554","modified":1480496898000},{"_id":"themes/icarus/source/css/_partial/footer.styl","hash":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1480496898000},{"_id":"themes/icarus/source/css/_partial/header.styl","hash":"1e351f741144135871a3373fe7e969dc961b65e7","modified":1480496898000},{"_id":"themes/icarus/source/css/_partial/insight.styl","hash":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1480496898000},{"_id":"themes/icarus/source/css/_partial/profile.styl","hash":"fb0170075dc2a41e01dd11bbfdbccbed544c479a","modified":1481252309000},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","hash":"f528ca7064d9fcecd737b9b71c9c54601365d7d3","modified":1480496898000},{"_id":"themes/icarus/source/css/_partial/timeline.styl","hash":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1480496898000},{"_id":"themes/icarus/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1480496898000},{"_id":"themes/icarus/source/css/_util/grid.styl","hash":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1480496898000},{"_id":"themes/icarus/source/css/_util/mixin.styl","hash":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1480496898000},{"_id":"themes/icarus/source/css/images/avatar.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1480497902000},{"_id":"themes/icarus/source/css/images/avatar0.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1480504864000},{"_id":"themes/icarus/source/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1480496898000},{"_id":"themes/icarus/source/css/images/avatar1.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1480504872000},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1480496898000},{"_id":"themes/icarus/source/libs/font-awesome/.DS_Store","hash":"71de49345b332e02516e8cd5f553d3a97c7c0bf7","modified":1482902630000},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1480496898000},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1480496898000},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1480496898000},{"_id":"source/images/blogimages/2016/androidart_broadcastreceiver2.png","hash":"173269356b75bfe4213c28374a19e3a4938fd36b","modified":1482748875000},{"_id":"source/images/blogimages/2016/androidart_service1.png","hash":"30b35c17a3e468fcbbaab25990439bad304acfa1","modified":1482748875000},{"_id":"source/images/blogimages/2016/androidart_activity.png","hash":"9d8bda879c62adc0b71cd26262603850ca16ab05","modified":1482748875000},{"_id":"source/images/blogimages/2016/androidart_contentprovider.png","hash":"9dbe7f17e629d0f36218b5dd3c3941cd8aa320f0","modified":1482748875000},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1480496898000},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1480496898000},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1480496898000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1480496898000},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1480496898000},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1480496898000},{"_id":"source/images/blogimages/2016/androidart_ipc.png","hash":"3f3a0ead6d747386983ab5618f46a2f0c33bd84e","modified":1482748875000},{"_id":"source/images/blogimages/2016/androidart_service2.png","hash":"afdf0ded0d671ec79a03fddbd253de15eb5248ea","modified":1482748875000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1480496898000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1480496898000},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1480496898000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1480496898000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1480496898000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1480496898000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1480496898000},{"_id":"themes/icarus/gallery/two_children_2.jpg","hash":"8044dafd28feb4c6aca2f5d48719385684ae9270","modified":1389073946000},{"_id":"public/about/index.html","hash":"6228413bc1569a20a4982d1785e33bc010ec926e","modified":1482906585587},{"_id":"public/categories/index.html","hash":"49a3253da1ef3b4ce9b0ef2ef6042e0b4208d456","modified":1482906585839},{"_id":"public/tags/index.html","hash":"b92a0ba7abb09e5b53422849ac4f500885f9eb44","modified":1482906585851},{"_id":"public/2016/12/20/Android-patch-update/index.html","hash":"9233859be33357189e9cb53692d800edb8fdea14","modified":1482906585851},{"_id":"public/2016/12/06/hexo-learning1/index.html","hash":"016d43342f17184787d88447019b3e2fa4917bc4","modified":1482906585851},{"_id":"public/2016/12/04/hexo-learning0/index.html","hash":"42e68d66be1f320098f6a6ced24e3d81dfedae22","modified":1482906585852},{"_id":"public/2016/12/03/nodejs-learning-getting-started/index.html","hash":"3a54e43dda86927518f1b0431bc3157c12198eac","modified":1482906585852},{"_id":"public/2016/11/03/hexo-mac-module-not-found/index.html","hash":"60ea3960fdbad1e4d195ffcff5c79f1792139761","modified":1482906585852},{"_id":"public/2016/10/13/gradle-learning2/index.html","hash":"886817ded49b13b33e1f19256de619c25b6bd8cb","modified":1482906585852},{"_id":"public/2016/10/12/gradle-learning/index.html","hash":"81ea3a38d819fa4e6c5ce1ef8b90228b4fd67eea","modified":1482906585852},{"_id":"public/2016/09/28/Android-interview-questions/index.html","hash":"b29301f2aa3ddee4c7cc8a287779e9dcfbbad919","modified":1482906585852},{"_id":"public/2016/09/22/quit-whole-application/index.html","hash":"1884ddd778f148b58ce8fda070c6be17df165e6f","modified":1482906585852},{"_id":"public/2016/09/22/JNI-get-publickey/index.html","hash":"ee7a297a236a748cd0fb5c541647c4db0757670b","modified":1482906585852},{"_id":"public/2016/09/20/android-design-pattern-singleton/index.html","hash":"476caaefd7b3ff7a1d22f4a43b751965ba7a510a","modified":1482906585852},{"_id":"public/2016/09/20/AVG-unwanted-software/index.html","hash":"e8838be1d982f5ab5a41e8320da82d227a12d4df","modified":1482906585852},{"_id":"public/2016/09/05/ThreadLocal-HandlerThread-Lopper/index.html","hash":"014adb741c4203047ce69d6c4b415f8ba9c1349f","modified":1482906585852},{"_id":"public/2016/08/16/RxAndroid-Learning/index.html","hash":"4a4ddd2bb43e445ce54e52a1426f59733adb28de","modified":1482906585852},{"_id":"public/2016/08/03/android-LocationListener/index.html","hash":"f641ab1982a64dd5b2f8b0a2aae9de90ea412583","modified":1482906585852},{"_id":"public/2016/07/25/android-webview-summary/index.html","hash":"9289aca59d9f2a32c5c9ccb35c7a2526a1c301c2","modified":1482906585852},{"_id":"public/2016/06/08/gson-summary/index.html","hash":"860905d5ec1ad01626ef9f0db7aa756da4de836f","modified":1482906585852},{"_id":"public/2016/05/28/qiniu-android-summary/index.html","hash":"2d19a6d81e3669968a654f0ce4516162b8b2f080","modified":1482906585852},{"_id":"public/2016/05/24/JNI-Learning0/index.html","hash":"87b1b1f0e745b3eec5d887722db02eddb6428cb2","modified":1482906585852},{"_id":"public/2016/05/24/JNI-Learning/index.html","hash":"05da9eba64b5b431bdad8c9b0625c2a66bc4cae2","modified":1482906585852},{"_id":"public/2016/05/18/javaString-and-bytes/index.html","hash":"c2ded02905b97dc647055a8d30980607e721c181","modified":1482906585852},{"_id":"public/2016/05/12/GCM-Azure_summary/index.html","hash":"985408351087ff3b05eda31e5a78af72c3214846","modified":1482906585852},{"_id":"public/2016/03/20/android-books-reading-/index.html","hash":"b3a5c0be1d5582117c098d8aed30e20f189ff9fa","modified":1482906585852},{"_id":"public/2016/03/20/android-new-knowledge-summary/index.html","hash":"763e63d6995b9d24ee6c0c8e22bcfeeaff1766fd","modified":1482906585852},{"_id":"public/2016/03/15/facebook-google+signin/index.html","hash":"2baf0aa245b9d6ea8d007342c1f4d1613387b006","modified":1482906585853},{"_id":"public/2016/03/01/android-googlemap-summary/index.html","hash":"2ba6dc9f0bd4781bbdaea059ec3f306f2ee0a7de","modified":1482906585853},{"_id":"public/2015/11/06/book-list-of-2015/index.html","hash":"e017b6f478f2dd442566d7c8afe9ae7cb75f564f","modified":1482906585853},{"_id":"public/2015/03/16/java-multithreading-concurrent/index.html","hash":"67c3e1f94c959360cccab3f6e9f22bc76e6c6a7d","modified":1482906585853},{"_id":"public/2014/12/23/hello-world/index.html","hash":"94c07f98c0c8fcd78755553c613b3278f54ef882","modified":1482906585853},{"_id":"public/archives/index.html","hash":"a27e55b629b0d967b5409d6e4d36477439e7dfc6","modified":1482906585853},{"_id":"public/archives/page/2/index.html","hash":"f493ddae20cbac85283fdaeb40b3d2af19312455","modified":1482906585853},{"_id":"public/archives/page/3/index.html","hash":"06a90030891380a2c6d62af3f3f9c5681be3362d","modified":1482906585853},{"_id":"public/archives/page/4/index.html","hash":"455a4b994a468fe582b415104000c2ff3704a0de","modified":1482906585853},{"_id":"public/archives/2014/index.html","hash":"a850989df90afafcb954d38ca96cb2469a659727","modified":1482906585853},{"_id":"public/archives/2014/12/index.html","hash":"3a3c72eda135b4b4e1b626eea1c708bda079ec2c","modified":1482906585867},{"_id":"public/archives/2015/index.html","hash":"fe650721a8832f5f274b4e8e7ff08070b4a26529","modified":1482906585867},{"_id":"public/archives/2015/03/index.html","hash":"520e6719972d85efd349d50a6b4f270a34a090ef","modified":1482906585867},{"_id":"public/archives/2015/11/index.html","hash":"ebf71b8807fd8240bb3e889fb4426f8ce796e92e","modified":1482906585867},{"_id":"public/archives/2016/index.html","hash":"02a82361d1a88ec31a5639b61d9e69eb9cf04898","modified":1482906585867},{"_id":"public/archives/2016/page/2/index.html","hash":"3f7c0cff04d687165d602bec9471d4d10b66cd69","modified":1482906585867},{"_id":"public/archives/2016/page/3/index.html","hash":"a1e185e269e026147070fa0c415c1c2a1a43d0a4","modified":1482906585867},{"_id":"public/archives/2016/page/4/index.html","hash":"f470d50eb1f603b99230041f61370f4c534fe64e","modified":1482906585867},{"_id":"public/archives/2016/03/index.html","hash":"320c6514861052563c61c1e736d3c555ad13784b","modified":1482906585867},{"_id":"public/archives/2016/05/index.html","hash":"1a2d57a0420bd84d01730d07fa00a7b44e452202","modified":1482906585867},{"_id":"public/archives/2016/06/index.html","hash":"b695f03ff8faf7d62d1bc9e084d8da6f9a974ea1","modified":1482906585867},{"_id":"public/archives/2016/07/index.html","hash":"ebd7ec555becbe4869f561ac9cc229a76238afbf","modified":1482906585867},{"_id":"public/archives/2016/08/index.html","hash":"d1d4ef5c6e5d1e5dfbc846346a3c04f1361a8eaa","modified":1482906585867},{"_id":"public/archives/2016/09/index.html","hash":"449c25b933e6e6c22f2330472ea6490a53652823","modified":1482906585867},{"_id":"public/archives/2016/10/index.html","hash":"8728e711c3433fcb1b9d0f646a3ef5d0d08d3ee4","modified":1482906585867},{"_id":"public/archives/2016/11/index.html","hash":"26e177a32210172997b723ed0003c155fc98b05e","modified":1482906585867},{"_id":"public/archives/2016/12/index.html","hash":"7abce31960a0238e0cc9042a6c730340914270cd","modified":1482906585867},{"_id":"public/categories/read/index.html","hash":"32134df839ddbda8f52c4de825eeda087a2a4e0f","modified":1482906585867},{"_id":"public/categories/technology/index.html","hash":"d7c9e617982da83f319574143c52a69bdf97ede8","modified":1482906585867},{"_id":"public/categories/accumulation/index.html","hash":"36f6d46e3a571af55d1d58b482276182aab90d5a","modified":1482906585867},{"_id":"public/categories/accumulation/page/2/index.html","hash":"63ee0d77e24f7d6c004eacec5712ab23b330f1ae","modified":1482906585868},{"_id":"public/categories/accumulation/page/3/index.html","hash":"fe07889c8c41fc70ed6b5e0241e118fb52f2af86","modified":1482906585868},{"_id":"public/index.html","hash":"fad5d55c11f37cf80b9e49dad66990c0681f92f7","modified":1482906585868},{"_id":"public/page/2/index.html","hash":"3a8c470d40309b647b8dac313f69788300c8d0e1","modified":1482906585868},{"_id":"public/page/3/index.html","hash":"5f17765873e6b1f0e0c6c67733391c163bd42cf9","modified":1482906585868},{"_id":"public/page/4/index.html","hash":"5ad168b7a38f558e01fb014e960004553ab05805","modified":1482906585868},{"_id":"public/tags/read/index.html","hash":"ba0f5789e9a16c86079ec1d0621299f7e652774f","modified":1482906585868},{"_id":"public/tags/accumulation/index.html","hash":"221db863bbe37981f464102c9679577fe47a311b","modified":1482906585868},{"_id":"public/tags/accumulation/page/2/index.html","hash":"a6c8322108e3c93227acffd83ad2801bb70e64fa","modified":1482906585868},{"_id":"public/tags/android-jni/index.html","hash":"7904e378df23c40387067356ff5e929f2ac41c14","modified":1482906585868},{"_id":"public/tags/technology/index.html","hash":"701e39e5fa61b62449cda05453a521d9cc3a7d81","modified":1482906585868},{"_id":"public/tags/rxjava/index.html","hash":"1ac69ace198c7ab1da2223a48368919793f25933","modified":1482906585868},{"_id":"public/tags/android-design-pattern/index.html","hash":"378a63d3a6962514e2ec30fec0803bfcd4c48ff4","modified":1482906585868},{"_id":"public/tags/gradle/index.html","hash":"98760bf4e7e2d0b04e4516b1515ec8ca49d5dd07","modified":1482906585868},{"_id":"public/tags/hexo/index.html","hash":"7a70456488c5ef455bab879d3992b0ef6f503a24","modified":1482906585868},{"_id":"public/tags/ejs/index.html","hash":"aa42e935bb60c4453a5ed0b155ac611e48b253ed","modified":1482906585868},{"_id":"public/tags/android-patch-update/index.html","hash":"0be8a9a83b825aebeac31c7fc2ed145cd8eb90bc","modified":1482906585868},{"_id":"public/tags/nodejs/index.html","hash":"1f979df5d71de67c51f89502681fa0fd9c50bc93","modified":1482906585869},{"_id":"public/images/avatar.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1482906585869},{"_id":"public/images/favicon.ico","hash":"e64542caa1b7a07484925304cd99c93129dfce8e","modified":1482906585869},{"_id":"public/images/blogimages/2016/androidart_broadcastreceiver1.png","hash":"dc4a97d2b8ef1f6592717204788d9f716117fdee","modified":1482906585869},{"_id":"public/images/blogimages/2016/avg_warning.PNG","hash":"1b8817b076f48cf8217439e0265cb4216abb3d17","modified":1482906585869},{"_id":"public/images/blogimages/2016/google_servcie_ads.PNG","hash":"10c107e578bcfb28ee9f38c247f62cb99f14ea1a","modified":1482906585869},{"_id":"public/images/blogimages/2016/gradle_structure1.png","hash":"0b8c1f213bb88852ecb0fd8a50b60f310d6a23e8","modified":1482906585869},{"_id":"public/images/blogimages/2016/gradle_structure2.png","hash":"6a8aefb3577950beeba2900f507e749dd518345e","modified":1482906585869},{"_id":"public/images/blogimages/2016/jni_structure.png","hash":"312696c9a056a734ff63d9457ff0bb83f356f057","modified":1482906585869},{"_id":"public/images/blogimages/2016/gradle_task.png","hash":"6890da207d5772a6f141024267547db56e9bec38","modified":1482906585869},{"_id":"public/css/images/avatar.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1482906585869},{"_id":"public/css/images/avatar0.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1482906585869},{"_id":"public/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1482906585869},{"_id":"public/css/images/avatar1.png","hash":"2daa0d02ee54bee9a6968e098013fb37a7fab7bc","modified":1482906585870},{"_id":"public/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1482906585870},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1482906585870},{"_id":"public/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1482906585870},{"_id":"public/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1482906585870},{"_id":"public/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1482906585870},{"_id":"public/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1482906585870},{"_id":"public/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1482906585870},{"_id":"public/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1482906585870},{"_id":"public/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1482906585870},{"_id":"public/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1482906585870},{"_id":"public/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1482906585870},{"_id":"public/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1482906585870},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1482906585871},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1482906585871},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1482906585871},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1482906585871},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1482906585871},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1482906585871},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1482906585871},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1482906585871},{"_id":"public/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1482906585871},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1482906585871},{"_id":"public/images/blogimages/2016/androidart_broadcastreceiver2.png","hash":"173269356b75bfe4213c28374a19e3a4938fd36b","modified":1482906586456},{"_id":"public/images/blogimages/2016/androidart_service1.png","hash":"30b35c17a3e468fcbbaab25990439bad304acfa1","modified":1482906586460},{"_id":"public/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1482906586466},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1482906586466},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1482906586466},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1482906586466},{"_id":"public/js/insight.js","hash":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3","modified":1482906586474},{"_id":"public/js/main.js","hash":"1faffdc7aa7f0d28e85edbf49c99de3ad0b65753","modified":1482906586474},{"_id":"public/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1482906586474},{"_id":"public/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1482906586474},{"_id":"public/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1482906586475},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1482906586475},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1482906586476},{"_id":"public/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1482906586476},{"_id":"public/css/style.css","hash":"d0b8ae1ae0c8485fd0a830e3939e2d531e948f6c","modified":1482906586476},{"_id":"public/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1482906586476},{"_id":"public/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1482906586476},{"_id":"public/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1482906586476},{"_id":"public/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1482906586476},{"_id":"public/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1482906586476},{"_id":"public/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1482906586476},{"_id":"public/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1482906586477},{"_id":"public/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1482906586477},{"_id":"public/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1482906586477},{"_id":"public/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1482906586477},{"_id":"public/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1482906586477},{"_id":"public/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1482906586477},{"_id":"public/images/blogimages/2016/androidart_activity.png","hash":"9d8bda879c62adc0b71cd26262603850ca16ab05","modified":1482906586477},{"_id":"public/images/blogimages/2016/androidart_contentprovider.png","hash":"9dbe7f17e629d0f36218b5dd3c3941cd8aa320f0","modified":1482906586477},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1482906586477},{"_id":"public/images/blogimages/2016/androidart_ipc.png","hash":"3f3a0ead6d747386983ab5618f46a2f0c33bd84e","modified":1482906586492},{"_id":"public/images/blogimages/2016/androidart_service2.png","hash":"afdf0ded0d671ec79a03fddbd253de15eb5248ea","modified":1482906586492},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1482906586505}],"Category":[{"name":"read","_id":"cix8kaj3w0006bxs6bzk63kra"},{"name":"technology","_id":"cix8kaj48000bbxs6hw928tpv"},{"name":"accumulation","_id":"cix8kaj4r000obxs63x5xzzwk"}],"Data":[],"Page":[{"title":"","layout":"about","_content":"\n<!--使用markdown填写自己的about信息-->\n#### 自我介绍\n","source":"about/index.md","raw":"title: \"\"\nlayout: \"about\"\n---\n\n<!--使用markdown填写自己的about信息-->\n#### 自我介绍\n","date":"2016-12-26T10:41:15.000Z","updated":"2016-12-26T10:41:15.000Z","path":"about/index.html","comments":1,"_id":"cix8kaj3g0001bxs6zhx41787","content":"<!--使用markdown填写自己的about信息-->\n<h4 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h4>","excerpt":"","more":"<!--使用markdown填写自己的about信息-->\n<h4 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h4>"},{"title":"Categories","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"Categories\"\nlayout: \"categories\"\n---\n","date":"2016-12-26T10:41:15.000Z","updated":"2016-12-26T10:41:15.000Z","path":"categories/index.html","comments":1,"_id":"cix8kaj3j0003bxs625n9g8ll","content":"","excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2016-12-26T10:41:15.000Z","updated":"2016-12-26T10:41:15.000Z","path":"tags/index.html","comments":1,"_id":"cix8kaj3m0005bxs6wmxf79vk","content":"","excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n<!--more-->\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/2014-12-23-hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n<!--more-->\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2014-12-22T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix8kaj3b0000bxs613vlftu9","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>","more":"<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"},{"layout":"book","title":"2015阅读书单","keywords":"阅读,书单,2015","books":[{"title":"教父2 The Sicilian","status":"未读","author":"马克·瓦恩加德纳","publisher":"上海译文出版社","language":"中文译","link":"https://book.douban.com/subject/25762007/","cover":"https://img3.doubanio.com/mpic/s27244215.jpg","description":"无感。时势造就了安吉利诺，时势也毁灭了安吉利诺。被最亲密的朋友背叛，令人震惊。"},{"title":"教父复仇 The Godfather's Revenge","status":"未读","author":"马克·瓦恩加德纳","publisher":"上海译文出版社","language":"中文译","link":"http://book.douban.com/subject/4020110/","cover":"http://img3.douban.com/mpic/s4014854.jpg","description":null},{"title":"教父归来 The Godfather Returns","status":"在读","author":"马克·瓦恩加德纳","publisher":"译林出版社","language":"中文译","link":"http://book.douban.com/subject/1959055/","cover":"http://img3.doubanio.com/mpic/s5848649.jpg","description":null},{"title":"教父 The Godfather","status":"已读","author":"马里奥·普佐","publisher":"江苏文艺出版社","language":"中文译","link":"http://book.douban.com/subject/25762009/","cover":"http://img3.douban.com/mpic/s27227804.jpg","description":"教父三部曲第一部，美国出版史上头号畅销书，都说男人必看，果然名不虚传，电影也看了。教父的世界里，友谊，是通行的货币；忠诚，是最好的礼物；缄默，是唯一的规则。他藐视一切价值，不给警告，不虚张声势，不留余地。教父，就是自己的上帝。继续看第二部ing。"},{"title":"追风筝的人 The Kite Runner","status":"已读","author":"卡勒德·胡赛尼","publisher":"上海人民出版社","language":"中文译","link":"http://book.douban.com/subject/1770782/","cover":"http://img3.douban.com/mpic/s1727290.jpg","description":"为你，千千万万遍。念及那些如风往事，冷暖自知。也许谁的生命里都有一只想要挽回的“风筝”，谁没有令自己痛悔的事，谁能保证自己的心灵永在阳光的照耀下？但重回那个被时光深埋的地点，重新面对心灵的考问，不是每个人都有那份勇气，即使，“那儿有再次成为好人的路”。"}],"_content":"","source":"_posts/2015-11-06-book-list-of-2015.md","raw":"---\nlayout: book\ntitle: 2015阅读书单\ncategory: read\ntags: read\nkeywords: 阅读,书单,2015\nbooks:\n    - title: 教父2 The Sicilian\n      status: 未读\n      author: 马克·瓦恩加德纳\n      publisher: 上海译文出版社\n      language: 中文译\n      link: https://book.douban.com/subject/25762007/\n      cover: https://img3.doubanio.com/mpic/s27244215.jpg\n      description: 无感。时势造就了安吉利诺，时势也毁灭了安吉利诺。被最亲密的朋友背叛，令人震惊。\n    - title: 教父复仇 The Godfather's Revenge\n      status: 未读\n      author: 马克·瓦恩加德纳\n      publisher: 上海译文出版社\n      language: 中文译\n      link: http://book.douban.com/subject/4020110/\n      cover: http://img3.douban.com/mpic/s4014854.jpg\n      description:\n    - title: 教父归来 The Godfather Returns\n      status: 在读\n      author: 马克·瓦恩加德纳\n      publisher: 译林出版社\n      language: 中文译\n      link: http://book.douban.com/subject/1959055/\n      cover: http://img3.doubanio.com/mpic/s5848649.jpg\n      description:\n    - title: 教父 The Godfather\n      status: 已读\n      author: 马里奥·普佐\n      publisher: 江苏文艺出版社\n      language: 中文译\n      link: http://book.douban.com/subject/25762009/\n      cover: http://img3.douban.com/mpic/s27227804.jpg\n      description: 教父三部曲第一部，美国出版史上头号畅销书，都说男人必看，果然名不虚传，电影也看了。教父的世界里，友谊，是通行的货币；忠诚，是最好的礼物；缄默，是唯一的规则。他藐视一切价值，不给警告，不虚张声势，不留余地。教父，就是自己的上帝。继续看第二部ing。\n    - title: 追风筝的人 The Kite Runner\n      status: 已读\n      author: 卡勒德·胡赛尼\n      publisher: 上海人民出版社\n      language: 中文译\n      link: http://book.douban.com/subject/1770782/\n      cover: http://img3.douban.com/mpic/s1727290.jpg\n      description: 为你，千千万万遍。念及那些如风往事，冷暖自知。也许谁的生命里都有一只想要挽回的“风筝”，谁没有令自己痛悔的事，谁能保证自己的心灵永在阳光的照耀下？但重回那个被时光深埋的地点，重新面对心灵的考问，不是每个人都有那份勇气，即使，“那儿有再次成为好人的路”。\n---\n","slug":"book-list-of-2015","published":1,"date":"2015-11-05T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj3h0002bxs6dxgppuzo","content":"","excerpt":"","more":""},{"layout":"post","title":"java多线程和并发面试问答","keywords":"java, 多线程, 并发","description":null,"banner":"http://obxk8w81b.bkt.clouddn.com/Daubigny%20s%20Garden%203.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Daubigny%20s%20Garden%203.jpg","_content":"\n本文基于**酷勤网关于java多线程和并发面试题的文**章，进行了少量的整理和补充。[原文在这](http://www.kuqin.com/shuoit/20140708/341091.html)。\n\n------\n\n以下是正文：\n\n多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。\n\n<!--more-->\n\n# Java多线程面试问题\n\n### 1. 什么是进程和线程？\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。\n\n线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。\n\n### 2. 进程和线程之间有什么不同？\n一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。\n\n- 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。\n- 线程的划分尺度小于进程，使得多线程程序的并发性高。\n- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，极大地提高了程序的运行效率。\n- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。\n\n> 形象的讲，进程就是一个项目组，每个程序员就是里面的线程呀！当然一个程序员也可以叫做一个项目组，对应的就是一个进程只有一个线程。公司里面的任务是分配给项目组级别的，干活的就是其中的程序员。总的意思就是，进程和线程没有什么区别。\n吐槽的话：我的意思就是进程干不过来了，那就多开几个线程呀！from [JacobK](https://www.zhihu.com/question/21535820/answer/19120563)\n\n\n### 3. 多线程编程的好处是什么？\n- 在进程内创建、终止线程比创建、终止进程要快；\n- 同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。\n\n在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。\n\n### 4. 用户线程和守护线程有什么区别？\n当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出（与守护线程是否在运行没有关系）。一个守护线程创建的子线程依然是守护线程。**守护线程应用背景**：后台线程，比如可以收集某些系统状态的线程，发送email的线程，等不希望影响JVM的事情。\n\n### 5. 我们如何创建一个线程？\n有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。[Read more...](http://www.journaldev.com/1016/java-thread-example-extending-thread-class-and-implementing-runnable-interface)\n\n### 6. 有哪些不同的线程生命周期？\n当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked和Dead。[Read more...](http://www.journaldev.com/1044/life-cycle-of-thread-understanding-thread-states-in-java)\n\n- **新建（new Thread）**：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：`Thread  t1=new Thread()`;\n- **就绪（runnable）**：线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：`t1.start()`;\n- **运行（running）**：线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。\n- **死亡（dead）**：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。\n- **自然终止**：正常运行run()方法后终止\n- **异常终止**：调用stop()方法让一个线程终止运行\n- **堵塞（blocked）**：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。\n- **正在睡眠**：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。\n- **正在等待**：调用wait()方法。（调用motify()方法回到就绪状态）\n- **被另一个线程所阻塞**：调用suspend()方法。（调用resume()方法恢复）\n\n### 7. 可以直接调用Thread类的run()方法么？\n可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread。start()方法。\n\n### 8. 如何让正在运行的线程暂停一段时间？\n我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。\n\n### 9. 你对线程优先级的理解是什么？\n线程的优先级越高，那么就可以分占相对多的CPU时间片。每个进程都有相应的优先级，**线程优先级决定它何时运行和占用CPU时间**。最终的优先级共分32级。是从0到31的数值，称为 **基本优先级别**。OS调度的是线程，**真正具有优先级的是线程**，而进程优先级是作为一个优先级Class存在。一个线程创建的时候，会继承进程的优先级。 外线程优先级可以用SetThreadPriority来进行微调。常用的桌面系统，都是分时操调度，根据线程的优先级来分配调度时间。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。\n\n### 10. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？\n线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。\n\n### 11. 在多线程中，什么是上下文切换(context-switching)？\n上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。\n\n### 12. 你如何确保main()方法所在的线程是Java程序最后结束的线程？\n我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。[Read more...](http://www.journaldev.com/1024/java-thread-join-example-with-explanation)\n> 线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。在join()方法内设定超时，使得join()方法的影响在特定超时后无效。当超时时，主方法和任务线程申请运行的时候是平等的。然而，当涉及sleep时，join()方法依靠操作系统计时，所以你不应该假定join()方法将会等待你指定的时间。\n\n### 13.线程之间是如何通信的？\n线程间通信有三种方式：\n\na. 使用全局变量。进程中的线程间内存共享，这是比较常用的通信方式和交互方式。主要由于多个线程可能更改全局变量，因此全局变量最好声明为violate\n\nb. 使用消息实现通信。在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。\n\n```\n1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20;  \n2)添加消息函数声明afx_msg int OnTSendmsg();\n3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)\n4)添加OnTSM()的实现函数；\n5)在线程函数中添加PostMessage消息Post函数\n```\n\nc. 使用事件CEvent类实现线程间通信。Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。\n\n```\n1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；\n2)threadStart.SetEvent();使其处于通信状态；\n3)调用WaitForSingleObject()来监视CEvent对象\n```\n\n当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()notify()notifyAll()方法可以用于线程间通信关于资源的锁的状态。[Read more](http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example)\n\n### 14. 进程间通信方式及特点？\n进程是转入内存并准备执行的程序，每个程序都有私有的虚拟地址空间，由代码，数据以及它可利用的系统资源(如文件，管道)组成。多进程/多线程是windows操作系统的一个基本特征。Linux系统一般都统称为进程。\n\n由于不同的进程运行在各自不同的内存空间中，其中一个进程对于变量的修改另一方是无法感知的，因此，进程之间的消息传递不能通过变量或其他数据结构直接进行，只能通过进程间通信来完成。进程间通信是指**不同进程间进行数据共享和数据交换**。\n\n进程间通信方式：**文件和记录锁定，管道，有名管道，FIFO，信号量，信号，消息队列，共享内存，套接字**。[^14] [Read Read Read...](http://blog.csdn.net/chenhuajie123/article/details/9315477)\n\n\n### 15. 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？\nJava的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法\n\n### 16. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？\n当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。\n\n### 17. 为什么Thread类的sleep()和yield()方法是静态的？\nThread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。\n\n### 18. 如何确保线程安全？\n在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。[Read more](http://www.journaldev.com/1061/java-synchronization-and-thread-safety-tutorial-with-examples)\n\n### 19. volatile关键字在Java中有什么作用？\n当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。\n\n### 20. 同步方法和同步块，哪个是更好的选择？\n同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。\n\n### 21. 如何创建守护线程？\n使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。\n\n### 22. 什么是ThreadLocal?\nThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。\n\n每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。[Read more](http://www.journaldev.com/1076/java-threadlocal-example-to-create-thread-local-variables)。\n\n### 23. 什么是死锁(Deadlock)？如何避免死锁？\n死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。死锁的四个必要条件：\n- **互斥（Mutual exclusion）**：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；\n- **持有（Hold and wait）**：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源；\n- **不可剥夺（No preemption）**：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；\n- **环形等待（Circular wait）**：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。\n\n在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁。目前处理死锁的方法可归结为[四种](http://blog.csdn.net/joejames/article/details/37960873)\n\n### 24. 什么是线程池？如何创建一个Java线程池？\n一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。\n\njava.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。[如何创建和使用线程池](http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor)\n\n# Java并发面试问题\n\n### 1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？\n原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。\n\nint++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。\n\n为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。[Read more](http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor)。\n\n### 2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？\nLock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：\n- 可以使锁更公平\n- 可以使线程在等待锁的时候响应中断\n- 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间\n- 可以在不同的范围，以不同的顺序获取和释放锁\n\n### 3. 什么是Executors框架？\nExecutor框架同java.util.concurrent.Executor 接口在Java5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。\n\n无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。[Read more](http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor)\n\n### 4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？\njava.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。\n\n阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。\n\n阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。\n\nBlockingQueue接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。[使用阻塞队列实现生产者-消费者问题](http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem)。\n\n### 5. 什么是并发容器的实现？\nJava集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。\n\n并发容器支持并发的遍历和并发的更新。\n\n主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet。\n\n### 6. Executors类是什么？\nExecutors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。\n\nExecutors可以用于方便的创建线程池。\n\n# 好文推荐\n\n### [秒杀多线程面试题系列](http://blog.csdn.net/column/details/killthreadseries.html)\n\n### [进程通信方式及特点](http://blog.csdn.net/chenhuajie123/article/details/9315477)\n\n-----\n\n[^1-3]: [进程与线程及其区别](http://blog.chinaunix.net/uid-21411227-id-1826748.html)\n[^14]: [进程通信方式及特点](http://blog.csdn.net/chenhuajie123/article/details/9315477)\n","source":"_posts/2015-03-16-java-multithreading-concurrent.md","raw":"---\nlayout: post\ntitle: java多线程和并发面试问答\ncategory: technology\ntags: accumulation\nkeywords: java, 多线程, 并发\ndescription:\nbanner: http://obxk8w81b.bkt.clouddn.com/Daubigny%20s%20Garden%203.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Daubigny%20s%20Garden%203.jpg\n---\n\n本文基于**酷勤网关于java多线程和并发面试题的文**章，进行了少量的整理和补充。[原文在这](http://www.kuqin.com/shuoit/20140708/341091.html)。\n\n------\n\n以下是正文：\n\n多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。\n\n<!--more-->\n\n# Java多线程面试问题\n\n### 1. 什么是进程和线程？\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。\n\n线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。\n\n### 2. 进程和线程之间有什么不同？\n一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。\n\n- 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。\n- 线程的划分尺度小于进程，使得多线程程序的并发性高。\n- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，极大地提高了程序的运行效率。\n- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。\n\n> 形象的讲，进程就是一个项目组，每个程序员就是里面的线程呀！当然一个程序员也可以叫做一个项目组，对应的就是一个进程只有一个线程。公司里面的任务是分配给项目组级别的，干活的就是其中的程序员。总的意思就是，进程和线程没有什么区别。\n吐槽的话：我的意思就是进程干不过来了，那就多开几个线程呀！from [JacobK](https://www.zhihu.com/question/21535820/answer/19120563)\n\n\n### 3. 多线程编程的好处是什么？\n- 在进程内创建、终止线程比创建、终止进程要快；\n- 同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。\n\n在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。\n\n### 4. 用户线程和守护线程有什么区别？\n当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出（与守护线程是否在运行没有关系）。一个守护线程创建的子线程依然是守护线程。**守护线程应用背景**：后台线程，比如可以收集某些系统状态的线程，发送email的线程，等不希望影响JVM的事情。\n\n### 5. 我们如何创建一个线程？\n有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。[Read more...](http://www.journaldev.com/1016/java-thread-example-extending-thread-class-and-implementing-runnable-interface)\n\n### 6. 有哪些不同的线程生命周期？\n当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked和Dead。[Read more...](http://www.journaldev.com/1044/life-cycle-of-thread-understanding-thread-states-in-java)\n\n- **新建（new Thread）**：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：`Thread  t1=new Thread()`;\n- **就绪（runnable）**：线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：`t1.start()`;\n- **运行（running）**：线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。\n- **死亡（dead）**：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。\n- **自然终止**：正常运行run()方法后终止\n- **异常终止**：调用stop()方法让一个线程终止运行\n- **堵塞（blocked）**：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。\n- **正在睡眠**：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。\n- **正在等待**：调用wait()方法。（调用motify()方法回到就绪状态）\n- **被另一个线程所阻塞**：调用suspend()方法。（调用resume()方法恢复）\n\n### 7. 可以直接调用Thread类的run()方法么？\n可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread。start()方法。\n\n### 8. 如何让正在运行的线程暂停一段时间？\n我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。\n\n### 9. 你对线程优先级的理解是什么？\n线程的优先级越高，那么就可以分占相对多的CPU时间片。每个进程都有相应的优先级，**线程优先级决定它何时运行和占用CPU时间**。最终的优先级共分32级。是从0到31的数值，称为 **基本优先级别**。OS调度的是线程，**真正具有优先级的是线程**，而进程优先级是作为一个优先级Class存在。一个线程创建的时候，会继承进程的优先级。 外线程优先级可以用SetThreadPriority来进行微调。常用的桌面系统，都是分时操调度，根据线程的优先级来分配调度时间。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。\n\n### 10. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？\n线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。\n\n### 11. 在多线程中，什么是上下文切换(context-switching)？\n上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。\n\n### 12. 你如何确保main()方法所在的线程是Java程序最后结束的线程？\n我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。[Read more...](http://www.journaldev.com/1024/java-thread-join-example-with-explanation)\n> 线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。在join()方法内设定超时，使得join()方法的影响在特定超时后无效。当超时时，主方法和任务线程申请运行的时候是平等的。然而，当涉及sleep时，join()方法依靠操作系统计时，所以你不应该假定join()方法将会等待你指定的时间。\n\n### 13.线程之间是如何通信的？\n线程间通信有三种方式：\n\na. 使用全局变量。进程中的线程间内存共享，这是比较常用的通信方式和交互方式。主要由于多个线程可能更改全局变量，因此全局变量最好声明为violate\n\nb. 使用消息实现通信。在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。\n\n```\n1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20;  \n2)添加消息函数声明afx_msg int OnTSendmsg();\n3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)\n4)添加OnTSM()的实现函数；\n5)在线程函数中添加PostMessage消息Post函数\n```\n\nc. 使用事件CEvent类实现线程间通信。Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。\n\n```\n1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；\n2)threadStart.SetEvent();使其处于通信状态；\n3)调用WaitForSingleObject()来监视CEvent对象\n```\n\n当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()notify()notifyAll()方法可以用于线程间通信关于资源的锁的状态。[Read more](http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example)\n\n### 14. 进程间通信方式及特点？\n进程是转入内存并准备执行的程序，每个程序都有私有的虚拟地址空间，由代码，数据以及它可利用的系统资源(如文件，管道)组成。多进程/多线程是windows操作系统的一个基本特征。Linux系统一般都统称为进程。\n\n由于不同的进程运行在各自不同的内存空间中，其中一个进程对于变量的修改另一方是无法感知的，因此，进程之间的消息传递不能通过变量或其他数据结构直接进行，只能通过进程间通信来完成。进程间通信是指**不同进程间进行数据共享和数据交换**。\n\n进程间通信方式：**文件和记录锁定，管道，有名管道，FIFO，信号量，信号，消息队列，共享内存，套接字**。[^14] [Read Read Read...](http://blog.csdn.net/chenhuajie123/article/details/9315477)\n\n\n### 15. 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？\nJava的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法\n\n### 16. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？\n当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。\n\n### 17. 为什么Thread类的sleep()和yield()方法是静态的？\nThread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。\n\n### 18. 如何确保线程安全？\n在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。[Read more](http://www.journaldev.com/1061/java-synchronization-and-thread-safety-tutorial-with-examples)\n\n### 19. volatile关键字在Java中有什么作用？\n当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。\n\n### 20. 同步方法和同步块，哪个是更好的选择？\n同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。\n\n### 21. 如何创建守护线程？\n使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。\n\n### 22. 什么是ThreadLocal?\nThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。\n\n每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。[Read more](http://www.journaldev.com/1076/java-threadlocal-example-to-create-thread-local-variables)。\n\n### 23. 什么是死锁(Deadlock)？如何避免死锁？\n死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。死锁的四个必要条件：\n- **互斥（Mutual exclusion）**：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；\n- **持有（Hold and wait）**：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源；\n- **不可剥夺（No preemption）**：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；\n- **环形等待（Circular wait）**：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。\n\n在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁。目前处理死锁的方法可归结为[四种](http://blog.csdn.net/joejames/article/details/37960873)\n\n### 24. 什么是线程池？如何创建一个Java线程池？\n一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。\n\njava.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。[如何创建和使用线程池](http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor)\n\n# Java并发面试问题\n\n### 1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？\n原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。\n\nint++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。\n\n为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。[Read more](http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor)。\n\n### 2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？\nLock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：\n- 可以使锁更公平\n- 可以使线程在等待锁的时候响应中断\n- 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间\n- 可以在不同的范围，以不同的顺序获取和释放锁\n\n### 3. 什么是Executors框架？\nExecutor框架同java.util.concurrent.Executor 接口在Java5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。\n\n无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。[Read more](http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor)\n\n### 4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？\njava.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。\n\n阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。\n\n阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。\n\nBlockingQueue接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。[使用阻塞队列实现生产者-消费者问题](http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem)。\n\n### 5. 什么是并发容器的实现？\nJava集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。\n\n并发容器支持并发的遍历和并发的更新。\n\n主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet。\n\n### 6. Executors类是什么？\nExecutors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。\n\nExecutors可以用于方便的创建线程池。\n\n# 好文推荐\n\n### [秒杀多线程面试题系列](http://blog.csdn.net/column/details/killthreadseries.html)\n\n### [进程通信方式及特点](http://blog.csdn.net/chenhuajie123/article/details/9315477)\n\n-----\n\n[^1-3]: [进程与线程及其区别](http://blog.chinaunix.net/uid-21411227-id-1826748.html)\n[^14]: [进程通信方式及特点](http://blog.csdn.net/chenhuajie123/article/details/9315477)\n","slug":"java-multithreading-concurrent","published":1,"date":"2015-03-15T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj3l0004bxs6wizadlw9","content":"<p>本文基于<strong>酷勤网关于java多线程和并发面试题的文</strong>章，进行了少量的整理和补充。<a href=\"http://www.kuqin.com/shuoit/20140708/341091.html\" target=\"_blank\" rel=\"external\">原文在这</a>。</p>\n<hr>\n<p>以下是正文：</p>\n<p>多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。</p>\n<a id=\"more\"></a>\n<h1 id=\"Java多线程面试问题\"><a href=\"#Java多线程面试问题\" class=\"headerlink\" title=\"Java多线程面试问题\"></a>Java多线程面试问题</h1><h3 id=\"1-什么是进程和线程？\"><a href=\"#1-什么是进程和线程？\" class=\"headerlink\" title=\"1. 什么是进程和线程？\"></a>1. 什么是进程和线程？</h3><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>\n<p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p>\n<h3 id=\"2-进程和线程之间有什么不同？\"><a href=\"#2-进程和线程之间有什么不同？\" class=\"headerlink\" title=\"2. 进程和线程之间有什么不同？\"></a>2. 进程和线程之间有什么不同？</h3><p>一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。</p>\n<ul>\n<li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</li>\n<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>\n<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，极大地提高了程序的运行效率。</li>\n<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>\n<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>\n</ul>\n<blockquote>\n<p>形象的讲，进程就是一个项目组，每个程序员就是里面的线程呀！当然一个程序员也可以叫做一个项目组，对应的就是一个进程只有一个线程。公司里面的任务是分配给项目组级别的，干活的就是其中的程序员。总的意思就是，进程和线程没有什么区别。<br>吐槽的话：我的意思就是进程干不过来了，那就多开几个线程呀！from <a href=\"https://www.zhihu.com/question/21535820/answer/19120563\" target=\"_blank\" rel=\"external\">JacobK</a></p>\n</blockquote>\n<h3 id=\"3-多线程编程的好处是什么？\"><a href=\"#3-多线程编程的好处是什么？\" class=\"headerlink\" title=\"3. 多线程编程的好处是什么？\"></a>3. 多线程编程的好处是什么？</h3><ul>\n<li>在进程内创建、终止线程比创建、终止进程要快；</li>\n<li>同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。</li>\n</ul>\n<p>在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。</p>\n<h3 id=\"4-用户线程和守护线程有什么区别？\"><a href=\"#4-用户线程和守护线程有什么区别？\" class=\"headerlink\" title=\"4. 用户线程和守护线程有什么区别？\"></a>4. 用户线程和守护线程有什么区别？</h3><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出（与守护线程是否在运行没有关系）。一个守护线程创建的子线程依然是守护线程。<strong>守护线程应用背景</strong>：后台线程，比如可以收集某些系统状态的线程，发送email的线程，等不希望影响JVM的事情。</p>\n<h3 id=\"5-我们如何创建一个线程？\"><a href=\"#5-我们如何创建一个线程？\" class=\"headerlink\" title=\"5. 我们如何创建一个线程？\"></a>5. 我们如何创建一个线程？</h3><p>有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。<a href=\"http://www.journaldev.com/1016/java-thread-example-extending-thread-class-and-implementing-runnable-interface\" target=\"_blank\" rel=\"external\">Read more…</a></p>\n<h3 id=\"6-有哪些不同的线程生命周期？\"><a href=\"#6-有哪些不同的线程生命周期？\" class=\"headerlink\" title=\"6. 有哪些不同的线程生命周期？\"></a>6. 有哪些不同的线程生命周期？</h3><p>当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked和Dead。<a href=\"http://www.journaldev.com/1044/life-cycle-of-thread-understanding-thread-states-in-java\" target=\"_blank\" rel=\"external\">Read more…</a></p>\n<ul>\n<li><strong>新建（new Thread）</strong>：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：<code>Thread  t1=new Thread()</code>;</li>\n<li><strong>就绪（runnable）</strong>：线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：<code>t1.start()</code>;</li>\n<li><strong>运行（running）</strong>：线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</li>\n<li><strong>死亡（dead）</strong>：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</li>\n<li><strong>自然终止</strong>：正常运行run()方法后终止</li>\n<li><strong>异常终止</strong>：调用stop()方法让一个线程终止运行</li>\n<li><strong>堵塞（blocked）</strong>：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。</li>\n<li><strong>正在睡眠</strong>：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</li>\n<li><strong>正在等待</strong>：调用wait()方法。（调用motify()方法回到就绪状态）</li>\n<li><strong>被另一个线程所阻塞</strong>：调用suspend()方法。（调用resume()方法恢复）</li>\n</ul>\n<h3 id=\"7-可以直接调用Thread类的run-方法么？\"><a href=\"#7-可以直接调用Thread类的run-方法么？\" class=\"headerlink\" title=\"7. 可以直接调用Thread类的run()方法么？\"></a>7. 可以直接调用Thread类的run()方法么？</h3><p>可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread。start()方法。</p>\n<h3 id=\"8-如何让正在运行的线程暂停一段时间？\"><a href=\"#8-如何让正在运行的线程暂停一段时间？\" class=\"headerlink\" title=\"8. 如何让正在运行的线程暂停一段时间？\"></a>8. 如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。</p>\n<h3 id=\"9-你对线程优先级的理解是什么？\"><a href=\"#9-你对线程优先级的理解是什么？\" class=\"headerlink\" title=\"9. 你对线程优先级的理解是什么？\"></a>9. 你对线程优先级的理解是什么？</h3><p>线程的优先级越高，那么就可以分占相对多的CPU时间片。每个进程都有相应的优先级，<strong>线程优先级决定它何时运行和占用CPU时间</strong>。最终的优先级共分32级。是从0到31的数值，称为 <strong>基本优先级别</strong>。OS调度的是线程，<strong>真正具有优先级的是线程</strong>，而进程优先级是作为一个优先级Class存在。一个线程创建的时候，会继承进程的优先级。 外线程优先级可以用SetThreadPriority来进行微调。常用的桌面系统，都是分时操调度，根据线程的优先级来分配调度时间。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。</p>\n<h3 id=\"10-什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？\"><a href=\"#10-什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？\" class=\"headerlink\" title=\"10. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？\"></a>10. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h3><p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>\n<h3 id=\"11-在多线程中，什么是上下文切换-context-switching-？\"><a href=\"#11-在多线程中，什么是上下文切换-context-switching-？\" class=\"headerlink\" title=\"11. 在多线程中，什么是上下文切换(context-switching)？\"></a>11. 在多线程中，什么是上下文切换(context-switching)？</h3><p>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>\n<h3 id=\"12-你如何确保main-方法所在的线程是Java程序最后结束的线程？\"><a href=\"#12-你如何确保main-方法所在的线程是Java程序最后结束的线程？\" class=\"headerlink\" title=\"12. 你如何确保main()方法所在的线程是Java程序最后结束的线程？\"></a>12. 你如何确保main()方法所在的线程是Java程序最后结束的线程？</h3><p>我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。<a href=\"http://www.journaldev.com/1024/java-thread-join-example-with-explanation\" target=\"_blank\" rel=\"external\">Read more…</a></p>\n<blockquote>\n<p>线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。在join()方法内设定超时，使得join()方法的影响在特定超时后无效。当超时时，主方法和任务线程申请运行的时候是平等的。然而，当涉及sleep时，join()方法依靠操作系统计时，所以你不应该假定join()方法将会等待你指定的时间。</p>\n</blockquote>\n<h3 id=\"13-线程之间是如何通信的？\"><a href=\"#13-线程之间是如何通信的？\" class=\"headerlink\" title=\"13.线程之间是如何通信的？\"></a>13.线程之间是如何通信的？</h3><p>线程间通信有三种方式：</p>\n<p>a. 使用全局变量。进程中的线程间内存共享，这是比较常用的通信方式和交互方式。主要由于多个线程可能更改全局变量，因此全局变量最好声明为violate</p>\n<p>b. 使用消息实现通信。在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20;  </div><div class=\"line\">2)添加消息函数声明afx_msg int OnTSendmsg();</div><div class=\"line\">3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)</div><div class=\"line\">4)添加OnTSM()的实现函数；</div><div class=\"line\">5)在线程函数中添加PostMessage消息Post函数</div></pre></td></tr></table></figure>\n<p>c. 使用事件CEvent类实现线程间通信。Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；</div><div class=\"line\">2)threadStart.SetEvent();使其处于通信状态；</div><div class=\"line\">3)调用WaitForSingleObject()来监视CEvent对象</div></pre></td></tr></table></figure>\n<p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()notify()notifyAll()方法可以用于线程间通信关于资源的锁的状态。<a href=\"http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example\" target=\"_blank\" rel=\"external\">Read more</a></p>\n<h3 id=\"14-进程间通信方式及特点？\"><a href=\"#14-进程间通信方式及特点？\" class=\"headerlink\" title=\"14. 进程间通信方式及特点？\"></a>14. 进程间通信方式及特点？</h3><p>进程是转入内存并准备执行的程序，每个程序都有私有的虚拟地址空间，由代码，数据以及它可利用的系统资源(如文件，管道)组成。多进程/多线程是windows操作系统的一个基本特征。Linux系统一般都统称为进程。</p>\n<p>由于不同的进程运行在各自不同的内存空间中，其中一个进程对于变量的修改另一方是无法感知的，因此，进程之间的消息传递不能通过变量或其他数据结构直接进行，只能通过进程间通信来完成。进程间通信是指<strong>不同进程间进行数据共享和数据交换</strong>。</p>\n<p>进程间通信方式：<strong>文件和记录锁定，管道，有名管道，FIFO，信号量，信号，消息队列，共享内存，套接字</strong>。[^14] <a href=\"http://blog.csdn.net/chenhuajie123/article/details/9315477\" target=\"_blank\" rel=\"external\">Read Read Read…</a></p>\n<h3 id=\"15-为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？\"><a href=\"#15-为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？\" class=\"headerlink\" title=\"15. 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？\"></a>15. 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？</h3><p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法</p>\n<h3 id=\"16-为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？\"><a href=\"#16-为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？\" class=\"headerlink\" title=\"16. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？\"></a>16. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3><p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>\n<h3 id=\"17-为什么Thread类的sleep-和yield-方法是静态的？\"><a href=\"#17-为什么Thread类的sleep-和yield-方法是静态的？\" class=\"headerlink\" title=\"17. 为什么Thread类的sleep()和yield()方法是静态的？\"></a>17. 为什么Thread类的sleep()和yield()方法是静态的？</h3><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>\n<h3 id=\"18-如何确保线程安全？\"><a href=\"#18-如何确保线程安全？\" class=\"headerlink\" title=\"18. 如何确保线程安全？\"></a>18. 如何确保线程安全？</h3><p>在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。<a href=\"http://www.journaldev.com/1061/java-synchronization-and-thread-safety-tutorial-with-examples\" target=\"_blank\" rel=\"external\">Read more</a></p>\n<h3 id=\"19-volatile关键字在Java中有什么作用？\"><a href=\"#19-volatile关键字在Java中有什么作用？\" class=\"headerlink\" title=\"19. volatile关键字在Java中有什么作用？\"></a>19. volatile关键字在Java中有什么作用？</h3><p>当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p>\n<h3 id=\"20-同步方法和同步块，哪个是更好的选择？\"><a href=\"#20-同步方法和同步块，哪个是更好的选择？\" class=\"headerlink\" title=\"20. 同步方法和同步块，哪个是更好的选择？\"></a>20. 同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>\n<h3 id=\"21-如何创建守护线程？\"><a href=\"#21-如何创建守护线程？\" class=\"headerlink\" title=\"21. 如何创建守护线程？\"></a>21. 如何创建守护线程？</h3><p>使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。</p>\n<h3 id=\"22-什么是ThreadLocal\"><a href=\"#22-什么是ThreadLocal\" class=\"headerlink\" title=\"22. 什么是ThreadLocal?\"></a>22. 什么是ThreadLocal?</h3><p>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。</p>\n<p>每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。<a href=\"http://www.journaldev.com/1076/java-threadlocal-example-to-create-thread-local-variables\" target=\"_blank\" rel=\"external\">Read more</a>。</p>\n<h3 id=\"23-什么是死锁-Deadlock-？如何避免死锁？\"><a href=\"#23-什么是死锁-Deadlock-？如何避免死锁？\" class=\"headerlink\" title=\"23. 什么是死锁(Deadlock)？如何避免死锁？\"></a>23. 什么是死锁(Deadlock)？如何避免死锁？</h3><p>死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。死锁的四个必要条件：</p>\n<ul>\n<li><strong>互斥（Mutual exclusion）</strong>：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；</li>\n<li><strong>持有（Hold and wait）</strong>：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源；</li>\n<li><strong>不可剥夺（No preemption）</strong>：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；</li>\n<li><strong>环形等待（Circular wait）</strong>：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。</li>\n</ul>\n<p>在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁。目前处理死锁的方法可归结为<a href=\"http://blog.csdn.net/joejames/article/details/37960873\" target=\"_blank\" rel=\"external\">四种</a></p>\n<h3 id=\"24-什么是线程池？如何创建一个Java线程池？\"><a href=\"#24-什么是线程池？如何创建一个Java线程池？\" class=\"headerlink\" title=\"24. 什么是线程池？如何创建一个Java线程池？\"></a>24. 什么是线程池？如何创建一个Java线程池？</h3><p>一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。</p>\n<p>java.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\" target=\"_blank\" rel=\"external\">如何创建和使用线程池</a></p>\n<h1 id=\"Java并发面试问题\"><a href=\"#Java并发面试问题\" class=\"headerlink\" title=\"Java并发面试问题\"></a>Java并发面试问题</h1><h3 id=\"1-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？\"><a href=\"#1-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？\" class=\"headerlink\" title=\"1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？\"></a>1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>\n<p>int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>\n<p>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\" target=\"_blank\" rel=\"external\">Read more</a>。</p>\n<h3 id=\"2-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？\"><a href=\"#2-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？\" class=\"headerlink\" title=\"2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？\"></a>2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：</p>\n<ul>\n<li>可以使锁更公平</li>\n<li>可以使线程在等待锁的时候响应中断</li>\n<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li>\n<li>可以在不同的范围，以不同的顺序获取和释放锁</li>\n</ul>\n<h3 id=\"3-什么是Executors框架？\"><a href=\"#3-什么是Executors框架？\" class=\"headerlink\" title=\"3. 什么是Executors框架？\"></a>3. 什么是Executors框架？</h3><p>Executor框架同java.util.concurrent.Executor 接口在Java5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>\n<p>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\" target=\"_blank\" rel=\"external\">Read more</a></p>\n<h3 id=\"4-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？\"><a href=\"#4-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？\" class=\"headerlink\" title=\"4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？\"></a>4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。</p>\n<p>阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。</p>\n<p>阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。</p>\n<p>BlockingQueue接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。<a href=\"http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem\" target=\"_blank\" rel=\"external\">使用阻塞队列实现生产者-消费者问题</a>。</p>\n<h3 id=\"5-什么是并发容器的实现？\"><a href=\"#5-什么是并发容器的实现？\" class=\"headerlink\" title=\"5. 什么是并发容器的实现？\"></a>5. 什么是并发容器的实现？</h3><p>Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。</p>\n<p>并发容器支持并发的遍历和并发的更新。</p>\n<p>主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet。</p>\n<h3 id=\"6-Executors类是什么？\"><a href=\"#6-Executors类是什么？\" class=\"headerlink\" title=\"6. Executors类是什么？\"></a>6. Executors类是什么？</h3><p>Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。</p>\n<p>Executors可以用于方便的创建线程池。</p>\n<h1 id=\"好文推荐\"><a href=\"#好文推荐\" class=\"headerlink\" title=\"好文推荐\"></a>好文推荐</h1><h3 id=\"秒杀多线程面试题系列\"><a href=\"#秒杀多线程面试题系列\" class=\"headerlink\" title=\"秒杀多线程面试题系列\"></a><a href=\"http://blog.csdn.net/column/details/killthreadseries.html\" target=\"_blank\" rel=\"external\">秒杀多线程面试题系列</a></h3><h3 id=\"进程通信方式及特点\"><a href=\"#进程通信方式及特点\" class=\"headerlink\" title=\"进程通信方式及特点\"></a><a href=\"http://blog.csdn.net/chenhuajie123/article/details/9315477\" target=\"_blank\" rel=\"external\">进程通信方式及特点</a></h3><hr>\n","excerpt":"<p>本文基于<strong>酷勤网关于java多线程和并发面试题的文</strong>章，进行了少量的整理和补充。<a href=\"http://www.kuqin.com/shuoit/20140708/341091.html\">原文在这</a>。</p>\n<hr>\n<p>以下是正文：</p>\n<p>多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。</p>","more":"<h1 id=\"Java多线程面试问题\"><a href=\"#Java多线程面试问题\" class=\"headerlink\" title=\"Java多线程面试问题\"></a>Java多线程面试问题</h1><h3 id=\"1-什么是进程和线程？\"><a href=\"#1-什么是进程和线程？\" class=\"headerlink\" title=\"1. 什么是进程和线程？\"></a>1. 什么是进程和线程？</h3><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>\n<p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p>\n<h3 id=\"2-进程和线程之间有什么不同？\"><a href=\"#2-进程和线程之间有什么不同？\" class=\"headerlink\" title=\"2. 进程和线程之间有什么不同？\"></a>2. 进程和线程之间有什么不同？</h3><p>一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。</p>\n<ul>\n<li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</li>\n<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>\n<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，极大地提高了程序的运行效率。</li>\n<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>\n<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>\n</ul>\n<blockquote>\n<p>形象的讲，进程就是一个项目组，每个程序员就是里面的线程呀！当然一个程序员也可以叫做一个项目组，对应的就是一个进程只有一个线程。公司里面的任务是分配给项目组级别的，干活的就是其中的程序员。总的意思就是，进程和线程没有什么区别。<br>吐槽的话：我的意思就是进程干不过来了，那就多开几个线程呀！from <a href=\"https://www.zhihu.com/question/21535820/answer/19120563\">JacobK</a></p>\n</blockquote>\n<h3 id=\"3-多线程编程的好处是什么？\"><a href=\"#3-多线程编程的好处是什么？\" class=\"headerlink\" title=\"3. 多线程编程的好处是什么？\"></a>3. 多线程编程的好处是什么？</h3><ul>\n<li>在进程内创建、终止线程比创建、终止进程要快；</li>\n<li>同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。</li>\n</ul>\n<p>在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。</p>\n<h3 id=\"4-用户线程和守护线程有什么区别？\"><a href=\"#4-用户线程和守护线程有什么区别？\" class=\"headerlink\" title=\"4. 用户线程和守护线程有什么区别？\"></a>4. 用户线程和守护线程有什么区别？</h3><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出（与守护线程是否在运行没有关系）。一个守护线程创建的子线程依然是守护线程。<strong>守护线程应用背景</strong>：后台线程，比如可以收集某些系统状态的线程，发送email的线程，等不希望影响JVM的事情。</p>\n<h3 id=\"5-我们如何创建一个线程？\"><a href=\"#5-我们如何创建一个线程？\" class=\"headerlink\" title=\"5. 我们如何创建一个线程？\"></a>5. 我们如何创建一个线程？</h3><p>有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。<a href=\"http://www.journaldev.com/1016/java-thread-example-extending-thread-class-and-implementing-runnable-interface\">Read more…</a></p>\n<h3 id=\"6-有哪些不同的线程生命周期？\"><a href=\"#6-有哪些不同的线程生命周期？\" class=\"headerlink\" title=\"6. 有哪些不同的线程生命周期？\"></a>6. 有哪些不同的线程生命周期？</h3><p>当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked和Dead。<a href=\"http://www.journaldev.com/1044/life-cycle-of-thread-understanding-thread-states-in-java\">Read more…</a></p>\n<ul>\n<li><strong>新建（new Thread）</strong>：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：<code>Thread  t1=new Thread()</code>;</li>\n<li><strong>就绪（runnable）</strong>：线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：<code>t1.start()</code>;</li>\n<li><strong>运行（running）</strong>：线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</li>\n<li><strong>死亡（dead）</strong>：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</li>\n<li><strong>自然终止</strong>：正常运行run()方法后终止</li>\n<li><strong>异常终止</strong>：调用stop()方法让一个线程终止运行</li>\n<li><strong>堵塞（blocked）</strong>：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。</li>\n<li><strong>正在睡眠</strong>：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</li>\n<li><strong>正在等待</strong>：调用wait()方法。（调用motify()方法回到就绪状态）</li>\n<li><strong>被另一个线程所阻塞</strong>：调用suspend()方法。（调用resume()方法恢复）</li>\n</ul>\n<h3 id=\"7-可以直接调用Thread类的run-方法么？\"><a href=\"#7-可以直接调用Thread类的run-方法么？\" class=\"headerlink\" title=\"7. 可以直接调用Thread类的run()方法么？\"></a>7. 可以直接调用Thread类的run()方法么？</h3><p>可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread。start()方法。</p>\n<h3 id=\"8-如何让正在运行的线程暂停一段时间？\"><a href=\"#8-如何让正在运行的线程暂停一段时间？\" class=\"headerlink\" title=\"8. 如何让正在运行的线程暂停一段时间？\"></a>8. 如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。</p>\n<h3 id=\"9-你对线程优先级的理解是什么？\"><a href=\"#9-你对线程优先级的理解是什么？\" class=\"headerlink\" title=\"9. 你对线程优先级的理解是什么？\"></a>9. 你对线程优先级的理解是什么？</h3><p>线程的优先级越高，那么就可以分占相对多的CPU时间片。每个进程都有相应的优先级，<strong>线程优先级决定它何时运行和占用CPU时间</strong>。最终的优先级共分32级。是从0到31的数值，称为 <strong>基本优先级别</strong>。OS调度的是线程，<strong>真正具有优先级的是线程</strong>，而进程优先级是作为一个优先级Class存在。一个线程创建的时候，会继承进程的优先级。 外线程优先级可以用SetThreadPriority来进行微调。常用的桌面系统，都是分时操调度，根据线程的优先级来分配调度时间。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。</p>\n<h3 id=\"10-什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？\"><a href=\"#10-什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？\" class=\"headerlink\" title=\"10. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？\"></a>10. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h3><p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>\n<h3 id=\"11-在多线程中，什么是上下文切换-context-switching-？\"><a href=\"#11-在多线程中，什么是上下文切换-context-switching-？\" class=\"headerlink\" title=\"11. 在多线程中，什么是上下文切换(context-switching)？\"></a>11. 在多线程中，什么是上下文切换(context-switching)？</h3><p>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>\n<h3 id=\"12-你如何确保main-方法所在的线程是Java程序最后结束的线程？\"><a href=\"#12-你如何确保main-方法所在的线程是Java程序最后结束的线程？\" class=\"headerlink\" title=\"12. 你如何确保main()方法所在的线程是Java程序最后结束的线程？\"></a>12. 你如何确保main()方法所在的线程是Java程序最后结束的线程？</h3><p>我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。<a href=\"http://www.journaldev.com/1024/java-thread-join-example-with-explanation\">Read more…</a></p>\n<blockquote>\n<p>线程实例的方法join()方法可以使得一个线程在另一个线程结束后再执行。如果join()方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。在join()方法内设定超时，使得join()方法的影响在特定超时后无效。当超时时，主方法和任务线程申请运行的时候是平等的。然而，当涉及sleep时，join()方法依靠操作系统计时，所以你不应该假定join()方法将会等待你指定的时间。</p>\n</blockquote>\n<h3 id=\"13-线程之间是如何通信的？\"><a href=\"#13-线程之间是如何通信的？\" class=\"headerlink\" title=\"13.线程之间是如何通信的？\"></a>13.线程之间是如何通信的？</h3><p>线程间通信有三种方式：</p>\n<p>a. 使用全局变量。进程中的线程间内存共享，这是比较常用的通信方式和交互方式。主要由于多个线程可能更改全局变量，因此全局变量最好声明为violate</p>\n<p>b. 使用消息实现通信。在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20;  </div><div class=\"line\">2)添加消息函数声明afx_msg int OnTSendmsg();</div><div class=\"line\">3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)</div><div class=\"line\">4)添加OnTSM()的实现函数；</div><div class=\"line\">5)在线程函数中添加PostMessage消息Post函数</div></pre></td></tr></table></figure>\n<p>c. 使用事件CEvent类实现线程间通信。Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；</div><div class=\"line\">2)threadStart.SetEvent();使其处于通信状态；</div><div class=\"line\">3)调用WaitForSingleObject()来监视CEvent对象</div></pre></td></tr></table></figure>\n<p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()notify()notifyAll()方法可以用于线程间通信关于资源的锁的状态。<a href=\"http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example\">Read more</a></p>\n<h3 id=\"14-进程间通信方式及特点？\"><a href=\"#14-进程间通信方式及特点？\" class=\"headerlink\" title=\"14. 进程间通信方式及特点？\"></a>14. 进程间通信方式及特点？</h3><p>进程是转入内存并准备执行的程序，每个程序都有私有的虚拟地址空间，由代码，数据以及它可利用的系统资源(如文件，管道)组成。多进程/多线程是windows操作系统的一个基本特征。Linux系统一般都统称为进程。</p>\n<p>由于不同的进程运行在各自不同的内存空间中，其中一个进程对于变量的修改另一方是无法感知的，因此，进程之间的消息传递不能通过变量或其他数据结构直接进行，只能通过进程间通信来完成。进程间通信是指<strong>不同进程间进行数据共享和数据交换</strong>。</p>\n<p>进程间通信方式：<strong>文件和记录锁定，管道，有名管道，FIFO，信号量，信号，消息队列，共享内存，套接字</strong>。[^14] <a href=\"http://blog.csdn.net/chenhuajie123/article/details/9315477\">Read Read Read…</a></p>\n<h3 id=\"15-为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？\"><a href=\"#15-为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？\" class=\"headerlink\" title=\"15. 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？\"></a>15. 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？</h3><p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法</p>\n<h3 id=\"16-为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？\"><a href=\"#16-为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？\" class=\"headerlink\" title=\"16. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？\"></a>16. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3><p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>\n<h3 id=\"17-为什么Thread类的sleep-和yield-方法是静态的？\"><a href=\"#17-为什么Thread类的sleep-和yield-方法是静态的？\" class=\"headerlink\" title=\"17. 为什么Thread类的sleep()和yield()方法是静态的？\"></a>17. 为什么Thread类的sleep()和yield()方法是静态的？</h3><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>\n<h3 id=\"18-如何确保线程安全？\"><a href=\"#18-如何确保线程安全？\" class=\"headerlink\" title=\"18. 如何确保线程安全？\"></a>18. 如何确保线程安全？</h3><p>在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。<a href=\"http://www.journaldev.com/1061/java-synchronization-and-thread-safety-tutorial-with-examples\">Read more</a></p>\n<h3 id=\"19-volatile关键字在Java中有什么作用？\"><a href=\"#19-volatile关键字在Java中有什么作用？\" class=\"headerlink\" title=\"19. volatile关键字在Java中有什么作用？\"></a>19. volatile关键字在Java中有什么作用？</h3><p>当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p>\n<h3 id=\"20-同步方法和同步块，哪个是更好的选择？\"><a href=\"#20-同步方法和同步块，哪个是更好的选择？\" class=\"headerlink\" title=\"20. 同步方法和同步块，哪个是更好的选择？\"></a>20. 同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>\n<h3 id=\"21-如何创建守护线程？\"><a href=\"#21-如何创建守护线程？\" class=\"headerlink\" title=\"21. 如何创建守护线程？\"></a>21. 如何创建守护线程？</h3><p>使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。</p>\n<h3 id=\"22-什么是ThreadLocal\"><a href=\"#22-什么是ThreadLocal\" class=\"headerlink\" title=\"22. 什么是ThreadLocal?\"></a>22. 什么是ThreadLocal?</h3><p>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。</p>\n<p>每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。<a href=\"http://www.journaldev.com/1076/java-threadlocal-example-to-create-thread-local-variables\">Read more</a>。</p>\n<h3 id=\"23-什么是死锁-Deadlock-？如何避免死锁？\"><a href=\"#23-什么是死锁-Deadlock-？如何避免死锁？\" class=\"headerlink\" title=\"23. 什么是死锁(Deadlock)？如何避免死锁？\"></a>23. 什么是死锁(Deadlock)？如何避免死锁？</h3><p>死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。死锁的四个必要条件：</p>\n<ul>\n<li><strong>互斥（Mutual exclusion）</strong>：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；</li>\n<li><strong>持有（Hold and wait）</strong>：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源；</li>\n<li><strong>不可剥夺（No preemption）</strong>：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；</li>\n<li><strong>环形等待（Circular wait）</strong>：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。</li>\n</ul>\n<p>在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁。目前处理死锁的方法可归结为<a href=\"http://blog.csdn.net/joejames/article/details/37960873\">四种</a></p>\n<h3 id=\"24-什么是线程池？如何创建一个Java线程池？\"><a href=\"#24-什么是线程池？如何创建一个Java线程池？\" class=\"headerlink\" title=\"24. 什么是线程池？如何创建一个Java线程池？\"></a>24. 什么是线程池？如何创建一个Java线程池？</h3><p>一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。</p>\n<p>java.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\">如何创建和使用线程池</a></p>\n<h1 id=\"Java并发面试问题\"><a href=\"#Java并发面试问题\" class=\"headerlink\" title=\"Java并发面试问题\"></a>Java并发面试问题</h1><h3 id=\"1-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？\"><a href=\"#1-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？\" class=\"headerlink\" title=\"1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？\"></a>1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>\n<p>int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>\n<p>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\">Read more</a>。</p>\n<h3 id=\"2-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？\"><a href=\"#2-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？\" class=\"headerlink\" title=\"2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？\"></a>2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：</p>\n<ul>\n<li>可以使锁更公平</li>\n<li>可以使线程在等待锁的时候响应中断</li>\n<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li>\n<li>可以在不同的范围，以不同的顺序获取和释放锁</li>\n</ul>\n<h3 id=\"3-什么是Executors框架？\"><a href=\"#3-什么是Executors框架？\" class=\"headerlink\" title=\"3. 什么是Executors框架？\"></a>3. 什么是Executors框架？</h3><p>Executor框架同java.util.concurrent.Executor 接口在Java5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>\n<p>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\">Read more</a></p>\n<h3 id=\"4-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？\"><a href=\"#4-什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？\" class=\"headerlink\" title=\"4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？\"></a>4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h3><p>java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。</p>\n<p>阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。</p>\n<p>阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。</p>\n<p>BlockingQueue接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。<a href=\"http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem\">使用阻塞队列实现生产者-消费者问题</a>。</p>\n<h3 id=\"5-什么是并发容器的实现？\"><a href=\"#5-什么是并发容器的实现？\" class=\"headerlink\" title=\"5. 什么是并发容器的实现？\"></a>5. 什么是并发容器的实现？</h3><p>Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。</p>\n<p>并发容器支持并发的遍历和并发的更新。</p>\n<p>主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet。</p>\n<h3 id=\"6-Executors类是什么？\"><a href=\"#6-Executors类是什么？\" class=\"headerlink\" title=\"6. Executors类是什么？\"></a>6. Executors类是什么？</h3><p>Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。</p>\n<p>Executors可以用于方便的创建线程池。</p>\n<h1 id=\"好文推荐\"><a href=\"#好文推荐\" class=\"headerlink\" title=\"好文推荐\"></a>好文推荐</h1><h3 id=\"秒杀多线程面试题系列\"><a href=\"#秒杀多线程面试题系列\" class=\"headerlink\" title=\"秒杀多线程面试题系列\"></a><a href=\"http://blog.csdn.net/column/details/killthreadseries.html\">秒杀多线程面试题系列</a></h3><h3 id=\"进程通信方式及特点\"><a href=\"#进程通信方式及特点\" class=\"headerlink\" title=\"进程通信方式及特点\"></a><a href=\"http://blog.csdn.net/chenhuajie123/article/details/9315477\">进程通信方式及特点</a></h3><hr>"},{"layout":"post","title":"android Google map使用总结","keywords":"android, google map","description":"google map2.0使用总结","banner":"http://obxk8w81b.bkt.clouddn.com/Chestnut%20Tree%20in%20Blossom.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Chestnut%20Tree%20in%20Blossom.jpg","_content":"\n\n### 1.在代码中编译google map\n要想编译编译google map必须使用Google map api。并在自己的工程中引入google-play-services_lib。两个都需要在SDK Manager中下载。前者要在对应android api中勾选，后者要勾选在Extras下的Google Play Service。\n\n要注意的是map2.0要使用com.google.android.gms包名下的类\n\nGoogle Maps Android API 使用OpenGL ES第2版来渲染地图。如果未安装OpenGL ES第2版，地图将不会出现。可以在 AndroidManifest.xml 中添加以下<uses-feature>元素作为<manifest>元素的子元素来过滤不能支持的手机：\n\n~~~ Java\n<uses-feature\n        android:glEsVersion=\"0x00020000\"\n        android:required=\"true\"/>\n~~~\n\n<!--more-->\n\n### 2.在编码中遇到的问题\n1.可以实现OnCameraChangeListener接口，来实现对相机状态的监听，比如我就记录下了地图缩放的大小\n\n~~~ Java\n@Override\npublic void onCameraChange(CameraPosition arg0) {\n\t// TODO Auto-generated method stub\n\tzoom = arg0.zoom;\n}\n~~~\n\n2.向将处理地图的 Activity 添加 Fragment 对象。 最简单的实现方式是，向Activity 的布局文件添加 <fragment> 元素。\n\n3.实现 OnMapReadyCallback 接口，并使用onMapReady(GoogleMap)回调方法获取GoogleMap对象的句柄。GoogleMap对象是对地图本身的内部表示。如需设置地图的视图选项，可以使用UiSettings设置地图的样式。\n\n4.调用Fragment上的getMapAsync()以注册回调。\n\n5.使用手机定位，定位成功后再map上显示标记：\n\n~~~ Java\nMarkerOptions markerOpt = new MarkerOptions();  \nmarkerOpt.position(new LatLng(geoLat, geoLng));  \nmarkerOpt.draggable(false);  \nmarkerOpt.visible(true);  \nmarkerOpt.anchor(0.5f, 0.5f);//设为图片中心  \nmarkerOpt.icon(BitmapDescriptorFactory  \n\t.fromResource(R.drawable.sos_location_38x53));  \nmMap.addMarker(markerOpt);  \n//将摄影机移动到指定的地理位置  \ncameraPosition = new CameraPosition.Builder()  \n.target(new LatLng(geoLat, geoLng))              // Sets the center of the map to ZINTUN  \n\t.zoom(zoom)                  // 缩放比例  \n\t.bearing(0)                // Sets the orientation of the camera to east  \n\t.build();                  // Creates a CameraPosition from the builder  \nmMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition));\n~~~   \n\n6.实现地图圆角效果：使用圆角.9图片，中间透明，圆角四周不透明<br>\n详细可以看这个提问：[Is there a way to implement rounded corners to a Mapfragment?](http://stackoverflow.com/questions/14469208/is-there-a-way-to-implement-rounded-corners-to-a-mapfragment)\n\n7.去掉google地图自带的蓝色圆点\nGoogleMap.setMyLocationEnabled(false);\n\n8.解决mapview与scrollview嵌套滑动的问题：\n思路就是使用getParent().requestDisallowInterceptTouchEvent(true);方法，让子类接收到touch事件\n\n~~~ Java\npublic class MyMapView extends MapView {\n    private ViewParent mViewParent;\n\n    public MyMapView(Context context) {\n        super(context);\n    }\n\n    public MyMapView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public MyMapView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n    }\n\n    public MyMapView(Context context, GoogleMapOptions options) {\n        super(context, options);\n    }\n\n\n    public void setViewParent(@Nullable final ViewParent viewParent) { //any ViewGroup\n        mViewParent = viewParent;\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(final MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                if (null == mViewParent) {\n                    //设置父类不拦截touch事件，子view可以接收到touch事件\n                    getParent().requestDisallowInterceptTouchEvent(true);\n                } else {\n                    mViewParent.requestDisallowInterceptTouchEvent(true);\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                if (null == mViewParent) {\n                    //让父类拦截touch事件\n                    getParent().requestDisallowInterceptTouchEvent(false);\n                } else {\n                    mViewParent.requestDisallowInterceptTouchEvent(false);\n                }\n                break;\n            default:\n                break;\n        }\n\n        return super.onInterceptTouchEvent(event);\n    }\n}\n~~~\n\n9.LocationListener，一直回调到onProviderDisabled\n\n有可能是因为手机没有开启定位服务，解决办法是：\n\n~~~ Java\n@Override\npublic void onProviderDisabled(String provider) {\n    isLocatedSuccess = false;\n    if (provider.equals(\"network\")) //跳到位置服务设置页面\n        startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));\n}\n~~~\n\n### 3.在真机上测试效果\n需要在真机上安装这两个包：com.android.vending.apk（Google play store）和com.google.android.gms.apk（Google play services）\n可以在国内应用市场上去搜索最新版本，也可以使用我上传的文件：\n\n链接：http://pan.baidu.com/s/1i5q8jo5 密码：solm\n\n安装成功以后，再运行自己的程序，查看效果了\n","source":"_posts/2016-03-01-android-googlemap-summary.md","raw":"---\nlayout: post\ntitle: android Google map使用总结\ncategory: technology\ntags: accumulation\nkeywords: android, google map\ndescription: google map2.0使用总结\nbanner: http://obxk8w81b.bkt.clouddn.com/Chestnut%20Tree%20in%20Blossom.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Chestnut%20Tree%20in%20Blossom.jpg\n---\n\n\n### 1.在代码中编译google map\n要想编译编译google map必须使用Google map api。并在自己的工程中引入google-play-services_lib。两个都需要在SDK Manager中下载。前者要在对应android api中勾选，后者要勾选在Extras下的Google Play Service。\n\n要注意的是map2.0要使用com.google.android.gms包名下的类\n\nGoogle Maps Android API 使用OpenGL ES第2版来渲染地图。如果未安装OpenGL ES第2版，地图将不会出现。可以在 AndroidManifest.xml 中添加以下<uses-feature>元素作为<manifest>元素的子元素来过滤不能支持的手机：\n\n~~~ Java\n<uses-feature\n        android:glEsVersion=\"0x00020000\"\n        android:required=\"true\"/>\n~~~\n\n<!--more-->\n\n### 2.在编码中遇到的问题\n1.可以实现OnCameraChangeListener接口，来实现对相机状态的监听，比如我就记录下了地图缩放的大小\n\n~~~ Java\n@Override\npublic void onCameraChange(CameraPosition arg0) {\n\t// TODO Auto-generated method stub\n\tzoom = arg0.zoom;\n}\n~~~\n\n2.向将处理地图的 Activity 添加 Fragment 对象。 最简单的实现方式是，向Activity 的布局文件添加 <fragment> 元素。\n\n3.实现 OnMapReadyCallback 接口，并使用onMapReady(GoogleMap)回调方法获取GoogleMap对象的句柄。GoogleMap对象是对地图本身的内部表示。如需设置地图的视图选项，可以使用UiSettings设置地图的样式。\n\n4.调用Fragment上的getMapAsync()以注册回调。\n\n5.使用手机定位，定位成功后再map上显示标记：\n\n~~~ Java\nMarkerOptions markerOpt = new MarkerOptions();  \nmarkerOpt.position(new LatLng(geoLat, geoLng));  \nmarkerOpt.draggable(false);  \nmarkerOpt.visible(true);  \nmarkerOpt.anchor(0.5f, 0.5f);//设为图片中心  \nmarkerOpt.icon(BitmapDescriptorFactory  \n\t.fromResource(R.drawable.sos_location_38x53));  \nmMap.addMarker(markerOpt);  \n//将摄影机移动到指定的地理位置  \ncameraPosition = new CameraPosition.Builder()  \n.target(new LatLng(geoLat, geoLng))              // Sets the center of the map to ZINTUN  \n\t.zoom(zoom)                  // 缩放比例  \n\t.bearing(0)                // Sets the orientation of the camera to east  \n\t.build();                  // Creates a CameraPosition from the builder  \nmMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition));\n~~~   \n\n6.实现地图圆角效果：使用圆角.9图片，中间透明，圆角四周不透明<br>\n详细可以看这个提问：[Is there a way to implement rounded corners to a Mapfragment?](http://stackoverflow.com/questions/14469208/is-there-a-way-to-implement-rounded-corners-to-a-mapfragment)\n\n7.去掉google地图自带的蓝色圆点\nGoogleMap.setMyLocationEnabled(false);\n\n8.解决mapview与scrollview嵌套滑动的问题：\n思路就是使用getParent().requestDisallowInterceptTouchEvent(true);方法，让子类接收到touch事件\n\n~~~ Java\npublic class MyMapView extends MapView {\n    private ViewParent mViewParent;\n\n    public MyMapView(Context context) {\n        super(context);\n    }\n\n    public MyMapView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public MyMapView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n    }\n\n    public MyMapView(Context context, GoogleMapOptions options) {\n        super(context, options);\n    }\n\n\n    public void setViewParent(@Nullable final ViewParent viewParent) { //any ViewGroup\n        mViewParent = viewParent;\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(final MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                if (null == mViewParent) {\n                    //设置父类不拦截touch事件，子view可以接收到touch事件\n                    getParent().requestDisallowInterceptTouchEvent(true);\n                } else {\n                    mViewParent.requestDisallowInterceptTouchEvent(true);\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                if (null == mViewParent) {\n                    //让父类拦截touch事件\n                    getParent().requestDisallowInterceptTouchEvent(false);\n                } else {\n                    mViewParent.requestDisallowInterceptTouchEvent(false);\n                }\n                break;\n            default:\n                break;\n        }\n\n        return super.onInterceptTouchEvent(event);\n    }\n}\n~~~\n\n9.LocationListener，一直回调到onProviderDisabled\n\n有可能是因为手机没有开启定位服务，解决办法是：\n\n~~~ Java\n@Override\npublic void onProviderDisabled(String provider) {\n    isLocatedSuccess = false;\n    if (provider.equals(\"network\")) //跳到位置服务设置页面\n        startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));\n}\n~~~\n\n### 3.在真机上测试效果\n需要在真机上安装这两个包：com.android.vending.apk（Google play store）和com.google.android.gms.apk（Google play services）\n可以在国内应用市场上去搜索最新版本，也可以使用我上传的文件：\n\n链接：http://pan.baidu.com/s/1i5q8jo5 密码：solm\n\n安装成功以后，再运行自己的程序，查看效果了\n","slug":"android-googlemap-summary","published":1,"date":"2016-02-29T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj410008bxs6j8x0dglc","content":"<h3 id=\"1-在代码中编译google-map\"><a href=\"#1-在代码中编译google-map\" class=\"headerlink\" title=\"1.在代码中编译google map\"></a>1.在代码中编译google map</h3><p>要想编译编译google map必须使用Google map api。并在自己的工程中引入google-play-services_lib。两个都需要在SDK Manager中下载。前者要在对应android api中勾选，后者要勾选在Extras下的Google Play Service。</p>\n<p>要注意的是map2.0要使用com.google.android.gms包名下的类</p>\n<p>Google Maps Android API 使用OpenGL ES第2版来渲染地图。如果未安装OpenGL ES第2版，地图将不会出现。可以在 AndroidManifest.xml 中添加以下<uses-feature>元素作为<manifest>元素的子元素来过滤不能支持的手机：</manifest></uses-feature></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;uses-feature</div><div class=\"line\">        android:glEsVersion=<span class=\"string\">\"0x00020000\"</span></div><div class=\"line\">        android:required=<span class=\"string\">\"true\"</span>/&gt;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"2-在编码中遇到的问题\"><a href=\"#2-在编码中遇到的问题\" class=\"headerlink\" title=\"2.在编码中遇到的问题\"></a>2.在编码中遇到的问题</h3><p>1.可以实现OnCameraChangeListener接口，来实现对相机状态的监听，比如我就记录下了地图缩放的大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCameraChange</span><span class=\"params\">(CameraPosition arg0)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\tzoom = arg0.zoom;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.向将处理地图的 Activity 添加 Fragment 对象。 最简单的实现方式是，向Activity 的布局文件添加 <fragment> 元素。</fragment></p>\n<p>3.实现 OnMapReadyCallback 接口，并使用onMapReady(GoogleMap)回调方法获取GoogleMap对象的句柄。GoogleMap对象是对地图本身的内部表示。如需设置地图的视图选项，可以使用UiSettings设置地图的样式。</p>\n<p>4.调用Fragment上的getMapAsync()以注册回调。</p>\n<p>5.使用手机定位，定位成功后再map上显示标记：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">MarkerOptions markerOpt = <span class=\"keyword\">new</span> MarkerOptions();  </div><div class=\"line\">markerOpt.position(<span class=\"keyword\">new</span> LatLng(geoLat, geoLng));  </div><div class=\"line\">markerOpt.draggable(<span class=\"keyword\">false</span>);  </div><div class=\"line\">markerOpt.visible(<span class=\"keyword\">true</span>);  </div><div class=\"line\">markerOpt.anchor(<span class=\"number\">0.5f</span>, <span class=\"number\">0.5f</span>);<span class=\"comment\">//设为图片中心  </span></div><div class=\"line\">markerOpt.icon(BitmapDescriptorFactory  </div><div class=\"line\">\t.fromResource(R.drawable.sos_location_38x53));  </div><div class=\"line\">mMap.addMarker(markerOpt);  </div><div class=\"line\"><span class=\"comment\">//将摄影机移动到指定的地理位置  </span></div><div class=\"line\">cameraPosition = <span class=\"keyword\">new</span> CameraPosition.Builder()  </div><div class=\"line\">.target(<span class=\"keyword\">new</span> LatLng(geoLat, geoLng))              <span class=\"comment\">// Sets the center of the map to ZINTUN  </span></div><div class=\"line\">\t.zoom(zoom)                  <span class=\"comment\">// 缩放比例  </span></div><div class=\"line\">\t.bearing(<span class=\"number\">0</span>)                <span class=\"comment\">// Sets the orientation of the camera to east  </span></div><div class=\"line\">\t.build();                  <span class=\"comment\">// Creates a CameraPosition from the builder  </span></div><div class=\"line\">mMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition));</div><div class=\"line\">~~~   </div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">6</span>.实现地图圆角效果：使用圆角.<span class=\"number\">9</span>图片，中间透明，圆角四周不透明&lt;br&gt;</div><div class=\"line\">详细可以看这个提问：[Is there a way to implement rounded corners to a Mapfragment?](http:<span class=\"comment\">//stackoverflow.com/questions/14469208/is-there-a-way-to-implement-rounded-corners-to-a-mapfragment)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">7</span>.去掉google地图自带的蓝色圆点</div><div class=\"line\">GoogleMap.setMyLocationEnabled(<span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">8</span>.解决mapview与scrollview嵌套滑动的问题：</div><div class=\"line\">思路就是使用getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);方法，让子类接收到touch事件</div><div class=\"line\"></div><div class=\"line\">~~~ Java</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">MapView</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> ViewParent mViewParent;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMapView</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMapView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMapView</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyle)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyle);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMapView</span><span class=\"params\">(Context context, GoogleMapOptions options)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, options);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setViewParent</span><span class=\"params\">(@Nullable <span class=\"keyword\">final</span> ViewParent viewParent)</span> </span>&#123; <span class=\"comment\">//any ViewGroup</span></div><div class=\"line\">        mViewParent = viewParent;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(<span class=\"keyword\">final</span> MotionEvent event)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mViewParent) &#123;</div><div class=\"line\">                    <span class=\"comment\">//设置父类不拦截touch事件，子view可以接收到touch事件</span></div><div class=\"line\">                    getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    mViewParent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mViewParent) &#123;</div><div class=\"line\">                    <span class=\"comment\">//让父类拦截touch事件</span></div><div class=\"line\">                    getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">false</span>);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    mViewParent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">false</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onInterceptTouchEvent(event);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>9.LocationListener，一直回调到onProviderDisabled</p>\n<p>有可能是因为手机没有开启定位服务，解决办法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProviderDisabled</span><span class=\"params\">(String provider)</span> </span>&#123;</div><div class=\"line\">    isLocatedSuccess = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (provider.equals(<span class=\"string\">\"network\"</span>)) <span class=\"comment\">//跳到位置服务设置页面</span></div><div class=\"line\">        startActivity(<span class=\"keyword\">new</span> Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-在真机上测试效果\"><a href=\"#3-在真机上测试效果\" class=\"headerlink\" title=\"3.在真机上测试效果\"></a>3.在真机上测试效果</h3><p>需要在真机上安装这两个包：com.android.vending.apk（Google play store）和com.google.android.gms.apk（Google play services）<br>可以在国内应用市场上去搜索最新版本，也可以使用我上传的文件：</p>\n<p>链接：<a href=\"http://pan.baidu.com/s/1i5q8jo5\" target=\"_blank\" rel=\"external\">http://pan.baidu.com/s/1i5q8jo5</a> 密码：solm</p>\n<p>安装成功以后，再运行自己的程序，查看效果了</p>\n","excerpt":"<h3 id=\"1-在代码中编译google-map\"><a href=\"#1-在代码中编译google-map\" class=\"headerlink\" title=\"1.在代码中编译google map\"></a>1.在代码中编译google map</h3><p>要想编译编译google map必须使用Google map api。并在自己的工程中引入google-play-services_lib。两个都需要在SDK Manager中下载。前者要在对应android api中勾选，后者要勾选在Extras下的Google Play Service。</p>\n<p>要注意的是map2.0要使用com.google.android.gms包名下的类</p>\n<p>Google Maps Android API 使用OpenGL ES第2版来渲染地图。如果未安装OpenGL ES第2版，地图将不会出现。可以在 AndroidManifest.xml 中添加以下<uses-feature>元素作为<manifest>元素的子元素来过滤不能支持的手机：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;uses-feature</div><div class=\"line\">        android:glEsVersion=<span class=\"string\">\"0x00020000\"</span></div><div class=\"line\">        android:required=<span class=\"string\">\"true\"</span>/&gt;</div></pre></td></tr></table></figure>","more":"<h3 id=\"2-在编码中遇到的问题\"><a href=\"#2-在编码中遇到的问题\" class=\"headerlink\" title=\"2.在编码中遇到的问题\"></a>2.在编码中遇到的问题</h3><p>1.可以实现OnCameraChangeListener接口，来实现对相机状态的监听，比如我就记录下了地图缩放的大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCameraChange</span><span class=\"params\">(CameraPosition arg0)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\tzoom = arg0.zoom;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.向将处理地图的 Activity 添加 Fragment 对象。 最简单的实现方式是，向Activity 的布局文件添加 <fragment> 元素。</p>\n<p>3.实现 OnMapReadyCallback 接口，并使用onMapReady(GoogleMap)回调方法获取GoogleMap对象的句柄。GoogleMap对象是对地图本身的内部表示。如需设置地图的视图选项，可以使用UiSettings设置地图的样式。</p>\n<p>4.调用Fragment上的getMapAsync()以注册回调。</p>\n<p>5.使用手机定位，定位成功后再map上显示标记：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">MarkerOptions markerOpt = <span class=\"keyword\">new</span> MarkerOptions();  </div><div class=\"line\">markerOpt.position(<span class=\"keyword\">new</span> LatLng(geoLat, geoLng));  </div><div class=\"line\">markerOpt.draggable(<span class=\"keyword\">false</span>);  </div><div class=\"line\">markerOpt.visible(<span class=\"keyword\">true</span>);  </div><div class=\"line\">markerOpt.anchor(<span class=\"number\">0.5f</span>, <span class=\"number\">0.5f</span>);<span class=\"comment\">//设为图片中心  </span></div><div class=\"line\">markerOpt.icon(BitmapDescriptorFactory  </div><div class=\"line\">\t.fromResource(R.drawable.sos_location_38x53));  </div><div class=\"line\">mMap.addMarker(markerOpt);  </div><div class=\"line\"><span class=\"comment\">//将摄影机移动到指定的地理位置  </span></div><div class=\"line\">cameraPosition = <span class=\"keyword\">new</span> CameraPosition.Builder()  </div><div class=\"line\">.target(<span class=\"keyword\">new</span> LatLng(geoLat, geoLng))              <span class=\"comment\">// Sets the center of the map to ZINTUN  </span></div><div class=\"line\">\t.zoom(zoom)                  <span class=\"comment\">// 缩放比例  </span></div><div class=\"line\">\t.bearing(<span class=\"number\">0</span>)                <span class=\"comment\">// Sets the orientation of the camera to east  </span></div><div class=\"line\">\t.build();                  <span class=\"comment\">// Creates a CameraPosition from the builder  </span></div><div class=\"line\">mMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition));</div><div class=\"line\">~~~   </div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">6</span>.实现地图圆角效果：使用圆角.<span class=\"number\">9</span>图片，中间透明，圆角四周不透明&lt;br&gt;</div><div class=\"line\">详细可以看这个提问：[Is there a way to implement rounded corners to a Mapfragment?](http:<span class=\"comment\">//stackoverflow.com/questions/14469208/is-there-a-way-to-implement-rounded-corners-to-a-mapfragment)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">7</span>.去掉google地图自带的蓝色圆点</div><div class=\"line\">GoogleMap.setMyLocationEnabled(<span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">8</span>.解决mapview与scrollview嵌套滑动的问题：</div><div class=\"line\">思路就是使用getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);方法，让子类接收到touch事件</div><div class=\"line\"></div><div class=\"line\">~~~ Java</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">MapView</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> ViewParent mViewParent;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMapView</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMapView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMapView</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyle)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyle);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMapView</span><span class=\"params\">(Context context, GoogleMapOptions options)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, options);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setViewParent</span><span class=\"params\">(@Nullable <span class=\"keyword\">final</span> ViewParent viewParent)</span> </span>&#123; <span class=\"comment\">//any ViewGroup</span></div><div class=\"line\">        mViewParent = viewParent;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(<span class=\"keyword\">final</span> MotionEvent event)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mViewParent) &#123;</div><div class=\"line\">                    <span class=\"comment\">//设置父类不拦截touch事件，子view可以接收到touch事件</span></div><div class=\"line\">                    getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    mViewParent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">true</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mViewParent) &#123;</div><div class=\"line\">                    <span class=\"comment\">//让父类拦截touch事件</span></div><div class=\"line\">                    getParent().requestDisallowInterceptTouchEvent(<span class=\"keyword\">false</span>);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    mViewParent.requestDisallowInterceptTouchEvent(<span class=\"keyword\">false</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onInterceptTouchEvent(event);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>9.LocationListener，一直回调到onProviderDisabled</p>\n<p>有可能是因为手机没有开启定位服务，解决办法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProviderDisabled</span><span class=\"params\">(String provider)</span> </span>&#123;</div><div class=\"line\">    isLocatedSuccess = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (provider.equals(<span class=\"string\">\"network\"</span>)) <span class=\"comment\">//跳到位置服务设置页面</span></div><div class=\"line\">        startActivity(<span class=\"keyword\">new</span> Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-在真机上测试效果\"><a href=\"#3-在真机上测试效果\" class=\"headerlink\" title=\"3.在真机上测试效果\"></a>3.在真机上测试效果</h3><p>需要在真机上安装这两个包：com.android.vending.apk（Google play store）和com.google.android.gms.apk（Google play services）<br>可以在国内应用市场上去搜索最新版本，也可以使用我上传的文件：</p>\n<p>链接：<a href=\"http://pan.baidu.com/s/1i5q8jo5\">http://pan.baidu.com/s/1i5q8jo5</a> 密码：solm</p>\n<p>安装成功以后，再运行自己的程序，查看效果了</p>"},{"layout":"post","title":"近期总结facebook google+ Twitter sign-in fragment使用","keywords":"android, google map, fragments","description":"google map2.0使用总结","banner":"http://obxk8w81b.bkt.clouddn.com/Cottages%20with%20a%20Woman%20Working%20in%20the%20Foreground.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Cottages%20with%20a%20Woman%20Working%20in%20the%20Foreground.jpg","_content":"\n\n### 1.相关资料\nblog: [关于Google+以及Facebook第三方登录实现的一点总结](http://www.cnblogs.com/lngg057/p/5020192.html)\n\ng+官方教程: [G+ start](https://developers.google.com/identity/sign-in/android/start)\n\nfacebook官方教程: [Facebook start](https://developers.facebook.com/docs/android/getting-started)\n\niCCP: [Not recognizing known sRGB profile](http://www.bigademo.com/iccp-not-recognizing-known-srgb-profile/)\n\n<!--more-->\n\n- 今天做分享的时候遇到了这个问题：\n\n    [2016-04-01 11:24:04 - Dex Loader] Unable to execute dex: method ID not in [0, 0xffff]: 65536\n    [2016-04-01 11:24:04 - VIVAT_SHARESDK] Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536\n\n[大项目中遇到的问题看这个博客](http://www.cnblogs.com/yaozhongxiao/p/3521428.html)\n\n- iCCP: Not recognizing known sRGB profile 删除png图片内嵌的iCCP profile sRGB报错\n\n今天有碰见一个坑，改其他代码，然后在编译的时候就出现这个问题，对就是这个问题。网上查了资料，也就这个资料最全面，大家可以去看见http://my.oschina.net/1pei/blog/479162?fromerr=ARrUPlGS\n\n处理这个问题我使用了一种方法，记录下来以便以后使用\n\n步骤1:下载Image Magick http://www.imagemagick.com.cn/download.html.如果是windows的，请下载含dll的\n\n步骤2： 在要处理的文件夹使用如下命令 ，一定要在要处理的文件夹使用\n\n~~~ C++\n//WINDOWS使用\nset fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe  \nfor /f \"tokens=*\" %i in ('dir/s/b *.png') do \"%fn%\" \"%i\" -strip \"%i\"\n（因为是window的，所以把%%i改为%i）\n~~~\n\n~~~ C++\n//LINUX使用\n set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe  \nfor /f \"tokens=*\" %%i in ('dir/s/b *.png') do \"%fn%\" \"%%i\" -strip \"%%i\"\n~~~\n\n### 2.遇到问题\n\n- 1.“This client application's callback url has been locked”.\n\n    使用Twitter signin时遇到了这个问题，这个错误信息是在logcat中找到的，原因是在[Twitter](https://apps.twitter.com)的Settings里勾选了“Enable Callback Locking (It is recommended to enable callback locking to ensure apps cannot overwrite the callback url)”选项，这个选项表示不允许app本地更改callback url。也可看这个[页面](https://twittercommunity.com/t/callback-url-is-locked/59481)\n\n### 3.add() vs. replace()\n- 只有在Fragment数量大于等于2的时候，调用add()还是replace()的区别才能体现出来。\n\n    当通过add()连续两次添加Fragment的时候，每个Fragment生命周期中的onAttach()-onResume()都会被各调用一次，而且两个Fragment的View会被同时attach到containerView。\n\n    同样，退出Activty时，每个Fragment生命周期中的onPause()-onDetach()也会被各调用一次。\n\n    但当使用replace()来添加Fragment的时候，第二次添加会导致第一个Fragment被销毁，即执行第二个Fragment的onAttach()方法之前会先执行第一个Fragment的onPause()-onDetach()方法，同时containerView会detach第一个Fragment的View。\n\n- 调用show() & hide()方法时.\n\n    Fragment的生命周期方法并不会被执行，仅仅是Fragment的View被显示或者​隐藏。而且，尽管Fragment的View被隐藏，但它在父布局中并未被detach，仍然是作为containerView的childView存在着。相比较下，attach() & detach()做的就更彻底一些。一旦一个Fragment被detach()，它的onPause()-onDestroyView()周期都会被执行。\n\n    同时Fragment的View也会被detach。在重新调用attach()后，onCreateView()-onResume()周期也会被再次执行。\n\n- remove()\n\n    其实看完上面的分析，remove()方法基本也就明白了。相对应add()方法执行onAttach()-onResume()的生命周期，remove()就是完成剩下的onPause()-onDetach()周期。\n\n\n### 4.FragmentTransaction add 和 replace 区别\n使用 FragmentTransaction 的时候，它提供了这样两个方法，一个 add ， 一个 replace .add 和 replace 影响的只是界面，而控制回退的，是事务。\n\n- add 是把一个fragment添加到一个容器 container 里。\n\n    Add a fragment to the activity state. This fragment may optionally also have its view (if Fragment.onCreateView returns non-null) into a container view of the activity.\n\n~~~ Java\npublic abstract FragmentTransaction add (int containerViewId, Fragment fragment, String tag)\n~~~\n\n\n- replace 是先remove掉相同id的所有fragment，然后在add当前的这个fragment。\n\n    Replace an existing fragment that was added to a container. This is essentially the same as calling remove(Fragment) for all currently added fragments that were added with the same containerViewId and then add(int, Fragment, String) with the same arguments given here.\n\n~~~ Java\npublic abstract FragmentTransaction replace (int containerViewId, Fragment fragment, String tag)\n~~~\n\n\n\n在大部分情况下，这两个的表现基本相同。因为，一般，咱们会使用一个FrameLayout来当容器，而每个Fragment被add 或者 replace 到这个FrameLayout的时候，都是显示在最上层的。所以你看到的界面都是一样的。但是，使用add的情况下，这个FrameLayout其实有2层，多层肯定要比一层的来得浪费，所以还是推荐使用replace。当然有时候还是需要使用add的。比如要实现轮播图的效果，每个轮播图都是一个独立的Fragment，而他的容器FrameLayout需要add多个Fragment，这样他就可以根据提供的逻辑进行轮播了。\n\n而至于返回键的时候，这个跟事务有关，跟使用add还是replace没有任何关系。\n\n###\t5.要想fragment完整地执行生命周期\nfragment跳转是要使用replace()方法，并一定要指定tag，否则有些方法不会执行（比如onResume），例如：\n\n~~~ Java\ngetFragmentManager()\n \t.beginTransaction()\n    .replace(R.id.base_container,\n    \t inputVerifyCodeFragment,\"tag_code\")\n    .addToBackStack(null).commit();\n~~~\n\n### 6.fragment事件穿透\n如果发现fragment2的点击事件可以被fragment栈下一层的fragment1获取到，可以在fragment2布局的根部加上：android:clickable=\"true\"。问题解决\n","source":"_posts/2016-03-15-facebook-google+signin.md","raw":"---\nlayout: post\ntitle: 近期总结facebook google+ Twitter sign-in fragment使用\ncategory: accumulation\ntags: accumulation\nkeywords: android, google map, fragments\ndescription: google map2.0使用总结\nbanner: http://obxk8w81b.bkt.clouddn.com/Cottages%20with%20a%20Woman%20Working%20in%20the%20Foreground.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Cottages%20with%20a%20Woman%20Working%20in%20the%20Foreground.jpg\n---\n\n\n### 1.相关资料\nblog: [关于Google+以及Facebook第三方登录实现的一点总结](http://www.cnblogs.com/lngg057/p/5020192.html)\n\ng+官方教程: [G+ start](https://developers.google.com/identity/sign-in/android/start)\n\nfacebook官方教程: [Facebook start](https://developers.facebook.com/docs/android/getting-started)\n\niCCP: [Not recognizing known sRGB profile](http://www.bigademo.com/iccp-not-recognizing-known-srgb-profile/)\n\n<!--more-->\n\n- 今天做分享的时候遇到了这个问题：\n\n    [2016-04-01 11:24:04 - Dex Loader] Unable to execute dex: method ID not in [0, 0xffff]: 65536\n    [2016-04-01 11:24:04 - VIVAT_SHARESDK] Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536\n\n[大项目中遇到的问题看这个博客](http://www.cnblogs.com/yaozhongxiao/p/3521428.html)\n\n- iCCP: Not recognizing known sRGB profile 删除png图片内嵌的iCCP profile sRGB报错\n\n今天有碰见一个坑，改其他代码，然后在编译的时候就出现这个问题，对就是这个问题。网上查了资料，也就这个资料最全面，大家可以去看见http://my.oschina.net/1pei/blog/479162?fromerr=ARrUPlGS\n\n处理这个问题我使用了一种方法，记录下来以便以后使用\n\n步骤1:下载Image Magick http://www.imagemagick.com.cn/download.html.如果是windows的，请下载含dll的\n\n步骤2： 在要处理的文件夹使用如下命令 ，一定要在要处理的文件夹使用\n\n~~~ C++\n//WINDOWS使用\nset fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe  \nfor /f \"tokens=*\" %i in ('dir/s/b *.png') do \"%fn%\" \"%i\" -strip \"%i\"\n（因为是window的，所以把%%i改为%i）\n~~~\n\n~~~ C++\n//LINUX使用\n set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe  \nfor /f \"tokens=*\" %%i in ('dir/s/b *.png') do \"%fn%\" \"%%i\" -strip \"%%i\"\n~~~\n\n### 2.遇到问题\n\n- 1.“This client application's callback url has been locked”.\n\n    使用Twitter signin时遇到了这个问题，这个错误信息是在logcat中找到的，原因是在[Twitter](https://apps.twitter.com)的Settings里勾选了“Enable Callback Locking (It is recommended to enable callback locking to ensure apps cannot overwrite the callback url)”选项，这个选项表示不允许app本地更改callback url。也可看这个[页面](https://twittercommunity.com/t/callback-url-is-locked/59481)\n\n### 3.add() vs. replace()\n- 只有在Fragment数量大于等于2的时候，调用add()还是replace()的区别才能体现出来。\n\n    当通过add()连续两次添加Fragment的时候，每个Fragment生命周期中的onAttach()-onResume()都会被各调用一次，而且两个Fragment的View会被同时attach到containerView。\n\n    同样，退出Activty时，每个Fragment生命周期中的onPause()-onDetach()也会被各调用一次。\n\n    但当使用replace()来添加Fragment的时候，第二次添加会导致第一个Fragment被销毁，即执行第二个Fragment的onAttach()方法之前会先执行第一个Fragment的onPause()-onDetach()方法，同时containerView会detach第一个Fragment的View。\n\n- 调用show() & hide()方法时.\n\n    Fragment的生命周期方法并不会被执行，仅仅是Fragment的View被显示或者​隐藏。而且，尽管Fragment的View被隐藏，但它在父布局中并未被detach，仍然是作为containerView的childView存在着。相比较下，attach() & detach()做的就更彻底一些。一旦一个Fragment被detach()，它的onPause()-onDestroyView()周期都会被执行。\n\n    同时Fragment的View也会被detach。在重新调用attach()后，onCreateView()-onResume()周期也会被再次执行。\n\n- remove()\n\n    其实看完上面的分析，remove()方法基本也就明白了。相对应add()方法执行onAttach()-onResume()的生命周期，remove()就是完成剩下的onPause()-onDetach()周期。\n\n\n### 4.FragmentTransaction add 和 replace 区别\n使用 FragmentTransaction 的时候，它提供了这样两个方法，一个 add ， 一个 replace .add 和 replace 影响的只是界面，而控制回退的，是事务。\n\n- add 是把一个fragment添加到一个容器 container 里。\n\n    Add a fragment to the activity state. This fragment may optionally also have its view (if Fragment.onCreateView returns non-null) into a container view of the activity.\n\n~~~ Java\npublic abstract FragmentTransaction add (int containerViewId, Fragment fragment, String tag)\n~~~\n\n\n- replace 是先remove掉相同id的所有fragment，然后在add当前的这个fragment。\n\n    Replace an existing fragment that was added to a container. This is essentially the same as calling remove(Fragment) for all currently added fragments that were added with the same containerViewId and then add(int, Fragment, String) with the same arguments given here.\n\n~~~ Java\npublic abstract FragmentTransaction replace (int containerViewId, Fragment fragment, String tag)\n~~~\n\n\n\n在大部分情况下，这两个的表现基本相同。因为，一般，咱们会使用一个FrameLayout来当容器，而每个Fragment被add 或者 replace 到这个FrameLayout的时候，都是显示在最上层的。所以你看到的界面都是一样的。但是，使用add的情况下，这个FrameLayout其实有2层，多层肯定要比一层的来得浪费，所以还是推荐使用replace。当然有时候还是需要使用add的。比如要实现轮播图的效果，每个轮播图都是一个独立的Fragment，而他的容器FrameLayout需要add多个Fragment，这样他就可以根据提供的逻辑进行轮播了。\n\n而至于返回键的时候，这个跟事务有关，跟使用add还是replace没有任何关系。\n\n###\t5.要想fragment完整地执行生命周期\nfragment跳转是要使用replace()方法，并一定要指定tag，否则有些方法不会执行（比如onResume），例如：\n\n~~~ Java\ngetFragmentManager()\n \t.beginTransaction()\n    .replace(R.id.base_container,\n    \t inputVerifyCodeFragment,\"tag_code\")\n    .addToBackStack(null).commit();\n~~~\n\n### 6.fragment事件穿透\n如果发现fragment2的点击事件可以被fragment栈下一层的fragment1获取到，可以在fragment2布局的根部加上：android:clickable=\"true\"。问题解决\n","slug":"facebook-google+signin","published":1,"date":"2016-03-14T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj420009bxs6au58dxam","content":"<h3 id=\"1-相关资料\"><a href=\"#1-相关资料\" class=\"headerlink\" title=\"1.相关资料\"></a>1.相关资料</h3><p>blog: <a href=\"http://www.cnblogs.com/lngg057/p/5020192.html\" target=\"_blank\" rel=\"external\">关于Google+以及Facebook第三方登录实现的一点总结</a></p>\n<p>g+官方教程: <a href=\"https://developers.google.com/identity/sign-in/android/start\" target=\"_blank\" rel=\"external\">G+ start</a></p>\n<p>facebook官方教程: <a href=\"https://developers.facebook.com/docs/android/getting-started\" target=\"_blank\" rel=\"external\">Facebook start</a></p>\n<p>iCCP: <a href=\"http://www.bigademo.com/iccp-not-recognizing-known-srgb-profile/\" target=\"_blank\" rel=\"external\">Not recognizing known sRGB profile</a></p>\n<a id=\"more\"></a>\n<ul>\n<li><p>今天做分享的时候遇到了这个问题：</p>\n<p>  [2016-04-01 11:24:04 - Dex Loader] Unable to execute dex: method ID not in [0, 0xffff]: 65536<br>  [2016-04-01 11:24:04 - VIVAT_SHARESDK] Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536</p>\n</li>\n</ul>\n<p><a href=\"http://www.cnblogs.com/yaozhongxiao/p/3521428.html\" target=\"_blank\" rel=\"external\">大项目中遇到的问题看这个博客</a></p>\n<ul>\n<li>iCCP: Not recognizing known sRGB profile 删除png图片内嵌的iCCP profile sRGB报错</li>\n</ul>\n<p>今天有碰见一个坑，改其他代码，然后在编译的时候就出现这个问题，对就是这个问题。网上查了资料，也就这个资料最全面，大家可以去看见<a href=\"http://my.oschina.net/1pei/blog/479162?fromerr=ARrUPlGS\" target=\"_blank\" rel=\"external\">http://my.oschina.net/1pei/blog/479162?fromerr=ARrUPlGS</a></p>\n<p>处理这个问题我使用了一种方法，记录下来以便以后使用</p>\n<p>步骤1:下载Image Magick <a href=\"http://www.imagemagick.com.cn/download.html.如果是windows的，请下载含dll的\" target=\"_blank\" rel=\"external\">http://www.imagemagick.com.cn/download.html.如果是windows的，请下载含dll的</a></p>\n<p>步骤2： 在要处理的文件夹使用如下命令 ，一定要在要处理的文件夹使用</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//WINDOWS使用</div><div class=\"line\">set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe  </div><div class=\"line\">for /f \"tokens=*\" %i in ('dir/s/b *.png') do \"%fn%\" \"%i\" -strip \"%i\"</div><div class=\"line\">（因为是window的，所以把%%i改为%i）</div></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//LINUX使用</div><div class=\"line\"> set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe  </div><div class=\"line\">for /f \"tokens=*\" %%i in ('dir/s/b *.png') do \"%fn%\" \"%%i\" -strip \"%%i\"</div></pre></td></tr></table></figure>\n<h3 id=\"2-遇到问题\"><a href=\"#2-遇到问题\" class=\"headerlink\" title=\"2.遇到问题\"></a>2.遇到问题</h3><ul>\n<li><p>1.“This client application’s callback url has been locked”.</p>\n<p>  使用Twitter signin时遇到了这个问题，这个错误信息是在logcat中找到的，原因是在<a href=\"https://apps.twitter.com\" target=\"_blank\" rel=\"external\">Twitter</a>的Settings里勾选了“Enable Callback Locking (It is recommended to enable callback locking to ensure apps cannot overwrite the callback url)”选项，这个选项表示不允许app本地更改callback url。也可看这个<a href=\"https://twittercommunity.com/t/callback-url-is-locked/59481\" target=\"_blank\" rel=\"external\">页面</a></p>\n</li>\n</ul>\n<h3 id=\"3-add-vs-replace\"><a href=\"#3-add-vs-replace\" class=\"headerlink\" title=\"3.add() vs. replace()\"></a>3.add() vs. replace()</h3><ul>\n<li><p>只有在Fragment数量大于等于2的时候，调用add()还是replace()的区别才能体现出来。</p>\n<p>  当通过add()连续两次添加Fragment的时候，每个Fragment生命周期中的onAttach()-onResume()都会被各调用一次，而且两个Fragment的View会被同时attach到containerView。</p>\n<p>  同样，退出Activty时，每个Fragment生命周期中的onPause()-onDetach()也会被各调用一次。</p>\n<p>  但当使用replace()来添加Fragment的时候，第二次添加会导致第一个Fragment被销毁，即执行第二个Fragment的onAttach()方法之前会先执行第一个Fragment的onPause()-onDetach()方法，同时containerView会detach第一个Fragment的View。</p>\n</li>\n<li><p>调用show() &amp; hide()方法时.</p>\n<p>  Fragment的生命周期方法并不会被执行，仅仅是Fragment的View被显示或者​隐藏。而且，尽管Fragment的View被隐藏，但它在父布局中并未被detach，仍然是作为containerView的childView存在着。相比较下，attach() &amp; detach()做的就更彻底一些。一旦一个Fragment被detach()，它的onPause()-onDestroyView()周期都会被执行。</p>\n<p>  同时Fragment的View也会被detach。在重新调用attach()后，onCreateView()-onResume()周期也会被再次执行。</p>\n</li>\n<li><p>remove()</p>\n<p>  其实看完上面的分析，remove()方法基本也就明白了。相对应add()方法执行onAttach()-onResume()的生命周期，remove()就是完成剩下的onPause()-onDetach()周期。</p>\n</li>\n</ul>\n<h3 id=\"4-FragmentTransaction-add-和-replace-区别\"><a href=\"#4-FragmentTransaction-add-和-replace-区别\" class=\"headerlink\" title=\"4.FragmentTransaction add 和 replace 区别\"></a>4.FragmentTransaction add 和 replace 区别</h3><p>使用 FragmentTransaction 的时候，它提供了这样两个方法，一个 add ， 一个 replace .add 和 replace 影响的只是界面，而控制回退的，是事务。</p>\n<ul>\n<li><p>add 是把一个fragment添加到一个容器 container 里。</p>\n<p>  Add a fragment to the activity state. This fragment may optionally also have its view (if Fragment.onCreateView returns non-null) into a container view of the activity.</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FragmentTransaction <span class=\"title\">add</span> <span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag)</span></span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>replace 是先remove掉相同id的所有fragment，然后在add当前的这个fragment。</p>\n<p>  Replace an existing fragment that was added to a container. This is essentially the same as calling remove(Fragment) for all currently added fragments that were added with the same containerViewId and then add(int, Fragment, String) with the same arguments given here.</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FragmentTransaction <span class=\"title\">replace</span> <span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag)</span></span></div></pre></td></tr></table></figure>\n<p>在大部分情况下，这两个的表现基本相同。因为，一般，咱们会使用一个FrameLayout来当容器，而每个Fragment被add 或者 replace 到这个FrameLayout的时候，都是显示在最上层的。所以你看到的界面都是一样的。但是，使用add的情况下，这个FrameLayout其实有2层，多层肯定要比一层的来得浪费，所以还是推荐使用replace。当然有时候还是需要使用add的。比如要实现轮播图的效果，每个轮播图都是一个独立的Fragment，而他的容器FrameLayout需要add多个Fragment，这样他就可以根据提供的逻辑进行轮播了。</p>\n<p>而至于返回键的时候，这个跟事务有关，跟使用add还是replace没有任何关系。</p>\n<h3 id=\"5-要想fragment完整地执行生命周期\"><a href=\"#5-要想fragment完整地执行生命周期\" class=\"headerlink\" title=\"5.要想fragment完整地执行生命周期\"></a>5.要想fragment完整地执行生命周期</h3><p>fragment跳转是要使用replace()方法，并一定要指定tag，否则有些方法不会执行（比如onResume），例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">getFragmentManager()</div><div class=\"line\"> \t.beginTransaction()</div><div class=\"line\">    .replace(R.id.base_container,</div><div class=\"line\">    \t inputVerifyCodeFragment,<span class=\"string\">\"tag_code\"</span>)</div><div class=\"line\">    .addToBackStack(<span class=\"keyword\">null</span>).commit();</div></pre></td></tr></table></figure>\n<h3 id=\"6-fragment事件穿透\"><a href=\"#6-fragment事件穿透\" class=\"headerlink\" title=\"6.fragment事件穿透\"></a>6.fragment事件穿透</h3><p>如果发现fragment2的点击事件可以被fragment栈下一层的fragment1获取到，可以在fragment2布局的根部加上：android:clickable=”true”。问题解决</p>\n","excerpt":"<h3 id=\"1-相关资料\"><a href=\"#1-相关资料\" class=\"headerlink\" title=\"1.相关资料\"></a>1.相关资料</h3><p>blog: <a href=\"http://www.cnblogs.com/lngg057/p/5020192.html\">关于Google+以及Facebook第三方登录实现的一点总结</a></p>\n<p>g+官方教程: <a href=\"https://developers.google.com/identity/sign-in/android/start\">G+ start</a></p>\n<p>facebook官方教程: <a href=\"https://developers.facebook.com/docs/android/getting-started\">Facebook start</a></p>\n<p>iCCP: <a href=\"http://www.bigademo.com/iccp-not-recognizing-known-srgb-profile/\">Not recognizing known sRGB profile</a></p>","more":"<ul>\n<li><p>今天做分享的时候遇到了这个问题：</p>\n<p>  [2016-04-01 11:24:04 - Dex Loader] Unable to execute dex: method ID not in [0, 0xffff]: 65536<br>  [2016-04-01 11:24:04 - VIVAT_SHARESDK] Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536</p>\n</li>\n</ul>\n<p><a href=\"http://www.cnblogs.com/yaozhongxiao/p/3521428.html\">大项目中遇到的问题看这个博客</a></p>\n<ul>\n<li>iCCP: Not recognizing known sRGB profile 删除png图片内嵌的iCCP profile sRGB报错</li>\n</ul>\n<p>今天有碰见一个坑，改其他代码，然后在编译的时候就出现这个问题，对就是这个问题。网上查了资料，也就这个资料最全面，大家可以去看见<a href=\"http://my.oschina.net/1pei/blog/479162?fromerr=ARrUPlGS\">http://my.oschina.net/1pei/blog/479162?fromerr=ARrUPlGS</a></p>\n<p>处理这个问题我使用了一种方法，记录下来以便以后使用</p>\n<p>步骤1:下载Image Magick <a href=\"http://www.imagemagick.com.cn/download.html.如果是windows的，请下载含dll的\">http://www.imagemagick.com.cn/download.html.如果是windows的，请下载含dll的</a></p>\n<p>步骤2： 在要处理的文件夹使用如下命令 ，一定要在要处理的文件夹使用</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//WINDOWS使用</div><div class=\"line\">set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe  </div><div class=\"line\">for /f \"tokens=*\" %i in ('dir/s/b *.png') do \"%fn%\" \"%i\" -strip \"%i\"</div><div class=\"line\">（因为是window的，所以把%%i改为%i）</div></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//LINUX使用</div><div class=\"line\"> set fn=E:\\Program Files\\ImageMagick-6.9.0-Q16\\convert.exe  </div><div class=\"line\">for /f \"tokens=*\" %%i in ('dir/s/b *.png') do \"%fn%\" \"%%i\" -strip \"%%i\"</div></pre></td></tr></table></figure>\n<h3 id=\"2-遇到问题\"><a href=\"#2-遇到问题\" class=\"headerlink\" title=\"2.遇到问题\"></a>2.遇到问题</h3><ul>\n<li><p>1.“This client application’s callback url has been locked”.</p>\n<p>  使用Twitter signin时遇到了这个问题，这个错误信息是在logcat中找到的，原因是在<a href=\"https://apps.twitter.com\">Twitter</a>的Settings里勾选了“Enable Callback Locking (It is recommended to enable callback locking to ensure apps cannot overwrite the callback url)”选项，这个选项表示不允许app本地更改callback url。也可看这个<a href=\"https://twittercommunity.com/t/callback-url-is-locked/59481\">页面</a></p>\n</li>\n</ul>\n<h3 id=\"3-add-vs-replace\"><a href=\"#3-add-vs-replace\" class=\"headerlink\" title=\"3.add() vs. replace()\"></a>3.add() vs. replace()</h3><ul>\n<li><p>只有在Fragment数量大于等于2的时候，调用add()还是replace()的区别才能体现出来。</p>\n<p>  当通过add()连续两次添加Fragment的时候，每个Fragment生命周期中的onAttach()-onResume()都会被各调用一次，而且两个Fragment的View会被同时attach到containerView。</p>\n<p>  同样，退出Activty时，每个Fragment生命周期中的onPause()-onDetach()也会被各调用一次。</p>\n<p>  但当使用replace()来添加Fragment的时候，第二次添加会导致第一个Fragment被销毁，即执行第二个Fragment的onAttach()方法之前会先执行第一个Fragment的onPause()-onDetach()方法，同时containerView会detach第一个Fragment的View。</p>\n</li>\n<li><p>调用show() &amp; hide()方法时.</p>\n<p>  Fragment的生命周期方法并不会被执行，仅仅是Fragment的View被显示或者​隐藏。而且，尽管Fragment的View被隐藏，但它在父布局中并未被detach，仍然是作为containerView的childView存在着。相比较下，attach() &amp; detach()做的就更彻底一些。一旦一个Fragment被detach()，它的onPause()-onDestroyView()周期都会被执行。</p>\n<p>  同时Fragment的View也会被detach。在重新调用attach()后，onCreateView()-onResume()周期也会被再次执行。</p>\n</li>\n<li><p>remove()</p>\n<p>  其实看完上面的分析，remove()方法基本也就明白了。相对应add()方法执行onAttach()-onResume()的生命周期，remove()就是完成剩下的onPause()-onDetach()周期。</p>\n</li>\n</ul>\n<h3 id=\"4-FragmentTransaction-add-和-replace-区别\"><a href=\"#4-FragmentTransaction-add-和-replace-区别\" class=\"headerlink\" title=\"4.FragmentTransaction add 和 replace 区别\"></a>4.FragmentTransaction add 和 replace 区别</h3><p>使用 FragmentTransaction 的时候，它提供了这样两个方法，一个 add ， 一个 replace .add 和 replace 影响的只是界面，而控制回退的，是事务。</p>\n<ul>\n<li><p>add 是把一个fragment添加到一个容器 container 里。</p>\n<p>  Add a fragment to the activity state. This fragment may optionally also have its view (if Fragment.onCreateView returns non-null) into a container view of the activity.</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FragmentTransaction <span class=\"title\">add</span> <span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag)</span></span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>replace 是先remove掉相同id的所有fragment，然后在add当前的这个fragment。</p>\n<p>  Replace an existing fragment that was added to a container. This is essentially the same as calling remove(Fragment) for all currently added fragments that were added with the same containerViewId and then add(int, Fragment, String) with the same arguments given here.</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FragmentTransaction <span class=\"title\">replace</span> <span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag)</span></span></div></pre></td></tr></table></figure>\n<p>在大部分情况下，这两个的表现基本相同。因为，一般，咱们会使用一个FrameLayout来当容器，而每个Fragment被add 或者 replace 到这个FrameLayout的时候，都是显示在最上层的。所以你看到的界面都是一样的。但是，使用add的情况下，这个FrameLayout其实有2层，多层肯定要比一层的来得浪费，所以还是推荐使用replace。当然有时候还是需要使用add的。比如要实现轮播图的效果，每个轮播图都是一个独立的Fragment，而他的容器FrameLayout需要add多个Fragment，这样他就可以根据提供的逻辑进行轮播了。</p>\n<p>而至于返回键的时候，这个跟事务有关，跟使用add还是replace没有任何关系。</p>\n<h3 id=\"5-要想fragment完整地执行生命周期\"><a href=\"#5-要想fragment完整地执行生命周期\" class=\"headerlink\" title=\"5.要想fragment完整地执行生命周期\"></a>5.要想fragment完整地执行生命周期</h3><p>fragment跳转是要使用replace()方法，并一定要指定tag，否则有些方法不会执行（比如onResume），例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">getFragmentManager()</div><div class=\"line\"> \t.beginTransaction()</div><div class=\"line\">    .replace(R.id.base_container,</div><div class=\"line\">    \t inputVerifyCodeFragment,<span class=\"string\">\"tag_code\"</span>)</div><div class=\"line\">    .addToBackStack(<span class=\"keyword\">null</span>).commit();</div></pre></td></tr></table></figure>\n<h3 id=\"6-fragment事件穿透\"><a href=\"#6-fragment事件穿透\" class=\"headerlink\" title=\"6.fragment事件穿透\"></a>6.fragment事件穿透</h3><p>如果发现fragment2的点击事件可以被fragment栈下一层的fragment1获取到，可以在fragment2布局的根部加上：android:clickable=”true”。问题解决</p>"},{"layout":"post","title":"android新特性新知识点总结","keywords":"新特性, 新知识点,总结","banner":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Chestnut%20Branches.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Chestnut%20Branches.jpg","_content":"\n\n### 一、mipmap 目录和drawable 目录有什么区别\nNexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap：\n\n### 二、setTranslucentStatus()方法\n在Android4.4之后使用沉浸式状态栏，需要用到这个方法\n\n<!--more-->\n\n~~~ Java\npublic class MainActivity extends Activity\n{\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //首先检测当前的版本是否是api>=19的\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT)\n        {\n            setTranslucentStatus(true);\n        }\n\n        SystemBarTintManager tintManager = new SystemBarTintManager(this);\n        tintManager.setStatusBarTintEnabled(true);\n        tintManager.setStatusBarTintColor(Color.parseColor(\"#FFC1E0\"));\n    }\n\n    @TargetApi(19)\n    private void setTranslucentStatus(boolean on)\n    {\n        Window win = getWindow();\n        WindowManager.LayoutParams winParams = win.getAttributes();\n        final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;\n        if (on)\n        {\n            winParams.flags |= bits;\n        }\n        else\n        {\n            winParams.flags &= ~bits;\n        }\n        win.setAttributes(winParams);\n    }\n}\n~~~\n\n布局设置\n\n~~~ Javascript%\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:layout_width=\"match_parent\"\n              android:layout_height=\"match_parent\"\n              <!--这两行是必须设置的-->\n              android:fitsSystemWindows=\"true\"\n              android:clipToPadding=\"true\"\n\n              android:orientation=\"vertical\"\n              android:background=\"#FFD9EC\"\n        >\n\n    <TextView\n            android:text=\"沉浸式状态栏\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"50dp\"\n            android:textSize=\"23dp\"\n            android:layout_gravity=\"center_horizontal\"\n            android:gravity=\"center\"\n            android:background=\"#FFD9EC\"\n            />\n    <TextView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:background=\"@android:color/darker_gray\"/>\n\n</LinearLayout>\n~~~\n\n### 三、获取Bitmap图片大小的代码\n\n~~~ Java\npublic int getBitmapSize(Bitmap bitmap){\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT){     //API 19\n        return bitmap.getAllocationByteCount();\n    }\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1){//API 12\n        return bitmap.getByteCount();\n    }\n    return bitmap.getRowBytes() * bitmap.getHeight();                //earlier version\n}\n~~~\n\n\n### 四、Activity横竖屏切换生命周期\n\n总结：\n\n* 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次\n\n* 2、设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次\n\n* 3、设置Activity的android:configChanges=\"orientation\\|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法\n\n验证：\n\n1、新建一个Activity，并把各个生命周期打印出来\n\n2、运行Activity，得到如下信息\n\n~~~ Java\nonCreate-->\nonStart-->\nonResume-->\n~~~\n\n3、按crtl+f12切换成横屏时\n\n~~~ Java\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\n~~~\n4、再按crtl+f12切换成竖屏时，发现打印了两次相同的log\n\n~~~ Java\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\n~~~\n5、修改AndroidManifest.xml，把该Activity添加 android:configChanges=\"orientation\"，执行步骤3\n\n~~~ Java\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\n~~~\n6、再执行步骤4，发现不会再打印相同信息，但多打印了一行onConfigChanged\n\n~~~ Java\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\nonConfigurationChanged-->\n~~~\n7、把步骤5的android:configChanges=\"orientation\" 改成android:configChanges=\"orientation\\|keyboardHidden\"，执行步骤3，就只打印onConfigChanged\n\n~~~ Java\nonConfigurationChanged-->\n~~~\n8、执行步骤4\n\n~~~ Java\nonConfigurationChanged-->\nonConfigurationChanged-->\n~~~\n\n总结一下整个Activity的生命周期\n\n  - 1.补充一点，当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变\n  - 2.Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState --> onPause --> onStop       onRestart -->onStart--->onResume\n  - 3.Activity未被完全覆盖只是失去焦点：onPause--->onResume\n","source":"_posts/2016-03-20-android-new-knowledge-summary.md","raw":"---\nlayout: post\ntitle:  android新特性新知识点总结\ncategory: accumulation\ntags: accumulation\nkeywords: 新特性, 新知识点,总结\nbanner: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Chestnut%20Branches.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Chestnut%20Branches.jpg\n---\n\n\n### 一、mipmap 目录和drawable 目录有什么区别\nNexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap：\n\n### 二、setTranslucentStatus()方法\n在Android4.4之后使用沉浸式状态栏，需要用到这个方法\n\n<!--more-->\n\n~~~ Java\npublic class MainActivity extends Activity\n{\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        //首先检测当前的版本是否是api>=19的\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT)\n        {\n            setTranslucentStatus(true);\n        }\n\n        SystemBarTintManager tintManager = new SystemBarTintManager(this);\n        tintManager.setStatusBarTintEnabled(true);\n        tintManager.setStatusBarTintColor(Color.parseColor(\"#FFC1E0\"));\n    }\n\n    @TargetApi(19)\n    private void setTranslucentStatus(boolean on)\n    {\n        Window win = getWindow();\n        WindowManager.LayoutParams winParams = win.getAttributes();\n        final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;\n        if (on)\n        {\n            winParams.flags |= bits;\n        }\n        else\n        {\n            winParams.flags &= ~bits;\n        }\n        win.setAttributes(winParams);\n    }\n}\n~~~\n\n布局设置\n\n~~~ Javascript%\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:layout_width=\"match_parent\"\n              android:layout_height=\"match_parent\"\n              <!--这两行是必须设置的-->\n              android:fitsSystemWindows=\"true\"\n              android:clipToPadding=\"true\"\n\n              android:orientation=\"vertical\"\n              android:background=\"#FFD9EC\"\n        >\n\n    <TextView\n            android:text=\"沉浸式状态栏\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"50dp\"\n            android:textSize=\"23dp\"\n            android:layout_gravity=\"center_horizontal\"\n            android:gravity=\"center\"\n            android:background=\"#FFD9EC\"\n            />\n    <TextView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:background=\"@android:color/darker_gray\"/>\n\n</LinearLayout>\n~~~\n\n### 三、获取Bitmap图片大小的代码\n\n~~~ Java\npublic int getBitmapSize(Bitmap bitmap){\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT){     //API 19\n        return bitmap.getAllocationByteCount();\n    }\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1){//API 12\n        return bitmap.getByteCount();\n    }\n    return bitmap.getRowBytes() * bitmap.getHeight();                //earlier version\n}\n~~~\n\n\n### 四、Activity横竖屏切换生命周期\n\n总结：\n\n* 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次\n\n* 2、设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次\n\n* 3、设置Activity的android:configChanges=\"orientation\\|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法\n\n验证：\n\n1、新建一个Activity，并把各个生命周期打印出来\n\n2、运行Activity，得到如下信息\n\n~~~ Java\nonCreate-->\nonStart-->\nonResume-->\n~~~\n\n3、按crtl+f12切换成横屏时\n\n~~~ Java\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\n~~~\n4、再按crtl+f12切换成竖屏时，发现打印了两次相同的log\n\n~~~ Java\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\n~~~\n5、修改AndroidManifest.xml，把该Activity添加 android:configChanges=\"orientation\"，执行步骤3\n\n~~~ Java\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\n~~~\n6、再执行步骤4，发现不会再打印相同信息，但多打印了一行onConfigChanged\n\n~~~ Java\nonSaveInstanceState-->\nonPause-->\nonStop-->\nonDestroy-->\nonCreate-->\nonStart-->\nonRestoreInstanceState-->\nonResume-->\nonConfigurationChanged-->\n~~~\n7、把步骤5的android:configChanges=\"orientation\" 改成android:configChanges=\"orientation\\|keyboardHidden\"，执行步骤3，就只打印onConfigChanged\n\n~~~ Java\nonConfigurationChanged-->\n~~~\n8、执行步骤4\n\n~~~ Java\nonConfigurationChanged-->\nonConfigurationChanged-->\n~~~\n\n总结一下整个Activity的生命周期\n\n  - 1.补充一点，当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变\n  - 2.Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState --> onPause --> onStop       onRestart -->onStart--->onResume\n  - 3.Activity未被完全覆盖只是失去焦点：onPause--->onResume\n","slug":"android-new-knowledge-summary","published":1,"date":"2016-03-19T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj46000abxs60x3e3xyj","content":"<h3 id=\"一、mipmap-目录和drawable-目录有什么区别\"><a href=\"#一、mipmap-目录和drawable-目录有什么区别\" class=\"headerlink\" title=\"一、mipmap 目录和drawable 目录有什么区别\"></a>一、mipmap 目录和drawable 目录有什么区别</h3><p>Nexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap：</p>\n<h3 id=\"二、setTranslucentStatus-方法\"><a href=\"#二、setTranslucentStatus-方法\" class=\"headerlink\" title=\"二、setTranslucentStatus()方法\"></a>二、setTranslucentStatus()方法</h3><p>在Android4.4之后使用沉浸式状态栏，需要用到这个方法</p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_main);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//首先检测当前的版本是否是api&gt;=19的</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)</div><div class=\"line\">        &#123;</div><div class=\"line\">            setTranslucentStatus(<span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        SystemBarTintManager tintManager = <span class=\"keyword\">new</span> SystemBarTintManager(<span class=\"keyword\">this</span>);</div><div class=\"line\">        tintManager.setStatusBarTintEnabled(<span class=\"keyword\">true</span>);</div><div class=\"line\">        tintManager.setStatusBarTintColor(Color.parseColor(<span class=\"string\">\"#FFC1E0\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@TargetApi</span>(<span class=\"number\">19</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setTranslucentStatus</span><span class=\"params\">(<span class=\"keyword\">boolean</span> on)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        Window win = getWindow();</div><div class=\"line\">        WindowManager.LayoutParams winParams = win.getAttributes();</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;</div><div class=\"line\">        <span class=\"keyword\">if</span> (on)</div><div class=\"line\">        &#123;</div><div class=\"line\">            winParams.flags |= bits;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            winParams.flags &amp;= ~bits;</div><div class=\"line\">        &#125;</div><div class=\"line\">        win.setAttributes(winParams);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>布局设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">              android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">              android:layout_height=&quot;match_parent&quot;</div><div class=\"line\">              &lt;!--这两行是必须设置的--&gt;</div><div class=\"line\">              android:fitsSystemWindows=&quot;true&quot;</div><div class=\"line\">              android:clipToPadding=&quot;true&quot;</div><div class=\"line\"></div><div class=\"line\">              android:orientation=&quot;vertical&quot;</div><div class=\"line\">              android:background=&quot;#FFD9EC&quot;</div><div class=\"line\">        &gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;TextView</div><div class=\"line\">            android:text=&quot;沉浸式状态栏&quot;</div><div class=\"line\">            android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">            android:layout_height=&quot;50dp&quot;</div><div class=\"line\">            android:textSize=&quot;23dp&quot;</div><div class=\"line\">            android:layout_gravity=&quot;center_horizontal&quot;</div><div class=\"line\">            android:gravity=&quot;center&quot;</div><div class=\"line\">            android:background=&quot;#FFD9EC&quot;</div><div class=\"line\">            /&gt;</div><div class=\"line\">    &lt;TextView</div><div class=\"line\">            android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">            android:layout_height=&quot;match_parent&quot;</div><div class=\"line\">            android:background=&quot;@android:color/darker_gray&quot;/&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"三、获取Bitmap图片大小的代码\"><a href=\"#三、获取Bitmap图片大小的代码\" class=\"headerlink\" title=\"三、获取Bitmap图片大小的代码\"></a>三、获取Bitmap图片大小的代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getBitmapSize</span><span class=\"params\">(Bitmap bitmap)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123;     <span class=\"comment\">//API 19</span></div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap.getAllocationByteCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1)&#123;<span class=\"comment\">//API 12</span></div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap.getByteCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> bitmap.getRowBytes() * bitmap.getHeight();                <span class=\"comment\">//earlier version</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四、Activity横竖屏切换生命周期\"><a href=\"#四、Activity横竖屏切换生命周期\" class=\"headerlink\" title=\"四、Activity横竖屏切换生命周期\"></a>四、Activity横竖屏切换生命周期</h3><p>总结：</p>\n<ul>\n<li><p>1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>\n</li>\n<li><p>2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>\n</li>\n<li><p>3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>\n</li>\n</ul>\n<p>验证：</p>\n<p>1、新建一个Activity，并把各个生命周期打印出来</p>\n<p>2、运行Activity，得到如下信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onResume--&gt;</div></pre></td></tr></table></figure>\n<p>3、按crtl+f12切换成横屏时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div></pre></td></tr></table></figure>\n<p>4、再按crtl+f12切换成竖屏时，发现打印了两次相同的log</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div></pre></td></tr></table></figure>\n<p>5、修改AndroidManifest.xml，把该Activity添加 android:configChanges=”orientation”，执行步骤3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div></pre></td></tr></table></figure>\n<p>6、再执行步骤4，发现不会再打印相同信息，但多打印了一行onConfigChanged</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div><div class=\"line\">onConfigurationChanged--&gt;</div></pre></td></tr></table></figure>\n<p>7、把步骤5的android:configChanges=”orientation” 改成android:configChanges=”orientation|keyboardHidden”，执行步骤3，就只打印onConfigChanged</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onConfigurationChanged--&gt;</div></pre></td></tr></table></figure>\n<p>8、执行步骤4</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onConfigurationChanged--&gt;</div><div class=\"line\">onConfigurationChanged--&gt;</div></pre></td></tr></table></figure>\n<p>总结一下整个Activity的生命周期</p>\n<ul>\n<li>1.补充一点，当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变</li>\n<li>2.Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState –&gt; onPause –&gt; onStop       onRestart –&gt;onStart—&gt;onResume</li>\n<li>3.Activity未被完全覆盖只是失去焦点：onPause—&gt;onResume</li>\n</ul>\n","excerpt":"<h3 id=\"一、mipmap-目录和drawable-目录有什么区别\"><a href=\"#一、mipmap-目录和drawable-目录有什么区别\" class=\"headerlink\" title=\"一、mipmap 目录和drawable 目录有什么区别\"></a>一、mipmap 目录和drawable 目录有什么区别</h3><p>Nexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap：</p>\n<h3 id=\"二、setTranslucentStatus-方法\"><a href=\"#二、setTranslucentStatus-方法\" class=\"headerlink\" title=\"二、setTranslucentStatus()方法\"></a>二、setTranslucentStatus()方法</h3><p>在Android4.4之后使用沉浸式状态栏，需要用到这个方法</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_main);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//首先检测当前的版本是否是api&gt;=19的</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)</div><div class=\"line\">        &#123;</div><div class=\"line\">            setTranslucentStatus(<span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        SystemBarTintManager tintManager = <span class=\"keyword\">new</span> SystemBarTintManager(<span class=\"keyword\">this</span>);</div><div class=\"line\">        tintManager.setStatusBarTintEnabled(<span class=\"keyword\">true</span>);</div><div class=\"line\">        tintManager.setStatusBarTintColor(Color.parseColor(<span class=\"string\">\"#FFC1E0\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@TargetApi</span>(<span class=\"number\">19</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setTranslucentStatus</span><span class=\"params\">(<span class=\"keyword\">boolean</span> on)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        Window win = getWindow();</div><div class=\"line\">        WindowManager.LayoutParams winParams = win.getAttributes();</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;</div><div class=\"line\">        <span class=\"keyword\">if</span> (on)</div><div class=\"line\">        &#123;</div><div class=\"line\">            winParams.flags |= bits;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            winParams.flags &amp;= ~bits;</div><div class=\"line\">        &#125;</div><div class=\"line\">        win.setAttributes(winParams);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>布局设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class=\"line\">              android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">              android:layout_height=&quot;match_parent&quot;</div><div class=\"line\">              &lt;!--这两行是必须设置的--&gt;</div><div class=\"line\">              android:fitsSystemWindows=&quot;true&quot;</div><div class=\"line\">              android:clipToPadding=&quot;true&quot;</div><div class=\"line\"></div><div class=\"line\">              android:orientation=&quot;vertical&quot;</div><div class=\"line\">              android:background=&quot;#FFD9EC&quot;</div><div class=\"line\">        &gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;TextView</div><div class=\"line\">            android:text=&quot;沉浸式状态栏&quot;</div><div class=\"line\">            android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">            android:layout_height=&quot;50dp&quot;</div><div class=\"line\">            android:textSize=&quot;23dp&quot;</div><div class=\"line\">            android:layout_gravity=&quot;center_horizontal&quot;</div><div class=\"line\">            android:gravity=&quot;center&quot;</div><div class=\"line\">            android:background=&quot;#FFD9EC&quot;</div><div class=\"line\">            /&gt;</div><div class=\"line\">    &lt;TextView</div><div class=\"line\">            android:layout_width=&quot;match_parent&quot;</div><div class=\"line\">            android:layout_height=&quot;match_parent&quot;</div><div class=\"line\">            android:background=&quot;@android:color/darker_gray&quot;/&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"三、获取Bitmap图片大小的代码\"><a href=\"#三、获取Bitmap图片大小的代码\" class=\"headerlink\" title=\"三、获取Bitmap图片大小的代码\"></a>三、获取Bitmap图片大小的代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getBitmapSize</span><span class=\"params\">(Bitmap bitmap)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123;     <span class=\"comment\">//API 19</span></div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap.getAllocationByteCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1)&#123;<span class=\"comment\">//API 12</span></div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap.getByteCount();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> bitmap.getRowBytes() * bitmap.getHeight();                <span class=\"comment\">//earlier version</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四、Activity横竖屏切换生命周期\"><a href=\"#四、Activity横竖屏切换生命周期\" class=\"headerlink\" title=\"四、Activity横竖屏切换生命周期\"></a>四、Activity横竖屏切换生命周期</h3><p>总结：</p>\n<ul>\n<li><p>1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>\n</li>\n<li><p>2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>\n</li>\n<li><p>3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>\n</li>\n</ul>\n<p>验证：</p>\n<p>1、新建一个Activity，并把各个生命周期打印出来</p>\n<p>2、运行Activity，得到如下信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onResume--&gt;</div></pre></td></tr></table></figure>\n<p>3、按crtl+f12切换成横屏时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div></pre></td></tr></table></figure>\n<p>4、再按crtl+f12切换成竖屏时，发现打印了两次相同的log</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div></pre></td></tr></table></figure>\n<p>5、修改AndroidManifest.xml，把该Activity添加 android:configChanges=”orientation”，执行步骤3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div></pre></td></tr></table></figure>\n<p>6、再执行步骤4，发现不会再打印相同信息，但多打印了一行onConfigChanged</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onSaveInstanceState--&gt;</div><div class=\"line\">onPause--&gt;</div><div class=\"line\">onStop--&gt;</div><div class=\"line\">onDestroy--&gt;</div><div class=\"line\">onCreate--&gt;</div><div class=\"line\">onStart--&gt;</div><div class=\"line\">onRestoreInstanceState--&gt;</div><div class=\"line\">onResume--&gt;</div><div class=\"line\">onConfigurationChanged--&gt;</div></pre></td></tr></table></figure>\n<p>7、把步骤5的android:configChanges=”orientation” 改成android:configChanges=”orientation|keyboardHidden”，执行步骤3，就只打印onConfigChanged</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onConfigurationChanged--&gt;</div></pre></td></tr></table></figure>\n<p>8、执行步骤4</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">onConfigurationChanged--&gt;</div><div class=\"line\">onConfigurationChanged--&gt;</div></pre></td></tr></table></figure>\n<p>总结一下整个Activity的生命周期</p>\n<ul>\n<li>1.补充一点，当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变</li>\n<li>2.Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState –&gt; onPause –&gt; onStop       onRestart –&gt;onStart—&gt;onResume</li>\n<li>3.Activity未被完全覆盖只是失去焦点：onPause—&gt;onResume</li>\n</ul>"},{"layout":"post","title":"google cloud message（GCM）和Azure实现Notification总结","keywords":"gcm, azure, notification","description":"google cloud message（GCM）和Azure实现Notification总结","banner":"http://obxk8w81b.bkt.clouddn.com/Country%20Lane%20with%20Two%20Figures.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Country%20Lane%20with%20Two%20Figures.jpg","_content":"\n\n### 1.相关资料\n我也是一知半解，基本上就是根据官方教程来实现，但microsoft的azure文档我找了好久，英文不好，汗。。。\n\ngcm start: https://developers.google.com/cloud-messaging/android/start\n\nazure start: https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/\n\ngcm official demo: https://github.com/google/gcm\n\ngcm personal demo: https://github.com/iammert/FastGCM\n\n<!--more-->\n\n### 2.遇到的问题\n- 1.手机运行官方demo时，发送消息，消息收不到必须切换一下网络才可以\n\nstackoverflow上有人问过这个问题：http://stackoverflow.com/questions/13835676/google-cloud-messaging-messages-sometimes-not-received-until-network-state-cha\n\n\n### 3.onActivityResult()和onResume()调用顺序\nAPI中这样描述：当你一个Activity是以请求码开始，结束时返回给前页面结果码，页面根据结果码进行相应的信息处理。我们会在返回的页面先接受结果码，然后才调用onResume()。\n\n通常我们还会遇到这样一个问题：\n在处理返回页面的数据问题\n1.需要从服务器上刷新数据时我们会在onResume()方法里处理\n2.而刷新从结束界面返回的数据我们会在onAcitviyResult()方法里面处理\n\n为了避免二者在同一块控件上对数据处理，我们只需加个标识符，在两个方法里进行判断，要用哪个方法进行刷新\n\n### 4.Android4.4以上系统根据Uri正确获取文件路径的方法\n\n~~~ Java\n\npublic static String getPhotoPathFromContentUri(Context context, Uri uri) {\n    String photoPath = \"\";\n    if(context == null || uri == null) {\n        return photoPath;\n    }\n\n    if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n        String docId = DocumentsContract.getDocumentId(uri);\n        if(isExternalStorageDocument(uri)) {\n            String [] split = docId.split(\":\");\n            if(split.length >= 2) {\n                String type = split[0];\n                if(\"primary\".equalsIgnoreCase(type)) {\n                    photoPath = Environment.getExternalStorageDirectory() + \"/\" + split[1];\n                }\n            }\n        }\n        else if(isDownloadsDocument(uri)) {\n            Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.valueOf(docId));\n            photoPath = getDataColumn(context, contentUri, null, null);\n        }\n        else if(isMediaDocument(uri)) {\n            String[] split = docId.split(\":\");\n            if(split.length >= 2) {\n                String type = split[0];\n                Uri contentUris = null;\n                if(\"image\".equals(type)) {\n                    contentUris = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;\n                }\n                else if(\"video\".equals(type)) {\n                    contentUris = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;\n                }\n                else if(\"audio\".equals(type)) {\n                    contentUris = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                }\n                String selection = MediaStore.Images.Media._ID + \"=?\";\n                String[] selectionArgs = new String[] { split[1] };\n                photoPath = getDataColumn(context, contentUris, selection, selectionArgs);\n            }\n        }\n    }\n    else if(\"file\".equalsIgnoreCase(uri.getScheme())) {\n        photoPath = uri.getPath();\n    }\n    else {\n        photoPath = getDataColumn(context, uri, null, null);\n    }\n\n    return photoPath;\n}\n\nprivate static boolean isExternalStorageDocument(Uri uri) {\n    return \"com.android.externalstorage.documents\".equals(uri.getAuthority());\n}\n\nprivate static boolean isDownloadsDocument(Uri uri) {\n    return \"com.android.providers.downloads.documents\".equals(uri.getAuthority());\n}\n\nprivate static boolean isMediaDocument(Uri uri) {\n    return \"com.android.providers.media.documents\".equals(uri.getAuthority());\n}\n\nprivate static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) {\n    Cursor cursor = null;\n    String column = MediaStore.Images.Media.DATA;\n    String[] projection = { column };\n    try {\n        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null);\n        if (cursor != null && cursor.moveToFirst()) {\n            int index = cursor.getColumnIndexOrThrow(column);\n            return cursor.getString(index);\n        }\n    } finally {\n        if (cursor != null && !cursor.isClosed())\n                cursor.close();\n    }\n    return null;\n}\n\n~~~\n","source":"_posts/2016-05-12-GCM-Azure_summary.md","raw":"---\nlayout: post\ntitle: google cloud message（GCM）和Azure实现Notification总结\ncategory: accumulation\ntags: accumulation\nkeywords: gcm, azure, notification\ndescription: google cloud message（GCM）和Azure实现Notification总结\nbanner: http://obxk8w81b.bkt.clouddn.com/Country%20Lane%20with%20Two%20Figures.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Country%20Lane%20with%20Two%20Figures.jpg\n\n---\n\n\n### 1.相关资料\n我也是一知半解，基本上就是根据官方教程来实现，但microsoft的azure文档我找了好久，英文不好，汗。。。\n\ngcm start: https://developers.google.com/cloud-messaging/android/start\n\nazure start: https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/\n\ngcm official demo: https://github.com/google/gcm\n\ngcm personal demo: https://github.com/iammert/FastGCM\n\n<!--more-->\n\n### 2.遇到的问题\n- 1.手机运行官方demo时，发送消息，消息收不到必须切换一下网络才可以\n\nstackoverflow上有人问过这个问题：http://stackoverflow.com/questions/13835676/google-cloud-messaging-messages-sometimes-not-received-until-network-state-cha\n\n\n### 3.onActivityResult()和onResume()调用顺序\nAPI中这样描述：当你一个Activity是以请求码开始，结束时返回给前页面结果码，页面根据结果码进行相应的信息处理。我们会在返回的页面先接受结果码，然后才调用onResume()。\n\n通常我们还会遇到这样一个问题：\n在处理返回页面的数据问题\n1.需要从服务器上刷新数据时我们会在onResume()方法里处理\n2.而刷新从结束界面返回的数据我们会在onAcitviyResult()方法里面处理\n\n为了避免二者在同一块控件上对数据处理，我们只需加个标识符，在两个方法里进行判断，要用哪个方法进行刷新\n\n### 4.Android4.4以上系统根据Uri正确获取文件路径的方法\n\n~~~ Java\n\npublic static String getPhotoPathFromContentUri(Context context, Uri uri) {\n    String photoPath = \"\";\n    if(context == null || uri == null) {\n        return photoPath;\n    }\n\n    if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n        String docId = DocumentsContract.getDocumentId(uri);\n        if(isExternalStorageDocument(uri)) {\n            String [] split = docId.split(\":\");\n            if(split.length >= 2) {\n                String type = split[0];\n                if(\"primary\".equalsIgnoreCase(type)) {\n                    photoPath = Environment.getExternalStorageDirectory() + \"/\" + split[1];\n                }\n            }\n        }\n        else if(isDownloadsDocument(uri)) {\n            Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.valueOf(docId));\n            photoPath = getDataColumn(context, contentUri, null, null);\n        }\n        else if(isMediaDocument(uri)) {\n            String[] split = docId.split(\":\");\n            if(split.length >= 2) {\n                String type = split[0];\n                Uri contentUris = null;\n                if(\"image\".equals(type)) {\n                    contentUris = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;\n                }\n                else if(\"video\".equals(type)) {\n                    contentUris = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;\n                }\n                else if(\"audio\".equals(type)) {\n                    contentUris = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                }\n                String selection = MediaStore.Images.Media._ID + \"=?\";\n                String[] selectionArgs = new String[] { split[1] };\n                photoPath = getDataColumn(context, contentUris, selection, selectionArgs);\n            }\n        }\n    }\n    else if(\"file\".equalsIgnoreCase(uri.getScheme())) {\n        photoPath = uri.getPath();\n    }\n    else {\n        photoPath = getDataColumn(context, uri, null, null);\n    }\n\n    return photoPath;\n}\n\nprivate static boolean isExternalStorageDocument(Uri uri) {\n    return \"com.android.externalstorage.documents\".equals(uri.getAuthority());\n}\n\nprivate static boolean isDownloadsDocument(Uri uri) {\n    return \"com.android.providers.downloads.documents\".equals(uri.getAuthority());\n}\n\nprivate static boolean isMediaDocument(Uri uri) {\n    return \"com.android.providers.media.documents\".equals(uri.getAuthority());\n}\n\nprivate static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) {\n    Cursor cursor = null;\n    String column = MediaStore.Images.Media.DATA;\n    String[] projection = { column };\n    try {\n        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null);\n        if (cursor != null && cursor.moveToFirst()) {\n            int index = cursor.getColumnIndexOrThrow(column);\n            return cursor.getString(index);\n        }\n    } finally {\n        if (cursor != null && !cursor.isClosed())\n                cursor.close();\n    }\n    return null;\n}\n\n~~~\n","slug":"GCM-Azure_summary","published":1,"date":"2016-05-11T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj4a000ebxs6gh4ldmv9","content":"<h3 id=\"1-相关资料\"><a href=\"#1-相关资料\" class=\"headerlink\" title=\"1.相关资料\"></a>1.相关资料</h3><p>我也是一知半解，基本上就是根据官方教程来实现，但microsoft的azure文档我找了好久，英文不好，汗。。。</p>\n<p>gcm start: <a href=\"https://developers.google.com/cloud-messaging/android/start\" target=\"_blank\" rel=\"external\">https://developers.google.com/cloud-messaging/android/start</a></p>\n<p>azure start: <a href=\"https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/\" target=\"_blank\" rel=\"external\">https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/</a></p>\n<p>gcm official demo: <a href=\"https://github.com/google/gcm\" target=\"_blank\" rel=\"external\">https://github.com/google/gcm</a></p>\n<p>gcm personal demo: <a href=\"https://github.com/iammert/FastGCM\" target=\"_blank\" rel=\"external\">https://github.com/iammert/FastGCM</a></p>\n<a id=\"more\"></a>\n<h3 id=\"2-遇到的问题\"><a href=\"#2-遇到的问题\" class=\"headerlink\" title=\"2.遇到的问题\"></a>2.遇到的问题</h3><ul>\n<li>1.手机运行官方demo时，发送消息，消息收不到必须切换一下网络才可以</li>\n</ul>\n<p>stackoverflow上有人问过这个问题：<a href=\"http://stackoverflow.com/questions/13835676/google-cloud-messaging-messages-sometimes-not-received-until-network-state-cha\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/13835676/google-cloud-messaging-messages-sometimes-not-received-until-network-state-cha</a></p>\n<h3 id=\"3-onActivityResult-和onResume-调用顺序\"><a href=\"#3-onActivityResult-和onResume-调用顺序\" class=\"headerlink\" title=\"3.onActivityResult()和onResume()调用顺序\"></a>3.onActivityResult()和onResume()调用顺序</h3><p>API中这样描述：当你一个Activity是以请求码开始，结束时返回给前页面结果码，页面根据结果码进行相应的信息处理。我们会在返回的页面先接受结果码，然后才调用onResume()。</p>\n<p>通常我们还会遇到这样一个问题：<br>在处理返回页面的数据问题<br>1.需要从服务器上刷新数据时我们会在onResume()方法里处理<br>2.而刷新从结束界面返回的数据我们会在onAcitviyResult()方法里面处理</p>\n<p>为了避免二者在同一块控件上对数据处理，我们只需加个标识符，在两个方法里进行判断，要用哪个方法进行刷新</p>\n<h3 id=\"4-Android4-4以上系统根据Uri正确获取文件路径的方法\"><a href=\"#4-Android4-4以上系统根据Uri正确获取文件路径的方法\" class=\"headerlink\" title=\"4.Android4.4以上系统根据Uri正确获取文件路径的方法\"></a>4.Android4.4以上系统根据Uri正确获取文件路径的方法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getPhotoPathFromContentUri</span><span class=\"params\">(Context context, Uri uri)</span> </span>&#123;</div><div class=\"line\">    String photoPath = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(context == <span class=\"keyword\">null</span> || uri == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> photoPath;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123;</div><div class=\"line\">        String docId = DocumentsContract.getDocumentId(uri);</div><div class=\"line\">        <span class=\"keyword\">if</span>(isExternalStorageDocument(uri)) &#123;</div><div class=\"line\">            String [] split = docId.split(<span class=\"string\">\":\"</span>);</div><div class=\"line\">            <span class=\"keyword\">if</span>(split.length &gt;= <span class=\"number\">2</span>) &#123;</div><div class=\"line\">                String type = split[<span class=\"number\">0</span>];</div><div class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"string\">\"primary\"</span>.equalsIgnoreCase(type)) &#123;</div><div class=\"line\">                    photoPath = Environment.getExternalStorageDirectory() + <span class=\"string\">\"/\"</span> + split[<span class=\"number\">1</span>];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(isDownloadsDocument(uri)) &#123;</div><div class=\"line\">            Uri contentUri = ContentUris.withAppendedId(Uri.parse(<span class=\"string\">\"content://downloads/public_downloads\"</span>), Long.valueOf(docId));</div><div class=\"line\">            photoPath = getDataColumn(context, contentUri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(isMediaDocument(uri)) &#123;</div><div class=\"line\">            String[] split = docId.split(<span class=\"string\">\":\"</span>);</div><div class=\"line\">            <span class=\"keyword\">if</span>(split.length &gt;= <span class=\"number\">2</span>) &#123;</div><div class=\"line\">                String type = split[<span class=\"number\">0</span>];</div><div class=\"line\">                Uri contentUris = <span class=\"keyword\">null</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"string\">\"image\"</span>.equals(type)) &#123;</div><div class=\"line\">                    contentUris = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"video\"</span>.equals(type)) &#123;</div><div class=\"line\">                    contentUris = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"audio\"</span>.equals(type)) &#123;</div><div class=\"line\">                    contentUris = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</div><div class=\"line\">                &#125;</div><div class=\"line\">                String selection = MediaStore.Images.Media._ID + <span class=\"string\">\"=?\"</span>;</div><div class=\"line\">                String[] selectionArgs = <span class=\"keyword\">new</span> String[] &#123; split[<span class=\"number\">1</span>] &#125;;</div><div class=\"line\">                photoPath = getDataColumn(context, contentUris, selection, selectionArgs);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"file\"</span>.equalsIgnoreCase(uri.getScheme())) &#123;</div><div class=\"line\">        photoPath = uri.getPath();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        photoPath = getDataColumn(context, uri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> photoPath;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isExternalStorageDocument</span><span class=\"params\">(Uri uri)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"com.android.externalstorage.documents\"</span>.equals(uri.getAuthority());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDownloadsDocument</span><span class=\"params\">(Uri uri)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"com.android.providers.downloads.documents\"</span>.equals(uri.getAuthority());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMediaDocument</span><span class=\"params\">(Uri uri)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"com.android.providers.media.documents\"</span>.equals(uri.getAuthority());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getDataColumn</span><span class=\"params\">(Context context, Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class=\"line\">    Cursor cursor = <span class=\"keyword\">null</span>;</div><div class=\"line\">    String column = MediaStore.Images.Media.DATA;</div><div class=\"line\">    String[] projection = &#123; column &#125;;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, <span class=\"keyword\">null</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (cursor != <span class=\"keyword\">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> index = cursor.getColumnIndexOrThrow(column);</div><div class=\"line\">            <span class=\"keyword\">return</span> cursor.getString(index);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (cursor != <span class=\"keyword\">null</span> &amp;&amp; !cursor.isClosed())</div><div class=\"line\">                cursor.close();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"1-相关资料\"><a href=\"#1-相关资料\" class=\"headerlink\" title=\"1.相关资料\"></a>1.相关资料</h3><p>我也是一知半解，基本上就是根据官方教程来实现，但microsoft的azure文档我找了好久，英文不好，汗。。。</p>\n<p>gcm start: <a href=\"https://developers.google.com/cloud-messaging/android/start\">https://developers.google.com/cloud-messaging/android/start</a></p>\n<p>azure start: <a href=\"https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/\">https://azure.microsoft.com/zh-cn/documentation/articles/notification-hubs-android-get-started/</a></p>\n<p>gcm official demo: <a href=\"https://github.com/google/gcm\">https://github.com/google/gcm</a></p>\n<p>gcm personal demo: <a href=\"https://github.com/iammert/FastGCM\">https://github.com/iammert/FastGCM</a></p>","more":"<h3 id=\"2-遇到的问题\"><a href=\"#2-遇到的问题\" class=\"headerlink\" title=\"2.遇到的问题\"></a>2.遇到的问题</h3><ul>\n<li>1.手机运行官方demo时，发送消息，消息收不到必须切换一下网络才可以</li>\n</ul>\n<p>stackoverflow上有人问过这个问题：<a href=\"http://stackoverflow.com/questions/13835676/google-cloud-messaging-messages-sometimes-not-received-until-network-state-cha\">http://stackoverflow.com/questions/13835676/google-cloud-messaging-messages-sometimes-not-received-until-network-state-cha</a></p>\n<h3 id=\"3-onActivityResult-和onResume-调用顺序\"><a href=\"#3-onActivityResult-和onResume-调用顺序\" class=\"headerlink\" title=\"3.onActivityResult()和onResume()调用顺序\"></a>3.onActivityResult()和onResume()调用顺序</h3><p>API中这样描述：当你一个Activity是以请求码开始，结束时返回给前页面结果码，页面根据结果码进行相应的信息处理。我们会在返回的页面先接受结果码，然后才调用onResume()。</p>\n<p>通常我们还会遇到这样一个问题：<br>在处理返回页面的数据问题<br>1.需要从服务器上刷新数据时我们会在onResume()方法里处理<br>2.而刷新从结束界面返回的数据我们会在onAcitviyResult()方法里面处理</p>\n<p>为了避免二者在同一块控件上对数据处理，我们只需加个标识符，在两个方法里进行判断，要用哪个方法进行刷新</p>\n<h3 id=\"4-Android4-4以上系统根据Uri正确获取文件路径的方法\"><a href=\"#4-Android4-4以上系统根据Uri正确获取文件路径的方法\" class=\"headerlink\" title=\"4.Android4.4以上系统根据Uri正确获取文件路径的方法\"></a>4.Android4.4以上系统根据Uri正确获取文件路径的方法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getPhotoPathFromContentUri</span><span class=\"params\">(Context context, Uri uri)</span> </span>&#123;</div><div class=\"line\">    String photoPath = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(context == <span class=\"keyword\">null</span> || uri == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> photoPath;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123;</div><div class=\"line\">        String docId = DocumentsContract.getDocumentId(uri);</div><div class=\"line\">        <span class=\"keyword\">if</span>(isExternalStorageDocument(uri)) &#123;</div><div class=\"line\">            String [] split = docId.split(<span class=\"string\">\":\"</span>);</div><div class=\"line\">            <span class=\"keyword\">if</span>(split.length &gt;= <span class=\"number\">2</span>) &#123;</div><div class=\"line\">                String type = split[<span class=\"number\">0</span>];</div><div class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"string\">\"primary\"</span>.equalsIgnoreCase(type)) &#123;</div><div class=\"line\">                    photoPath = Environment.getExternalStorageDirectory() + <span class=\"string\">\"/\"</span> + split[<span class=\"number\">1</span>];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(isDownloadsDocument(uri)) &#123;</div><div class=\"line\">            Uri contentUri = ContentUris.withAppendedId(Uri.parse(<span class=\"string\">\"content://downloads/public_downloads\"</span>), Long.valueOf(docId));</div><div class=\"line\">            photoPath = getDataColumn(context, contentUri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(isMediaDocument(uri)) &#123;</div><div class=\"line\">            String[] split = docId.split(<span class=\"string\">\":\"</span>);</div><div class=\"line\">            <span class=\"keyword\">if</span>(split.length &gt;= <span class=\"number\">2</span>) &#123;</div><div class=\"line\">                String type = split[<span class=\"number\">0</span>];</div><div class=\"line\">                Uri contentUris = <span class=\"keyword\">null</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"string\">\"image\"</span>.equals(type)) &#123;</div><div class=\"line\">                    contentUris = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"video\"</span>.equals(type)) &#123;</div><div class=\"line\">                    contentUris = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"audio\"</span>.equals(type)) &#123;</div><div class=\"line\">                    contentUris = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</div><div class=\"line\">                &#125;</div><div class=\"line\">                String selection = MediaStore.Images.Media._ID + <span class=\"string\">\"=?\"</span>;</div><div class=\"line\">                String[] selectionArgs = <span class=\"keyword\">new</span> String[] &#123; split[<span class=\"number\">1</span>] &#125;;</div><div class=\"line\">                photoPath = getDataColumn(context, contentUris, selection, selectionArgs);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"file\"</span>.equalsIgnoreCase(uri.getScheme())) &#123;</div><div class=\"line\">        photoPath = uri.getPath();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        photoPath = getDataColumn(context, uri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> photoPath;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isExternalStorageDocument</span><span class=\"params\">(Uri uri)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"com.android.externalstorage.documents\"</span>.equals(uri.getAuthority());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDownloadsDocument</span><span class=\"params\">(Uri uri)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"com.android.providers.downloads.documents\"</span>.equals(uri.getAuthority());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMediaDocument</span><span class=\"params\">(Uri uri)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"com.android.providers.media.documents\"</span>.equals(uri.getAuthority());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getDataColumn</span><span class=\"params\">(Context context, Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class=\"line\">    Cursor cursor = <span class=\"keyword\">null</span>;</div><div class=\"line\">    String column = MediaStore.Images.Media.DATA;</div><div class=\"line\">    String[] projection = &#123; column &#125;;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, <span class=\"keyword\">null</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (cursor != <span class=\"keyword\">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> index = cursor.getColumnIndexOrThrow(column);</div><div class=\"line\">            <span class=\"keyword\">return</span> cursor.getString(index);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (cursor != <span class=\"keyword\">null</span> &amp;&amp; !cursor.isClosed())</div><div class=\"line\">                cursor.close();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Java String与C/C++中byte[]","keywords":"Java String, bytes,coding","description":"Java String与C/C++中byte[]","banner":"http://obxk8w81b.bkt.clouddn.com/Bridge%20and%20Houses%20on%20the%20Corner%20of%20Herengracht-Prinsessegracht,%20The%20Hague.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Bridge%20and%20Houses%20on%20the%20Corner%20of%20Herengracht-Prinsessegracht,%20The%20Hague.jpg","_content":"\n\n   做JAVA经常会碰到中文乱码问题，还有各种编码的问题，特别是String类的内容需要重新编码的问题。要解决这些问题，必须了解清楚JAVA对于字符串是怎么处理的。\n\n### 1，“字符”是由数字来表示的\n   先来重新了解一下计算机是如何处理“字符”的，这个原理是大家必须记住的，特别是在用JAVA写程序的时候，万万不可模糊。我们知道，**计算机把任何东西都用数字来表示，“字符”也不例外**。比如我们要显示一个阿拉伯数字“3”，在我们的PC里，其实并不是仅仅用一个数字3来代表我们要写的“3”，而是以十六进制的0x33来代表，包括放在内存或者是写到文件里，其实都是写着0x33的，不信你可以编辑一个文本文件，写一个“3”，然后用ultraEdit看他的原始码。\n\n   <!--more-->\n\n### 2，一切“字符”都必定用数字+编码表表示。\n   这时候，有一个问题：为什么一定要用0x33来代表“3”呢？而不用0x43来代表呢？或者是直接用0x03来代替？其实用什么来代表都可以，只不过大家都习惯了用ASCII编码表（是美国国家信息交换表）来确定各字符应该是用什么数字代表的。同样，为了表示中国字，我国也指定了中文的编码表，其中最广泛使用的是GB2312。比如中文的“当”字，就是用0xB5, 0xB1这两个八位的数字来表示的。所以 **如果显示字符的程序不知道一列数字到底是按什么编码表编码的，他也无法去判断到底这些是什么文字**。如果随便用一个不对的编码表来处理这些数字，处理出来的字符很可能完全是错的。比如在英文系统上，没有GB2312编码表，送给他一个0xB5,0xB1，他就傻傻的当作ASCII来处理（操作系统通常都有自己默认的编码表），结果显示出来就是两个奇怪的符号，因为这两个字在ASCII表里就是那两个符号。同样在繁体中文系统里，他的编码表是BIG5，显示出来也是一个奇怪的中文，不是“当”字。\n\n### 3，UNICODE让全世界都说一种语言\n   看完上面的文字，是否觉得，世界有那么多语言，每个都有自己的一套编码表，很麻烦呢？就算是中文，也有两套流行的编码表，一个是GB2312，一个是BIG5。要使用不同中文的编码的字符时，还要转来转去，的确很麻烦。不光这个，如果想要写一篇包含很多过国文字的文章，就麻烦了，必须要让处理这个文章的程序知道，哪个字是什么编码标准的。如果你想要在文章里找一个字，也必须指定你要找的是哪种编码的哪个字。否则，你要找一个0xB5,0xB1的中文“当”字，很可能把同样数字表示的日文、波兰文这些不相干的字一起给你找出来，够麻烦的吧！\n   所以人们想，不如大家都用同一个编码标准吧，各种文字都在编码表里有一席之地，处理文字的程序只需要都按这个编码表来处理就可以了。不过要一个编码表里包含所有的文字，这张表就大了，本来英文字+数字一共只有128个以内。但加上中文后，忽然就多了数万个，所以存放一个字符需要的大小也大了很多。现在 **UNICODE规定了一个字符必须由2个8位数字来表示**，想想，8x8x8x8x = 65536，是多大的一个数字啊！所以全世界的文字才能都包含进去。当然拉，也有人说中国字可能都不止6万个拉，还要包括别的文字，但人家外国人觉得你们中国人常用的也没那么多，所以就这么定了，我们也没办法。需要注意的是GB2312和UNICODE虽然都是用两个8位数来代表一个中文字，但具体的规格可不一样，比如0xB5,0xB1在UNICODE里面可不是“当”字，而是另外一国的文字来的。\n\n### 4，C是如何简洁的处理字符的\n   我们来谈谈C的字符串。C语言诞生在JAVA之前，**C语言的基本数据类型是没有字符串这个类型的，它只有char[]**。也就是C把字符顺序放入一个字节数组就完了。而且C也不管放在数组里的是什么文字，也不管那些字是按什么编码标准的。而且他的char的大小也不一定是8位数字，有时候是16位也可能，**这要看具体的机器和操作系统**。所以写程序的人必须要知道正在处理的char[]的内容到底是按什么编码表表示的字符串，要知道如果比较两国文字是否相同，可是没任何意义的哦！\n\n### 5，JAVA是是如何处理字符的。\n   世界总会进步的，JAVA就是一个例子。JAVA终于有了String类了，它是解决字符问题的最好工具。在JAVA里，一个基本的要点是：**String类对象是不需要指定编码表的！** 为什么它会自己知道一堆数字各代表什么字符呢？就是因为 **String里的字符信息是用UNICODE编码存放的**。而JAVA为了表示字符（注意是单个字符），也有char这个数据类型，而且他的大小是固定2个8位16进制数字长度，也就是0~65535罗。为的就是对应UNICODE里面的一个字符。大家如果想取一个String里的按UNICODE数字，可以用getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 方法取得一个char[]，这个char[]里就是表示String字符的，按UNICODE编码表编码的数字。\n\n   可惜现在绝大多数的系统和程序都不是按UNICODE来处理字符，而JAVA程序总是要和别的程序和系统交换数据的，所以在接收一个字符，或者是发送一个字符的时候，就必须要留意当前系统和UNICODE的关系了。比如你从网络或者文件接受到一数字：0xB5,0xB1，JAVA程序并不知道这两个字到底是中文呢？还是日文，或者英文。你如果不指明这个两个数字的编码表，JAVA就会按当前系统默认的编码表来处理。如果这两个数字是从中文WIN98发出去的，JAVA程序又是在英文LINUX上运行的，那就出现了所谓的乱码问题了。也就是JAVA按英文的编码表ASCII来处理这两个数字，当通过new String({0xB5,0xB1})得到的String的时候，这个String代表的已经不是中文的“当”字，而是两个英文的奇怪字符了。不过如果你知道这两个数字一定是中文的话，就可以指定用new String({0xB5,0xB1},\"GB2312\")来处理，这时候新建立的String才真的是一个“当”字。当然拉，如果你要把一个“当”字的JAVA的String显示在中文WIN98上，必须把这个字输出成两个8位数字：0xB5,0xB1，不管是写成文件还是输出到浏览器上，都必须是0xB5,0xB1。如何把“当”字用GB2312输出？**String.getBytes(\"GB2312\")** 就可以拉！所以有一点要记住：**和外界交换任何信息都是以byte[]来进行的！**。你可以留意一下JAVA大多数的I/O类，都有以byte[]作为参数和返回值的方法。不过，也有很多写的比较糊涂的程序，没有提供byte[]交换信息的方法，害的不同文字平台的程序员很头疼。Servlet的HttpRequest.getParameter()就是这样。好在有的JSP/SERVLET容易还提供先指定编码表的方法，才能比较简单的解决这个问题。\n\n### 6，网上关于JAVA中文问题的一些错误处理方法。\n\n   一个是最常见的，不管什么内容，都用new String(...,\"ISO-8859-1\")来建立字符串，然后使用的时候按默认的编码格式（通常在服务器上都是英文系统）输出字符串。这样其实你使用的String并不是按UNICODE来代表真正的字符，而是强行把BYTE数组复制到String的char[]里，一旦你的运行环境改变，你就被迫要修改一大堆的代码。而且也无法在同一个字符串里处理几种不同编码的文字。\n\n   另一个是把一种编码格式的字符串，比如是GB2312，转换成另一种格式的字符串，比如UTF-8，然后不指明是UTF-8编码，而直接用new String(...)来建立String，这样放在String里面的字符也是无法确定的，它在不同的系统上代表不同的字符。如果要求别人用“UTF-8格式”的String来交换信息的时候，其实已经破坏了JAVA为了兼容各种语言所做的规定。这种错误的本质思想是还按写C语言的方式，把字符串纯粹当作可以自己自由编码的存储器使用，而忽略了JAVA字符串只有一种编码格式。如果真的想自由编码，用byte[]或者char[]就完全了解决问题的了。\n\n\n### 7，其他资料\n[字符，字节和编码](http://www.regexlab.com/zh/encoding.htm)\n","source":"_posts/2016-05-18-javaString-and-bytes.md","raw":"---\nlayout: post\ntitle: Java String与C/C++中byte[]\ncategory: accumulation\ntags: accumulation\nkeywords: Java String, bytes,coding\ndescription: Java String与C/C++中byte[]\nbanner: http://obxk8w81b.bkt.clouddn.com/Bridge%20and%20Houses%20on%20the%20Corner%20of%20Herengracht-Prinsessegracht,%20The%20Hague.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Bridge%20and%20Houses%20on%20the%20Corner%20of%20Herengracht-Prinsessegracht,%20The%20Hague.jpg\n---\n\n\n   做JAVA经常会碰到中文乱码问题，还有各种编码的问题，特别是String类的内容需要重新编码的问题。要解决这些问题，必须了解清楚JAVA对于字符串是怎么处理的。\n\n### 1，“字符”是由数字来表示的\n   先来重新了解一下计算机是如何处理“字符”的，这个原理是大家必须记住的，特别是在用JAVA写程序的时候，万万不可模糊。我们知道，**计算机把任何东西都用数字来表示，“字符”也不例外**。比如我们要显示一个阿拉伯数字“3”，在我们的PC里，其实并不是仅仅用一个数字3来代表我们要写的“3”，而是以十六进制的0x33来代表，包括放在内存或者是写到文件里，其实都是写着0x33的，不信你可以编辑一个文本文件，写一个“3”，然后用ultraEdit看他的原始码。\n\n   <!--more-->\n\n### 2，一切“字符”都必定用数字+编码表表示。\n   这时候，有一个问题：为什么一定要用0x33来代表“3”呢？而不用0x43来代表呢？或者是直接用0x03来代替？其实用什么来代表都可以，只不过大家都习惯了用ASCII编码表（是美国国家信息交换表）来确定各字符应该是用什么数字代表的。同样，为了表示中国字，我国也指定了中文的编码表，其中最广泛使用的是GB2312。比如中文的“当”字，就是用0xB5, 0xB1这两个八位的数字来表示的。所以 **如果显示字符的程序不知道一列数字到底是按什么编码表编码的，他也无法去判断到底这些是什么文字**。如果随便用一个不对的编码表来处理这些数字，处理出来的字符很可能完全是错的。比如在英文系统上，没有GB2312编码表，送给他一个0xB5,0xB1，他就傻傻的当作ASCII来处理（操作系统通常都有自己默认的编码表），结果显示出来就是两个奇怪的符号，因为这两个字在ASCII表里就是那两个符号。同样在繁体中文系统里，他的编码表是BIG5，显示出来也是一个奇怪的中文，不是“当”字。\n\n### 3，UNICODE让全世界都说一种语言\n   看完上面的文字，是否觉得，世界有那么多语言，每个都有自己的一套编码表，很麻烦呢？就算是中文，也有两套流行的编码表，一个是GB2312，一个是BIG5。要使用不同中文的编码的字符时，还要转来转去，的确很麻烦。不光这个，如果想要写一篇包含很多过国文字的文章，就麻烦了，必须要让处理这个文章的程序知道，哪个字是什么编码标准的。如果你想要在文章里找一个字，也必须指定你要找的是哪种编码的哪个字。否则，你要找一个0xB5,0xB1的中文“当”字，很可能把同样数字表示的日文、波兰文这些不相干的字一起给你找出来，够麻烦的吧！\n   所以人们想，不如大家都用同一个编码标准吧，各种文字都在编码表里有一席之地，处理文字的程序只需要都按这个编码表来处理就可以了。不过要一个编码表里包含所有的文字，这张表就大了，本来英文字+数字一共只有128个以内。但加上中文后，忽然就多了数万个，所以存放一个字符需要的大小也大了很多。现在 **UNICODE规定了一个字符必须由2个8位数字来表示**，想想，8x8x8x8x = 65536，是多大的一个数字啊！所以全世界的文字才能都包含进去。当然拉，也有人说中国字可能都不止6万个拉，还要包括别的文字，但人家外国人觉得你们中国人常用的也没那么多，所以就这么定了，我们也没办法。需要注意的是GB2312和UNICODE虽然都是用两个8位数来代表一个中文字，但具体的规格可不一样，比如0xB5,0xB1在UNICODE里面可不是“当”字，而是另外一国的文字来的。\n\n### 4，C是如何简洁的处理字符的\n   我们来谈谈C的字符串。C语言诞生在JAVA之前，**C语言的基本数据类型是没有字符串这个类型的，它只有char[]**。也就是C把字符顺序放入一个字节数组就完了。而且C也不管放在数组里的是什么文字，也不管那些字是按什么编码标准的。而且他的char的大小也不一定是8位数字，有时候是16位也可能，**这要看具体的机器和操作系统**。所以写程序的人必须要知道正在处理的char[]的内容到底是按什么编码表表示的字符串，要知道如果比较两国文字是否相同，可是没任何意义的哦！\n\n### 5，JAVA是是如何处理字符的。\n   世界总会进步的，JAVA就是一个例子。JAVA终于有了String类了，它是解决字符问题的最好工具。在JAVA里，一个基本的要点是：**String类对象是不需要指定编码表的！** 为什么它会自己知道一堆数字各代表什么字符呢？就是因为 **String里的字符信息是用UNICODE编码存放的**。而JAVA为了表示字符（注意是单个字符），也有char这个数据类型，而且他的大小是固定2个8位16进制数字长度，也就是0~65535罗。为的就是对应UNICODE里面的一个字符。大家如果想取一个String里的按UNICODE数字，可以用getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 方法取得一个char[]，这个char[]里就是表示String字符的，按UNICODE编码表编码的数字。\n\n   可惜现在绝大多数的系统和程序都不是按UNICODE来处理字符，而JAVA程序总是要和别的程序和系统交换数据的，所以在接收一个字符，或者是发送一个字符的时候，就必须要留意当前系统和UNICODE的关系了。比如你从网络或者文件接受到一数字：0xB5,0xB1，JAVA程序并不知道这两个字到底是中文呢？还是日文，或者英文。你如果不指明这个两个数字的编码表，JAVA就会按当前系统默认的编码表来处理。如果这两个数字是从中文WIN98发出去的，JAVA程序又是在英文LINUX上运行的，那就出现了所谓的乱码问题了。也就是JAVA按英文的编码表ASCII来处理这两个数字，当通过new String({0xB5,0xB1})得到的String的时候，这个String代表的已经不是中文的“当”字，而是两个英文的奇怪字符了。不过如果你知道这两个数字一定是中文的话，就可以指定用new String({0xB5,0xB1},\"GB2312\")来处理，这时候新建立的String才真的是一个“当”字。当然拉，如果你要把一个“当”字的JAVA的String显示在中文WIN98上，必须把这个字输出成两个8位数字：0xB5,0xB1，不管是写成文件还是输出到浏览器上，都必须是0xB5,0xB1。如何把“当”字用GB2312输出？**String.getBytes(\"GB2312\")** 就可以拉！所以有一点要记住：**和外界交换任何信息都是以byte[]来进行的！**。你可以留意一下JAVA大多数的I/O类，都有以byte[]作为参数和返回值的方法。不过，也有很多写的比较糊涂的程序，没有提供byte[]交换信息的方法，害的不同文字平台的程序员很头疼。Servlet的HttpRequest.getParameter()就是这样。好在有的JSP/SERVLET容易还提供先指定编码表的方法，才能比较简单的解决这个问题。\n\n### 6，网上关于JAVA中文问题的一些错误处理方法。\n\n   一个是最常见的，不管什么内容，都用new String(...,\"ISO-8859-1\")来建立字符串，然后使用的时候按默认的编码格式（通常在服务器上都是英文系统）输出字符串。这样其实你使用的String并不是按UNICODE来代表真正的字符，而是强行把BYTE数组复制到String的char[]里，一旦你的运行环境改变，你就被迫要修改一大堆的代码。而且也无法在同一个字符串里处理几种不同编码的文字。\n\n   另一个是把一种编码格式的字符串，比如是GB2312，转换成另一种格式的字符串，比如UTF-8，然后不指明是UTF-8编码，而直接用new String(...)来建立String，这样放在String里面的字符也是无法确定的，它在不同的系统上代表不同的字符。如果要求别人用“UTF-8格式”的String来交换信息的时候，其实已经破坏了JAVA为了兼容各种语言所做的规定。这种错误的本质思想是还按写C语言的方式，把字符串纯粹当作可以自己自由编码的存储器使用，而忽略了JAVA字符串只有一种编码格式。如果真的想自由编码，用byte[]或者char[]就完全了解决问题的了。\n\n\n### 7，其他资料\n[字符，字节和编码](http://www.regexlab.com/zh/encoding.htm)\n","slug":"javaString-and-bytes","published":1,"date":"2016-05-17T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj4d000gbxs667ak3zb7","content":"<p>   做JAVA经常会碰到中文乱码问题，还有各种编码的问题，特别是String类的内容需要重新编码的问题。要解决这些问题，必须了解清楚JAVA对于字符串是怎么处理的。</p>\n<h3 id=\"1，“字符”是由数字来表示的\"><a href=\"#1，“字符”是由数字来表示的\" class=\"headerlink\" title=\"1，“字符”是由数字来表示的\"></a>1，“字符”是由数字来表示的</h3><p>   先来重新了解一下计算机是如何处理“字符”的，这个原理是大家必须记住的，特别是在用JAVA写程序的时候，万万不可模糊。我们知道，<strong>计算机把任何东西都用数字来表示，“字符”也不例外</strong>。比如我们要显示一个阿拉伯数字“3”，在我们的PC里，其实并不是仅仅用一个数字3来代表我们要写的“3”，而是以十六进制的0x33来代表，包括放在内存或者是写到文件里，其实都是写着0x33的，不信你可以编辑一个文本文件，写一个“3”，然后用ultraEdit看他的原始码。</p>\n   <a id=\"more\"></a>\n<h3 id=\"2，一切“字符”都必定用数字-编码表表示。\"><a href=\"#2，一切“字符”都必定用数字-编码表表示。\" class=\"headerlink\" title=\"2，一切“字符”都必定用数字+编码表表示。\"></a>2，一切“字符”都必定用数字+编码表表示。</h3><p>   这时候，有一个问题：为什么一定要用0x33来代表“3”呢？而不用0x43来代表呢？或者是直接用0x03来代替？其实用什么来代表都可以，只不过大家都习惯了用ASCII编码表（是美国国家信息交换表）来确定各字符应该是用什么数字代表的。同样，为了表示中国字，我国也指定了中文的编码表，其中最广泛使用的是GB2312。比如中文的“当”字，就是用0xB5, 0xB1这两个八位的数字来表示的。所以 <strong>如果显示字符的程序不知道一列数字到底是按什么编码表编码的，他也无法去判断到底这些是什么文字</strong>。如果随便用一个不对的编码表来处理这些数字，处理出来的字符很可能完全是错的。比如在英文系统上，没有GB2312编码表，送给他一个0xB5,0xB1，他就傻傻的当作ASCII来处理（操作系统通常都有自己默认的编码表），结果显示出来就是两个奇怪的符号，因为这两个字在ASCII表里就是那两个符号。同样在繁体中文系统里，他的编码表是BIG5，显示出来也是一个奇怪的中文，不是“当”字。</p>\n<h3 id=\"3，UNICODE让全世界都说一种语言\"><a href=\"#3，UNICODE让全世界都说一种语言\" class=\"headerlink\" title=\"3，UNICODE让全世界都说一种语言\"></a>3，UNICODE让全世界都说一种语言</h3><p>   看完上面的文字，是否觉得，世界有那么多语言，每个都有自己的一套编码表，很麻烦呢？就算是中文，也有两套流行的编码表，一个是GB2312，一个是BIG5。要使用不同中文的编码的字符时，还要转来转去，的确很麻烦。不光这个，如果想要写一篇包含很多过国文字的文章，就麻烦了，必须要让处理这个文章的程序知道，哪个字是什么编码标准的。如果你想要在文章里找一个字，也必须指定你要找的是哪种编码的哪个字。否则，你要找一个0xB5,0xB1的中文“当”字，很可能把同样数字表示的日文、波兰文这些不相干的字一起给你找出来，够麻烦的吧！<br>   所以人们想，不如大家都用同一个编码标准吧，各种文字都在编码表里有一席之地，处理文字的程序只需要都按这个编码表来处理就可以了。不过要一个编码表里包含所有的文字，这张表就大了，本来英文字+数字一共只有128个以内。但加上中文后，忽然就多了数万个，所以存放一个字符需要的大小也大了很多。现在 <strong>UNICODE规定了一个字符必须由2个8位数字来表示</strong>，想想，8x8x8x8x = 65536，是多大的一个数字啊！所以全世界的文字才能都包含进去。当然拉，也有人说中国字可能都不止6万个拉，还要包括别的文字，但人家外国人觉得你们中国人常用的也没那么多，所以就这么定了，我们也没办法。需要注意的是GB2312和UNICODE虽然都是用两个8位数来代表一个中文字，但具体的规格可不一样，比如0xB5,0xB1在UNICODE里面可不是“当”字，而是另外一国的文字来的。</p>\n<h3 id=\"4，C是如何简洁的处理字符的\"><a href=\"#4，C是如何简洁的处理字符的\" class=\"headerlink\" title=\"4，C是如何简洁的处理字符的\"></a>4，C是如何简洁的处理字符的</h3><p>   我们来谈谈C的字符串。C语言诞生在JAVA之前，<strong>C语言的基本数据类型是没有字符串这个类型的，它只有char[]</strong>。也就是C把字符顺序放入一个字节数组就完了。而且C也不管放在数组里的是什么文字，也不管那些字是按什么编码标准的。而且他的char的大小也不一定是8位数字，有时候是16位也可能，<strong>这要看具体的机器和操作系统</strong>。所以写程序的人必须要知道正在处理的char[]的内容到底是按什么编码表表示的字符串，要知道如果比较两国文字是否相同，可是没任何意义的哦！</p>\n<h3 id=\"5，JAVA是是如何处理字符的。\"><a href=\"#5，JAVA是是如何处理字符的。\" class=\"headerlink\" title=\"5，JAVA是是如何处理字符的。\"></a>5，JAVA是是如何处理字符的。</h3><p>   世界总会进步的，JAVA就是一个例子。JAVA终于有了String类了，它是解决字符问题的最好工具。在JAVA里，一个基本的要点是：<strong>String类对象是不需要指定编码表的！</strong> 为什么它会自己知道一堆数字各代表什么字符呢？就是因为 <strong>String里的字符信息是用UNICODE编码存放的</strong>。而JAVA为了表示字符（注意是单个字符），也有char这个数据类型，而且他的大小是固定2个8位16进制数字长度，也就是0~65535罗。为的就是对应UNICODE里面的一个字符。大家如果想取一个String里的按UNICODE数字，可以用getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 方法取得一个char[]，这个char[]里就是表示String字符的，按UNICODE编码表编码的数字。</p>\n<p>   可惜现在绝大多数的系统和程序都不是按UNICODE来处理字符，而JAVA程序总是要和别的程序和系统交换数据的，所以在接收一个字符，或者是发送一个字符的时候，就必须要留意当前系统和UNICODE的关系了。比如你从网络或者文件接受到一数字：0xB5,0xB1，JAVA程序并不知道这两个字到底是中文呢？还是日文，或者英文。你如果不指明这个两个数字的编码表，JAVA就会按当前系统默认的编码表来处理。如果这两个数字是从中文WIN98发出去的，JAVA程序又是在英文LINUX上运行的，那就出现了所谓的乱码问题了。也就是JAVA按英文的编码表ASCII来处理这两个数字，当通过new String({0xB5,0xB1})得到的String的时候，这个String代表的已经不是中文的“当”字，而是两个英文的奇怪字符了。不过如果你知道这两个数字一定是中文的话，就可以指定用new String({0xB5,0xB1},”GB2312”)来处理，这时候新建立的String才真的是一个“当”字。当然拉，如果你要把一个“当”字的JAVA的String显示在中文WIN98上，必须把这个字输出成两个8位数字：0xB5,0xB1，不管是写成文件还是输出到浏览器上，都必须是0xB5,0xB1。如何把“当”字用GB2312输出？<strong>String.getBytes(“GB2312”)</strong> 就可以拉！所以有一点要记住：<strong>和外界交换任何信息都是以byte[]来进行的！</strong>。你可以留意一下JAVA大多数的I/O类，都有以byte[]作为参数和返回值的方法。不过，也有很多写的比较糊涂的程序，没有提供byte[]交换信息的方法，害的不同文字平台的程序员很头疼。Servlet的HttpRequest.getParameter()就是这样。好在有的JSP/SERVLET容易还提供先指定编码表的方法，才能比较简单的解决这个问题。</p>\n<h3 id=\"6，网上关于JAVA中文问题的一些错误处理方法。\"><a href=\"#6，网上关于JAVA中文问题的一些错误处理方法。\" class=\"headerlink\" title=\"6，网上关于JAVA中文问题的一些错误处理方法。\"></a>6，网上关于JAVA中文问题的一些错误处理方法。</h3><p>   一个是最常见的，不管什么内容，都用new String(…,”ISO-8859-1”)来建立字符串，然后使用的时候按默认的编码格式（通常在服务器上都是英文系统）输出字符串。这样其实你使用的String并不是按UNICODE来代表真正的字符，而是强行把BYTE数组复制到String的char[]里，一旦你的运行环境改变，你就被迫要修改一大堆的代码。而且也无法在同一个字符串里处理几种不同编码的文字。</p>\n<p>   另一个是把一种编码格式的字符串，比如是GB2312，转换成另一种格式的字符串，比如UTF-8，然后不指明是UTF-8编码，而直接用new String(…)来建立String，这样放在String里面的字符也是无法确定的，它在不同的系统上代表不同的字符。如果要求别人用“UTF-8格式”的String来交换信息的时候，其实已经破坏了JAVA为了兼容各种语言所做的规定。这种错误的本质思想是还按写C语言的方式，把字符串纯粹当作可以自己自由编码的存储器使用，而忽略了JAVA字符串只有一种编码格式。如果真的想自由编码，用byte[]或者char[]就完全了解决问题的了。</p>\n<h3 id=\"7，其他资料\"><a href=\"#7，其他资料\" class=\"headerlink\" title=\"7，其他资料\"></a>7，其他资料</h3><p><a href=\"http://www.regexlab.com/zh/encoding.htm\" target=\"_blank\" rel=\"external\">字符，字节和编码</a></p>\n","excerpt":"<p>   做JAVA经常会碰到中文乱码问题，还有各种编码的问题，特别是String类的内容需要重新编码的问题。要解决这些问题，必须了解清楚JAVA对于字符串是怎么处理的。</p>\n<h3 id=\"1，“字符”是由数字来表示的\"><a href=\"#1，“字符”是由数字来表示的\" class=\"headerlink\" title=\"1，“字符”是由数字来表示的\"></a>1，“字符”是由数字来表示的</h3><p>   先来重新了解一下计算机是如何处理“字符”的，这个原理是大家必须记住的，特别是在用JAVA写程序的时候，万万不可模糊。我们知道，<strong>计算机把任何东西都用数字来表示，“字符”也不例外</strong>。比如我们要显示一个阿拉伯数字“3”，在我们的PC里，其实并不是仅仅用一个数字3来代表我们要写的“3”，而是以十六进制的0x33来代表，包括放在内存或者是写到文件里，其实都是写着0x33的，不信你可以编辑一个文本文件，写一个“3”，然后用ultraEdit看他的原始码。</p>","more":"<h3 id=\"2，一切“字符”都必定用数字-编码表表示。\"><a href=\"#2，一切“字符”都必定用数字-编码表表示。\" class=\"headerlink\" title=\"2，一切“字符”都必定用数字+编码表表示。\"></a>2，一切“字符”都必定用数字+编码表表示。</h3><p>   这时候，有一个问题：为什么一定要用0x33来代表“3”呢？而不用0x43来代表呢？或者是直接用0x03来代替？其实用什么来代表都可以，只不过大家都习惯了用ASCII编码表（是美国国家信息交换表）来确定各字符应该是用什么数字代表的。同样，为了表示中国字，我国也指定了中文的编码表，其中最广泛使用的是GB2312。比如中文的“当”字，就是用0xB5, 0xB1这两个八位的数字来表示的。所以 <strong>如果显示字符的程序不知道一列数字到底是按什么编码表编码的，他也无法去判断到底这些是什么文字</strong>。如果随便用一个不对的编码表来处理这些数字，处理出来的字符很可能完全是错的。比如在英文系统上，没有GB2312编码表，送给他一个0xB5,0xB1，他就傻傻的当作ASCII来处理（操作系统通常都有自己默认的编码表），结果显示出来就是两个奇怪的符号，因为这两个字在ASCII表里就是那两个符号。同样在繁体中文系统里，他的编码表是BIG5，显示出来也是一个奇怪的中文，不是“当”字。</p>\n<h3 id=\"3，UNICODE让全世界都说一种语言\"><a href=\"#3，UNICODE让全世界都说一种语言\" class=\"headerlink\" title=\"3，UNICODE让全世界都说一种语言\"></a>3，UNICODE让全世界都说一种语言</h3><p>   看完上面的文字，是否觉得，世界有那么多语言，每个都有自己的一套编码表，很麻烦呢？就算是中文，也有两套流行的编码表，一个是GB2312，一个是BIG5。要使用不同中文的编码的字符时，还要转来转去，的确很麻烦。不光这个，如果想要写一篇包含很多过国文字的文章，就麻烦了，必须要让处理这个文章的程序知道，哪个字是什么编码标准的。如果你想要在文章里找一个字，也必须指定你要找的是哪种编码的哪个字。否则，你要找一个0xB5,0xB1的中文“当”字，很可能把同样数字表示的日文、波兰文这些不相干的字一起给你找出来，够麻烦的吧！<br>   所以人们想，不如大家都用同一个编码标准吧，各种文字都在编码表里有一席之地，处理文字的程序只需要都按这个编码表来处理就可以了。不过要一个编码表里包含所有的文字，这张表就大了，本来英文字+数字一共只有128个以内。但加上中文后，忽然就多了数万个，所以存放一个字符需要的大小也大了很多。现在 <strong>UNICODE规定了一个字符必须由2个8位数字来表示</strong>，想想，8x8x8x8x = 65536，是多大的一个数字啊！所以全世界的文字才能都包含进去。当然拉，也有人说中国字可能都不止6万个拉，还要包括别的文字，但人家外国人觉得你们中国人常用的也没那么多，所以就这么定了，我们也没办法。需要注意的是GB2312和UNICODE虽然都是用两个8位数来代表一个中文字，但具体的规格可不一样，比如0xB5,0xB1在UNICODE里面可不是“当”字，而是另外一国的文字来的。</p>\n<h3 id=\"4，C是如何简洁的处理字符的\"><a href=\"#4，C是如何简洁的处理字符的\" class=\"headerlink\" title=\"4，C是如何简洁的处理字符的\"></a>4，C是如何简洁的处理字符的</h3><p>   我们来谈谈C的字符串。C语言诞生在JAVA之前，<strong>C语言的基本数据类型是没有字符串这个类型的，它只有char[]</strong>。也就是C把字符顺序放入一个字节数组就完了。而且C也不管放在数组里的是什么文字，也不管那些字是按什么编码标准的。而且他的char的大小也不一定是8位数字，有时候是16位也可能，<strong>这要看具体的机器和操作系统</strong>。所以写程序的人必须要知道正在处理的char[]的内容到底是按什么编码表表示的字符串，要知道如果比较两国文字是否相同，可是没任何意义的哦！</p>\n<h3 id=\"5，JAVA是是如何处理字符的。\"><a href=\"#5，JAVA是是如何处理字符的。\" class=\"headerlink\" title=\"5，JAVA是是如何处理字符的。\"></a>5，JAVA是是如何处理字符的。</h3><p>   世界总会进步的，JAVA就是一个例子。JAVA终于有了String类了，它是解决字符问题的最好工具。在JAVA里，一个基本的要点是：<strong>String类对象是不需要指定编码表的！</strong> 为什么它会自己知道一堆数字各代表什么字符呢？就是因为 <strong>String里的字符信息是用UNICODE编码存放的</strong>。而JAVA为了表示字符（注意是单个字符），也有char这个数据类型，而且他的大小是固定2个8位16进制数字长度，也就是0~65535罗。为的就是对应UNICODE里面的一个字符。大家如果想取一个String里的按UNICODE数字，可以用getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 方法取得一个char[]，这个char[]里就是表示String字符的，按UNICODE编码表编码的数字。</p>\n<p>   可惜现在绝大多数的系统和程序都不是按UNICODE来处理字符，而JAVA程序总是要和别的程序和系统交换数据的，所以在接收一个字符，或者是发送一个字符的时候，就必须要留意当前系统和UNICODE的关系了。比如你从网络或者文件接受到一数字：0xB5,0xB1，JAVA程序并不知道这两个字到底是中文呢？还是日文，或者英文。你如果不指明这个两个数字的编码表，JAVA就会按当前系统默认的编码表来处理。如果这两个数字是从中文WIN98发出去的，JAVA程序又是在英文LINUX上运行的，那就出现了所谓的乱码问题了。也就是JAVA按英文的编码表ASCII来处理这两个数字，当通过new String({0xB5,0xB1})得到的String的时候，这个String代表的已经不是中文的“当”字，而是两个英文的奇怪字符了。不过如果你知道这两个数字一定是中文的话，就可以指定用new String({0xB5,0xB1},”GB2312”)来处理，这时候新建立的String才真的是一个“当”字。当然拉，如果你要把一个“当”字的JAVA的String显示在中文WIN98上，必须把这个字输出成两个8位数字：0xB5,0xB1，不管是写成文件还是输出到浏览器上，都必须是0xB5,0xB1。如何把“当”字用GB2312输出？<strong>String.getBytes(“GB2312”)</strong> 就可以拉！所以有一点要记住：<strong>和外界交换任何信息都是以byte[]来进行的！</strong>。你可以留意一下JAVA大多数的I/O类，都有以byte[]作为参数和返回值的方法。不过，也有很多写的比较糊涂的程序，没有提供byte[]交换信息的方法，害的不同文字平台的程序员很头疼。Servlet的HttpRequest.getParameter()就是这样。好在有的JSP/SERVLET容易还提供先指定编码表的方法，才能比较简单的解决这个问题。</p>\n<h3 id=\"6，网上关于JAVA中文问题的一些错误处理方法。\"><a href=\"#6，网上关于JAVA中文问题的一些错误处理方法。\" class=\"headerlink\" title=\"6，网上关于JAVA中文问题的一些错误处理方法。\"></a>6，网上关于JAVA中文问题的一些错误处理方法。</h3><p>   一个是最常见的，不管什么内容，都用new String(…,”ISO-8859-1”)来建立字符串，然后使用的时候按默认的编码格式（通常在服务器上都是英文系统）输出字符串。这样其实你使用的String并不是按UNICODE来代表真正的字符，而是强行把BYTE数组复制到String的char[]里，一旦你的运行环境改变，你就被迫要修改一大堆的代码。而且也无法在同一个字符串里处理几种不同编码的文字。</p>\n<p>   另一个是把一种编码格式的字符串，比如是GB2312，转换成另一种格式的字符串，比如UTF-8，然后不指明是UTF-8编码，而直接用new String(…)来建立String，这样放在String里面的字符也是无法确定的，它在不同的系统上代表不同的字符。如果要求别人用“UTF-8格式”的String来交换信息的时候，其实已经破坏了JAVA为了兼容各种语言所做的规定。这种错误的本质思想是还按写C语言的方式，把字符串纯粹当作可以自己自由编码的存储器使用，而忽略了JAVA字符串只有一种编码格式。如果真的想自由编码，用byte[]或者char[]就完全了解决问题的了。</p>\n<h3 id=\"7，其他资料\"><a href=\"#7，其他资料\" class=\"headerlink\" title=\"7，其他资料\"></a>7，其他资料</h3><p><a href=\"http://www.regexlab.com/zh/encoding.htm\">字符，字节和编码</a></p>"},{"layout":"post","title":"《android开发艺术探索》读书笔记","keywords":"《android开发艺术探索》,读书笔记","banner":"http://obxk8w81b.bkt.clouddn.com/Auvers%20Town%20Hall%20on%2014%20July%201890.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Auvers%20Town%20Hall%20on%2014%20July%201890.jpg","_content":"\n\n### 第1章 Activity的生命周期和启动模式\n\n本节和《Android群英传》中的第8章Activity和Activity调用栈分析有关系，建议先阅读该章的总结\n\n第1章 Activity的生命周期和启动模式\n\n#### 1.1 Activity生命周期全面分析\n\n##### 1.1.1 典型情况下生命周期分析\n\n- (1)一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart方法就会被调用。\n\n- (2)当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -> onStop，但是如果新Activity采用了透明主题，那么onStop方法不会被回调。当用户再次回到原来的Activity时，回调如下：onRestart -> onStart -> onResume。\n\n<!--more-->\n\n- (3)onStart和onStop对应，它们是从Activity是否可见这个角度来回调的；onPause和onResume方法对应，它们是从Activity是否位于前台这个角度来回调的。\n\n- (4)从Activity A进入到Activity B，回调顺序是onPause(A) -> onCreate(B) -> onStart(B) -> onResume(B) -> onStop(A)，所以不能在onPause方法中做重量级的操作。\n\n1.1.2 异常情况下生命周期分析\n\n- (1)onSaveInstanceState方法只会出现在Activity被异常终止的情况下，它的调用时机是在onStop之前，它和onPause方法没有既定的时序关系，可能在它之前，也可能在它之后。\n\n    当Activity被重新创建的时候，onRestoreInstanceState会被回调，它的调用时机是onStart之后。\n\n    系统只会在Activity即将被销毁并且有机会重新显示的情况下才会去调用onSaveInstanceState方法。\n\n    当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据，比如文本框中用户输入的数据、listview滚动的位置等，这些view相关的状态系统都会默认为我们恢复。具体针对某一个view系统能为我们恢复哪些数据可以查看view的源码中的onSaveInstanceState和onRestoreInstanceState方法。\n\n- (2)Activity按优先级的分类\n\n    前台Activity；可见但非前台Activity；后台Activity\n\n- (3)android:configChanges=\"xxx\"属性，常用的主要有下面三个选项：\n\n    local：设备的本地位置发生了变化，一般指切换了系统语言；\n\n    keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘；\n\n    orientation：屏幕方向发生了变化，比如旋转了手机屏幕。\n\n    配置了android:configChanges=\"xxx\"属性之后，Activity就不会在对应变化发生时重新创建，而是调用Activity的onConfigurationChanged方法。\n\n#### 1.2 Activity的启动模式\n\n##### 1.2.1 启动模式\n\n- (1)当任务栈中没有任何Activity的时候，系统就会回收这个任务栈。\n\n- (2)从非Activity类型的Context(例如ApplicationContext、Service等)中以standard模式启动新的Activity是不行的，因为这类context并没有任务栈，所以需要为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标志位。\n\n- (3)任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。\n\n- (4)参数TaskAffinity用来指定Activity所需要的任务栈，意为任务相关性。\n\n    默认情况下，所有Activity所需的任务栈的名字为应用的包名。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。\n\n    当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中；\n\n    当TaskAffinity和allowTaskReparenting结合的时候，当一个应用A启动了应用B的某个Activity C后，如果Activity C的allowTaskReparenting属性设置为true的话，那么当应用B被启动后，系统会发现Activity C所需的任务栈存在了，就将Activity C从A的任务栈中转移到B的任务栈中。\n\n- (5)singleTask模式的具体分析：\n\n    当一个具有singleTask启动模式的Activity请求启动之后，系统首先会寻找是否存在A想要的任务栈，\n\n    如果不存在，就重新创建一个任务栈，然后创建Activity的实例把它放到栈中；如果存在Activity所需的任务栈，这时候要看栈中是否有Activity实例存在.\n\n    如果有，那么系统就会把该Activity实例调到栈顶，并调用它的onNewIntent方法(它之上的Activity会被迫出栈，所以singleTask模式具有FLAG_ACTIVITY_CLEAR_TOP效果)；如果Activity实例不存在，那么就创建Activity实例并把它压入栈中。\n\n- (6)设置启动模式既可以使用xml属性android:launchMode，也可以使用代码intent.addFlags()。区别在于限定范围不同，前者无法直接为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，而后者无法为Activity指定singleInstance模式。\n\n##### 1.2.2 Activity的Flags\n\nFLAG_ACTIVITY_NEW_TASK,FLAG_ACTIVITY_SINGLE_TOP,FLAG_ACTIVITY_CLEAR_TOP\n\nFLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用，它等同于属性设置android:excludeFromRecents=\"true\"。\n\n#### 1.3 IntentFilter的匹配规则\n\n- (1)IntentFilter中的过滤信息有action、category、data，为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。\n\n    一个过滤列表中的action、category、data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别和data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。此外，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intenf-filter即可成功启动对应的Activity。\n~~~ Javascript\n<intent-filter>\n    <action android:name=\"com.ryg.charpter_1.c\" />\n    <action android:name=\"com.ryg.charpter_1.d\" />\n\n    <category android:name=\"com.ryg.category.c\" />\n    <category android:name=\"com.ryg.category.d\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n\n    <data android:mimeType=\"text/plain\" />\n</intent-filter>\n~~~  \n\n- (2)action匹配规则\n\n    只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，action匹配区分大小写。\n\n- (3)category匹配规则\n\n    Intent中如果有category那么所有的category都必须和过滤规则中的其中一个category相同，如果没有category的话那么就是默认的category，即android.intent.category.DEFAULT，所以为了Activity能够接收隐式调用，配置多个category的时候必须加上默认的category。\n\n- (4)data匹配规则\n\n    data的结构很复杂，语法大致如下：\n~~~ Javascript\n<data android:scheme=\"string\"\n\tandroid:host=\"string\"\n\tandroid:port=\"string\"\n\tandroid:path=\"string\"`\n\tandroid:pathPattern=\"string\"\n\tandroid:pathPrefix=\"string\"\n\tandroid:mimeType=\"string\" />\n~~~\n    主要由mimeType和URI组成，其中mimeType代表媒体类型，而URI的结构也复杂，大致如下：\n~~~ Javascript\n<scheme>://<host>:<port>/[<path>]|[<pathPrefix>]|[pathPattern]\n~~~\n    例如content://com.example.project:200/folder/subfolder/etc\n\n  - scheme、host、port分别表示URI的模式、主机名和端口号，其中如果scheme或者host未指定那么URI就无效。\n\n  - path、pathPattern、pathPrefix都是表示路径信息，其中path表示完整的路径信息，pathPrefix表示路径的前缀信息；pathPattern表示完整的路径，但是它里面包含了通配符(\\*)。\n\n  data匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。\n\n  URI有默认的scheme！\n\n  如果过滤规则中的mimeType指定为image/\\*或者text/\\*等这种类型的话，那么即使过滤规则中没有指定URI，URI有默认的scheme是content和file！如果过滤规则中指定了scheme的话那就不是默认的scheme了。\n\n~~~ Java\n//URI有默认值\n<intent-filter>\n    <data android:mimeType=\"image/*\"/>\n  ...\n</intent-filter>\n~~~\n\n~~~ Java\n//URI默认值被覆盖\n<intent-filter>\n    <data android:mimeType=\"image/*\" android:scheme=\"http\" .../>\n    ...\n</intent-filter>\n~~~\n\n  如果要为Intent指定完整的data，必须要调用setDataAndType方法！\n\n  不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。\n~~~ Java\nintent.setDataAndType(Uri.parse(\"file://abc\"), \"image/png\");\n~~~\n  data的下面两种写法作用是一样的：\n\n~~~ Java\n<intent-filter>\n    <data android:scheme=\"file\" android:host=\"www.github.com\"/>\n</intent-filter>\n\n<intent-filter>\n    <data android:scheme=\"file\"/>\n    <data android:host=\"www.github.com\"/>\n</intent-filter>\n~~~\n  如何判断是否有Activity能够匹配我们的隐式Intent？\n\n  - (1)PackageManager的resolveActivity方法或者Intent的resolveActivity方法：如果找不到就会返回null\n\n  - (2)PackageManager的queryIntentActivities方法：它返回所有成功匹配的Activity信息\n针对Service和BroadcastReceiver等组件，PackageManager同样提供了类似的方法去获取成功匹配的组件信息，例如queryIntentServices、queryBroadcastReceivers等方法\n\n  - 有一类action和category比较重要，它们在一起用来标明这是一个入口Activity，并且会出现在系统的应用列表中。\n~~~ Java\n<intent-filter>\n    <action android:name=\"android.intent.action.MAIN\" />\n    <category android:name=\"android.intent.category.LAUNCHER\" />\n</intent-filter>\n~~~\n\n### 第2章 IPC机制\n\n#### 2.1 Android IPC简介\n\n(1)任何一个操作系统都需要有相应的IPC机制，Linux上可以通过命名通道、共享内存、信号量等来进行进程间通信。Android系统不仅可以使用了Binder机制来实现IPC，还可以使用Socket实现任意两个终端之间的通信。\n\n#### 2.2 Android中的多进程模式\n\n- (1)通过给四大组件指定android:process属性就可以开启多进程模式.\n\n    默认进程的进程名是包名packageName，进程名以:开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以:开头的进程属于全局进程，其他应用通过ShareUID方法可以和它跑在同一个进程中。\n\n    android:process=\":xyz\" //进程名是 packageName:xyz\n\n    android:process=\"aaa.bbb.ccc\" //进程名是 aaa.bbb.ccc\n\n- (2)Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。\n\n    两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。 在这种情况下，它们可以相互访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。如果它们跑在同一个进程中，还可以共享内存数据，它们看起来就像是一个应用的两个部分。\n- (3)android系统会为每个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，所以不同的虚拟机中访问同一个类的对象会产生多个副本。\n\n- (4)使用多进程容易造成以下几个问题：\n\n  - 1.静态成员和单例模式完全失效；\n  - 2.线程同步机制完全失效：无论锁对象还是锁全局对象都无法保证线程同步；\n  - 3.SharedPreferences的可靠性下降：SharedPreferences不支持并发读写；\n  - 4.Application会多次创建：当一个组件跑在一个新的进程的时候，系统要在创建新的进程的同时分配独立的虚拟机，应用会重新启动一次，也就会创建新的Application。运行在同一个进程中的组件是属于同一个虚拟机和同一个Application。\n\n    同一个应用的不同组件，如果它们运行在不同进程中，那么和它们分别属于两个应用没有本质区别。\n\n#### 2.3 IPC基础概念介绍\n\n- (1)Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口。\n\n- (2)serialVersionUId是一串long型数字，主要是用来辅助序列化和反序列化的，原则上序列化后的数据中的serialVersionUId只有和当前类的serialVersionUId相同才能够正常地被反序列化。\n\n  serialVersionUId的详细工作机制：序列化的时候系统会把当前类的serialVersionUId写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUId，看它是否和当前类的serialVersionUId一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUId的值。\n\n  - 1.静态成员变量属于类不属于对象，所以不参与序列化过程；\n\n  - 2.声明为transient的成员变量不参与序列化过程。\n\n- (3)Parcelable接口内部包装了可序列化的数据，可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例\n\n~~~ Java\npublic class Book implements Parcelable {\n    public int bookId;\n    public String bookName;\n    public Book() {\n    }\n\n    public Book(int bookId, String bookName) {\n        this.bookId = bookId;\n        this.bookName = bookName;\n    }\n\n    //“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0\n    public int describeContents() {\n        return 0;\n    }\n\n    //实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0\n    public void writeToParcel(Parcel out, int flags) {\n        out.writeInt(bookId);\n        out.writeString(bookName);\n    }\n\n    //实现反序列化操作\n    public static final Parcelable.Creator<Book> CREATOR = new Parcelable.Creator<Book>() {\n        //从序列化后的对象中创建原始对象\n        public Book createFromParcel(Parcel in) {\n            return new Book(in);\n        }\n        public Book[] newArray(int size) {//创建指定长度的原始对象数组\n            return new Book[size];\n        }\n    };\n\n    private Book(Parcel in) {\n        bookId = in.readInt();\n        bookName = in.readString();\n    }\n\n}\n~~~\n\n- (4)Binder是Android中的一个类，它实现了IBinder接口。\n\n  从IPC角度看，Binder是Android中一种跨进程通信的方式；Binder还可以理解为虚拟的物理设备，它的设备驱动是/dev/binder；\n\n  从Framework层角度看，Binder是ServiceManager连接各种Manager和相应的ManagerService的桥梁；\n\n  从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。\n\n\n  在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。\n\n- (5)aidl工具根据aidl文件自动生成的java接口的解析：\n\n  首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；\n\n  接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。\n\n  所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：\n\n  - 1.asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。\n  - 2.asBinder：返回当前Binder对象。\n  - 3.onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。\n\n    这个方法的原型是public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)\n\n    服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。\n\n  - 4.Proxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：\n\n    首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。\n\n  如果搞清楚了自动生成的接口文件的结构和作用之后，其实是可以不用通过AIDL而直接实现Binder的，[主席写的示例代码](https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_2/src/com/ryg/chapter_2/manualbinder/BookManagerImpl.java)\n\n- (6)Binder的两个重要方法linkToDeath和unlinkToDeath\n\n  Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。\n\n  如何给Binder设置死亡代理呢？\n\n  - 1.声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。\n\n~~~ Java\nprivate IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() {\n    @Override\n    public void binderDied() {\n        if (mRemoteBookManager == null) return;\n        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0);\n        mRemoteBookManager = null;\n        // TODO:这里重新绑定远程Service\n    }\n};\n~~~\n  - 2.在客户端绑定远程服务成功之后，给binder设置死亡代理\n\n~~~ Java\nmRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, 0);\n~~~\n\n#### 2.4 Android中的IPC方式\n\n- (1)使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。\n\n- (2)使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。\n\n  SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。\n\n- (3)使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形，详细的示例见原书。\n\n- (4)使用AIDL\n\n  大致流程：首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。\n\n  - 1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；\n  - 2.某些类即使和AIDL文件在同一个包中也要显式import进来；\n  - 3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；\n  - 4.AIDL接口中支持方法，不支持声明静态变量；\n  - 5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。\n  - 6.RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。\n\n- (5)使用ContentProvider\n\n  - 1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；\n  - 2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；\n  - 3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；\n  - 4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；\n\n- (6)使用Socket\n\n  Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。\n\n#### 2.5 Binder连接池\n\n- (1)当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。\n\n  整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。\n\n  Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。\n\n- (2)作者实现的Binder连接池BinderPool的实现源码，建议在AIDL开发工作中引入BinderPool机制。\n\n#### 2.6 选用合适的IPC方式\n\n![选择合适的IPC方式](/images/blogimages/2016/androidart_ipc.png)\n\n\n\n### 第9章 四大组件的工作过程\n本篇摘选自[amurocrash的专栏](http://blog.csdn.net/amurocrash/article/details/48858353)\n\n#### 9.1 四大组件的运行状态\n\n- (1)四大组件中只有BroadcastReceiver既可以在AndroidManifest文件中注册，也可以在代码中注册，其他三个组件都必须在AndroidManifest文件中注册；ContentProvider的调用不需要借助Intent，其他三个组件都需要借助Intent。\n- (2)Activity是一种展示型组件，用于向用户展示界面，可由显式或者隐式Intent来启动。\n- (3)Service是一种计算型组件，用于在后台执行计算任务。尽管service是用于后台执行计算的，但是它本身是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。Service组件有两种状态：启动状态和绑定状态。当service处于绑定状态时，外界可以很方便的和service进行通信，而在启动状态中是不可与外界通信的。\n- (4)BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息，它工作在系统内部。广播有两种注册方式：静态注册和动态注册。静态注册是在AndroidManifest中注册，在应用安装的时候会被系统解析，这种广播不需要应用启动就可以收到相应的广播。动态注册需要通过Context.registerReceiver()来注册，这种广播需要应用启动才能注册并接收广播。BroadcastReceiver组件一般来说不需要停止，它也没有停止的概念。\n- (5)ContentProvider是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。ContentProvider中的insert、delete、update、query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的，另外ContentProvider组件也不需要手动停止。\n\n#### 9.2 Activity的工作过程\n\n##### (1)Activity启动的大致流程\n![Activity启动的大致流程](/images/blogimages/2016/androidart_activity.png)\n\n(2)ApplicationThread是ActivityThread的一个内部类，它继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口，ApplicationThreadNative的作用其实就和系统为AIDL文件生成的类是一样的。\n(3)ActivityManagerService(AMS)继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。\n(4)一个应用只有一个Application对象，它的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。\n(5)ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当window接收到外部输入事件后就可以将事件传递给Activity。 [这里可能有误，应该是Activity将事件传递给window]\n\n#### 9.3 Service的工作过程\n\n##### (1)Service有两种状态：\n启动状态和绑定状态，两种状态是可以共存的。\n**启动过程：**\n![Service1](/images/blogimages/2016/androidart_service1.png)\n\n**绑定过程：**\n![Service2](/images/blogimages/2016/androidart_service2.png)\n\n#### 9.4 BroadcastReceiver的工作过程\n##### (1)BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。\n\n**注册过程**：静态注册的时候是由PackageManagerService来完成整个注册过程，下面是动态注册的过程\n![broadcastreceiver1](/images/blogimages/2016/androidart_broadcastreceiver1.png)\n**发送和接收**：\n![broadcastreceiver2](/images/blogimages/2016/androidart_broadcastreceiver2.png)\n##### (2)广播的发送有几种类型：\n普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是发送和接收过程是类似的。\n##### (3)一个应用处于停止状态分为两种情况：\n一是应用安装后未运行；二是应用被手动或者其他应用强停了。从Android 3.1开始，处于停止状态的应用无法接受到开机广播。\n\n#### 9.5 ContentProvider的工作过程\n\n##### (1)当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。\n##### (2)ContentProvider的启动过程：\n- 1.当一个应用启动时，入口方法是ActivityThread的main方法，其中创建ActivityThread的实例并创建主线程的消息队列；\n- 2.ActivityThread的attach方法中会远程调用ActivityManagerService的attachApplication，并将ApplicationThread提供给AMS，ApplicationThread主要用于ActivityThread和AMS之间的通信；\n- 3.ActivityManagerService的attachApplication会调用ApplicationThread的bindApplication方法，这个方法会通过H切换到ActivityThread中去执行，即调用handleBindApplication方法；\n- 4.handleBindApplication方法会创建Application对象并加载ContentProvider，注意是先加载ContentProvider，然后调用Application的onCreate方法。\n\n##### (3)ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。\n\n##### (4)当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：\n![ContentProvider](/images/blogimages/2016/androidart_contentprovider.png)\n","source":"_posts/2016-03-20-android-books-reading-.md","raw":"---\nlayout: post\ntitle: 《android开发艺术探索》读书笔记\ncategory: read\ntags: read\nkeywords: 《android开发艺术探索》,读书笔记\nbanner: http://obxk8w81b.bkt.clouddn.com/Auvers%20Town%20Hall%20on%2014%20July%201890.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Auvers%20Town%20Hall%20on%2014%20July%201890.jpg\n---\n\n\n### 第1章 Activity的生命周期和启动模式\n\n本节和《Android群英传》中的第8章Activity和Activity调用栈分析有关系，建议先阅读该章的总结\n\n第1章 Activity的生命周期和启动模式\n\n#### 1.1 Activity生命周期全面分析\n\n##### 1.1.1 典型情况下生命周期分析\n\n- (1)一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart方法就会被调用。\n\n- (2)当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -> onStop，但是如果新Activity采用了透明主题，那么onStop方法不会被回调。当用户再次回到原来的Activity时，回调如下：onRestart -> onStart -> onResume。\n\n<!--more-->\n\n- (3)onStart和onStop对应，它们是从Activity是否可见这个角度来回调的；onPause和onResume方法对应，它们是从Activity是否位于前台这个角度来回调的。\n\n- (4)从Activity A进入到Activity B，回调顺序是onPause(A) -> onCreate(B) -> onStart(B) -> onResume(B) -> onStop(A)，所以不能在onPause方法中做重量级的操作。\n\n1.1.2 异常情况下生命周期分析\n\n- (1)onSaveInstanceState方法只会出现在Activity被异常终止的情况下，它的调用时机是在onStop之前，它和onPause方法没有既定的时序关系，可能在它之前，也可能在它之后。\n\n    当Activity被重新创建的时候，onRestoreInstanceState会被回调，它的调用时机是onStart之后。\n\n    系统只会在Activity即将被销毁并且有机会重新显示的情况下才会去调用onSaveInstanceState方法。\n\n    当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据，比如文本框中用户输入的数据、listview滚动的位置等，这些view相关的状态系统都会默认为我们恢复。具体针对某一个view系统能为我们恢复哪些数据可以查看view的源码中的onSaveInstanceState和onRestoreInstanceState方法。\n\n- (2)Activity按优先级的分类\n\n    前台Activity；可见但非前台Activity；后台Activity\n\n- (3)android:configChanges=\"xxx\"属性，常用的主要有下面三个选项：\n\n    local：设备的本地位置发生了变化，一般指切换了系统语言；\n\n    keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘；\n\n    orientation：屏幕方向发生了变化，比如旋转了手机屏幕。\n\n    配置了android:configChanges=\"xxx\"属性之后，Activity就不会在对应变化发生时重新创建，而是调用Activity的onConfigurationChanged方法。\n\n#### 1.2 Activity的启动模式\n\n##### 1.2.1 启动模式\n\n- (1)当任务栈中没有任何Activity的时候，系统就会回收这个任务栈。\n\n- (2)从非Activity类型的Context(例如ApplicationContext、Service等)中以standard模式启动新的Activity是不行的，因为这类context并没有任务栈，所以需要为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标志位。\n\n- (3)任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。\n\n- (4)参数TaskAffinity用来指定Activity所需要的任务栈，意为任务相关性。\n\n    默认情况下，所有Activity所需的任务栈的名字为应用的包名。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。\n\n    当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中；\n\n    当TaskAffinity和allowTaskReparenting结合的时候，当一个应用A启动了应用B的某个Activity C后，如果Activity C的allowTaskReparenting属性设置为true的话，那么当应用B被启动后，系统会发现Activity C所需的任务栈存在了，就将Activity C从A的任务栈中转移到B的任务栈中。\n\n- (5)singleTask模式的具体分析：\n\n    当一个具有singleTask启动模式的Activity请求启动之后，系统首先会寻找是否存在A想要的任务栈，\n\n    如果不存在，就重新创建一个任务栈，然后创建Activity的实例把它放到栈中；如果存在Activity所需的任务栈，这时候要看栈中是否有Activity实例存在.\n\n    如果有，那么系统就会把该Activity实例调到栈顶，并调用它的onNewIntent方法(它之上的Activity会被迫出栈，所以singleTask模式具有FLAG_ACTIVITY_CLEAR_TOP效果)；如果Activity实例不存在，那么就创建Activity实例并把它压入栈中。\n\n- (6)设置启动模式既可以使用xml属性android:launchMode，也可以使用代码intent.addFlags()。区别在于限定范围不同，前者无法直接为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，而后者无法为Activity指定singleInstance模式。\n\n##### 1.2.2 Activity的Flags\n\nFLAG_ACTIVITY_NEW_TASK,FLAG_ACTIVITY_SINGLE_TOP,FLAG_ACTIVITY_CLEAR_TOP\n\nFLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用，它等同于属性设置android:excludeFromRecents=\"true\"。\n\n#### 1.3 IntentFilter的匹配规则\n\n- (1)IntentFilter中的过滤信息有action、category、data，为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。\n\n    一个过滤列表中的action、category、data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别和data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。此外，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intenf-filter即可成功启动对应的Activity。\n~~~ Javascript\n<intent-filter>\n    <action android:name=\"com.ryg.charpter_1.c\" />\n    <action android:name=\"com.ryg.charpter_1.d\" />\n\n    <category android:name=\"com.ryg.category.c\" />\n    <category android:name=\"com.ryg.category.d\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n\n    <data android:mimeType=\"text/plain\" />\n</intent-filter>\n~~~  \n\n- (2)action匹配规则\n\n    只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，action匹配区分大小写。\n\n- (3)category匹配规则\n\n    Intent中如果有category那么所有的category都必须和过滤规则中的其中一个category相同，如果没有category的话那么就是默认的category，即android.intent.category.DEFAULT，所以为了Activity能够接收隐式调用，配置多个category的时候必须加上默认的category。\n\n- (4)data匹配规则\n\n    data的结构很复杂，语法大致如下：\n~~~ Javascript\n<data android:scheme=\"string\"\n\tandroid:host=\"string\"\n\tandroid:port=\"string\"\n\tandroid:path=\"string\"`\n\tandroid:pathPattern=\"string\"\n\tandroid:pathPrefix=\"string\"\n\tandroid:mimeType=\"string\" />\n~~~\n    主要由mimeType和URI组成，其中mimeType代表媒体类型，而URI的结构也复杂，大致如下：\n~~~ Javascript\n<scheme>://<host>:<port>/[<path>]|[<pathPrefix>]|[pathPattern]\n~~~\n    例如content://com.example.project:200/folder/subfolder/etc\n\n  - scheme、host、port分别表示URI的模式、主机名和端口号，其中如果scheme或者host未指定那么URI就无效。\n\n  - path、pathPattern、pathPrefix都是表示路径信息，其中path表示完整的路径信息，pathPrefix表示路径的前缀信息；pathPattern表示完整的路径，但是它里面包含了通配符(\\*)。\n\n  data匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。\n\n  URI有默认的scheme！\n\n  如果过滤规则中的mimeType指定为image/\\*或者text/\\*等这种类型的话，那么即使过滤规则中没有指定URI，URI有默认的scheme是content和file！如果过滤规则中指定了scheme的话那就不是默认的scheme了。\n\n~~~ Java\n//URI有默认值\n<intent-filter>\n    <data android:mimeType=\"image/*\"/>\n  ...\n</intent-filter>\n~~~\n\n~~~ Java\n//URI默认值被覆盖\n<intent-filter>\n    <data android:mimeType=\"image/*\" android:scheme=\"http\" .../>\n    ...\n</intent-filter>\n~~~\n\n  如果要为Intent指定完整的data，必须要调用setDataAndType方法！\n\n  不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。\n~~~ Java\nintent.setDataAndType(Uri.parse(\"file://abc\"), \"image/png\");\n~~~\n  data的下面两种写法作用是一样的：\n\n~~~ Java\n<intent-filter>\n    <data android:scheme=\"file\" android:host=\"www.github.com\"/>\n</intent-filter>\n\n<intent-filter>\n    <data android:scheme=\"file\"/>\n    <data android:host=\"www.github.com\"/>\n</intent-filter>\n~~~\n  如何判断是否有Activity能够匹配我们的隐式Intent？\n\n  - (1)PackageManager的resolveActivity方法或者Intent的resolveActivity方法：如果找不到就会返回null\n\n  - (2)PackageManager的queryIntentActivities方法：它返回所有成功匹配的Activity信息\n针对Service和BroadcastReceiver等组件，PackageManager同样提供了类似的方法去获取成功匹配的组件信息，例如queryIntentServices、queryBroadcastReceivers等方法\n\n  - 有一类action和category比较重要，它们在一起用来标明这是一个入口Activity，并且会出现在系统的应用列表中。\n~~~ Java\n<intent-filter>\n    <action android:name=\"android.intent.action.MAIN\" />\n    <category android:name=\"android.intent.category.LAUNCHER\" />\n</intent-filter>\n~~~\n\n### 第2章 IPC机制\n\n#### 2.1 Android IPC简介\n\n(1)任何一个操作系统都需要有相应的IPC机制，Linux上可以通过命名通道、共享内存、信号量等来进行进程间通信。Android系统不仅可以使用了Binder机制来实现IPC，还可以使用Socket实现任意两个终端之间的通信。\n\n#### 2.2 Android中的多进程模式\n\n- (1)通过给四大组件指定android:process属性就可以开启多进程模式.\n\n    默认进程的进程名是包名packageName，进程名以:开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以:开头的进程属于全局进程，其他应用通过ShareUID方法可以和它跑在同一个进程中。\n\n    android:process=\":xyz\" //进程名是 packageName:xyz\n\n    android:process=\"aaa.bbb.ccc\" //进程名是 aaa.bbb.ccc\n\n- (2)Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。\n\n    两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。 在这种情况下，它们可以相互访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。如果它们跑在同一个进程中，还可以共享内存数据，它们看起来就像是一个应用的两个部分。\n- (3)android系统会为每个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，所以不同的虚拟机中访问同一个类的对象会产生多个副本。\n\n- (4)使用多进程容易造成以下几个问题：\n\n  - 1.静态成员和单例模式完全失效；\n  - 2.线程同步机制完全失效：无论锁对象还是锁全局对象都无法保证线程同步；\n  - 3.SharedPreferences的可靠性下降：SharedPreferences不支持并发读写；\n  - 4.Application会多次创建：当一个组件跑在一个新的进程的时候，系统要在创建新的进程的同时分配独立的虚拟机，应用会重新启动一次，也就会创建新的Application。运行在同一个进程中的组件是属于同一个虚拟机和同一个Application。\n\n    同一个应用的不同组件，如果它们运行在不同进程中，那么和它们分别属于两个应用没有本质区别。\n\n#### 2.3 IPC基础概念介绍\n\n- (1)Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口。\n\n- (2)serialVersionUId是一串long型数字，主要是用来辅助序列化和反序列化的，原则上序列化后的数据中的serialVersionUId只有和当前类的serialVersionUId相同才能够正常地被反序列化。\n\n  serialVersionUId的详细工作机制：序列化的时候系统会把当前类的serialVersionUId写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUId，看它是否和当前类的serialVersionUId一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUId的值。\n\n  - 1.静态成员变量属于类不属于对象，所以不参与序列化过程；\n\n  - 2.声明为transient的成员变量不参与序列化过程。\n\n- (3)Parcelable接口内部包装了可序列化的数据，可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例\n\n~~~ Java\npublic class Book implements Parcelable {\n    public int bookId;\n    public String bookName;\n    public Book() {\n    }\n\n    public Book(int bookId, String bookName) {\n        this.bookId = bookId;\n        this.bookName = bookName;\n    }\n\n    //“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0\n    public int describeContents() {\n        return 0;\n    }\n\n    //实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0\n    public void writeToParcel(Parcel out, int flags) {\n        out.writeInt(bookId);\n        out.writeString(bookName);\n    }\n\n    //实现反序列化操作\n    public static final Parcelable.Creator<Book> CREATOR = new Parcelable.Creator<Book>() {\n        //从序列化后的对象中创建原始对象\n        public Book createFromParcel(Parcel in) {\n            return new Book(in);\n        }\n        public Book[] newArray(int size) {//创建指定长度的原始对象数组\n            return new Book[size];\n        }\n    };\n\n    private Book(Parcel in) {\n        bookId = in.readInt();\n        bookName = in.readString();\n    }\n\n}\n~~~\n\n- (4)Binder是Android中的一个类，它实现了IBinder接口。\n\n  从IPC角度看，Binder是Android中一种跨进程通信的方式；Binder还可以理解为虚拟的物理设备，它的设备驱动是/dev/binder；\n\n  从Framework层角度看，Binder是ServiceManager连接各种Manager和相应的ManagerService的桥梁；\n\n  从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。\n\n\n  在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。\n\n- (5)aidl工具根据aidl文件自动生成的java接口的解析：\n\n  首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；\n\n  接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。\n\n  所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：\n\n  - 1.asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。\n  - 2.asBinder：返回当前Binder对象。\n  - 3.onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。\n\n    这个方法的原型是public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)\n\n    服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。\n\n  - 4.Proxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：\n\n    首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。\n\n  如果搞清楚了自动生成的接口文件的结构和作用之后，其实是可以不用通过AIDL而直接实现Binder的，[主席写的示例代码](https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_2/src/com/ryg/chapter_2/manualbinder/BookManagerImpl.java)\n\n- (6)Binder的两个重要方法linkToDeath和unlinkToDeath\n\n  Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。\n\n  如何给Binder设置死亡代理呢？\n\n  - 1.声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。\n\n~~~ Java\nprivate IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() {\n    @Override\n    public void binderDied() {\n        if (mRemoteBookManager == null) return;\n        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0);\n        mRemoteBookManager = null;\n        // TODO:这里重新绑定远程Service\n    }\n};\n~~~\n  - 2.在客户端绑定远程服务成功之后，给binder设置死亡代理\n\n~~~ Java\nmRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, 0);\n~~~\n\n#### 2.4 Android中的IPC方式\n\n- (1)使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。\n\n- (2)使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。\n\n  SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。\n\n- (3)使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形，详细的示例见原书。\n\n- (4)使用AIDL\n\n  大致流程：首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。\n\n  - 1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；\n  - 2.某些类即使和AIDL文件在同一个包中也要显式import进来；\n  - 3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；\n  - 4.AIDL接口中支持方法，不支持声明静态变量；\n  - 5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。\n  - 6.RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。\n\n- (5)使用ContentProvider\n\n  - 1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；\n  - 2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；\n  - 3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；\n  - 4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；\n\n- (6)使用Socket\n\n  Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。\n\n#### 2.5 Binder连接池\n\n- (1)当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。\n\n  整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。\n\n  Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。\n\n- (2)作者实现的Binder连接池BinderPool的实现源码，建议在AIDL开发工作中引入BinderPool机制。\n\n#### 2.6 选用合适的IPC方式\n\n![选择合适的IPC方式](/images/blogimages/2016/androidart_ipc.png)\n\n\n\n### 第9章 四大组件的工作过程\n本篇摘选自[amurocrash的专栏](http://blog.csdn.net/amurocrash/article/details/48858353)\n\n#### 9.1 四大组件的运行状态\n\n- (1)四大组件中只有BroadcastReceiver既可以在AndroidManifest文件中注册，也可以在代码中注册，其他三个组件都必须在AndroidManifest文件中注册；ContentProvider的调用不需要借助Intent，其他三个组件都需要借助Intent。\n- (2)Activity是一种展示型组件，用于向用户展示界面，可由显式或者隐式Intent来启动。\n- (3)Service是一种计算型组件，用于在后台执行计算任务。尽管service是用于后台执行计算的，但是它本身是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。Service组件有两种状态：启动状态和绑定状态。当service处于绑定状态时，外界可以很方便的和service进行通信，而在启动状态中是不可与外界通信的。\n- (4)BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息，它工作在系统内部。广播有两种注册方式：静态注册和动态注册。静态注册是在AndroidManifest中注册，在应用安装的时候会被系统解析，这种广播不需要应用启动就可以收到相应的广播。动态注册需要通过Context.registerReceiver()来注册，这种广播需要应用启动才能注册并接收广播。BroadcastReceiver组件一般来说不需要停止，它也没有停止的概念。\n- (5)ContentProvider是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。ContentProvider中的insert、delete、update、query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的，另外ContentProvider组件也不需要手动停止。\n\n#### 9.2 Activity的工作过程\n\n##### (1)Activity启动的大致流程\n![Activity启动的大致流程](/images/blogimages/2016/androidart_activity.png)\n\n(2)ApplicationThread是ActivityThread的一个内部类，它继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口，ApplicationThreadNative的作用其实就和系统为AIDL文件生成的类是一样的。\n(3)ActivityManagerService(AMS)继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。\n(4)一个应用只有一个Application对象，它的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。\n(5)ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当window接收到外部输入事件后就可以将事件传递给Activity。 [这里可能有误，应该是Activity将事件传递给window]\n\n#### 9.3 Service的工作过程\n\n##### (1)Service有两种状态：\n启动状态和绑定状态，两种状态是可以共存的。\n**启动过程：**\n![Service1](/images/blogimages/2016/androidart_service1.png)\n\n**绑定过程：**\n![Service2](/images/blogimages/2016/androidart_service2.png)\n\n#### 9.4 BroadcastReceiver的工作过程\n##### (1)BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。\n\n**注册过程**：静态注册的时候是由PackageManagerService来完成整个注册过程，下面是动态注册的过程\n![broadcastreceiver1](/images/blogimages/2016/androidart_broadcastreceiver1.png)\n**发送和接收**：\n![broadcastreceiver2](/images/blogimages/2016/androidart_broadcastreceiver2.png)\n##### (2)广播的发送有几种类型：\n普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是发送和接收过程是类似的。\n##### (3)一个应用处于停止状态分为两种情况：\n一是应用安装后未运行；二是应用被手动或者其他应用强停了。从Android 3.1开始，处于停止状态的应用无法接受到开机广播。\n\n#### 9.5 ContentProvider的工作过程\n\n##### (1)当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。\n##### (2)ContentProvider的启动过程：\n- 1.当一个应用启动时，入口方法是ActivityThread的main方法，其中创建ActivityThread的实例并创建主线程的消息队列；\n- 2.ActivityThread的attach方法中会远程调用ActivityManagerService的attachApplication，并将ApplicationThread提供给AMS，ApplicationThread主要用于ActivityThread和AMS之间的通信；\n- 3.ActivityManagerService的attachApplication会调用ApplicationThread的bindApplication方法，这个方法会通过H切换到ActivityThread中去执行，即调用handleBindApplication方法；\n- 4.handleBindApplication方法会创建Application对象并加载ContentProvider，注意是先加载ContentProvider，然后调用Application的onCreate方法。\n\n##### (3)ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。\n\n##### (4)当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：\n![ContentProvider](/images/blogimages/2016/androidart_contentprovider.png)\n","slug":"android-books-reading-","published":1,"date":"2016-03-19T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj4h000kbxs6tiyvg0sh","content":"<h3 id=\"第1章-Activity的生命周期和启动模式\"><a href=\"#第1章-Activity的生命周期和启动模式\" class=\"headerlink\" title=\"第1章 Activity的生命周期和启动模式\"></a>第1章 Activity的生命周期和启动模式</h3><p>本节和《Android群英传》中的第8章Activity和Activity调用栈分析有关系，建议先阅读该章的总结</p>\n<p>第1章 Activity的生命周期和启动模式</p>\n<h4 id=\"1-1-Activity生命周期全面分析\"><a href=\"#1-1-Activity生命周期全面分析\" class=\"headerlink\" title=\"1.1 Activity生命周期全面分析\"></a>1.1 Activity生命周期全面分析</h4><h5 id=\"1-1-1-典型情况下生命周期分析\"><a href=\"#1-1-1-典型情况下生命周期分析\" class=\"headerlink\" title=\"1.1.1 典型情况下生命周期分析\"></a>1.1.1 典型情况下生命周期分析</h5><ul>\n<li><p>(1)一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart方法就会被调用。</p>\n</li>\n<li><p>(2)当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新Activity采用了透明主题，那么onStop方法不会被回调。当用户再次回到原来的Activity时，回调如下：onRestart -&gt; onStart -&gt; onResume。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>(3)onStart和onStop对应，它们是从Activity是否可见这个角度来回调的；onPause和onResume方法对应，它们是从Activity是否位于前台这个角度来回调的。</p>\n</li>\n<li><p>(4)从Activity A进入到Activity B，回调顺序是onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)，所以不能在onPause方法中做重量级的操作。</p>\n</li>\n</ul>\n<p>1.1.2 异常情况下生命周期分析</p>\n<ul>\n<li><p>(1)onSaveInstanceState方法只会出现在Activity被异常终止的情况下，它的调用时机是在onStop之前，它和onPause方法没有既定的时序关系，可能在它之前，也可能在它之后。</p>\n<p>  当Activity被重新创建的时候，onRestoreInstanceState会被回调，它的调用时机是onStart之后。</p>\n<p>  系统只会在Activity即将被销毁并且有机会重新显示的情况下才会去调用onSaveInstanceState方法。</p>\n<p>  当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据，比如文本框中用户输入的数据、listview滚动的位置等，这些view相关的状态系统都会默认为我们恢复。具体针对某一个view系统能为我们恢复哪些数据可以查看view的源码中的onSaveInstanceState和onRestoreInstanceState方法。</p>\n</li>\n<li><p>(2)Activity按优先级的分类</p>\n<p>  前台Activity；可见但非前台Activity；后台Activity</p>\n</li>\n<li><p>(3)android:configChanges=”xxx”属性，常用的主要有下面三个选项：</p>\n<p>  local：设备的本地位置发生了变化，一般指切换了系统语言；</p>\n<p>  keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘；</p>\n<p>  orientation：屏幕方向发生了变化，比如旋转了手机屏幕。</p>\n<p>  配置了android:configChanges=”xxx”属性之后，Activity就不会在对应变化发生时重新创建，而是调用Activity的onConfigurationChanged方法。</p>\n</li>\n</ul>\n<h4 id=\"1-2-Activity的启动模式\"><a href=\"#1-2-Activity的启动模式\" class=\"headerlink\" title=\"1.2 Activity的启动模式\"></a>1.2 Activity的启动模式</h4><h5 id=\"1-2-1-启动模式\"><a href=\"#1-2-1-启动模式\" class=\"headerlink\" title=\"1.2.1 启动模式\"></a>1.2.1 启动模式</h5><ul>\n<li><p>(1)当任务栈中没有任何Activity的时候，系统就会回收这个任务栈。</p>\n</li>\n<li><p>(2)从非Activity类型的Context(例如ApplicationContext、Service等)中以standard模式启动新的Activity是不行的，因为这类context并没有任务栈，所以需要为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标志位。</p>\n</li>\n<li><p>(3)任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。</p>\n</li>\n<li><p>(4)参数TaskAffinity用来指定Activity所需要的任务栈，意为任务相关性。</p>\n<p>  默认情况下，所有Activity所需的任务栈的名字为应用的包名。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。</p>\n<p>  当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中；</p>\n<p>  当TaskAffinity和allowTaskReparenting结合的时候，当一个应用A启动了应用B的某个Activity C后，如果Activity C的allowTaskReparenting属性设置为true的话，那么当应用B被启动后，系统会发现Activity C所需的任务栈存在了，就将Activity C从A的任务栈中转移到B的任务栈中。</p>\n</li>\n<li><p>(5)singleTask模式的具体分析：</p>\n<p>  当一个具有singleTask启动模式的Activity请求启动之后，系统首先会寻找是否存在A想要的任务栈，</p>\n<p>  如果不存在，就重新创建一个任务栈，然后创建Activity的实例把它放到栈中；如果存在Activity所需的任务栈，这时候要看栈中是否有Activity实例存在.</p>\n<p>  如果有，那么系统就会把该Activity实例调到栈顶，并调用它的onNewIntent方法(它之上的Activity会被迫出栈，所以singleTask模式具有FLAG_ACTIVITY_CLEAR_TOP效果)；如果Activity实例不存在，那么就创建Activity实例并把它压入栈中。</p>\n</li>\n<li><p>(6)设置启动模式既可以使用xml属性android:launchMode，也可以使用代码intent.addFlags()。区别在于限定范围不同，前者无法直接为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，而后者无法为Activity指定singleInstance模式。</p>\n</li>\n</ul>\n<h5 id=\"1-2-2-Activity的Flags\"><a href=\"#1-2-2-Activity的Flags\" class=\"headerlink\" title=\"1.2.2 Activity的Flags\"></a>1.2.2 Activity的Flags</h5><p>FLAG_ACTIVITY_NEW_TASK,FLAG_ACTIVITY_SINGLE_TOP,FLAG_ACTIVITY_CLEAR_TOP</p>\n<p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用，它等同于属性设置android:excludeFromRecents=”true”。</p>\n<h4 id=\"1-3-IntentFilter的匹配规则\"><a href=\"#1-3-IntentFilter的匹配规则\" class=\"headerlink\" title=\"1.3 IntentFilter的匹配规则\"></a>1.3 IntentFilter的匹配规则</h4><ul>\n<li><p>(1)IntentFilter中的过滤信息有action、category、data，为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。</p>\n<p>  一个过滤列表中的action、category、data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别和data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。此外，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intenf-filter即可成功启动对应的Activity。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;action android:name=\"com.ryg.charpter_1.c\" /&gt;</div><div class=\"line\">    &lt;action android:name=\"com.ryg.charpter_1.d\" /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;category android:name=\"com.ryg.category.c\" /&gt;</div><div class=\"line\">    &lt;category android:name=\"com.ryg.category.d\" /&gt;</div><div class=\"line\">    &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;data android:mimeType=\"text/plain\" /&gt;</div><div class=\"line\">&lt;/intent-filter&gt;</div><div class=\"line\">~~~  </div><div class=\"line\"></div><div class=\"line\">- (2)action匹配规则</div><div class=\"line\"></div><div class=\"line\">    只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，action匹配区分大小写。</div><div class=\"line\"></div><div class=\"line\">- (3)category匹配规则</div><div class=\"line\"></div><div class=\"line\">    Intent中如果有category那么所有的category都必须和过滤规则中的其中一个category相同，如果没有category的话那么就是默认的category，即android.intent.category.DEFAULT，所以为了Activity能够接收隐式调用，配置多个category的时候必须加上默认的category。</div><div class=\"line\"></div><div class=\"line\">- (4)data匹配规则</div><div class=\"line\"></div><div class=\"line\">    data的结构很复杂，语法大致如下：</div><div class=\"line\">~~~ Javascript</div><div class=\"line\">&lt;data android:scheme=\"string\"</div><div class=\"line\">\tandroid:host=\"string\"</div><div class=\"line\">\tandroid:port=\"string\"</div><div class=\"line\">\tandroid:path=\"string\"`</div><div class=\"line\">\tandroid:pathPattern=\"string\"</div><div class=\"line\">\tandroid:pathPrefix=\"string\"</div><div class=\"line\">\tandroid:mimeType=\"string\" /&gt;</div></pre></td></tr></table></figure>\n<p>  主要由mimeType和URI组成，其中mimeType代表媒体类型，而URI的结构也复杂，大致如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;scheme&gt;:<span class=\"comment\">//&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;]|[&lt;pathPrefix&gt;]|[pathPattern]</span></div></pre></td></tr></table></figure>\n<p>  例如content://com.example.project:200/folder/subfolder/etc</p>\n<ul>\n<li><p>scheme、host、port分别表示URI的模式、主机名和端口号，其中如果scheme或者host未指定那么URI就无效。</p>\n</li>\n<li><p>path、pathPattern、pathPrefix都是表示路径信息，其中path表示完整的路径信息，pathPrefix表示路径的前缀信息；pathPattern表示完整的路径，但是它里面包含了通配符(*)。</p>\n</li>\n</ul>\n<p>data匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。</p>\n<p>URI有默认的scheme！</p>\n<p>如果过滤规则中的mimeType指定为image/*或者text/*等这种类型的话，那么即使过滤规则中没有指定URI，URI有默认的scheme是content和file！如果过滤规则中指定了scheme的话那就不是默认的scheme了。</p>\n</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//URI有默认值</div><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;data android:mimeType=\"image/*\"/&gt;</div><div class=\"line\">  ...</div><div class=\"line\">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//URI默认值被覆盖</div><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;data android:mimeType=\"image/*\" android:scheme=\"http\" .../&gt;</div><div class=\"line\">    ...</div><div class=\"line\">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>\n<p>  如果要为Intent指定完整的data，必须要调用setDataAndType方法！</p>\n<p>  不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">intent.setDataAndType(Uri.parse(<span class=\"string\">\"file://abc\"</span>), <span class=\"string\">\"image/png\"</span>);</div></pre></td></tr></table></figure></p>\n<p>  data的下面两种写法作用是一样的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;data android:scheme=\"file\" android:host=\"www.github.com\"/&gt;</div><div class=\"line\">&lt;/intent-filter&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;data android:scheme=\"file\"/&gt;</div><div class=\"line\">    &lt;data android:host=\"www.github.com\"/&gt;</div><div class=\"line\">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>\n<p>  如何判断是否有Activity能够匹配我们的隐式Intent？</p>\n<ul>\n<li><p>(1)PackageManager的resolveActivity方法或者Intent的resolveActivity方法：如果找不到就会返回null</p>\n</li>\n<li><p>(2)PackageManager的queryIntentActivities方法：它返回所有成功匹配的Activity信息<br>针对Service和BroadcastReceiver等组件，PackageManager同样提供了类似的方法去获取成功匹配的组件信息，例如queryIntentServices、queryBroadcastReceivers等方法</p>\n</li>\n<li><p>有一类action和category比较重要，它们在一起用来标明这是一个入口Activity，并且会出现在系统的应用列表中。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;action android:name=\"android.intent.action.MAIN\" /&gt;</div><div class=\"line\">    &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;</div><div class=\"line\">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"第2章-IPC机制\"><a href=\"#第2章-IPC机制\" class=\"headerlink\" title=\"第2章 IPC机制\"></a>第2章 IPC机制</h3><h4 id=\"2-1-Android-IPC简介\"><a href=\"#2-1-Android-IPC简介\" class=\"headerlink\" title=\"2.1 Android IPC简介\"></a>2.1 Android IPC简介</h4><p>(1)任何一个操作系统都需要有相应的IPC机制，Linux上可以通过命名通道、共享内存、信号量等来进行进程间通信。Android系统不仅可以使用了Binder机制来实现IPC，还可以使用Socket实现任意两个终端之间的通信。</p>\n<h4 id=\"2-2-Android中的多进程模式\"><a href=\"#2-2-Android中的多进程模式\" class=\"headerlink\" title=\"2.2 Android中的多进程模式\"></a>2.2 Android中的多进程模式</h4><ul>\n<li><p>(1)通过给四大组件指定android:process属性就可以开启多进程模式.</p>\n<p>  默认进程的进程名是包名packageName，进程名以:开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以:开头的进程属于全局进程，其他应用通过ShareUID方法可以和它跑在同一个进程中。</p>\n<p>  android:process=”:xyz” //进程名是 packageName:xyz</p>\n<p>  android:process=”aaa.bbb.ccc” //进程名是 aaa.bbb.ccc</p>\n</li>\n<li><p>(2)Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。</p>\n<p>  两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。 在这种情况下，它们可以相互访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。如果它们跑在同一个进程中，还可以共享内存数据，它们看起来就像是一个应用的两个部分。</p>\n</li>\n<li><p>(3)android系统会为每个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，所以不同的虚拟机中访问同一个类的对象会产生多个副本。</p>\n</li>\n<li><p>(4)使用多进程容易造成以下几个问题：</p>\n<ul>\n<li>1.静态成员和单例模式完全失效；</li>\n<li>2.线程同步机制完全失效：无论锁对象还是锁全局对象都无法保证线程同步；</li>\n<li>3.SharedPreferences的可靠性下降：SharedPreferences不支持并发读写；</li>\n<li><p>4.Application会多次创建：当一个组件跑在一个新的进程的时候，系统要在创建新的进程的同时分配独立的虚拟机，应用会重新启动一次，也就会创建新的Application。运行在同一个进程中的组件是属于同一个虚拟机和同一个Application。</p>\n<p>同一个应用的不同组件，如果它们运行在不同进程中，那么和它们分别属于两个应用没有本质区别。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-IPC基础概念介绍\"><a href=\"#2-3-IPC基础概念介绍\" class=\"headerlink\" title=\"2.3 IPC基础概念介绍\"></a>2.3 IPC基础概念介绍</h4><ul>\n<li><p>(1)Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口。</p>\n</li>\n<li><p>(2)serialVersionUId是一串long型数字，主要是用来辅助序列化和反序列化的，原则上序列化后的数据中的serialVersionUId只有和当前类的serialVersionUId相同才能够正常地被反序列化。</p>\n<p>serialVersionUId的详细工作机制：序列化的时候系统会把当前类的serialVersionUId写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUId，看它是否和当前类的serialVersionUId一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUId的值。</p>\n<ul>\n<li><p>1.静态成员变量属于类不属于对象，所以不参与序列化过程；</p>\n</li>\n<li><p>2.声明为transient的成员变量不参与序列化过程。</p>\n</li>\n</ul>\n</li>\n<li><p>(3)Parcelable接口内部包装了可序列化的数据，可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> bookId;</div><div class=\"line\">    <span class=\"keyword\">public</span> String bookName;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Book</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Book</span><span class=\"params\">(<span class=\"keyword\">int</span> bookId, String bookName)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.bookId = bookId;</div><div class=\"line\">        <span class=\"keyword\">this</span>.bookName = bookName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">describeContents</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeToParcel</span><span class=\"params\">(Parcel out, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</div><div class=\"line\">        out.writeInt(bookId);</div><div class=\"line\">        out.writeString(bookName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//实现反序列化操作</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class=\"keyword\">new</span> Parcelable.Creator&lt;Book&gt;() &#123;</div><div class=\"line\">        <span class=\"comment\">//从序列化后的对象中创建原始对象</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Book <span class=\"title\">createFromParcel</span><span class=\"params\">(Parcel in)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book(in);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">public</span> Book[] newArray(<span class=\"keyword\">int</span> size) &#123;<span class=\"comment\">//创建指定长度的原始对象数组</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book[size];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Book</span><span class=\"params\">(Parcel in)</span> </span>&#123;</div><div class=\"line\">        bookId = in.readInt();</div><div class=\"line\">        bookName = in.readString();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>(4)Binder是Android中的一个类，它实现了IBinder接口。</p>\n<p>从IPC角度看，Binder是Android中一种跨进程通信的方式；Binder还可以理解为虚拟的物理设备，它的设备驱动是/dev/binder；</p>\n<p>从Framework层角度看，Binder是ServiceManager连接各种Manager和相应的ManagerService的桥梁；</p>\n<p>从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>\n</li>\n</ul>\n<p>  在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。</p>\n<ul>\n<li><p>(5)aidl工具根据aidl文件自动生成的java接口的解析：</p>\n<p>首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；</p>\n<p>接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。</p>\n<p>所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：</p>\n<ul>\n<li>1.asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。</li>\n<li>2.asBinder：返回当前Binder对象。</li>\n<li><p>3.onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。</p>\n<p>这个方法的原型是public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)</p>\n<p>服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。</p>\n</li>\n<li><p>4.Proxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：</p>\n<p>首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。</p>\n</li>\n</ul>\n<p>如果搞清楚了自动生成的接口文件的结构和作用之后，其实是可以不用通过AIDL而直接实现Binder的，<a href=\"https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_2/src/com/ryg/chapter_2/manualbinder/BookManagerImpl.java\" target=\"_blank\" rel=\"external\">主席写的示例代码</a></p>\n</li>\n<li><p>(6)Binder的两个重要方法linkToDeath和unlinkToDeath</p>\n<p>Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。</p>\n<p>如何给Binder设置死亡代理呢？</p>\n<ul>\n<li>1.声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> IBinder.DeathRecipient mDeathRecipient = <span class=\"keyword\">new</span> IBinder.DeathRecipient() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">binderDied</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mRemoteBookManager == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class=\"number\">0</span>);</div><div class=\"line\">        mRemoteBookManager = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span>这里重新绑定远程Service</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>2.在客户端绑定远程服务成功之后，给binder设置死亡代理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-Android中的IPC方式\"><a href=\"#2-4-Android中的IPC方式\" class=\"headerlink\" title=\"2.4 Android中的IPC方式\"></a>2.4 Android中的IPC方式</h4><ul>\n<li><p>(1)使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。</p>\n</li>\n<li><p>(2)使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。</p>\n<p>SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。</p>\n</li>\n<li><p>(3)使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形，详细的示例见原书。</p>\n</li>\n<li><p>(4)使用AIDL</p>\n<p>大致流程：首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。</p>\n<ul>\n<li>1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；</li>\n<li>2.某些类即使和AIDL文件在同一个包中也要显式import进来；</li>\n<li>3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；</li>\n<li>4.AIDL接口中支持方法，不支持声明静态变量；</li>\n<li>5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。</li>\n<li>6.RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。</li>\n</ul>\n</li>\n<li><p>(5)使用ContentProvider</p>\n<ul>\n<li>1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；</li>\n<li>2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；</li>\n<li>3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；</li>\n<li>4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；</li>\n</ul>\n</li>\n<li><p>(6)使用Socket</p>\n<p>Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。</p>\n</li>\n</ul>\n<h4 id=\"2-5-Binder连接池\"><a href=\"#2-5-Binder连接池\" class=\"headerlink\" title=\"2.5 Binder连接池\"></a>2.5 Binder连接池</h4><ul>\n<li><p>(1)当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。</p>\n<p>整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。</p>\n<p>Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。</p>\n</li>\n<li><p>(2)作者实现的Binder连接池BinderPool的实现源码，建议在AIDL开发工作中引入BinderPool机制。</p>\n</li>\n</ul>\n<h4 id=\"2-6-选用合适的IPC方式\"><a href=\"#2-6-选用合适的IPC方式\" class=\"headerlink\" title=\"2.6 选用合适的IPC方式\"></a>2.6 选用合适的IPC方式</h4><p><img src=\"/images/blogimages/2016/androidart_ipc.png\" alt=\"选择合适的IPC方式\"></p>\n<h3 id=\"第9章-四大组件的工作过程\"><a href=\"#第9章-四大组件的工作过程\" class=\"headerlink\" title=\"第9章 四大组件的工作过程\"></a>第9章 四大组件的工作过程</h3><p>本篇摘选自<a href=\"http://blog.csdn.net/amurocrash/article/details/48858353\" target=\"_blank\" rel=\"external\">amurocrash的专栏</a></p>\n<h4 id=\"9-1-四大组件的运行状态\"><a href=\"#9-1-四大组件的运行状态\" class=\"headerlink\" title=\"9.1 四大组件的运行状态\"></a>9.1 四大组件的运行状态</h4><ul>\n<li>(1)四大组件中只有BroadcastReceiver既可以在AndroidManifest文件中注册，也可以在代码中注册，其他三个组件都必须在AndroidManifest文件中注册；ContentProvider的调用不需要借助Intent，其他三个组件都需要借助Intent。</li>\n<li>(2)Activity是一种展示型组件，用于向用户展示界面，可由显式或者隐式Intent来启动。</li>\n<li>(3)Service是一种计算型组件，用于在后台执行计算任务。尽管service是用于后台执行计算的，但是它本身是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。Service组件有两种状态：启动状态和绑定状态。当service处于绑定状态时，外界可以很方便的和service进行通信，而在启动状态中是不可与外界通信的。</li>\n<li>(4)BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息，它工作在系统内部。广播有两种注册方式：静态注册和动态注册。静态注册是在AndroidManifest中注册，在应用安装的时候会被系统解析，这种广播不需要应用启动就可以收到相应的广播。动态注册需要通过Context.registerReceiver()来注册，这种广播需要应用启动才能注册并接收广播。BroadcastReceiver组件一般来说不需要停止，它也没有停止的概念。</li>\n<li>(5)ContentProvider是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。ContentProvider中的insert、delete、update、query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的，另外ContentProvider组件也不需要手动停止。</li>\n</ul>\n<h4 id=\"9-2-Activity的工作过程\"><a href=\"#9-2-Activity的工作过程\" class=\"headerlink\" title=\"9.2 Activity的工作过程\"></a>9.2 Activity的工作过程</h4><h5 id=\"1-Activity启动的大致流程\"><a href=\"#1-Activity启动的大致流程\" class=\"headerlink\" title=\"(1)Activity启动的大致流程\"></a>(1)Activity启动的大致流程</h5><p><img src=\"/images/blogimages/2016/androidart_activity.png\" alt=\"Activity启动的大致流程\"></p>\n<p>(2)ApplicationThread是ActivityThread的一个内部类，它继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口，ApplicationThreadNative的作用其实就和系统为AIDL文件生成的类是一样的。<br>(3)ActivityManagerService(AMS)继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。<br>(4)一个应用只有一个Application对象，它的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。<br>(5)ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当window接收到外部输入事件后就可以将事件传递给Activity。 [这里可能有误，应该是Activity将事件传递给window]</p>\n<h4 id=\"9-3-Service的工作过程\"><a href=\"#9-3-Service的工作过程\" class=\"headerlink\" title=\"9.3 Service的工作过程\"></a>9.3 Service的工作过程</h4><h5 id=\"1-Service有两种状态：\"><a href=\"#1-Service有两种状态：\" class=\"headerlink\" title=\"(1)Service有两种状态：\"></a>(1)Service有两种状态：</h5><p>启动状态和绑定状态，两种状态是可以共存的。<br><strong>启动过程：</strong><br><img src=\"/images/blogimages/2016/androidart_service1.png\" alt=\"Service1\"></p>\n<p><strong>绑定过程：</strong><br><img src=\"/images/blogimages/2016/androidart_service2.png\" alt=\"Service2\"></p>\n<h4 id=\"9-4-BroadcastReceiver的工作过程\"><a href=\"#9-4-BroadcastReceiver的工作过程\" class=\"headerlink\" title=\"9.4 BroadcastReceiver的工作过程\"></a>9.4 BroadcastReceiver的工作过程</h4><h5 id=\"1-BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。\"><a href=\"#1-BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。\" class=\"headerlink\" title=\"(1)BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。\"></a>(1)BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。</h5><p><strong>注册过程</strong>：静态注册的时候是由PackageManagerService来完成整个注册过程，下面是动态注册的过程<br><img src=\"/images/blogimages/2016/androidart_broadcastreceiver1.png\" alt=\"broadcastreceiver1\"><br><strong>发送和接收</strong>：<br><img src=\"/images/blogimages/2016/androidart_broadcastreceiver2.png\" alt=\"broadcastreceiver2\"></p>\n<h5 id=\"2-广播的发送有几种类型：\"><a href=\"#2-广播的发送有几种类型：\" class=\"headerlink\" title=\"(2)广播的发送有几种类型：\"></a>(2)广播的发送有几种类型：</h5><p>普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是发送和接收过程是类似的。</p>\n<h5 id=\"3-一个应用处于停止状态分为两种情况：\"><a href=\"#3-一个应用处于停止状态分为两种情况：\" class=\"headerlink\" title=\"(3)一个应用处于停止状态分为两种情况：\"></a>(3)一个应用处于停止状态分为两种情况：</h5><p>一是应用安装后未运行；二是应用被手动或者其他应用强停了。从Android 3.1开始，处于停止状态的应用无法接受到开机广播。</p>\n<h4 id=\"9-5-ContentProvider的工作过程\"><a href=\"#9-5-ContentProvider的工作过程\" class=\"headerlink\" title=\"9.5 ContentProvider的工作过程\"></a>9.5 ContentProvider的工作过程</h4><h5 id=\"1-当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。\"><a href=\"#1-当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。\" class=\"headerlink\" title=\"(1)当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。\"></a>(1)当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。</h5><h5 id=\"2-ContentProvider的启动过程：\"><a href=\"#2-ContentProvider的启动过程：\" class=\"headerlink\" title=\"(2)ContentProvider的启动过程：\"></a>(2)ContentProvider的启动过程：</h5><ul>\n<li>1.当一个应用启动时，入口方法是ActivityThread的main方法，其中创建ActivityThread的实例并创建主线程的消息队列；</li>\n<li>2.ActivityThread的attach方法中会远程调用ActivityManagerService的attachApplication，并将ApplicationThread提供给AMS，ApplicationThread主要用于ActivityThread和AMS之间的通信；</li>\n<li>3.ActivityManagerService的attachApplication会调用ApplicationThread的bindApplication方法，这个方法会通过H切换到ActivityThread中去执行，即调用handleBindApplication方法；</li>\n<li>4.handleBindApplication方法会创建Application对象并加载ContentProvider，注意是先加载ContentProvider，然后调用Application的onCreate方法。</li>\n</ul>\n<h5 id=\"3-ContentProvider的android-multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。\"><a href=\"#3-ContentProvider的android-multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。\" class=\"headerlink\" title=\"(3)ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。\"></a>(3)ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。</h5><h5 id=\"4-当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：\"><a href=\"#4-当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：\" class=\"headerlink\" title=\"(4)当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：\"></a>(4)当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：</h5><p><img src=\"/images/blogimages/2016/androidart_contentprovider.png\" alt=\"ContentProvider\"></p>\n","excerpt":"<h3 id=\"第1章-Activity的生命周期和启动模式\"><a href=\"#第1章-Activity的生命周期和启动模式\" class=\"headerlink\" title=\"第1章 Activity的生命周期和启动模式\"></a>第1章 Activity的生命周期和启动模式</h3><p>本节和《Android群英传》中的第8章Activity和Activity调用栈分析有关系，建议先阅读该章的总结</p>\n<p>第1章 Activity的生命周期和启动模式</p>\n<h4 id=\"1-1-Activity生命周期全面分析\"><a href=\"#1-1-Activity生命周期全面分析\" class=\"headerlink\" title=\"1.1 Activity生命周期全面分析\"></a>1.1 Activity生命周期全面分析</h4><h5 id=\"1-1-1-典型情况下生命周期分析\"><a href=\"#1-1-1-典型情况下生命周期分析\" class=\"headerlink\" title=\"1.1.1 典型情况下生命周期分析\"></a>1.1.1 典型情况下生命周期分析</h5><ul>\n<li><p>(1)一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart方法就会被调用。</p>\n</li>\n<li><p>(2)当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -&gt; onStop，但是如果新Activity采用了透明主题，那么onStop方法不会被回调。当用户再次回到原来的Activity时，回调如下：onRestart -&gt; onStart -&gt; onResume。</p>\n</li>\n</ul>","more":"<ul>\n<li><p>(3)onStart和onStop对应，它们是从Activity是否可见这个角度来回调的；onPause和onResume方法对应，它们是从Activity是否位于前台这个角度来回调的。</p>\n</li>\n<li><p>(4)从Activity A进入到Activity B，回调顺序是onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)，所以不能在onPause方法中做重量级的操作。</p>\n</li>\n</ul>\n<p>1.1.2 异常情况下生命周期分析</p>\n<ul>\n<li><p>(1)onSaveInstanceState方法只会出现在Activity被异常终止的情况下，它的调用时机是在onStop之前，它和onPause方法没有既定的时序关系，可能在它之前，也可能在它之后。</p>\n<p>  当Activity被重新创建的时候，onRestoreInstanceState会被回调，它的调用时机是onStart之后。</p>\n<p>  系统只会在Activity即将被销毁并且有机会重新显示的情况下才会去调用onSaveInstanceState方法。</p>\n<p>  当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据，比如文本框中用户输入的数据、listview滚动的位置等，这些view相关的状态系统都会默认为我们恢复。具体针对某一个view系统能为我们恢复哪些数据可以查看view的源码中的onSaveInstanceState和onRestoreInstanceState方法。</p>\n</li>\n<li><p>(2)Activity按优先级的分类</p>\n<p>  前台Activity；可见但非前台Activity；后台Activity</p>\n</li>\n<li><p>(3)android:configChanges=”xxx”属性，常用的主要有下面三个选项：</p>\n<p>  local：设备的本地位置发生了变化，一般指切换了系统语言；</p>\n<p>  keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘；</p>\n<p>  orientation：屏幕方向发生了变化，比如旋转了手机屏幕。</p>\n<p>  配置了android:configChanges=”xxx”属性之后，Activity就不会在对应变化发生时重新创建，而是调用Activity的onConfigurationChanged方法。</p>\n</li>\n</ul>\n<h4 id=\"1-2-Activity的启动模式\"><a href=\"#1-2-Activity的启动模式\" class=\"headerlink\" title=\"1.2 Activity的启动模式\"></a>1.2 Activity的启动模式</h4><h5 id=\"1-2-1-启动模式\"><a href=\"#1-2-1-启动模式\" class=\"headerlink\" title=\"1.2.1 启动模式\"></a>1.2.1 启动模式</h5><ul>\n<li><p>(1)当任务栈中没有任何Activity的时候，系统就会回收这个任务栈。</p>\n</li>\n<li><p>(2)从非Activity类型的Context(例如ApplicationContext、Service等)中以standard模式启动新的Activity是不行的，因为这类context并没有任务栈，所以需要为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标志位。</p>\n</li>\n<li><p>(3)任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。</p>\n</li>\n<li><p>(4)参数TaskAffinity用来指定Activity所需要的任务栈，意为任务相关性。</p>\n<p>  默认情况下，所有Activity所需的任务栈的名字为应用的包名。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。</p>\n<p>  当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中；</p>\n<p>  当TaskAffinity和allowTaskReparenting结合的时候，当一个应用A启动了应用B的某个Activity C后，如果Activity C的allowTaskReparenting属性设置为true的话，那么当应用B被启动后，系统会发现Activity C所需的任务栈存在了，就将Activity C从A的任务栈中转移到B的任务栈中。</p>\n</li>\n<li><p>(5)singleTask模式的具体分析：</p>\n<p>  当一个具有singleTask启动模式的Activity请求启动之后，系统首先会寻找是否存在A想要的任务栈，</p>\n<p>  如果不存在，就重新创建一个任务栈，然后创建Activity的实例把它放到栈中；如果存在Activity所需的任务栈，这时候要看栈中是否有Activity实例存在.</p>\n<p>  如果有，那么系统就会把该Activity实例调到栈顶，并调用它的onNewIntent方法(它之上的Activity会被迫出栈，所以singleTask模式具有FLAG_ACTIVITY_CLEAR_TOP效果)；如果Activity实例不存在，那么就创建Activity实例并把它压入栈中。</p>\n</li>\n<li><p>(6)设置启动模式既可以使用xml属性android:launchMode，也可以使用代码intent.addFlags()。区别在于限定范围不同，前者无法直接为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，而后者无法为Activity指定singleInstance模式。</p>\n</li>\n</ul>\n<h5 id=\"1-2-2-Activity的Flags\"><a href=\"#1-2-2-Activity的Flags\" class=\"headerlink\" title=\"1.2.2 Activity的Flags\"></a>1.2.2 Activity的Flags</h5><p>FLAG_ACTIVITY_NEW_TASK,FLAG_ACTIVITY_SINGLE_TOP,FLAG_ACTIVITY_CLEAR_TOP</p>\n<p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用，它等同于属性设置android:excludeFromRecents=”true”。</p>\n<h4 id=\"1-3-IntentFilter的匹配规则\"><a href=\"#1-3-IntentFilter的匹配规则\" class=\"headerlink\" title=\"1.3 IntentFilter的匹配规则\"></a>1.3 IntentFilter的匹配规则</h4><ul>\n<li><p>(1)IntentFilter中的过滤信息有action、category、data，为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。</p>\n<p>  一个过滤列表中的action、category、data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别和data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。此外，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intenf-filter即可成功启动对应的Activity。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;action android:name=\"com.ryg.charpter_1.c\" /&gt;</div><div class=\"line\">    &lt;action android:name=\"com.ryg.charpter_1.d\" /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;category android:name=\"com.ryg.category.c\" /&gt;</div><div class=\"line\">    &lt;category android:name=\"com.ryg.category.d\" /&gt;</div><div class=\"line\">    &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;data android:mimeType=\"text/plain\" /&gt;</div><div class=\"line\">&lt;/intent-filter&gt;</div><div class=\"line\">~~~  </div><div class=\"line\"></div><div class=\"line\">- (2)action匹配规则</div><div class=\"line\"></div><div class=\"line\">    只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，action匹配区分大小写。</div><div class=\"line\"></div><div class=\"line\">- (3)category匹配规则</div><div class=\"line\"></div><div class=\"line\">    Intent中如果有category那么所有的category都必须和过滤规则中的其中一个category相同，如果没有category的话那么就是默认的category，即android.intent.category.DEFAULT，所以为了Activity能够接收隐式调用，配置多个category的时候必须加上默认的category。</div><div class=\"line\"></div><div class=\"line\">- (4)data匹配规则</div><div class=\"line\"></div><div class=\"line\">    data的结构很复杂，语法大致如下：</div><div class=\"line\">~~~ Javascript</div><div class=\"line\">&lt;data android:scheme=\"string\"</div><div class=\"line\">\tandroid:host=\"string\"</div><div class=\"line\">\tandroid:port=\"string\"</div><div class=\"line\">\tandroid:path=\"string\"`</div><div class=\"line\">\tandroid:pathPattern=\"string\"</div><div class=\"line\">\tandroid:pathPrefix=\"string\"</div><div class=\"line\">\tandroid:mimeType=\"string\" /&gt;</div></pre></td></tr></table></figure>\n<p>  主要由mimeType和URI组成，其中mimeType代表媒体类型，而URI的结构也复杂，大致如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;scheme&gt;:<span class=\"comment\">//&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;]|[&lt;pathPrefix&gt;]|[pathPattern]</span></div></pre></td></tr></table></figure>\n<p>  例如content://com.example.project:200/folder/subfolder/etc</p>\n<ul>\n<li><p>scheme、host、port分别表示URI的模式、主机名和端口号，其中如果scheme或者host未指定那么URI就无效。</p>\n</li>\n<li><p>path、pathPattern、pathPrefix都是表示路径信息，其中path表示完整的路径信息，pathPrefix表示路径的前缀信息；pathPattern表示完整的路径，但是它里面包含了通配符(*)。</p>\n</li>\n</ul>\n<p>data匹配规则：Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。</p>\n<p>URI有默认的scheme！</p>\n<p>如果过滤规则中的mimeType指定为image/*或者text/*等这种类型的话，那么即使过滤规则中没有指定URI，URI有默认的scheme是content和file！如果过滤规则中指定了scheme的话那就不是默认的scheme了。</p>\n</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//URI有默认值</div><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;data android:mimeType=\"image/*\"/&gt;</div><div class=\"line\">  ...</div><div class=\"line\">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//URI默认值被覆盖</div><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;data android:mimeType=\"image/*\" android:scheme=\"http\" .../&gt;</div><div class=\"line\">    ...</div><div class=\"line\">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>\n<p>  如果要为Intent指定完整的data，必须要调用setDataAndType方法！</p>\n<p>  不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">intent.setDataAndType(Uri.parse(<span class=\"string\">\"file://abc\"</span>), <span class=\"string\">\"image/png\"</span>);</div></pre></td></tr></table></figure></p>\n<p>  data的下面两种写法作用是一样的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;data android:scheme=\"file\" android:host=\"www.github.com\"/&gt;</div><div class=\"line\">&lt;/intent-filter&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;data android:scheme=\"file\"/&gt;</div><div class=\"line\">    &lt;data android:host=\"www.github.com\"/&gt;</div><div class=\"line\">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>\n<p>  如何判断是否有Activity能够匹配我们的隐式Intent？</p>\n<ul>\n<li><p>(1)PackageManager的resolveActivity方法或者Intent的resolveActivity方法：如果找不到就会返回null</p>\n</li>\n<li><p>(2)PackageManager的queryIntentActivities方法：它返回所有成功匹配的Activity信息<br>针对Service和BroadcastReceiver等组件，PackageManager同样提供了类似的方法去获取成功匹配的组件信息，例如queryIntentServices、queryBroadcastReceivers等方法</p>\n</li>\n<li><p>有一类action和category比较重要，它们在一起用来标明这是一个入口Activity，并且会出现在系统的应用列表中。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;intent-filter&gt;</div><div class=\"line\">    &lt;action android:name=\"android.intent.action.MAIN\" /&gt;</div><div class=\"line\">    &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;</div><div class=\"line\">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"第2章-IPC机制\"><a href=\"#第2章-IPC机制\" class=\"headerlink\" title=\"第2章 IPC机制\"></a>第2章 IPC机制</h3><h4 id=\"2-1-Android-IPC简介\"><a href=\"#2-1-Android-IPC简介\" class=\"headerlink\" title=\"2.1 Android IPC简介\"></a>2.1 Android IPC简介</h4><p>(1)任何一个操作系统都需要有相应的IPC机制，Linux上可以通过命名通道、共享内存、信号量等来进行进程间通信。Android系统不仅可以使用了Binder机制来实现IPC，还可以使用Socket实现任意两个终端之间的通信。</p>\n<h4 id=\"2-2-Android中的多进程模式\"><a href=\"#2-2-Android中的多进程模式\" class=\"headerlink\" title=\"2.2 Android中的多进程模式\"></a>2.2 Android中的多进程模式</h4><ul>\n<li><p>(1)通过给四大组件指定android:process属性就可以开启多进程模式.</p>\n<p>  默认进程的进程名是包名packageName，进程名以:开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以:开头的进程属于全局进程，其他应用通过ShareUID方法可以和它跑在同一个进程中。</p>\n<p>  android:process=”:xyz” //进程名是 packageName:xyz</p>\n<p>  android:process=”aaa.bbb.ccc” //进程名是 aaa.bbb.ccc</p>\n</li>\n<li><p>(2)Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。</p>\n<p>  两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。 在这种情况下，它们可以相互访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。如果它们跑在同一个进程中，还可以共享内存数据，它们看起来就像是一个应用的两个部分。</p>\n</li>\n<li><p>(3)android系统会为每个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，所以不同的虚拟机中访问同一个类的对象会产生多个副本。</p>\n</li>\n<li><p>(4)使用多进程容易造成以下几个问题：</p>\n<ul>\n<li>1.静态成员和单例模式完全失效；</li>\n<li>2.线程同步机制完全失效：无论锁对象还是锁全局对象都无法保证线程同步；</li>\n<li>3.SharedPreferences的可靠性下降：SharedPreferences不支持并发读写；</li>\n<li><p>4.Application会多次创建：当一个组件跑在一个新的进程的时候，系统要在创建新的进程的同时分配独立的虚拟机，应用会重新启动一次，也就会创建新的Application。运行在同一个进程中的组件是属于同一个虚拟机和同一个Application。</p>\n<p>同一个应用的不同组件，如果它们运行在不同进程中，那么和它们分别属于两个应用没有本质区别。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-IPC基础概念介绍\"><a href=\"#2-3-IPC基础概念介绍\" class=\"headerlink\" title=\"2.3 IPC基础概念介绍\"></a>2.3 IPC基础概念介绍</h4><ul>\n<li><p>(1)Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口。</p>\n</li>\n<li><p>(2)serialVersionUId是一串long型数字，主要是用来辅助序列化和反序列化的，原则上序列化后的数据中的serialVersionUId只有和当前类的serialVersionUId相同才能够正常地被反序列化。</p>\n<p>serialVersionUId的详细工作机制：序列化的时候系统会把当前类的serialVersionUId写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUId，看它是否和当前类的serialVersionUId一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUId的值。</p>\n<ul>\n<li><p>1.静态成员变量属于类不属于对象，所以不参与序列化过程；</p>\n</li>\n<li><p>2.声明为transient的成员变量不参与序列化过程。</p>\n</li>\n</ul>\n</li>\n<li><p>(3)Parcelable接口内部包装了可序列化的数据，可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> bookId;</div><div class=\"line\">    <span class=\"keyword\">public</span> String bookName;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Book</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Book</span><span class=\"params\">(<span class=\"keyword\">int</span> bookId, String bookName)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.bookId = bookId;</div><div class=\"line\">        <span class=\"keyword\">this</span>.bookName = bookName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">describeContents</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeToParcel</span><span class=\"params\">(Parcel out, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</div><div class=\"line\">        out.writeInt(bookId);</div><div class=\"line\">        out.writeString(bookName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//实现反序列化操作</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class=\"keyword\">new</span> Parcelable.Creator&lt;Book&gt;() &#123;</div><div class=\"line\">        <span class=\"comment\">//从序列化后的对象中创建原始对象</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Book <span class=\"title\">createFromParcel</span><span class=\"params\">(Parcel in)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book(in);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">public</span> Book[] newArray(<span class=\"keyword\">int</span> size) &#123;<span class=\"comment\">//创建指定长度的原始对象数组</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book[size];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Book</span><span class=\"params\">(Parcel in)</span> </span>&#123;</div><div class=\"line\">        bookId = in.readInt();</div><div class=\"line\">        bookName = in.readString();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>(4)Binder是Android中的一个类，它实现了IBinder接口。</p>\n<p>从IPC角度看，Binder是Android中一种跨进程通信的方式；Binder还可以理解为虚拟的物理设备，它的设备驱动是/dev/binder；</p>\n<p>从Framework层角度看，Binder是ServiceManager连接各种Manager和相应的ManagerService的桥梁；</p>\n<p>从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>\n</li>\n</ul>\n<p>  在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。</p>\n<ul>\n<li><p>(5)aidl工具根据aidl文件自动生成的java接口的解析：</p>\n<p>首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；</p>\n<p>接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。</p>\n<p>所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：</p>\n<ul>\n<li>1.asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。</li>\n<li>2.asBinder：返回当前Binder对象。</li>\n<li><p>3.onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。</p>\n<p>这个方法的原型是public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)</p>\n<p>服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。</p>\n</li>\n<li><p>4.Proxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：</p>\n<p>首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。</p>\n</li>\n</ul>\n<p>如果搞清楚了自动生成的接口文件的结构和作用之后，其实是可以不用通过AIDL而直接实现Binder的，<a href=\"https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_2/src/com/ryg/chapter_2/manualbinder/BookManagerImpl.java\">主席写的示例代码</a></p>\n</li>\n<li><p>(6)Binder的两个重要方法linkToDeath和unlinkToDeath</p>\n<p>Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。</p>\n<p>如何给Binder设置死亡代理呢？</p>\n<ul>\n<li>1.声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> IBinder.DeathRecipient mDeathRecipient = <span class=\"keyword\">new</span> IBinder.DeathRecipient() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">binderDied</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mRemoteBookManager == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class=\"number\">0</span>);</div><div class=\"line\">        mRemoteBookManager = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span>这里重新绑定远程Service</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>2.在客户端绑定远程服务成功之后，给binder设置死亡代理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"2-4-Android中的IPC方式\"><a href=\"#2-4-Android中的IPC方式\" class=\"headerlink\" title=\"2.4 Android中的IPC方式\"></a>2.4 Android中的IPC方式</h4><ul>\n<li><p>(1)使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。</p>\n</li>\n<li><p>(2)使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。</p>\n<p>SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。</p>\n</li>\n<li><p>(3)使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形，详细的示例见原书。</p>\n</li>\n<li><p>(4)使用AIDL</p>\n<p>大致流程：首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。</p>\n<ul>\n<li>1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；</li>\n<li>2.某些类即使和AIDL文件在同一个包中也要显式import进来；</li>\n<li>3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；</li>\n<li>4.AIDL接口中支持方法，不支持声明静态变量；</li>\n<li>5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。</li>\n<li>6.RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。</li>\n</ul>\n</li>\n<li><p>(5)使用ContentProvider</p>\n<ul>\n<li>1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；</li>\n<li>2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；</li>\n<li>3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；</li>\n<li>4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；</li>\n</ul>\n</li>\n<li><p>(6)使用Socket</p>\n<p>Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。</p>\n</li>\n</ul>\n<h4 id=\"2-5-Binder连接池\"><a href=\"#2-5-Binder连接池\" class=\"headerlink\" title=\"2.5 Binder连接池\"></a>2.5 Binder连接池</h4><ul>\n<li><p>(1)当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。</p>\n<p>整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。</p>\n<p>Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。</p>\n</li>\n<li><p>(2)作者实现的Binder连接池BinderPool的实现源码，建议在AIDL开发工作中引入BinderPool机制。</p>\n</li>\n</ul>\n<h4 id=\"2-6-选用合适的IPC方式\"><a href=\"#2-6-选用合适的IPC方式\" class=\"headerlink\" title=\"2.6 选用合适的IPC方式\"></a>2.6 选用合适的IPC方式</h4><p><img src=\"/images/blogimages/2016/androidart_ipc.png\" alt=\"选择合适的IPC方式\"></p>\n<h3 id=\"第9章-四大组件的工作过程\"><a href=\"#第9章-四大组件的工作过程\" class=\"headerlink\" title=\"第9章 四大组件的工作过程\"></a>第9章 四大组件的工作过程</h3><p>本篇摘选自<a href=\"http://blog.csdn.net/amurocrash/article/details/48858353\">amurocrash的专栏</a></p>\n<h4 id=\"9-1-四大组件的运行状态\"><a href=\"#9-1-四大组件的运行状态\" class=\"headerlink\" title=\"9.1 四大组件的运行状态\"></a>9.1 四大组件的运行状态</h4><ul>\n<li>(1)四大组件中只有BroadcastReceiver既可以在AndroidManifest文件中注册，也可以在代码中注册，其他三个组件都必须在AndroidManifest文件中注册；ContentProvider的调用不需要借助Intent，其他三个组件都需要借助Intent。</li>\n<li>(2)Activity是一种展示型组件，用于向用户展示界面，可由显式或者隐式Intent来启动。</li>\n<li>(3)Service是一种计算型组件，用于在后台执行计算任务。尽管service是用于后台执行计算的，但是它本身是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。Service组件有两种状态：启动状态和绑定状态。当service处于绑定状态时，外界可以很方便的和service进行通信，而在启动状态中是不可与外界通信的。</li>\n<li>(4)BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息，它工作在系统内部。广播有两种注册方式：静态注册和动态注册。静态注册是在AndroidManifest中注册，在应用安装的时候会被系统解析，这种广播不需要应用启动就可以收到相应的广播。动态注册需要通过Context.registerReceiver()来注册，这种广播需要应用启动才能注册并接收广播。BroadcastReceiver组件一般来说不需要停止，它也没有停止的概念。</li>\n<li>(5)ContentProvider是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。ContentProvider中的insert、delete、update、query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的，另外ContentProvider组件也不需要手动停止。</li>\n</ul>\n<h4 id=\"9-2-Activity的工作过程\"><a href=\"#9-2-Activity的工作过程\" class=\"headerlink\" title=\"9.2 Activity的工作过程\"></a>9.2 Activity的工作过程</h4><h5 id=\"1-Activity启动的大致流程\"><a href=\"#1-Activity启动的大致流程\" class=\"headerlink\" title=\"(1)Activity启动的大致流程\"></a>(1)Activity启动的大致流程</h5><p><img src=\"/images/blogimages/2016/androidart_activity.png\" alt=\"Activity启动的大致流程\"></p>\n<p>(2)ApplicationThread是ActivityThread的一个内部类，它继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口，ApplicationThreadNative的作用其实就和系统为AIDL文件生成的类是一样的。<br>(3)ActivityManagerService(AMS)继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。<br>(4)一个应用只有一个Application对象，它的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。<br>(5)ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当window接收到外部输入事件后就可以将事件传递给Activity。 [这里可能有误，应该是Activity将事件传递给window]</p>\n<h4 id=\"9-3-Service的工作过程\"><a href=\"#9-3-Service的工作过程\" class=\"headerlink\" title=\"9.3 Service的工作过程\"></a>9.3 Service的工作过程</h4><h5 id=\"1-Service有两种状态：\"><a href=\"#1-Service有两种状态：\" class=\"headerlink\" title=\"(1)Service有两种状态：\"></a>(1)Service有两种状态：</h5><p>启动状态和绑定状态，两种状态是可以共存的。<br><strong>启动过程：</strong><br><img src=\"/images/blogimages/2016/androidart_service1.png\" alt=\"Service1\"></p>\n<p><strong>绑定过程：</strong><br><img src=\"/images/blogimages/2016/androidart_service2.png\" alt=\"Service2\"></p>\n<h4 id=\"9-4-BroadcastReceiver的工作过程\"><a href=\"#9-4-BroadcastReceiver的工作过程\" class=\"headerlink\" title=\"9.4 BroadcastReceiver的工作过程\"></a>9.4 BroadcastReceiver的工作过程</h4><h5 id=\"1-BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。\"><a href=\"#1-BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。\" class=\"headerlink\" title=\"(1)BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。\"></a>(1)BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。</h5><p><strong>注册过程</strong>：静态注册的时候是由PackageManagerService来完成整个注册过程，下面是动态注册的过程<br><img src=\"/images/blogimages/2016/androidart_broadcastreceiver1.png\" alt=\"broadcastreceiver1\"><br><strong>发送和接收</strong>：<br><img src=\"/images/blogimages/2016/androidart_broadcastreceiver2.png\" alt=\"broadcastreceiver2\"></p>\n<h5 id=\"2-广播的发送有几种类型：\"><a href=\"#2-广播的发送有几种类型：\" class=\"headerlink\" title=\"(2)广播的发送有几种类型：\"></a>(2)广播的发送有几种类型：</h5><p>普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是发送和接收过程是类似的。</p>\n<h5 id=\"3-一个应用处于停止状态分为两种情况：\"><a href=\"#3-一个应用处于停止状态分为两种情况：\" class=\"headerlink\" title=\"(3)一个应用处于停止状态分为两种情况：\"></a>(3)一个应用处于停止状态分为两种情况：</h5><p>一是应用安装后未运行；二是应用被手动或者其他应用强停了。从Android 3.1开始，处于停止状态的应用无法接受到开机广播。</p>\n<h4 id=\"9-5-ContentProvider的工作过程\"><a href=\"#9-5-ContentProvider的工作过程\" class=\"headerlink\" title=\"9.5 ContentProvider的工作过程\"></a>9.5 ContentProvider的工作过程</h4><h5 id=\"1-当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。\"><a href=\"#1-当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。\" class=\"headerlink\" title=\"(1)当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。\"></a>(1)当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。</h5><h5 id=\"2-ContentProvider的启动过程：\"><a href=\"#2-ContentProvider的启动过程：\" class=\"headerlink\" title=\"(2)ContentProvider的启动过程：\"></a>(2)ContentProvider的启动过程：</h5><ul>\n<li>1.当一个应用启动时，入口方法是ActivityThread的main方法，其中创建ActivityThread的实例并创建主线程的消息队列；</li>\n<li>2.ActivityThread的attach方法中会远程调用ActivityManagerService的attachApplication，并将ApplicationThread提供给AMS，ApplicationThread主要用于ActivityThread和AMS之间的通信；</li>\n<li>3.ActivityManagerService的attachApplication会调用ApplicationThread的bindApplication方法，这个方法会通过H切换到ActivityThread中去执行，即调用handleBindApplication方法；</li>\n<li>4.handleBindApplication方法会创建Application对象并加载ContentProvider，注意是先加载ContentProvider，然后调用Application的onCreate方法。</li>\n</ul>\n<h5 id=\"3-ContentProvider的android-multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。\"><a href=\"#3-ContentProvider的android-multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。\" class=\"headerlink\" title=\"(3)ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。\"></a>(3)ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。</h5><h5 id=\"4-当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：\"><a href=\"#4-当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：\" class=\"headerlink\" title=\"(4)当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：\"></a>(4)当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：</h5><p><img src=\"/images/blogimages/2016/androidart_contentprovider.png\" alt=\"ContentProvider\"></p>"},{"layout":"post","title":"android JNI学习① 基础知识","keywords":"jni, aes 加密","description":"android JNI学习，实现aes加密","banner":"http://obxk8w81b.bkt.clouddn.com/Avenue%20of%20Plane%20Trees%20near%20Arles%20Station.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Avenue%20of%20Plane%20Trees%20near%20Arles%20Station.jpg","_content":"\n\n\n本文只是用来记录，写的不好还请见谅。\n\n### 1.JNI介绍\nJNI概念 : Java本地接口,Java Native Interface, 它是一个协议, 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码;\n\nC和Java的侧重 :\n\n- C语言 : C语言中最重要的是 函数 function;\n- Java语言 : Java中最重要的是 JVM, class类, 以及class中的方法;\n\nC与Java如何交流 :\n\n- JNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范;\n- C语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法;\n- Java语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上;\n- JNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍;\n\n<!--more-->\n\nJNI中的一些概念 :\n\n- native : Java语言中修饰本地方法的修饰符, 被该修饰符修饰的方法没有方法体;\n- Native方法 : 在Java语言中被native关键字修饰的方法是Native方法;\n- JNI层 : Java声明Native方法的部分;\n- JNI函数 : JNIEnv提供的函数, 这些函数在jni.h中进行定义;\n- JNI方法 : Native方法对应的JNI层实现的 C/C++方法, 即在jni目录中实现的那些C语言代码;\n\n### 2.NDK简单介绍\nC代码执行 : C代码被编译成库文件之后, 才能执行, 库文件分为动态库 和静态库 两种;\n\n- 动态库 : unix环境下.so后缀的是动态库, windows环境下.dll 后缀的是动态库; 动态库可以依赖静态库加载一些可执行的C代码;\n- 静态库 :.a后缀是静态库的扩展名;\n\n库文件来源 : C代码 进行 编译 链接操作之后, 才会生成库文件, 不同类型的CPU 操作系统 生成的库文件是不一样;\n\n- CPU分类 : arm结构, 嵌入式设备处理器; x86结构, pc服务器处理器; 不同的CPU指令集不同;\n- 交叉编译 :windows x86编译出来的库文件可以在arm平台运行的代码;\n- 交叉编译工具链 : Google提供的 NDK 就是交叉编译工具链, 可以在linux环境下编译出在arn平台下执行的二进制库文件;\n\nNDK作用 : 是Google提供了交叉编译工具链, 能够在linux平台编译出在arm平台下执行的二进制库文件;\n\nNDK版本介绍 : android-ndk-windows 是在windows系统中的cygwin使用的, android-ndk-linux 是在linux下使用的;\n\n想深入了解NDK开发的同学，可以去安装一下cygwin，本文只涉及简单的C语言代码，不需要使用cygwin。\n\n### 3.环境准备，使用android studio还是Eclipse\n推荐使用Eclipse，这篇文章讲了使用Eclipse生成.h文件和生成so文件的配置过程。配置成功后可以远离命令行[Eclipse ADT插件生成.h/.so文件](http://blog.csdn.net/jspping/article/details/47780307)\n\n#### 3.1 Java调用C流程\n\n- a. 定义 Native 方法 : 比如在com.packagename.jni.JNITest.java 类中定义 Native 方法 public native int add(int x, int y);\n- b. 生成方法签名 : 进入 AndroidProject/bin/classes 目录, 使用 javah com.packagename.jni.JNITest 命令, 便生成了头文件, 该头文件引用了 jni.h, 以及定义好了对应的 Native 方法, 生成 JNIEXPORT jint JNICALL Java_com_packagename_jni_JNITest_add (JNIEnv \\*, jobject, jint, jint);  \n\nJava中定义的方法 :\n\n~~~ Java\n//将Java中的两个int值 传给C语言, 进行相加后, 返回java语言 shuliang.han.ndkparameterpassing.DataProvider  \npublic native int add(int x, int y);  \n~~~\n对应C语言中定义的方法 :\n\n~~~ C++\n#include <jni.h>  \n\n//方法签名, Java环境和调用native方法的类必不可少, 后面的参数就是native方法的参数  \njint Java_com_packagename_jni_JNITest_add(JNIEnv * env, jobject obj, jint x, jint y)  \n{  \n    return x + y;  \n}  \n~~~\n\n#### 3.2 生成.so文件\n\nAndroid.mk 文件：\n\n~~~ C++\nLOCAL_PATH := $(call my-dir)    \n\ninclude $(CLEAR_VARS)    \n\nLOCAL_MODULE    := hello-jni    \nLOCAL_SRC_FILES := hello-jni.c    \n\ninclude $(BUILD_SHARED_LIBRARY)  \n~~~\n\n- 文件内容解释：\n\n  **获取当前文件内容** : $(call my-dir) 是编译器中的宏方法, 调用该宏方法, 就会返回前的目录路径;\n\n  **赋值符号** : \" := \" 是赋值符号, 第一句话 是 返回当前文件所在的当前目录, 并将这个目录路径赋值给 LOCAL_PATH;\n\n  **初始化编译模块参数** : $(CLEAR_VARS) 作用是将编译模块的参数初始化, LOCAL_MODULE LOCAL_SRC_FILES 也是这样的参数;\n\n  **指定编译模块** : LOCAL_MODULE    := hello-jni , 指定编译后的 so 文件名称, 编译好之后系统会在该名称前面加上 \"lib\", 后缀加上 \".so\";\n\n  **指定编译源文件** : LOCAL_SRC_FILES := hello-jni.c 告诉编译系统源文件, 如果有多个文件那么就依次写在后面即可;\n\n  **编译成静态库** : include $(BUILD_SHARED_LIBRARY), 作用是告诉系统, 将编译的结果编译成.so后缀的静态库;\n\n  **静态库引入** : NDK的platform中有很多 \".a\" 结尾的动态库, 我们编译动态库的时候, 可以将一些静态库引入进来;\n\n- 生成 动态库 so 文件 : 进入 Android.mk 所在目录, 在该目录执行ndk下的ndk-build命令;\n- Java代码加载动态库 : 在 Java 代码中调用该类的类前面, 在类的一开始, 不在方法中, 加入\n\n~~~ C++\nstatic{ System.loadLibrary(\"hello\"); } ;\n~~~\n\n- Application.mk 文件内容为（不写这个文件也可以）:\n\n~~~ Java\nAPP_STL := stlport_static\nAPP_ABI := all\n~~~\n\n<!-- ![]({{ site.url }}/assets/img/jni_structure.png  =338x461) -->\n<!-- 指定图片大小有问题 -->\n\n<!-- [![Pure CSS Happy Hacking Keyboard](/assets/img/jni_structure.png)](http://codepen.io/P233/pen/qEagi) -->\n![Eclipse JNI目录结构](/images/blogimages/2016/jni_structure.png)\n\n[这篇文章](http://blog.csdn.net/hejinjing_tom_com/article/details/8125648)是使用javah导出头文件过程中，常见错误和解决办法，这里做一个记录。\n\n\n### 4.字符串的处理\n\n- Java中的String转为C语言中的char字符串\n下面的工具方法可以在C程序中解决这个问题：\n\n~~~ Javascript\n// java中的jstring, 转化为c的一个字符数组  \nchar* Jstring2CStr(JNIEnv* env, jstring jstr) {  \n//声明了一个字符串变量 rtn  \nchar* rtn = NULL;  \n//找到Java中的String的Class对象  \njclass clsstring = (*env)->FindClass(env, \"java/lang/String\");  \n//创建一个Java中的字符串 \"GB2312\"  \njstring strencode = (*env)->NewStringUTF(env, \"GB2312\");  \n/*\n * 获取String中定义的方法 getBytes(), 该方法的参数是 String类型的, 返回值是 byte[]数组\n * \"(Ljava/lang/String;)[B\" 方法前面解析 :\n * -- Ljava/lang/String; 表示参数是String字符串\n * -- [B : 中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组\n */  \njmethodID mid = (*env)->GetMethodID(env, clsstring, \"getBytes\",  \n\t\t\"(Ljava/lang/String;)[B\");  \n//调用Java中的getBytes方法, 传入参数介绍 参数②表示调用该方法的对象, 参数③表示方法id , 参数④表示方法参数  \njbyteArray barr = (jbyteArray)(*env)->CallObjectMethod(env, jstr, mid,  \n\t\tstrencode); // String .getByte(\"GB2312\");  \n//获取数组的长度  \njsize alen = (*env)->GetArrayLength(env, barr);  \n//获取数组中的所有的元素 , 存放在 jbyte*数组中  \njbyte* ba = (*env)->GetByteArrayElements(env, barr, JNI_FALSE);  \n//将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 '\\0'  \nif (alen > 0) {  \n\trtn = (char*) malloc(alen + 1); //new   char[alen+1]; \"\\0\"  \n\tmemcpy(rtn, ba, alen);  \n\trtn[alen] = 0;  \n}  \n(*env)->ReleaseByteArrayElements(env, barr, ba, 0); //释放内存  \n\treturn rtn;  \n}  \n~~~\n\n- Jstring2CStr方法讲解 :\n   - a. 获取Java中String类型的class对象 : 参数 : 上下文环境 env, String类完整路径 ;\n~~~ Javascript\njclass clsstring = (*env)->FindClass(env, \"java/lang/String\");  \n~~~\n   - b.创建Java字符串 : 使用 NewStringUTF 方法;\n~~~ Javascript\njstring strencode = (*env)->NewStringUTF(env, \"GB2312\");  \n~~~   \n   - c.获取String中的getBytes()方法 : 参数介绍 ① env 上下文环境 ② 完整的类路径 ③ 方法名 ④ 方法签名, 方法签名 Ljava/lang/String; 代表参数是String字符串, [B  中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组;\n~~~ Javascript\njmethodID mid = (*env)->GetMethodID(env, clsstring, \"getBytes\",  \n    \"(Ljava/lang/String;)[B\");  \n~~~       \n   - d. 获取数组的长度 :\n~~~ Javascript\njsize alen = (*env)->GetArrayLength(env, barr);  \n~~~\n   - e. 获取数组元素 : 获取数组中的所有的元素 , 存放在 jbyte*数组中;\n~~~ Javascript\njbyte* ba = (*env)->GetByteArrayElements(env, barr, JNI_FALSE);  \n~~~\n   - f.数组拷贝: 将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 '\\0';\n~~~ Javascript\nif (alen > 0) {  \n    rtn = (char*) malloc(alen + 1); //new   char[alen+1]; \"\\0\"  \n    memcpy(rtn, ba, alen);  \n    rtn[alen] = 0;  \n}  \n~~~\n   - g.释放内存 :\n~~~ Javascript\n(*env)->ReleaseByteArrayElements(env, barr, ba, 0); //释放内存\n~~~\n\n### 5.JNI方法命名规则(标准JNI规范)\n\n- **JNI实现的方法与Java中Native方法的映射关系 :**\n\n  使用方法名进行映射, 可以使用javah工具进入bin/classes目录下执行命令, 即可生成头文件;\n\n- **JNI方法参数介绍:**\n\n  参数① : 第一个参数是JNI接口指针JNIEnv;\n\n  参数② : 如果Native方法是非静态的, 那么第二个参数就是对Java对象的引用, 如果Native方法是静态的, 那么第二个参数就是对Java类的Class对象的引用;\n\n- **JNI方法名规范:**  \n\n  返回值+Java前缀+全路径类名+方法名+参数① JNIEnv+参数② jobject+其它参数;\n\n  注意分隔符 : Java前缀 与 类名 以及类名之间的包名 和 方法名之间 使用 \"\\_\" 进行分割;\n\n- **声明 非静态 方法:**\n\n  Native方法 : public int hello (String str, int i);\n\n  JNI方法: jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject obj, jstring str, jint i);\n\n- **声明 静态 方法 :**\n\n  Native方法 : public static int hello (String str, int i);\n\n  JNI方法 : jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject clazz, jstring str, jint i);\n\n- **两种规范 :**\n\n  以上是Java的标准JNI规范, 在Android中还有一套自定义的规范, 该规范是Android应用框架层 和 框架层交互使用的JNI规范, 依靠方法注册 映射 Native方法 和 JNI方法;\n\n- **JNIEnv作用 :**\n\n  JNIEnv 是一个指针,指向了一组JNI函数, 这些函数可以在jni.h中查询到,通过这些函数可以实现 Java层 与 JNI层的交互 , 通过JNIEnv 调用JNI函数 可以访问java虚拟机, 操作java对象;\n\n- **JNI线程相关性 :**\n\n  JNIEnv只在当前的线程有效,JNIEnv不能跨线程传递, 相同的Java线程调用本地方法, 所使用的JNIEnv是相同的, 一个Native方法不能被不同的Java线程调用;\n\n- **JNIEnv结构体系 :**\n\n  JNIEnv指针指向一个线程相关的结构,线程相关结构指向一个指针数组,指针数组中的每个元素最终指向一个JNI函数.\n\n### 6.AES加密实现\n网上有几种AES实现的方式：\n\n- 1.这个是我现在项目中使用的方法，在Github上有这个工程，这种方式是使用JNI生成一个与设备相关的密码，可以将该密码作为AES的密钥。[链接地址](https://github.com/MasonLiuChn/AndroidUltimateEncrypt)\n\n- 2.网上还有一种方式是由JNI生成keyValue和iv，Java层使用：[链接地址](http://blog.csdn.net/why_2012_gogo/article/details/40055245)\n\n主要代码：\n\n~~~ Java\nstatic {\n\tSystem.loadLibrary(\"cwtlib\");\n\tkeyValue = getKeyValue();\n\tiv = getIv();\n\n\tif(null != keyValue &&\n\t\tnull != iv) {\n\t\tKeyGenerator kgen;  \n        try {  \n            kgen = KeyGenerator.getInstance(\"AES\");  \n            kgen.init(128, new SecureRandom(keyValue));  \n            key = kgen.generateKey();  \n            paramSpec = new IvParameterSpec(iv);  \n            ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");         \n        } catch (NoSuchAlgorithmException e) {  \n        } catch (NoSuchPaddingException e) {  \n        }  \n\t}\n}   \n\npublic static native byte[] getKeyValue();\npublic static native byte[] getIv();\n~~~\n\n  这种方式，在android app程序完全退出后，再进入该app时，之前加密好的字符串**无法解密。**\n\n- 3.还有一种是直接由C或C++实现AES整个算法，直接使用网上代码并不知道靠不靠谱\n\n  所以，我们项目最终使用了第一种方法\n\n### 7.JNI混淆问题\n\n  检查下 C/C++代码中没有直接访问Java代码的类或者类的成员变量、类的成员函数。\n\n  如果有的话，这些就不能混淆\n\n~~~ Java\n//保留jni的回调类\n-keep class com.your.jnicallback.class { *; }\n//这个不用更改，直接复制就可以\n-keepclasseswithmembernames class * {\n    native <methods>;\n}\n~~~\n\n### 8.总结\nandroid 实现JNI入门并不难，笔者也刚刚入门，但要深入了解还是需要很长的路要走。\n\n#### 8.1 更新内容，JNI获取publickey实现\n在本文中最终使用第6点中的第一种方式，但原方法在4.0.4手机上遇到兼容性问题，详情请看我的这篇博客[使用JNI获取publickey实现](https://agehua.github.io/2016/05/24/JNI-Learning0/)\n","source":"_posts/2016-05-24-JNI-Learning.md","raw":"---\nlayout: post\ntitle: android JNI学习① 基础知识\ncategory: accumulation\ntags: Android JNI\nkeywords: jni, aes 加密\ndescription: android JNI学习，实现aes加密\nbanner: http://obxk8w81b.bkt.clouddn.com/Avenue%20of%20Plane%20Trees%20near%20Arles%20Station.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Avenue%20of%20Plane%20Trees%20near%20Arles%20Station.jpg\n---\n\n\n\n本文只是用来记录，写的不好还请见谅。\n\n### 1.JNI介绍\nJNI概念 : Java本地接口,Java Native Interface, 它是一个协议, 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码;\n\nC和Java的侧重 :\n\n- C语言 : C语言中最重要的是 函数 function;\n- Java语言 : Java中最重要的是 JVM, class类, 以及class中的方法;\n\nC与Java如何交流 :\n\n- JNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范;\n- C语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法;\n- Java语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上;\n- JNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍;\n\n<!--more-->\n\nJNI中的一些概念 :\n\n- native : Java语言中修饰本地方法的修饰符, 被该修饰符修饰的方法没有方法体;\n- Native方法 : 在Java语言中被native关键字修饰的方法是Native方法;\n- JNI层 : Java声明Native方法的部分;\n- JNI函数 : JNIEnv提供的函数, 这些函数在jni.h中进行定义;\n- JNI方法 : Native方法对应的JNI层实现的 C/C++方法, 即在jni目录中实现的那些C语言代码;\n\n### 2.NDK简单介绍\nC代码执行 : C代码被编译成库文件之后, 才能执行, 库文件分为动态库 和静态库 两种;\n\n- 动态库 : unix环境下.so后缀的是动态库, windows环境下.dll 后缀的是动态库; 动态库可以依赖静态库加载一些可执行的C代码;\n- 静态库 :.a后缀是静态库的扩展名;\n\n库文件来源 : C代码 进行 编译 链接操作之后, 才会生成库文件, 不同类型的CPU 操作系统 生成的库文件是不一样;\n\n- CPU分类 : arm结构, 嵌入式设备处理器; x86结构, pc服务器处理器; 不同的CPU指令集不同;\n- 交叉编译 :windows x86编译出来的库文件可以在arm平台运行的代码;\n- 交叉编译工具链 : Google提供的 NDK 就是交叉编译工具链, 可以在linux环境下编译出在arn平台下执行的二进制库文件;\n\nNDK作用 : 是Google提供了交叉编译工具链, 能够在linux平台编译出在arm平台下执行的二进制库文件;\n\nNDK版本介绍 : android-ndk-windows 是在windows系统中的cygwin使用的, android-ndk-linux 是在linux下使用的;\n\n想深入了解NDK开发的同学，可以去安装一下cygwin，本文只涉及简单的C语言代码，不需要使用cygwin。\n\n### 3.环境准备，使用android studio还是Eclipse\n推荐使用Eclipse，这篇文章讲了使用Eclipse生成.h文件和生成so文件的配置过程。配置成功后可以远离命令行[Eclipse ADT插件生成.h/.so文件](http://blog.csdn.net/jspping/article/details/47780307)\n\n#### 3.1 Java调用C流程\n\n- a. 定义 Native 方法 : 比如在com.packagename.jni.JNITest.java 类中定义 Native 方法 public native int add(int x, int y);\n- b. 生成方法签名 : 进入 AndroidProject/bin/classes 目录, 使用 javah com.packagename.jni.JNITest 命令, 便生成了头文件, 该头文件引用了 jni.h, 以及定义好了对应的 Native 方法, 生成 JNIEXPORT jint JNICALL Java_com_packagename_jni_JNITest_add (JNIEnv \\*, jobject, jint, jint);  \n\nJava中定义的方法 :\n\n~~~ Java\n//将Java中的两个int值 传给C语言, 进行相加后, 返回java语言 shuliang.han.ndkparameterpassing.DataProvider  \npublic native int add(int x, int y);  \n~~~\n对应C语言中定义的方法 :\n\n~~~ C++\n#include <jni.h>  \n\n//方法签名, Java环境和调用native方法的类必不可少, 后面的参数就是native方法的参数  \njint Java_com_packagename_jni_JNITest_add(JNIEnv * env, jobject obj, jint x, jint y)  \n{  \n    return x + y;  \n}  \n~~~\n\n#### 3.2 生成.so文件\n\nAndroid.mk 文件：\n\n~~~ C++\nLOCAL_PATH := $(call my-dir)    \n\ninclude $(CLEAR_VARS)    \n\nLOCAL_MODULE    := hello-jni    \nLOCAL_SRC_FILES := hello-jni.c    \n\ninclude $(BUILD_SHARED_LIBRARY)  \n~~~\n\n- 文件内容解释：\n\n  **获取当前文件内容** : $(call my-dir) 是编译器中的宏方法, 调用该宏方法, 就会返回前的目录路径;\n\n  **赋值符号** : \" := \" 是赋值符号, 第一句话 是 返回当前文件所在的当前目录, 并将这个目录路径赋值给 LOCAL_PATH;\n\n  **初始化编译模块参数** : $(CLEAR_VARS) 作用是将编译模块的参数初始化, LOCAL_MODULE LOCAL_SRC_FILES 也是这样的参数;\n\n  **指定编译模块** : LOCAL_MODULE    := hello-jni , 指定编译后的 so 文件名称, 编译好之后系统会在该名称前面加上 \"lib\", 后缀加上 \".so\";\n\n  **指定编译源文件** : LOCAL_SRC_FILES := hello-jni.c 告诉编译系统源文件, 如果有多个文件那么就依次写在后面即可;\n\n  **编译成静态库** : include $(BUILD_SHARED_LIBRARY), 作用是告诉系统, 将编译的结果编译成.so后缀的静态库;\n\n  **静态库引入** : NDK的platform中有很多 \".a\" 结尾的动态库, 我们编译动态库的时候, 可以将一些静态库引入进来;\n\n- 生成 动态库 so 文件 : 进入 Android.mk 所在目录, 在该目录执行ndk下的ndk-build命令;\n- Java代码加载动态库 : 在 Java 代码中调用该类的类前面, 在类的一开始, 不在方法中, 加入\n\n~~~ C++\nstatic{ System.loadLibrary(\"hello\"); } ;\n~~~\n\n- Application.mk 文件内容为（不写这个文件也可以）:\n\n~~~ Java\nAPP_STL := stlport_static\nAPP_ABI := all\n~~~\n\n<!-- ![]({{ site.url }}/assets/img/jni_structure.png  =338x461) -->\n<!-- 指定图片大小有问题 -->\n\n<!-- [![Pure CSS Happy Hacking Keyboard](/assets/img/jni_structure.png)](http://codepen.io/P233/pen/qEagi) -->\n![Eclipse JNI目录结构](/images/blogimages/2016/jni_structure.png)\n\n[这篇文章](http://blog.csdn.net/hejinjing_tom_com/article/details/8125648)是使用javah导出头文件过程中，常见错误和解决办法，这里做一个记录。\n\n\n### 4.字符串的处理\n\n- Java中的String转为C语言中的char字符串\n下面的工具方法可以在C程序中解决这个问题：\n\n~~~ Javascript\n// java中的jstring, 转化为c的一个字符数组  \nchar* Jstring2CStr(JNIEnv* env, jstring jstr) {  \n//声明了一个字符串变量 rtn  \nchar* rtn = NULL;  \n//找到Java中的String的Class对象  \njclass clsstring = (*env)->FindClass(env, \"java/lang/String\");  \n//创建一个Java中的字符串 \"GB2312\"  \njstring strencode = (*env)->NewStringUTF(env, \"GB2312\");  \n/*\n * 获取String中定义的方法 getBytes(), 该方法的参数是 String类型的, 返回值是 byte[]数组\n * \"(Ljava/lang/String;)[B\" 方法前面解析 :\n * -- Ljava/lang/String; 表示参数是String字符串\n * -- [B : 中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组\n */  \njmethodID mid = (*env)->GetMethodID(env, clsstring, \"getBytes\",  \n\t\t\"(Ljava/lang/String;)[B\");  \n//调用Java中的getBytes方法, 传入参数介绍 参数②表示调用该方法的对象, 参数③表示方法id , 参数④表示方法参数  \njbyteArray barr = (jbyteArray)(*env)->CallObjectMethod(env, jstr, mid,  \n\t\tstrencode); // String .getByte(\"GB2312\");  \n//获取数组的长度  \njsize alen = (*env)->GetArrayLength(env, barr);  \n//获取数组中的所有的元素 , 存放在 jbyte*数组中  \njbyte* ba = (*env)->GetByteArrayElements(env, barr, JNI_FALSE);  \n//将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 '\\0'  \nif (alen > 0) {  \n\trtn = (char*) malloc(alen + 1); //new   char[alen+1]; \"\\0\"  \n\tmemcpy(rtn, ba, alen);  \n\trtn[alen] = 0;  \n}  \n(*env)->ReleaseByteArrayElements(env, barr, ba, 0); //释放内存  \n\treturn rtn;  \n}  \n~~~\n\n- Jstring2CStr方法讲解 :\n   - a. 获取Java中String类型的class对象 : 参数 : 上下文环境 env, String类完整路径 ;\n~~~ Javascript\njclass clsstring = (*env)->FindClass(env, \"java/lang/String\");  \n~~~\n   - b.创建Java字符串 : 使用 NewStringUTF 方法;\n~~~ Javascript\njstring strencode = (*env)->NewStringUTF(env, \"GB2312\");  \n~~~   \n   - c.获取String中的getBytes()方法 : 参数介绍 ① env 上下文环境 ② 完整的类路径 ③ 方法名 ④ 方法签名, 方法签名 Ljava/lang/String; 代表参数是String字符串, [B  中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组;\n~~~ Javascript\njmethodID mid = (*env)->GetMethodID(env, clsstring, \"getBytes\",  \n    \"(Ljava/lang/String;)[B\");  \n~~~       \n   - d. 获取数组的长度 :\n~~~ Javascript\njsize alen = (*env)->GetArrayLength(env, barr);  \n~~~\n   - e. 获取数组元素 : 获取数组中的所有的元素 , 存放在 jbyte*数组中;\n~~~ Javascript\njbyte* ba = (*env)->GetByteArrayElements(env, barr, JNI_FALSE);  \n~~~\n   - f.数组拷贝: 将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 '\\0';\n~~~ Javascript\nif (alen > 0) {  \n    rtn = (char*) malloc(alen + 1); //new   char[alen+1]; \"\\0\"  \n    memcpy(rtn, ba, alen);  \n    rtn[alen] = 0;  \n}  \n~~~\n   - g.释放内存 :\n~~~ Javascript\n(*env)->ReleaseByteArrayElements(env, barr, ba, 0); //释放内存\n~~~\n\n### 5.JNI方法命名规则(标准JNI规范)\n\n- **JNI实现的方法与Java中Native方法的映射关系 :**\n\n  使用方法名进行映射, 可以使用javah工具进入bin/classes目录下执行命令, 即可生成头文件;\n\n- **JNI方法参数介绍:**\n\n  参数① : 第一个参数是JNI接口指针JNIEnv;\n\n  参数② : 如果Native方法是非静态的, 那么第二个参数就是对Java对象的引用, 如果Native方法是静态的, 那么第二个参数就是对Java类的Class对象的引用;\n\n- **JNI方法名规范:**  \n\n  返回值+Java前缀+全路径类名+方法名+参数① JNIEnv+参数② jobject+其它参数;\n\n  注意分隔符 : Java前缀 与 类名 以及类名之间的包名 和 方法名之间 使用 \"\\_\" 进行分割;\n\n- **声明 非静态 方法:**\n\n  Native方法 : public int hello (String str, int i);\n\n  JNI方法: jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject obj, jstring str, jint i);\n\n- **声明 静态 方法 :**\n\n  Native方法 : public static int hello (String str, int i);\n\n  JNI方法 : jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject clazz, jstring str, jint i);\n\n- **两种规范 :**\n\n  以上是Java的标准JNI规范, 在Android中还有一套自定义的规范, 该规范是Android应用框架层 和 框架层交互使用的JNI规范, 依靠方法注册 映射 Native方法 和 JNI方法;\n\n- **JNIEnv作用 :**\n\n  JNIEnv 是一个指针,指向了一组JNI函数, 这些函数可以在jni.h中查询到,通过这些函数可以实现 Java层 与 JNI层的交互 , 通过JNIEnv 调用JNI函数 可以访问java虚拟机, 操作java对象;\n\n- **JNI线程相关性 :**\n\n  JNIEnv只在当前的线程有效,JNIEnv不能跨线程传递, 相同的Java线程调用本地方法, 所使用的JNIEnv是相同的, 一个Native方法不能被不同的Java线程调用;\n\n- **JNIEnv结构体系 :**\n\n  JNIEnv指针指向一个线程相关的结构,线程相关结构指向一个指针数组,指针数组中的每个元素最终指向一个JNI函数.\n\n### 6.AES加密实现\n网上有几种AES实现的方式：\n\n- 1.这个是我现在项目中使用的方法，在Github上有这个工程，这种方式是使用JNI生成一个与设备相关的密码，可以将该密码作为AES的密钥。[链接地址](https://github.com/MasonLiuChn/AndroidUltimateEncrypt)\n\n- 2.网上还有一种方式是由JNI生成keyValue和iv，Java层使用：[链接地址](http://blog.csdn.net/why_2012_gogo/article/details/40055245)\n\n主要代码：\n\n~~~ Java\nstatic {\n\tSystem.loadLibrary(\"cwtlib\");\n\tkeyValue = getKeyValue();\n\tiv = getIv();\n\n\tif(null != keyValue &&\n\t\tnull != iv) {\n\t\tKeyGenerator kgen;  \n        try {  \n            kgen = KeyGenerator.getInstance(\"AES\");  \n            kgen.init(128, new SecureRandom(keyValue));  \n            key = kgen.generateKey();  \n            paramSpec = new IvParameterSpec(iv);  \n            ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");         \n        } catch (NoSuchAlgorithmException e) {  \n        } catch (NoSuchPaddingException e) {  \n        }  \n\t}\n}   \n\npublic static native byte[] getKeyValue();\npublic static native byte[] getIv();\n~~~\n\n  这种方式，在android app程序完全退出后，再进入该app时，之前加密好的字符串**无法解密。**\n\n- 3.还有一种是直接由C或C++实现AES整个算法，直接使用网上代码并不知道靠不靠谱\n\n  所以，我们项目最终使用了第一种方法\n\n### 7.JNI混淆问题\n\n  检查下 C/C++代码中没有直接访问Java代码的类或者类的成员变量、类的成员函数。\n\n  如果有的话，这些就不能混淆\n\n~~~ Java\n//保留jni的回调类\n-keep class com.your.jnicallback.class { *; }\n//这个不用更改，直接复制就可以\n-keepclasseswithmembernames class * {\n    native <methods>;\n}\n~~~\n\n### 8.总结\nandroid 实现JNI入门并不难，笔者也刚刚入门，但要深入了解还是需要很长的路要走。\n\n#### 8.1 更新内容，JNI获取publickey实现\n在本文中最终使用第6点中的第一种方式，但原方法在4.0.4手机上遇到兼容性问题，详情请看我的这篇博客[使用JNI获取publickey实现](https://agehua.github.io/2016/05/24/JNI-Learning0/)\n","slug":"JNI-Learning","published":1,"date":"2016-05-23T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj4k000mbxs6ltqfvndk","content":"<p>本文只是用来记录，写的不好还请见谅。</p>\n<h3 id=\"1-JNI介绍\"><a href=\"#1-JNI介绍\" class=\"headerlink\" title=\"1.JNI介绍\"></a>1.JNI介绍</h3><p>JNI概念 : Java本地接口,Java Native Interface, 它是一个协议, 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码;</p>\n<p>C和Java的侧重 :</p>\n<ul>\n<li>C语言 : C语言中最重要的是 函数 function;</li>\n<li>Java语言 : Java中最重要的是 JVM, class类, 以及class中的方法;</li>\n</ul>\n<p>C与Java如何交流 :</p>\n<ul>\n<li>JNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范;</li>\n<li>C语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法;</li>\n<li>Java语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上;</li>\n<li>JNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍;</li>\n</ul>\n<a id=\"more\"></a>\n<p>JNI中的一些概念 :</p>\n<ul>\n<li>native : Java语言中修饰本地方法的修饰符, 被该修饰符修饰的方法没有方法体;</li>\n<li>Native方法 : 在Java语言中被native关键字修饰的方法是Native方法;</li>\n<li>JNI层 : Java声明Native方法的部分;</li>\n<li>JNI函数 : JNIEnv提供的函数, 这些函数在jni.h中进行定义;</li>\n<li>JNI方法 : Native方法对应的JNI层实现的 C/C++方法, 即在jni目录中实现的那些C语言代码;</li>\n</ul>\n<h3 id=\"2-NDK简单介绍\"><a href=\"#2-NDK简单介绍\" class=\"headerlink\" title=\"2.NDK简单介绍\"></a>2.NDK简单介绍</h3><p>C代码执行 : C代码被编译成库文件之后, 才能执行, 库文件分为动态库 和静态库 两种;</p>\n<ul>\n<li>动态库 : unix环境下.so后缀的是动态库, windows环境下.dll 后缀的是动态库; 动态库可以依赖静态库加载一些可执行的C代码;</li>\n<li>静态库 :.a后缀是静态库的扩展名;</li>\n</ul>\n<p>库文件来源 : C代码 进行 编译 链接操作之后, 才会生成库文件, 不同类型的CPU 操作系统 生成的库文件是不一样;</p>\n<ul>\n<li>CPU分类 : arm结构, 嵌入式设备处理器; x86结构, pc服务器处理器; 不同的CPU指令集不同;</li>\n<li>交叉编译 :windows x86编译出来的库文件可以在arm平台运行的代码;</li>\n<li>交叉编译工具链 : Google提供的 NDK 就是交叉编译工具链, 可以在linux环境下编译出在arn平台下执行的二进制库文件;</li>\n</ul>\n<p>NDK作用 : 是Google提供了交叉编译工具链, 能够在linux平台编译出在arm平台下执行的二进制库文件;</p>\n<p>NDK版本介绍 : android-ndk-windows 是在windows系统中的cygwin使用的, android-ndk-linux 是在linux下使用的;</p>\n<p>想深入了解NDK开发的同学，可以去安装一下cygwin，本文只涉及简单的C语言代码，不需要使用cygwin。</p>\n<h3 id=\"3-环境准备，使用android-studio还是Eclipse\"><a href=\"#3-环境准备，使用android-studio还是Eclipse\" class=\"headerlink\" title=\"3.环境准备，使用android studio还是Eclipse\"></a>3.环境准备，使用android studio还是Eclipse</h3><p>推荐使用Eclipse，这篇文章讲了使用Eclipse生成.h文件和生成so文件的配置过程。配置成功后可以远离命令行<a href=\"http://blog.csdn.net/jspping/article/details/47780307\" target=\"_blank\" rel=\"external\">Eclipse ADT插件生成.h/.so文件</a></p>\n<h4 id=\"3-1-Java调用C流程\"><a href=\"#3-1-Java调用C流程\" class=\"headerlink\" title=\"3.1 Java调用C流程\"></a>3.1 Java调用C流程</h4><ul>\n<li>a. 定义 Native 方法 : 比如在com.packagename.jni.JNITest.java 类中定义 Native 方法 public native int add(int x, int y);</li>\n<li>b. 生成方法签名 : 进入 AndroidProject/bin/classes 目录, 使用 javah com.packagename.jni.JNITest 命令, 便生成了头文件, 该头文件引用了 jni.h, 以及定义好了对应的 Native 方法, 生成 JNIEXPORT jint JNICALL Java_com_packagename_jni_JNITest_add (JNIEnv *, jobject, jint, jint);  </li>\n</ul>\n<p>Java中定义的方法 :</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//将Java中的两个int值 传给C语言, 进行相加后, 返回java语言 shuliang.han.ndkparameterpassing.DataProvider  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;</div></pre></td></tr></table></figure>\n<p>对应C语言中定义的方法 :</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span>  </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//方法签名, Java环境和调用native方法的类必不可少, 后面的参数就是native方法的参数  </span></div><div class=\"line\"><span class=\"function\">jint <span class=\"title\">Java_com_packagename_jni_JNITest_add</span><span class=\"params\">(JNIEnv * env, jobject obj, jint x, jint y)</span>  </span></div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-2-生成-so文件\"><a href=\"#3-2-生成-so文件\" class=\"headerlink\" title=\"3.2 生成.so文件\"></a>3.2 生成.so文件</h4><p>Android.mk 文件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)    </div><div class=\"line\"></div><div class=\"line\">include $(CLEAR_VARS)    </div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE    := hello-jni    </div><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c    </div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<ul>\n<li><p>文件内容解释：</p>\n<p><strong>获取当前文件内容</strong> : $(call my-dir) 是编译器中的宏方法, 调用该宏方法, 就会返回前的目录路径;</p>\n<p><strong>赋值符号</strong> : “ := “ 是赋值符号, 第一句话 是 返回当前文件所在的当前目录, 并将这个目录路径赋值给 LOCAL_PATH;</p>\n<p><strong>初始化编译模块参数</strong> : $(CLEAR_VARS) 作用是将编译模块的参数初始化, LOCAL_MODULE LOCAL_SRC_FILES 也是这样的参数;</p>\n<p><strong>指定编译模块</strong> : LOCAL_MODULE    := hello-jni , 指定编译后的 so 文件名称, 编译好之后系统会在该名称前面加上 “lib”, 后缀加上 “.so”;</p>\n<p><strong>指定编译源文件</strong> : LOCAL_SRC_FILES := hello-jni.c 告诉编译系统源文件, 如果有多个文件那么就依次写在后面即可;</p>\n<p><strong>编译成静态库</strong> : include $(BUILD_SHARED_LIBRARY), 作用是告诉系统, 将编译的结果编译成.so后缀的静态库;</p>\n<p><strong>静态库引入</strong> : NDK的platform中有很多 “.a” 结尾的动态库, 我们编译动态库的时候, 可以将一些静态库引入进来;</p>\n</li>\n<li><p>生成 动态库 so 文件 : 进入 Android.mk 所在目录, 在该目录执行ndk下的ndk-build命令;</p>\n</li>\n<li>Java代码加载动态库 : 在 Java 代码中调用该类的类前面, 在类的一开始, 不在方法中, 加入</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span>&#123; System.loadLibrary(<span class=\"string\">\"hello\"</span>); &#125; ;</div></pre></td></tr></table></figure>\n<ul>\n<li>Application.mk 文件内容为（不写这个文件也可以）:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">APP_STL := stlport_static</div><div class=\"line\">APP_ABI := all</div></pre></td></tr></table></figure>\n<!-- ![](/assets/img/jni_structure.png  =338x461) –&gt;\n<!-- 指定图片大小有问题 -->\n<!-- [![Pure CSS Happy Hacking Keyboard](/assets/img/jni_structure.png)](http://codepen.io/P233/pen/qEagi) -->\n<p><img src=\"/images/blogimages/2016/jni_structure.png\" alt=\"Eclipse JNI目录结构\"></p>\n<p><a href=\"http://blog.csdn.net/hejinjing_tom_com/article/details/8125648\" target=\"_blank\" rel=\"external\">这篇文章</a>是使用javah导出头文件过程中，常见错误和解决办法，这里做一个记录。</p>\n<h3 id=\"4-字符串的处理\"><a href=\"#4-字符串的处理\" class=\"headerlink\" title=\"4.字符串的处理\"></a>4.字符串的处理</h3><ul>\n<li>Java中的String转为C语言中的char字符串<br>下面的工具方法可以在C程序中解决这个问题：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// java中的jstring, 转化为c的一个字符数组  </span></div><div class=\"line\">char* Jstring2CStr(JNIEnv* env, jstring jstr) &#123;  </div><div class=\"line\"><span class=\"comment\">//声明了一个字符串变量 rtn  </span></div><div class=\"line\">char* rtn = NULL;  </div><div class=\"line\"><span class=\"comment\">//找到Java中的String的Class对象  </span></div><div class=\"line\">jclass clsstring = (*env)-&gt;FindClass(env, <span class=\"string\">\"java/lang/String\"</span>);  </div><div class=\"line\"><span class=\"comment\">//创建一个Java中的字符串 \"GB2312\"  </span></div><div class=\"line\">jstring strencode = (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"GB2312\"</span>);  </div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * 获取String中定义的方法 getBytes(), 该方法的参数是 String类型的, 返回值是 byte[]数组</div><div class=\"line\"> * \"(Ljava/lang/String;)[B\" 方法前面解析 :</div><div class=\"line\"> * -- Ljava/lang/String; 表示参数是String字符串</div><div class=\"line\"> * -- [B : 中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组</div><div class=\"line\"> */  </div><div class=\"line\">jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, <span class=\"string\">\"getBytes\"</span>,  </div><div class=\"line\">\t\t<span class=\"string\">\"(Ljava/lang/String;)[B\"</span>);  </div><div class=\"line\"><span class=\"comment\">//调用Java中的getBytes方法, 传入参数介绍 参数②表示调用该方法的对象, 参数③表示方法id , 参数④表示方法参数  </span></div><div class=\"line\">jbyteArray barr = (jbyteArray)(*env)-&gt;CallObjectMethod(env, jstr, mid,  </div><div class=\"line\">\t\tstrencode); <span class=\"comment\">// String .getByte(\"GB2312\");  </span></div><div class=\"line\"><span class=\"comment\">//获取数组的长度  </span></div><div class=\"line\">jsize alen = (*env)-&gt;GetArrayLength(env, barr);  </div><div class=\"line\"><span class=\"comment\">//获取数组中的所有的元素 , 存放在 jbyte*数组中  </span></div><div class=\"line\">jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE);  </div><div class=\"line\"><span class=\"comment\">//将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 '\\0'  </span></div><div class=\"line\"><span class=\"keyword\">if</span> (alen &gt; <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">\trtn = (char*) malloc(alen + <span class=\"number\">1</span>); <span class=\"comment\">//new   char[alen+1]; \"\\0\"  </span></div><div class=\"line\">\tmemcpy(rtn, ba, alen);  </div><div class=\"line\">\trtn[alen] = <span class=\"number\">0</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">(*env)-&gt;ReleaseByteArrayElements(env, barr, ba, <span class=\"number\">0</span>); <span class=\"comment\">//释放内存  </span></div><div class=\"line\">\t<span class=\"keyword\">return</span> rtn;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>Jstring2CStr方法讲解 :</p>\n<ul>\n<li><p>a. 获取Java中String类型的class对象 : 参数 : 上下文环境 env, String类完整路径 ;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">jclass clsstring = (*env)-&gt;FindClass(env, <span class=\"string\">\"java/lang/String\"</span>);</div></pre></td></tr></table></figure>\n</li>\n<li><p>b.创建Java字符串 : 使用 NewStringUTF 方法;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">jstring strencode = (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"GB2312\"</span>);  </div><div class=\"line\">~~~   </div><div class=\"line\">   - c.获取<span class=\"built_in\">String</span>中的getBytes()方法 : 参数介绍 ① env 上下文环境 ② 完整的类路径 ③ 方法名 ④ 方法签名, 方法签名 Ljava/lang/<span class=\"built_in\">String</span>; 代表参数是<span class=\"built_in\">String</span>字符串, [B  中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组;</div><div class=\"line\">~~~ Javascript</div><div class=\"line\">jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, <span class=\"string\">\"getBytes\"</span>,  </div><div class=\"line\">    <span class=\"string\">\"(Ljava/lang/String;)[B\"</span>);  </div><div class=\"line\">~~~       </div><div class=\"line\">   - d. 获取数组的长度 :</div><div class=\"line\">~~~ Javascript</div><div class=\"line\">jsize alen = (*env)-&gt;GetArrayLength(env, barr);</div></pre></td></tr></table></figure>\n</li>\n<li><p>e. 获取数组元素 : 获取数组中的所有的元素 , 存放在 jbyte*数组中;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE);</div></pre></td></tr></table></figure>\n</li>\n<li><p>f.数组拷贝: 将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 ‘\\0’;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (alen &gt; <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">    rtn = (char*) malloc(alen + <span class=\"number\">1</span>); <span class=\"comment\">//new   char[alen+1]; \"\\0\"  </span></div><div class=\"line\">    memcpy(rtn, ba, alen);  </div><div class=\"line\">    rtn[alen] = <span class=\"number\">0</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>g.释放内存 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">(*env)-&gt;ReleaseByteArrayElements(env, barr, ba, <span class=\"number\">0</span>); <span class=\"comment\">//释放内存</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-JNI方法命名规则-标准JNI规范\"><a href=\"#5-JNI方法命名规则-标准JNI规范\" class=\"headerlink\" title=\"5.JNI方法命名规则(标准JNI规范)\"></a>5.JNI方法命名规则(标准JNI规范)</h3><ul>\n<li><p><strong>JNI实现的方法与Java中Native方法的映射关系 :</strong></p>\n<p>使用方法名进行映射, 可以使用javah工具进入bin/classes目录下执行命令, 即可生成头文件;</p>\n</li>\n<li><p><strong>JNI方法参数介绍:</strong></p>\n<p>参数① : 第一个参数是JNI接口指针JNIEnv;</p>\n<p>参数② : 如果Native方法是非静态的, 那么第二个参数就是对Java对象的引用, 如果Native方法是静态的, 那么第二个参数就是对Java类的Class对象的引用;</p>\n</li>\n<li><p><strong>JNI方法名规范:</strong>  </p>\n<p>返回值+Java前缀+全路径类名+方法名+参数① JNIEnv+参数② jobject+其它参数;</p>\n<p>注意分隔符 : Java前缀 与 类名 以及类名之间的包名 和 方法名之间 使用 “_“ 进行分割;</p>\n</li>\n<li><p><strong>声明 非静态 方法:</strong></p>\n<p>Native方法 : public int hello (String str, int i);</p>\n<p>JNI方法: jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject obj, jstring str, jint i);</p>\n</li>\n<li><p><strong>声明 静态 方法 :</strong></p>\n<p>Native方法 : public static int hello (String str, int i);</p>\n<p>JNI方法 : jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject clazz, jstring str, jint i);</p>\n</li>\n<li><p><strong>两种规范 :</strong></p>\n<p>以上是Java的标准JNI规范, 在Android中还有一套自定义的规范, 该规范是Android应用框架层 和 框架层交互使用的JNI规范, 依靠方法注册 映射 Native方法 和 JNI方法;</p>\n</li>\n<li><p><strong>JNIEnv作用 :</strong></p>\n<p>JNIEnv 是一个指针,指向了一组JNI函数, 这些函数可以在jni.h中查询到,通过这些函数可以实现 Java层 与 JNI层的交互 , 通过JNIEnv 调用JNI函数 可以访问java虚拟机, 操作java对象;</p>\n</li>\n<li><p><strong>JNI线程相关性 :</strong></p>\n<p>JNIEnv只在当前的线程有效,JNIEnv不能跨线程传递, 相同的Java线程调用本地方法, 所使用的JNIEnv是相同的, 一个Native方法不能被不同的Java线程调用;</p>\n</li>\n<li><p><strong>JNIEnv结构体系 :</strong></p>\n<p>JNIEnv指针指向一个线程相关的结构,线程相关结构指向一个指针数组,指针数组中的每个元素最终指向一个JNI函数.</p>\n</li>\n</ul>\n<h3 id=\"6-AES加密实现\"><a href=\"#6-AES加密实现\" class=\"headerlink\" title=\"6.AES加密实现\"></a>6.AES加密实现</h3><p>网上有几种AES实现的方式：</p>\n<ul>\n<li><p>1.这个是我现在项目中使用的方法，在Github上有这个工程，这种方式是使用JNI生成一个与设备相关的密码，可以将该密码作为AES的密钥。<a href=\"https://github.com/MasonLiuChn/AndroidUltimateEncrypt\" target=\"_blank\" rel=\"external\">链接地址</a></p>\n</li>\n<li><p>2.网上还有一种方式是由JNI生成keyValue和iv，Java层使用：<a href=\"http://blog.csdn.net/why_2012_gogo/article/details/40055245\" target=\"_blank\" rel=\"external\">链接地址</a></p>\n</li>\n</ul>\n<p>主要代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> &#123;</div><div class=\"line\">\tSystem.loadLibrary(<span class=\"string\">\"cwtlib\"</span>);</div><div class=\"line\">\tkeyValue = getKeyValue();</div><div class=\"line\">\tiv = getIv();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != keyValue &amp;&amp;</div><div class=\"line\">\t\t<span class=\"keyword\">null</span> != iv) &#123;</div><div class=\"line\">\t\tKeyGenerator kgen;  </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            kgen = KeyGenerator.getInstance(<span class=\"string\">\"AES\"</span>);  </div><div class=\"line\">            kgen.init(<span class=\"number\">128</span>, <span class=\"keyword\">new</span> SecureRandom(keyValue));  </div><div class=\"line\">            key = kgen.generateKey();  </div><div class=\"line\">            paramSpec = <span class=\"keyword\">new</span> IvParameterSpec(iv);  </div><div class=\"line\">            ecipher = Cipher.getInstance(<span class=\"string\">\"AES/CBC/PKCS5Padding\"</span>);         </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;  </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchPaddingException e) &#123;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;   </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">byte</span>[] getKeyValue();</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">byte</span>[] getIv();</div></pre></td></tr></table></figure>\n<p>  这种方式，在android app程序完全退出后，再进入该app时，之前加密好的字符串<strong>无法解密。</strong></p>\n<ul>\n<li><p>3.还有一种是直接由C或C++实现AES整个算法，直接使用网上代码并不知道靠不靠谱</p>\n<p>所以，我们项目最终使用了第一种方法</p>\n</li>\n</ul>\n<h3 id=\"7-JNI混淆问题\"><a href=\"#7-JNI混淆问题\" class=\"headerlink\" title=\"7.JNI混淆问题\"></a>7.JNI混淆问题</h3><p>  检查下 C/C++代码中没有直接访问Java代码的类或者类的成员变量、类的成员函数。</p>\n<p>  如果有的话，这些就不能混淆</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//保留jni的回调类</span></div><div class=\"line\">-keep <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">your</span>.<span class=\"title\">jnicallback</span>.<span class=\"title\">class</span> </span>&#123; *; &#125;</div><div class=\"line\"><span class=\"comment\">//这个不用更改，直接复制就可以</span></div><div class=\"line\">-keepclasseswithmembernames <span class=\"class\"><span class=\"keyword\">class</span> * </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">native</span> &lt;methods&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8.总结\"></a>8.总结</h3><p>android 实现JNI入门并不难，笔者也刚刚入门，但要深入了解还是需要很长的路要走。</p>\n<h4 id=\"8-1-更新内容，JNI获取publickey实现\"><a href=\"#8-1-更新内容，JNI获取publickey实现\" class=\"headerlink\" title=\"8.1 更新内容，JNI获取publickey实现\"></a>8.1 更新内容，JNI获取publickey实现</h4><p>在本文中最终使用第6点中的第一种方式，但原方法在4.0.4手机上遇到兼容性问题，详情请看我的这篇博客<a href=\"https://agehua.github.io/2016/05/24/JNI-Learning0/\">使用JNI获取publickey实现</a></p>\n","excerpt":"<p>本文只是用来记录，写的不好还请见谅。</p>\n<h3 id=\"1-JNI介绍\"><a href=\"#1-JNI介绍\" class=\"headerlink\" title=\"1.JNI介绍\"></a>1.JNI介绍</h3><p>JNI概念 : Java本地接口,Java Native Interface, 它是一个协议, 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码;</p>\n<p>C和Java的侧重 :</p>\n<ul>\n<li>C语言 : C语言中最重要的是 函数 function;</li>\n<li>Java语言 : Java中最重要的是 JVM, class类, 以及class中的方法;</li>\n</ul>\n<p>C与Java如何交流 :</p>\n<ul>\n<li>JNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范;</li>\n<li>C语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法;</li>\n<li>Java语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上;</li>\n<li>JNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍;</li>\n</ul>","more":"<p>JNI中的一些概念 :</p>\n<ul>\n<li>native : Java语言中修饰本地方法的修饰符, 被该修饰符修饰的方法没有方法体;</li>\n<li>Native方法 : 在Java语言中被native关键字修饰的方法是Native方法;</li>\n<li>JNI层 : Java声明Native方法的部分;</li>\n<li>JNI函数 : JNIEnv提供的函数, 这些函数在jni.h中进行定义;</li>\n<li>JNI方法 : Native方法对应的JNI层实现的 C/C++方法, 即在jni目录中实现的那些C语言代码;</li>\n</ul>\n<h3 id=\"2-NDK简单介绍\"><a href=\"#2-NDK简单介绍\" class=\"headerlink\" title=\"2.NDK简单介绍\"></a>2.NDK简单介绍</h3><p>C代码执行 : C代码被编译成库文件之后, 才能执行, 库文件分为动态库 和静态库 两种;</p>\n<ul>\n<li>动态库 : unix环境下.so后缀的是动态库, windows环境下.dll 后缀的是动态库; 动态库可以依赖静态库加载一些可执行的C代码;</li>\n<li>静态库 :.a后缀是静态库的扩展名;</li>\n</ul>\n<p>库文件来源 : C代码 进行 编译 链接操作之后, 才会生成库文件, 不同类型的CPU 操作系统 生成的库文件是不一样;</p>\n<ul>\n<li>CPU分类 : arm结构, 嵌入式设备处理器; x86结构, pc服务器处理器; 不同的CPU指令集不同;</li>\n<li>交叉编译 :windows x86编译出来的库文件可以在arm平台运行的代码;</li>\n<li>交叉编译工具链 : Google提供的 NDK 就是交叉编译工具链, 可以在linux环境下编译出在arn平台下执行的二进制库文件;</li>\n</ul>\n<p>NDK作用 : 是Google提供了交叉编译工具链, 能够在linux平台编译出在arm平台下执行的二进制库文件;</p>\n<p>NDK版本介绍 : android-ndk-windows 是在windows系统中的cygwin使用的, android-ndk-linux 是在linux下使用的;</p>\n<p>想深入了解NDK开发的同学，可以去安装一下cygwin，本文只涉及简单的C语言代码，不需要使用cygwin。</p>\n<h3 id=\"3-环境准备，使用android-studio还是Eclipse\"><a href=\"#3-环境准备，使用android-studio还是Eclipse\" class=\"headerlink\" title=\"3.环境准备，使用android studio还是Eclipse\"></a>3.环境准备，使用android studio还是Eclipse</h3><p>推荐使用Eclipse，这篇文章讲了使用Eclipse生成.h文件和生成so文件的配置过程。配置成功后可以远离命令行<a href=\"http://blog.csdn.net/jspping/article/details/47780307\">Eclipse ADT插件生成.h/.so文件</a></p>\n<h4 id=\"3-1-Java调用C流程\"><a href=\"#3-1-Java调用C流程\" class=\"headerlink\" title=\"3.1 Java调用C流程\"></a>3.1 Java调用C流程</h4><ul>\n<li>a. 定义 Native 方法 : 比如在com.packagename.jni.JNITest.java 类中定义 Native 方法 public native int add(int x, int y);</li>\n<li>b. 生成方法签名 : 进入 AndroidProject/bin/classes 目录, 使用 javah com.packagename.jni.JNITest 命令, 便生成了头文件, 该头文件引用了 jni.h, 以及定义好了对应的 Native 方法, 生成 JNIEXPORT jint JNICALL Java_com_packagename_jni_JNITest_add (JNIEnv *, jobject, jint, jint);  </li>\n</ul>\n<p>Java中定义的方法 :</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//将Java中的两个int值 传给C语言, 进行相加后, 返回java语言 shuliang.han.ndkparameterpassing.DataProvider  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;</div></pre></td></tr></table></figure>\n<p>对应C语言中定义的方法 :</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span>  </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//方法签名, Java环境和调用native方法的类必不可少, 后面的参数就是native方法的参数  </span></div><div class=\"line\"><span class=\"function\">jint <span class=\"title\">Java_com_packagename_jni_JNITest_add</span><span class=\"params\">(JNIEnv * env, jobject obj, jint x, jint y)</span>  </div><div class=\"line\"></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-2-生成-so文件\"><a href=\"#3-2-生成-so文件\" class=\"headerlink\" title=\"3.2 生成.so文件\"></a>3.2 生成.so文件</h4><p>Android.mk 文件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir)    </div><div class=\"line\"></div><div class=\"line\">include $(CLEAR_VARS)    </div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE    := hello-jni    </div><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c    </div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<ul>\n<li><p>文件内容解释：</p>\n<p><strong>获取当前文件内容</strong> : $(call my-dir) 是编译器中的宏方法, 调用该宏方法, 就会返回前的目录路径;</p>\n<p><strong>赋值符号</strong> : “ := “ 是赋值符号, 第一句话 是 返回当前文件所在的当前目录, 并将这个目录路径赋值给 LOCAL_PATH;</p>\n<p><strong>初始化编译模块参数</strong> : $(CLEAR_VARS) 作用是将编译模块的参数初始化, LOCAL_MODULE LOCAL_SRC_FILES 也是这样的参数;</p>\n<p><strong>指定编译模块</strong> : LOCAL_MODULE    := hello-jni , 指定编译后的 so 文件名称, 编译好之后系统会在该名称前面加上 “lib”, 后缀加上 “.so”;</p>\n<p><strong>指定编译源文件</strong> : LOCAL_SRC_FILES := hello-jni.c 告诉编译系统源文件, 如果有多个文件那么就依次写在后面即可;</p>\n<p><strong>编译成静态库</strong> : include $(BUILD_SHARED_LIBRARY), 作用是告诉系统, 将编译的结果编译成.so后缀的静态库;</p>\n<p><strong>静态库引入</strong> : NDK的platform中有很多 “.a” 结尾的动态库, 我们编译动态库的时候, 可以将一些静态库引入进来;</p>\n</li>\n<li><p>生成 动态库 so 文件 : 进入 Android.mk 所在目录, 在该目录执行ndk下的ndk-build命令;</p>\n</li>\n<li>Java代码加载动态库 : 在 Java 代码中调用该类的类前面, 在类的一开始, 不在方法中, 加入</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span>&#123; System.loadLibrary(<span class=\"string\">\"hello\"</span>); &#125; ;</div></pre></td></tr></table></figure>\n<ul>\n<li>Application.mk 文件内容为（不写这个文件也可以）:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">APP_STL := stlport_static</div><div class=\"line\">APP_ABI := all</div></pre></td></tr></table></figure>\n<!-- ![](/assets/img/jni_structure.png  =338x461) –&gt;\n<!-- 指定图片大小有问题 -->\n<!-- [![Pure CSS Happy Hacking Keyboard](/assets/img/jni_structure.png)](http://codepen.io/P233/pen/qEagi) -->\n<p><img src=\"/images/blogimages/2016/jni_structure.png\" alt=\"Eclipse JNI目录结构\"></p>\n<p><a href=\"http://blog.csdn.net/hejinjing_tom_com/article/details/8125648\">这篇文章</a>是使用javah导出头文件过程中，常见错误和解决办法，这里做一个记录。</p>\n<h3 id=\"4-字符串的处理\"><a href=\"#4-字符串的处理\" class=\"headerlink\" title=\"4.字符串的处理\"></a>4.字符串的处理</h3><ul>\n<li>Java中的String转为C语言中的char字符串<br>下面的工具方法可以在C程序中解决这个问题：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// java中的jstring, 转化为c的一个字符数组  </span></div><div class=\"line\">char* Jstring2CStr(JNIEnv* env, jstring jstr) &#123;  </div><div class=\"line\"><span class=\"comment\">//声明了一个字符串变量 rtn  </span></div><div class=\"line\">char* rtn = NULL;  </div><div class=\"line\"><span class=\"comment\">//找到Java中的String的Class对象  </span></div><div class=\"line\">jclass clsstring = (*env)-&gt;FindClass(env, <span class=\"string\">\"java/lang/String\"</span>);  </div><div class=\"line\"><span class=\"comment\">//创建一个Java中的字符串 \"GB2312\"  </span></div><div class=\"line\">jstring strencode = (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"GB2312\"</span>);  </div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> * 获取String中定义的方法 getBytes(), 该方法的参数是 String类型的, 返回值是 byte[]数组</div><div class=\"line\"> * \"(Ljava/lang/String;)[B\" 方法前面解析 :</div><div class=\"line\"> * -- Ljava/lang/String; 表示参数是String字符串</div><div class=\"line\"> * -- [B : 中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组</div><div class=\"line\"> */</span>  </div><div class=\"line\">jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, <span class=\"string\">\"getBytes\"</span>,  </div><div class=\"line\">\t\t<span class=\"string\">\"(Ljava/lang/String;)[B\"</span>);  </div><div class=\"line\"><span class=\"comment\">//调用Java中的getBytes方法, 传入参数介绍 参数②表示调用该方法的对象, 参数③表示方法id , 参数④表示方法参数  </span></div><div class=\"line\">jbyteArray barr = (jbyteArray)(*env)-&gt;CallObjectMethod(env, jstr, mid,  </div><div class=\"line\">\t\tstrencode); <span class=\"comment\">// String .getByte(\"GB2312\");  </span></div><div class=\"line\"><span class=\"comment\">//获取数组的长度  </span></div><div class=\"line\">jsize alen = (*env)-&gt;GetArrayLength(env, barr);  </div><div class=\"line\"><span class=\"comment\">//获取数组中的所有的元素 , 存放在 jbyte*数组中  </span></div><div class=\"line\">jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE);  </div><div class=\"line\"><span class=\"comment\">//将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 '\\0'  </span></div><div class=\"line\"><span class=\"keyword\">if</span> (alen &gt; <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">\trtn = (char*) malloc(alen + <span class=\"number\">1</span>); <span class=\"comment\">//new   char[alen+1]; \"\\0\"  </span></div><div class=\"line\">\tmemcpy(rtn, ba, alen);  </div><div class=\"line\">\trtn[alen] = <span class=\"number\">0</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">(*env)-&gt;ReleaseByteArrayElements(env, barr, ba, <span class=\"number\">0</span>); <span class=\"comment\">//释放内存  </span></div><div class=\"line\">\t<span class=\"keyword\">return</span> rtn;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>Jstring2CStr方法讲解 :</p>\n<ul>\n<li><p>a. 获取Java中String类型的class对象 : 参数 : 上下文环境 env, String类完整路径 ;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">jclass clsstring = (*env)-&gt;FindClass(env, <span class=\"string\">\"java/lang/String\"</span>);</div></pre></td></tr></table></figure>\n</li>\n<li><p>b.创建Java字符串 : 使用 NewStringUTF 方法;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">jstring strencode = (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"GB2312\"</span>);  </div><div class=\"line\">~~~   </div><div class=\"line\">   - c.获取<span class=\"built_in\">String</span>中的getBytes()方法 : 参数介绍 ① env 上下文环境 ② 完整的类路径 ③ 方法名 ④ 方法签名, 方法签名 Ljava/lang/<span class=\"built_in\">String</span>; 代表参数是<span class=\"built_in\">String</span>字符串, [B  中括号表示这是一个数组, B代表byte类型, 返回值是一个byte数组;</div><div class=\"line\">~~~ Javascript</div><div class=\"line\">jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, <span class=\"string\">\"getBytes\"</span>,  </div><div class=\"line\">    <span class=\"string\">\"(Ljava/lang/String;)[B\"</span>);  </div><div class=\"line\">~~~       </div><div class=\"line\">   - d. 获取数组的长度 :</div><div class=\"line\">~~~ Javascript</div><div class=\"line\">jsize alen = (*env)-&gt;GetArrayLength(env, barr);</div></pre></td></tr></table></figure>\n</li>\n<li><p>e. 获取数组元素 : 获取数组中的所有的元素 , 存放在 jbyte*数组中;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE);</div></pre></td></tr></table></figure>\n</li>\n<li><p>f.数组拷贝: 将Java数组中所有元素拷贝到C的char*数组中, 注意C语言数组结尾要加一个 ‘\\0’;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (alen &gt; <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">    rtn = (char*) malloc(alen + <span class=\"number\">1</span>); <span class=\"comment\">//new   char[alen+1]; \"\\0\"  </span></div><div class=\"line\">    memcpy(rtn, ba, alen);  </div><div class=\"line\">    rtn[alen] = <span class=\"number\">0</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>g.释放内存 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">(*env)-&gt;ReleaseByteArrayElements(env, barr, ba, <span class=\"number\">0</span>); <span class=\"comment\">//释放内存</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-JNI方法命名规则-标准JNI规范\"><a href=\"#5-JNI方法命名规则-标准JNI规范\" class=\"headerlink\" title=\"5.JNI方法命名规则(标准JNI规范)\"></a>5.JNI方法命名规则(标准JNI规范)</h3><ul>\n<li><p><strong>JNI实现的方法与Java中Native方法的映射关系 :</strong></p>\n<p>使用方法名进行映射, 可以使用javah工具进入bin/classes目录下执行命令, 即可生成头文件;</p>\n</li>\n<li><p><strong>JNI方法参数介绍:</strong></p>\n<p>参数① : 第一个参数是JNI接口指针JNIEnv;</p>\n<p>参数② : 如果Native方法是非静态的, 那么第二个参数就是对Java对象的引用, 如果Native方法是静态的, 那么第二个参数就是对Java类的Class对象的引用;</p>\n</li>\n<li><p><strong>JNI方法名规范:</strong>  </p>\n<p>返回值+Java前缀+全路径类名+方法名+参数① JNIEnv+参数② jobject+其它参数;</p>\n<p>注意分隔符 : Java前缀 与 类名 以及类名之间的包名 和 方法名之间 使用 “_“ 进行分割;</p>\n</li>\n<li><p><strong>声明 非静态 方法:</strong></p>\n<p>Native方法 : public int hello (String str, int i);</p>\n<p>JNI方法: jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject obj, jstring str, jint i);</p>\n</li>\n<li><p><strong>声明 静态 方法 :</strong></p>\n<p>Native方法 : public static int hello (String str, int i);</p>\n<p>JNI方法 : jint Java_shuliang_han_Hello_hello(JNIEnv * env, jobject clazz, jstring str, jint i);</p>\n</li>\n<li><p><strong>两种规范 :</strong></p>\n<p>以上是Java的标准JNI规范, 在Android中还有一套自定义的规范, 该规范是Android应用框架层 和 框架层交互使用的JNI规范, 依靠方法注册 映射 Native方法 和 JNI方法;</p>\n</li>\n<li><p><strong>JNIEnv作用 :</strong></p>\n<p>JNIEnv 是一个指针,指向了一组JNI函数, 这些函数可以在jni.h中查询到,通过这些函数可以实现 Java层 与 JNI层的交互 , 通过JNIEnv 调用JNI函数 可以访问java虚拟机, 操作java对象;</p>\n</li>\n<li><p><strong>JNI线程相关性 :</strong></p>\n<p>JNIEnv只在当前的线程有效,JNIEnv不能跨线程传递, 相同的Java线程调用本地方法, 所使用的JNIEnv是相同的, 一个Native方法不能被不同的Java线程调用;</p>\n</li>\n<li><p><strong>JNIEnv结构体系 :</strong></p>\n<p>JNIEnv指针指向一个线程相关的结构,线程相关结构指向一个指针数组,指针数组中的每个元素最终指向一个JNI函数.</p>\n</li>\n</ul>\n<h3 id=\"6-AES加密实现\"><a href=\"#6-AES加密实现\" class=\"headerlink\" title=\"6.AES加密实现\"></a>6.AES加密实现</h3><p>网上有几种AES实现的方式：</p>\n<ul>\n<li><p>1.这个是我现在项目中使用的方法，在Github上有这个工程，这种方式是使用JNI生成一个与设备相关的密码，可以将该密码作为AES的密钥。<a href=\"https://github.com/MasonLiuChn/AndroidUltimateEncrypt\">链接地址</a></p>\n</li>\n<li><p>2.网上还有一种方式是由JNI生成keyValue和iv，Java层使用：<a href=\"http://blog.csdn.net/why_2012_gogo/article/details/40055245\">链接地址</a></p>\n</li>\n</ul>\n<p>主要代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> &#123;</div><div class=\"line\">\tSystem.loadLibrary(<span class=\"string\">\"cwtlib\"</span>);</div><div class=\"line\">\tkeyValue = getKeyValue();</div><div class=\"line\">\tiv = getIv();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != keyValue &amp;&amp;</div><div class=\"line\">\t\t<span class=\"keyword\">null</span> != iv) &#123;</div><div class=\"line\">\t\tKeyGenerator kgen;  </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            kgen = KeyGenerator.getInstance(<span class=\"string\">\"AES\"</span>);  </div><div class=\"line\">            kgen.init(<span class=\"number\">128</span>, <span class=\"keyword\">new</span> SecureRandom(keyValue));  </div><div class=\"line\">            key = kgen.generateKey();  </div><div class=\"line\">            paramSpec = <span class=\"keyword\">new</span> IvParameterSpec(iv);  </div><div class=\"line\">            ecipher = Cipher.getInstance(<span class=\"string\">\"AES/CBC/PKCS5Padding\"</span>);         </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;  </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchPaddingException e) &#123;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;   </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">byte</span>[] getKeyValue();</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">byte</span>[] getIv();</div></pre></td></tr></table></figure>\n<p>  这种方式，在android app程序完全退出后，再进入该app时，之前加密好的字符串<strong>无法解密。</strong></p>\n<ul>\n<li><p>3.还有一种是直接由C或C++实现AES整个算法，直接使用网上代码并不知道靠不靠谱</p>\n<p>所以，我们项目最终使用了第一种方法</p>\n</li>\n</ul>\n<h3 id=\"7-JNI混淆问题\"><a href=\"#7-JNI混淆问题\" class=\"headerlink\" title=\"7.JNI混淆问题\"></a>7.JNI混淆问题</h3><p>  检查下 C/C++代码中没有直接访问Java代码的类或者类的成员变量、类的成员函数。</p>\n<p>  如果有的话，这些就不能混淆</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//保留jni的回调类</span></div><div class=\"line\">-keep <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">your</span>.<span class=\"title\">jnicallback</span>.<span class=\"title\">class</span> </span>&#123; *; &#125;</div><div class=\"line\"><span class=\"comment\">//这个不用更改，直接复制就可以</span></div><div class=\"line\">-keepclasseswithmembernames <span class=\"class\"><span class=\"keyword\">class</span> * </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">native</span> &lt;methods&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8.总结\"></a>8.总结</h3><p>android 实现JNI入门并不难，笔者也刚刚入门，但要深入了解还是需要很长的路要走。</p>\n<h4 id=\"8-1-更新内容，JNI获取publickey实现\"><a href=\"#8-1-更新内容，JNI获取publickey实现\" class=\"headerlink\" title=\"8.1 更新内容，JNI获取publickey实现\"></a>8.1 更新内容，JNI获取publickey实现</h4><p>在本文中最终使用第6点中的第一种方式，但原方法在4.0.4手机上遇到兼容性问题，详情请看我的这篇博客<a href=\"https://agehua.github.io/2016/05/24/JNI-Learning0/\">使用JNI获取publickey实现</a></p>"},{"layout":"post","title":"android JNI学习② JNI调用过程","keywords":"jni, android源码","description":"android Jni调用过程","banner":"http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg","_content":"\n\n###  1.Android JNI调用过程\n\n#### 1.1 由Android系统加载的JNI\n\nAndroid系统在启动启动过程中，先**启动Kernel创建init进程**，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会**AndroidRuntime.cpp中的startVm**创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。\n\n<!--more-->\n\n在AndroidRuntime.cpp中：\n\n~~~ C++\nint AndroidRuntime::startReg(JNIEnv* env)\n{\n    //设置线程创建方法为javaCreateThreadEtc\n    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);\n\n    env->PushLocalFrame(200);\n    //进程NI方法的注册\n    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {\n        env->PopLocalFrame(NULL);\n        return -1;\n    }\n    env->PopLocalFrame(NULL);\n    return 0;\n}\n~~~\n\n**register_jni_procs(gRegJNI, NELEM(gRegJNI), env)**这行代码的作用就是就是循环调用gRegJNI数组成员所对应的方法。\n\n~~~ C++\nstatic int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)\n{\n    for (size_t i = 0; i < count; i++) {\n        if (array[i].mProc(env) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\n~~~\n\n   gRegJNI数组，有100多个成员变量，定义在AndroidRuntime.cpp：\n\n~~~ C++\nstatic const RegJNIRec gRegJNI[] = {\n    REG_JNI(register_android_os_MessageQueue),\n    REG_JNI(register_android_os_Binder),\n    ...\n};\n~~~\n\n   该数组的每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，该宏的作用就是调用相应的方法。\n\n比如MessageQueue和Binder方法都是Android系统启动时就已经注册，所以在AndroidRuntime.cpp中可以找到相应的native方法，见**AndroidRuntime.cpp的gRegJNI数组**。这些注册方法命令格式为：\n\n~~~ Java\nregister_[包名]_[类名]\n~~~\n\n##### 示例一：以MessageQueue.java中的nativePollOnce方法为例，\n\n~~~ Java\nprivate native void nativePollOnce(long ptr, int timeoutMillis);\n~~~\n方法名：**android.os.MessageQueue.nativePollOnce()**，而相对应的native层方法名只是将点号替换为下划线，可得**android_os_MessageQueue_nativePollOnce()。**\n\n- 前面说MessageQueue.java所定义的jni注册方法名应该是**register_android_os_MessageQueue**，的确存在于gRegJNI数组，说明这次JNI注册过程是有开机过程完成的。该方法在AndroidRuntime.cpp申明为extern方法：\n\n~~~ C++\nextern int register_android_os_MessageQueue(JNIEnv* env);\n~~~\n\n这些extern方法绝大多数位于/framework/base/core/jni/目录，大多数情况下native文件命名方式：\n\n~~~ C++\n[包名]_[类名].cpp\n[包名]_[类名].h\n~~~\n\n> **Tips**： MessageQueue.java ==> android_os_MessageQueue.cpp\n\n- 打开android_os_MessageQueue.cpp文件，搜索android_os_MessageQueue_nativePollOnce方法，这便找到了目标方法：\n\n~~~ C++\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n        jlong ptr, jint timeoutMillis) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n}\n~~~\n\n##### 示例二：对于native文件命名方式，有时并非[包名]\\_[类名].cpp，比如Binder.java\n\nBinder.java所对应的native文件：**android_util_Binder.cpp**\n\n~~~ Java\npublic static final native int getCallingPid();\n~~~\n\n   根据示例一方式，找到getCallingPid ==> android_os_Binder_getCallingPid()，并且在AndroidRuntime.cpp中的gRegJNI数组中找到register_android_os_Binder。\n\n按实例(一)方式则native文名应该为android_os_Binder.cpp，可是在/framework/base/core/jni/目录下**找不到该文件**，这是例外的情况。其实真正的文件名为**android_util_Binder.cpp**，这就是例外，这一点有些费劲，不明白为何google要如此打破规律的命名。\n\n~~~ C++\nstatic jint android_os_Binder_getCallingPid(JNIEnv* env, jobject clazz)\n{\n    return IPCThreadState::self()->getCallingPid();\n}\n~~~\n\n有人可能好奇，既然如何遇到打破常规的文件命令，怎么办？这个并不难，首先，可以尝试在/framework/base/core/jni/中搜索，对于binder.java，可以直接搜索binder关键字，其他也类似。如果这里也找不到，可以通过grep全局搜索android_os_Binder_getCallingPid这个方法在哪个文件。\n\njni存在的常见目录：\n\n- /framework/base/core/jni/\n- /framework/base/services/core/jni/\n- /framework/base/media/jni/\n\n\n#### 1.2 加载自定义的JNI方法\n前面两种都是在Android系统启动之初，便已经注册过JNI所对应的方法。 那么如果程序自己定义的jni方法，该如何查看jni方法所在位置呢？下面以MediaPlayer.java为例，其包名为android.media：\n\n~~~ Java\npublic class MediaPlayer{\n    static {\n        System.loadLibrary(\"media_jni\");\n        native_init();\n    }\n\n    private static native final void native_init();\n    ...\n}\n~~~\n\n- 通过static静态代码块中System.loadLibrary方法来加载动态库，库名为media_jni, Android平台则会自动扩展成所对应的libmedia_jni.so库\n\n- 接下来便要查看libmedia_jni.so库定义所在文件，一般都是通过Android.mk文件定义**LOCAL_MODULE:= libmedia_jni**，可以采用grep或者mgrep来搜索包含libmedia_jni字段的Android.mk所在路径。\n\n搜索可知，libmedia_jni.so位于/frameworks/base/media/jni/Android.mk。用前面实例(一)中的知识来查看相应的文件和方法名分别为：\n\n~~~ C++\nandroid_media_MediaPlayer.cpp\nandroid_media_MediaPlayer_native_init()\n~~~\n\n- 再然后，你会发现果然在该Android.mk所在目录/frameworks/base/media/jni/中找到android_media_MediaPlayer.cpp文件，并在文件中存在相应的方法：\n\n~~~ C++\nstatic void\nandroid_media_MediaPlayer_native_init(JNIEnv *env)\n{\n    jclass clazz;\n    clazz = env->FindClass(\"android/media/MediaPlayer\");\n    fields.context = env->GetFieldID(clazz, \"mNativeContext\", \"J\");\n    ...\n}\n~~~\n\n> **Tips**：MediaPlayer.java中的native_init方法所对应的native方法位于/frameworks/base/media/jni/目录下的android_media_MediaPlayer.cpp文件中的android_media_MediaPlayer_native_init方法。\n\n**总结：System.loadLibrary()的作用就是调用相应库中的JNI_OnLoad()方法**。\n\n#### 1.3 说说**JNI_OnLoad()**过程。\n\n[-> android_media_MediaPlayer.cpp]\n\n~~~ C++\njint JNI_OnLoad(JavaVM* vm, void* reserved)\n{\n    JNIEnv* env = NULL;\n    if (register_android_media_MediaPlayer(env) < 0) {\n        goto bail;\n    }\n    ...\n}\n~~~\n\n详细说一下**register_android_media_MediaPlayer**\n\n[-> android_media_MediaPlayer.cpp]\n\n~~~ C++\nstatic int register_android_media_MediaPlayer(JNIEnv *env)\n{\n    //【见3.4】\n    return AndroidRuntime::registerNativeMethods(env,\n                \"android/media/MediaPlayer\", gMethods, NELEM(gMethods));\n}\n~~~\n\n虚拟机相关的变量中有两个非常重要的量JavaVM和JNIEnv:\n\n- 1.JavaVM：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例\n- 2.JNIEnv：是指线程上下文环境，每个线程有且只有一个JNIEnv实例\n\n其中gMethods，记录java层和C/C++层方法的一一映射关系。\n\n~~~ C++\nstatic JNINativeMethod gMethods[] = {\n    {\"prepare\",      \"()V\",  (void *)android_media_MediaPlayer_prepare},\n    {\"_start\",       \"()V\",  (void *)android_media_MediaPlayer_start},\n    {\"_stop\",        \"()V\",  (void *)android_media_MediaPlayer_stop},\n    {\"seekTo\",       \"(I)V\", (void *)android_media_MediaPlayer_seekTo},\n    {\"_release\",     \"()V\",  (void *)android_media_MediaPlayer_release},\n    {\"native_init\",  \"()V\",  (void *)android_media_MediaPlayer_native_init},\n    ...\n};\n~~~\n\n这里涉及到结构体**JNINativeMethod**，其定义在jni.h文件：\n\n~~~ C++\ntypedef struct {\n    const char* name;  //Java层native函数名\n    const char* signature; //Java函数签名，记录参数类型和个数，以及返回值类型\n    void*       fnPtr; //Native层对应的函数指针\n} JNINativeMethod;\n~~~\n\n### 2.JNI资源\n\nJNINativeMethod结构体中有一个字段为**signature(签名)**，再介绍signature格式之前需要掌握各种数据类型在Java层、Native层以及签名所采用的签名格式。\n\n#### 2.1 数据类型\n\n- **基本数据类型**\n\n| *Signature格式* |\t*Java* |\t*Native* |\n|:--------:|:-------:|:--------:|\n|B | byte\t|jbyte|\n|C | char\t| jchar|\n|D\t| double\t| jdouble|\n|F\t| float | jfloat|\n|I\t| int |\tjint|\n|S\t| short |\tjshort|\n|J\t| long\t| jlong|\n|Z\t| boolean\t| jboolean|\n|V\t| void\t| void|\n\n- **数组数据类型**\n\n数组简称则是在前面添加**[**：\n\n| *Signature格式* |\t*Java* |\t*Native*|\n|:--------:|:-------:|:--------:|\n|[B |\tbyte[] |\tjbyteArray|\n|[C |\tchar[] |\tjcharArray|\n|[D |\tdouble[] |\tjdoubleArray|\n|[F |\tfloat[] |\tjfloatArray|\n|[I |\tint[] |\tjintArray|\n|[S |\tshort[] |\tjshortArray|\n|[J |\tlong[] |\tjlongArray|\n|[Z |\tboolean[] | jbooleanArray|\n\n- **复杂数据类型**\n\n对象类型简称：**L+classname +**;\n\n| Signature格式 | Java | Native |\n|:--------:|:-------:|:--------:|\n| Ljava/lang/String; | String | jstring |\n| L+classname +;\t| 所有对象|\tjobject|\n|[L+classname +;\t| Object[]\t| jobjectArray|\n| Ljava.lang.Class; |\tClass\t|jclass |\n|Ljava.lang.Throwable;\t| Throwable\t| jthrowable|\n\n- **Signature**\n\n有了前面的铺垫，那么再来通过实例说说函数签名： (输入参数...)返回值参数，这里用到的便是前面介绍的Signature格式。\n\n| Java函数 | 对应的签名|\n|:--------:|:--------:|\n|void foo()\t| ()V|\n|float foo(int i) |\t(I)F|\n|long foo(int[] i)\t| ([I)J|\n|double foo(Class c) |\t(Ljava/lang/Class;)D|\n|boolean foo(int[] i,String s) |\t([ILjava/lang/String;)Z|\n|String foo(int i) |\t(I)Ljava/lang/String;|\n\n#### 2.2 其他\n\n- **(一)垃圾回收**\n对于Java开发人员来说无需关系垃圾回收，完全由虚拟机GC来负责垃圾回收，而对于JNI开发人员，对于内存释放需要谨慎处理，需要的时候申请，使用完记得释放内容，以免发生内存泄露。在JNI提供了三种Reference类型，Local Reference(本地引用)， Global Reference（全局引用）， Weak Global Reference(全局弱引用)。其中Global Reference如果不主动释放，则一直不会释放；对于其他两个类型的引用都是释放的可能性，那是不是意味着不需要手动释放呢？答案是否定的，不管是这三种类型的那种引用，都尽可能在某个内存不再需要时，立即释放，这对系统更为安全可靠，以减少不可预知的性能与稳定性问题。\n\n  另外，ART虚拟机在GC算法有所优化，为了减少内存碎片化问题，在GC之后有可能会移动对象内存的位置，对于Java层程序并没有影响，但是对于JNI程序可要小心了，对于通过指针来直接访问内存对象是，Dalvik能正确运行的程序，ART下未必能正常运行。\n\n- **(二)异常处理**\nJava层出现异常，虚拟机会直接抛出异常，这是需要try..catch或者继续往外throw。但是对于JNI出现异常时，即执行到JNIEnv中某个函数异常时，并不会立即抛出异常来中断程序的执行，还可以继续执行内存之类的清理工作，直到返回到Java层时才会抛出相应的异常。\n\n  另外，Dalvik虚拟机有些情况下JNI函数出错可能返回NULL，但ART虚拟机在出错时更多的是抛出异常。这样导致的问题就可能是在Dalvik版本能正常运行的程序，在ART虚拟机上由于没有正确处理异常而崩溃。\n","source":"_posts/2016-05-24-JNI-Learning0.md","raw":"---\nlayout: post\ntitle: android JNI学习② JNI调用过程\ncategory: accumulation\ntags: Android JNI\nkeywords: jni, android源码\ndescription: android Jni调用过程\nbanner: http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg\n---\n\n\n###  1.Android JNI调用过程\n\n#### 1.1 由Android系统加载的JNI\n\nAndroid系统在启动启动过程中，先**启动Kernel创建init进程**，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会**AndroidRuntime.cpp中的startVm**创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。\n\n<!--more-->\n\n在AndroidRuntime.cpp中：\n\n~~~ C++\nint AndroidRuntime::startReg(JNIEnv* env)\n{\n    //设置线程创建方法为javaCreateThreadEtc\n    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);\n\n    env->PushLocalFrame(200);\n    //进程NI方法的注册\n    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {\n        env->PopLocalFrame(NULL);\n        return -1;\n    }\n    env->PopLocalFrame(NULL);\n    return 0;\n}\n~~~\n\n**register_jni_procs(gRegJNI, NELEM(gRegJNI), env)**这行代码的作用就是就是循环调用gRegJNI数组成员所对应的方法。\n\n~~~ C++\nstatic int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)\n{\n    for (size_t i = 0; i < count; i++) {\n        if (array[i].mProc(env) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\n~~~\n\n   gRegJNI数组，有100多个成员变量，定义在AndroidRuntime.cpp：\n\n~~~ C++\nstatic const RegJNIRec gRegJNI[] = {\n    REG_JNI(register_android_os_MessageQueue),\n    REG_JNI(register_android_os_Binder),\n    ...\n};\n~~~\n\n   该数组的每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，该宏的作用就是调用相应的方法。\n\n比如MessageQueue和Binder方法都是Android系统启动时就已经注册，所以在AndroidRuntime.cpp中可以找到相应的native方法，见**AndroidRuntime.cpp的gRegJNI数组**。这些注册方法命令格式为：\n\n~~~ Java\nregister_[包名]_[类名]\n~~~\n\n##### 示例一：以MessageQueue.java中的nativePollOnce方法为例，\n\n~~~ Java\nprivate native void nativePollOnce(long ptr, int timeoutMillis);\n~~~\n方法名：**android.os.MessageQueue.nativePollOnce()**，而相对应的native层方法名只是将点号替换为下划线，可得**android_os_MessageQueue_nativePollOnce()。**\n\n- 前面说MessageQueue.java所定义的jni注册方法名应该是**register_android_os_MessageQueue**，的确存在于gRegJNI数组，说明这次JNI注册过程是有开机过程完成的。该方法在AndroidRuntime.cpp申明为extern方法：\n\n~~~ C++\nextern int register_android_os_MessageQueue(JNIEnv* env);\n~~~\n\n这些extern方法绝大多数位于/framework/base/core/jni/目录，大多数情况下native文件命名方式：\n\n~~~ C++\n[包名]_[类名].cpp\n[包名]_[类名].h\n~~~\n\n> **Tips**： MessageQueue.java ==> android_os_MessageQueue.cpp\n\n- 打开android_os_MessageQueue.cpp文件，搜索android_os_MessageQueue_nativePollOnce方法，这便找到了目标方法：\n\n~~~ C++\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n        jlong ptr, jint timeoutMillis) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n}\n~~~\n\n##### 示例二：对于native文件命名方式，有时并非[包名]\\_[类名].cpp，比如Binder.java\n\nBinder.java所对应的native文件：**android_util_Binder.cpp**\n\n~~~ Java\npublic static final native int getCallingPid();\n~~~\n\n   根据示例一方式，找到getCallingPid ==> android_os_Binder_getCallingPid()，并且在AndroidRuntime.cpp中的gRegJNI数组中找到register_android_os_Binder。\n\n按实例(一)方式则native文名应该为android_os_Binder.cpp，可是在/framework/base/core/jni/目录下**找不到该文件**，这是例外的情况。其实真正的文件名为**android_util_Binder.cpp**，这就是例外，这一点有些费劲，不明白为何google要如此打破规律的命名。\n\n~~~ C++\nstatic jint android_os_Binder_getCallingPid(JNIEnv* env, jobject clazz)\n{\n    return IPCThreadState::self()->getCallingPid();\n}\n~~~\n\n有人可能好奇，既然如何遇到打破常规的文件命令，怎么办？这个并不难，首先，可以尝试在/framework/base/core/jni/中搜索，对于binder.java，可以直接搜索binder关键字，其他也类似。如果这里也找不到，可以通过grep全局搜索android_os_Binder_getCallingPid这个方法在哪个文件。\n\njni存在的常见目录：\n\n- /framework/base/core/jni/\n- /framework/base/services/core/jni/\n- /framework/base/media/jni/\n\n\n#### 1.2 加载自定义的JNI方法\n前面两种都是在Android系统启动之初，便已经注册过JNI所对应的方法。 那么如果程序自己定义的jni方法，该如何查看jni方法所在位置呢？下面以MediaPlayer.java为例，其包名为android.media：\n\n~~~ Java\npublic class MediaPlayer{\n    static {\n        System.loadLibrary(\"media_jni\");\n        native_init();\n    }\n\n    private static native final void native_init();\n    ...\n}\n~~~\n\n- 通过static静态代码块中System.loadLibrary方法来加载动态库，库名为media_jni, Android平台则会自动扩展成所对应的libmedia_jni.so库\n\n- 接下来便要查看libmedia_jni.so库定义所在文件，一般都是通过Android.mk文件定义**LOCAL_MODULE:= libmedia_jni**，可以采用grep或者mgrep来搜索包含libmedia_jni字段的Android.mk所在路径。\n\n搜索可知，libmedia_jni.so位于/frameworks/base/media/jni/Android.mk。用前面实例(一)中的知识来查看相应的文件和方法名分别为：\n\n~~~ C++\nandroid_media_MediaPlayer.cpp\nandroid_media_MediaPlayer_native_init()\n~~~\n\n- 再然后，你会发现果然在该Android.mk所在目录/frameworks/base/media/jni/中找到android_media_MediaPlayer.cpp文件，并在文件中存在相应的方法：\n\n~~~ C++\nstatic void\nandroid_media_MediaPlayer_native_init(JNIEnv *env)\n{\n    jclass clazz;\n    clazz = env->FindClass(\"android/media/MediaPlayer\");\n    fields.context = env->GetFieldID(clazz, \"mNativeContext\", \"J\");\n    ...\n}\n~~~\n\n> **Tips**：MediaPlayer.java中的native_init方法所对应的native方法位于/frameworks/base/media/jni/目录下的android_media_MediaPlayer.cpp文件中的android_media_MediaPlayer_native_init方法。\n\n**总结：System.loadLibrary()的作用就是调用相应库中的JNI_OnLoad()方法**。\n\n#### 1.3 说说**JNI_OnLoad()**过程。\n\n[-> android_media_MediaPlayer.cpp]\n\n~~~ C++\njint JNI_OnLoad(JavaVM* vm, void* reserved)\n{\n    JNIEnv* env = NULL;\n    if (register_android_media_MediaPlayer(env) < 0) {\n        goto bail;\n    }\n    ...\n}\n~~~\n\n详细说一下**register_android_media_MediaPlayer**\n\n[-> android_media_MediaPlayer.cpp]\n\n~~~ C++\nstatic int register_android_media_MediaPlayer(JNIEnv *env)\n{\n    //【见3.4】\n    return AndroidRuntime::registerNativeMethods(env,\n                \"android/media/MediaPlayer\", gMethods, NELEM(gMethods));\n}\n~~~\n\n虚拟机相关的变量中有两个非常重要的量JavaVM和JNIEnv:\n\n- 1.JavaVM：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例\n- 2.JNIEnv：是指线程上下文环境，每个线程有且只有一个JNIEnv实例\n\n其中gMethods，记录java层和C/C++层方法的一一映射关系。\n\n~~~ C++\nstatic JNINativeMethod gMethods[] = {\n    {\"prepare\",      \"()V\",  (void *)android_media_MediaPlayer_prepare},\n    {\"_start\",       \"()V\",  (void *)android_media_MediaPlayer_start},\n    {\"_stop\",        \"()V\",  (void *)android_media_MediaPlayer_stop},\n    {\"seekTo\",       \"(I)V\", (void *)android_media_MediaPlayer_seekTo},\n    {\"_release\",     \"()V\",  (void *)android_media_MediaPlayer_release},\n    {\"native_init\",  \"()V\",  (void *)android_media_MediaPlayer_native_init},\n    ...\n};\n~~~\n\n这里涉及到结构体**JNINativeMethod**，其定义在jni.h文件：\n\n~~~ C++\ntypedef struct {\n    const char* name;  //Java层native函数名\n    const char* signature; //Java函数签名，记录参数类型和个数，以及返回值类型\n    void*       fnPtr; //Native层对应的函数指针\n} JNINativeMethod;\n~~~\n\n### 2.JNI资源\n\nJNINativeMethod结构体中有一个字段为**signature(签名)**，再介绍signature格式之前需要掌握各种数据类型在Java层、Native层以及签名所采用的签名格式。\n\n#### 2.1 数据类型\n\n- **基本数据类型**\n\n| *Signature格式* |\t*Java* |\t*Native* |\n|:--------:|:-------:|:--------:|\n|B | byte\t|jbyte|\n|C | char\t| jchar|\n|D\t| double\t| jdouble|\n|F\t| float | jfloat|\n|I\t| int |\tjint|\n|S\t| short |\tjshort|\n|J\t| long\t| jlong|\n|Z\t| boolean\t| jboolean|\n|V\t| void\t| void|\n\n- **数组数据类型**\n\n数组简称则是在前面添加**[**：\n\n| *Signature格式* |\t*Java* |\t*Native*|\n|:--------:|:-------:|:--------:|\n|[B |\tbyte[] |\tjbyteArray|\n|[C |\tchar[] |\tjcharArray|\n|[D |\tdouble[] |\tjdoubleArray|\n|[F |\tfloat[] |\tjfloatArray|\n|[I |\tint[] |\tjintArray|\n|[S |\tshort[] |\tjshortArray|\n|[J |\tlong[] |\tjlongArray|\n|[Z |\tboolean[] | jbooleanArray|\n\n- **复杂数据类型**\n\n对象类型简称：**L+classname +**;\n\n| Signature格式 | Java | Native |\n|:--------:|:-------:|:--------:|\n| Ljava/lang/String; | String | jstring |\n| L+classname +;\t| 所有对象|\tjobject|\n|[L+classname +;\t| Object[]\t| jobjectArray|\n| Ljava.lang.Class; |\tClass\t|jclass |\n|Ljava.lang.Throwable;\t| Throwable\t| jthrowable|\n\n- **Signature**\n\n有了前面的铺垫，那么再来通过实例说说函数签名： (输入参数...)返回值参数，这里用到的便是前面介绍的Signature格式。\n\n| Java函数 | 对应的签名|\n|:--------:|:--------:|\n|void foo()\t| ()V|\n|float foo(int i) |\t(I)F|\n|long foo(int[] i)\t| ([I)J|\n|double foo(Class c) |\t(Ljava/lang/Class;)D|\n|boolean foo(int[] i,String s) |\t([ILjava/lang/String;)Z|\n|String foo(int i) |\t(I)Ljava/lang/String;|\n\n#### 2.2 其他\n\n- **(一)垃圾回收**\n对于Java开发人员来说无需关系垃圾回收，完全由虚拟机GC来负责垃圾回收，而对于JNI开发人员，对于内存释放需要谨慎处理，需要的时候申请，使用完记得释放内容，以免发生内存泄露。在JNI提供了三种Reference类型，Local Reference(本地引用)， Global Reference（全局引用）， Weak Global Reference(全局弱引用)。其中Global Reference如果不主动释放，则一直不会释放；对于其他两个类型的引用都是释放的可能性，那是不是意味着不需要手动释放呢？答案是否定的，不管是这三种类型的那种引用，都尽可能在某个内存不再需要时，立即释放，这对系统更为安全可靠，以减少不可预知的性能与稳定性问题。\n\n  另外，ART虚拟机在GC算法有所优化，为了减少内存碎片化问题，在GC之后有可能会移动对象内存的位置，对于Java层程序并没有影响，但是对于JNI程序可要小心了，对于通过指针来直接访问内存对象是，Dalvik能正确运行的程序，ART下未必能正常运行。\n\n- **(二)异常处理**\nJava层出现异常，虚拟机会直接抛出异常，这是需要try..catch或者继续往外throw。但是对于JNI出现异常时，即执行到JNIEnv中某个函数异常时，并不会立即抛出异常来中断程序的执行，还可以继续执行内存之类的清理工作，直到返回到Java层时才会抛出相应的异常。\n\n  另外，Dalvik虚拟机有些情况下JNI函数出错可能返回NULL，但ART虚拟机在出错时更多的是抛出异常。这样导致的问题就可能是在Dalvik版本能正常运行的程序，在ART虚拟机上由于没有正确处理异常而崩溃。\n","slug":"JNI-Learning0","published":1,"date":"2016-05-23T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj4s000rbxs6n717ql5g","content":"<h3 id=\"1-Android-JNI调用过程\"><a href=\"#1-Android-JNI调用过程\" class=\"headerlink\" title=\"1.Android JNI调用过程\"></a>1.Android JNI调用过程</h3><h4 id=\"1-1-由Android系统加载的JNI\"><a href=\"#1-1-由Android系统加载的JNI\" class=\"headerlink\" title=\"1.1 由Android系统加载的JNI\"></a>1.1 由Android系统加载的JNI</h4><p>Android系统在启动启动过程中，先<strong>启动Kernel创建init进程</strong>，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会<strong>AndroidRuntime.cpp中的startVm</strong>创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。</p>\n<a id=\"more\"></a>\n<p>在AndroidRuntime.cpp中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> AndroidRuntime::startReg(JNIEnv* env)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//设置线程创建方法为javaCreateThreadEtc</span></div><div class=\"line\">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</div><div class=\"line\"></div><div class=\"line\">    env-&gt;PushLocalFrame(<span class=\"number\">200</span>);</div><div class=\"line\">    <span class=\"comment\">//进程NI方法的注册</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        env-&gt;PopLocalFrame(<span class=\"literal\">NULL</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    env-&gt;PopLocalFrame(<span class=\"literal\">NULL</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>register_jni_procs(gRegJNI, NELEM(gRegJNI), env)</strong>这行代码的作用就是就是循环调用gRegJNI数组成员所对应的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">register_jni_procs</span><span class=\"params\">(<span class=\"keyword\">const</span> RegJNIRec <span class=\"built_in\">array</span>[], <span class=\"keyword\">size_t</span> count, JNIEnv* env)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>[i].mProc(env) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>   gRegJNI数组，有100多个成员变量，定义在AndroidRuntime.cpp：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> RegJNIRec gRegJNI[] = &#123;</div><div class=\"line\">    REG_JNI(register_android_os_MessageQueue),</div><div class=\"line\">    REG_JNI(register_android_os_Binder),</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>   该数组的每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，该宏的作用就是调用相应的方法。</p>\n<p>比如MessageQueue和Binder方法都是Android系统启动时就已经注册，所以在AndroidRuntime.cpp中可以找到相应的native方法，见<strong>AndroidRuntime.cpp的gRegJNI数组</strong>。这些注册方法命令格式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">register_[包名]_[类名]</div></pre></td></tr></table></figure>\n<h5 id=\"示例一：以MessageQueue-java中的nativePollOnce方法为例，\"><a href=\"#示例一：以MessageQueue-java中的nativePollOnce方法为例，\" class=\"headerlink\" title=\"示例一：以MessageQueue.java中的nativePollOnce方法为例，\"></a>示例一：以MessageQueue.java中的nativePollOnce方法为例，</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">nativePollOnce</span><span class=\"params\">(<span class=\"keyword\">long</span> ptr, <span class=\"keyword\">int</span> timeoutMillis)</span></span>;</div></pre></td></tr></table></figure>\n<p>方法名：<strong>android.os.MessageQueue.nativePollOnce()</strong>，而相对应的native层方法名只是将点号替换为下划线，可得<strong>android_os_MessageQueue_nativePollOnce()。</strong></p>\n<ul>\n<li>前面说MessageQueue.java所定义的jni注册方法名应该是<strong>register_android_os_MessageQueue</strong>，的确存在于gRegJNI数组，说明这次JNI注册过程是有开机过程完成的。该方法在AndroidRuntime.cpp申明为extern方法：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">register_android_os_MessageQueue</span><span class=\"params\">(JNIEnv* env)</span></span>;</div></pre></td></tr></table></figure>\n<p>这些extern方法绝大多数位于/framework/base/core/jni/目录，大多数情况下native文件命名方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">[包名]_[类名].cpp</div><div class=\"line\">[包名]_[类名].h</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Tips</strong>： MessageQueue.java ==&gt; android_os_MessageQueue.cpp</p>\n</blockquote>\n<ul>\n<li>打开android_os_MessageQueue.cpp文件，搜索android_os_MessageQueue_nativePollOnce方法，这便找到了目标方法：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,</span></span></div><div class=\"line\">        jlong ptr, jint timeoutMillis) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</div><div class=\"line\">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"示例二：对于native文件命名方式，有时并非-包名-类名-cpp，比如Binder-java\"><a href=\"#示例二：对于native文件命名方式，有时并非-包名-类名-cpp，比如Binder-java\" class=\"headerlink\" title=\"示例二：对于native文件命名方式，有时并非[包名]_[类名].cpp，比如Binder.java\"></a>示例二：对于native文件命名方式，有时并非[包名]_[类名].cpp，比如Binder.java</h5><p>Binder.java所对应的native文件：<strong>android_util_Binder.cpp</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">getCallingPid</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>   根据示例一方式，找到getCallingPid ==&gt; android_os_Binder_getCallingPid()，并且在AndroidRuntime.cpp中的gRegJNI数组中找到register_android_os_Binder。</p>\n<p>按实例(一)方式则native文名应该为android_os_Binder.cpp，可是在/framework/base/core/jni/目录下<strong>找不到该文件</strong>，这是例外的情况。其实真正的文件名为<strong>android_util_Binder.cpp</strong>，这就是例外，这一点有些费劲，不明白为何google要如此打破规律的命名。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> jint <span class=\"title\">android_os_Binder_getCallingPid</span><span class=\"params\">(JNIEnv* env, jobject clazz)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> IPCThreadState::self()-&gt;getCallingPid();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有人可能好奇，既然如何遇到打破常规的文件命令，怎么办？这个并不难，首先，可以尝试在/framework/base/core/jni/中搜索，对于binder.java，可以直接搜索binder关键字，其他也类似。如果这里也找不到，可以通过grep全局搜索android_os_Binder_getCallingPid这个方法在哪个文件。</p>\n<p>jni存在的常见目录：</p>\n<ul>\n<li>/framework/base/core/jni/</li>\n<li>/framework/base/services/core/jni/</li>\n<li>/framework/base/media/jni/</li>\n</ul>\n<h4 id=\"1-2-加载自定义的JNI方法\"><a href=\"#1-2-加载自定义的JNI方法\" class=\"headerlink\" title=\"1.2 加载自定义的JNI方法\"></a>1.2 加载自定义的JNI方法</h4><p>前面两种都是在Android系统启动之初，便已经注册过JNI所对应的方法。 那么如果程序自己定义的jni方法，该如何查看jni方法所在位置呢？下面以MediaPlayer.java为例，其包名为android.media：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MediaPlayer</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        System.loadLibrary(<span class=\"string\">\"media_jni\"</span>);</div><div class=\"line\">        native_init();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">native_init</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>通过static静态代码块中System.loadLibrary方法来加载动态库，库名为media_jni, Android平台则会自动扩展成所对应的libmedia_jni.so库</p>\n</li>\n<li><p>接下来便要查看libmedia_jni.so库定义所在文件，一般都是通过Android.mk文件定义<strong>LOCAL_MODULE:= libmedia_jni</strong>，可以采用grep或者mgrep来搜索包含libmedia_jni字段的Android.mk所在路径。</p>\n</li>\n</ul>\n<p>搜索可知，libmedia_jni.so位于/frameworks/base/media/jni/Android.mk。用前面实例(一)中的知识来查看相应的文件和方法名分别为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">android_media_MediaPlayer.<span class=\"function\">cpp</span></div><div class=\"line\"><span class=\"title\">android_media_MediaPlayer_native_init</span><span class=\"params\">()</span></div></pre></td></tr></table></figure>\n<ul>\n<li>再然后，你会发现果然在该Android.mk所在目录/frameworks/base/media/jni/中找到android_media_MediaPlayer.cpp文件，并在文件中存在相应的方法：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">android_media_MediaPlayer_native_init</span><span class=\"params\">(JNIEnv *env)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    jclass clazz;</div><div class=\"line\">    clazz = env-&gt;FindClass(<span class=\"string\">\"android/media/MediaPlayer\"</span>);</div><div class=\"line\">    fields.context = env-&gt;GetFieldID(clazz, <span class=\"string\">\"mNativeContext\"</span>, <span class=\"string\">\"J\"</span>);</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Tips</strong>：MediaPlayer.java中的native_init方法所对应的native方法位于/frameworks/base/media/jni/目录下的android_media_MediaPlayer.cpp文件中的android_media_MediaPlayer_native_init方法。</p>\n</blockquote>\n<p><strong>总结：System.loadLibrary()的作用就是调用相应库中的JNI_OnLoad()方法</strong>。</p>\n<h4 id=\"1-3-说说JNI-OnLoad-过程。\"><a href=\"#1-3-说说JNI-OnLoad-过程。\" class=\"headerlink\" title=\"1.3 说说JNI_OnLoad()过程。\"></a>1.3 说说<strong>JNI_OnLoad()</strong>过程。</h4><p>[-&gt; android_media_MediaPlayer.cpp]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">jint <span class=\"title\">JNI_OnLoad</span><span class=\"params\">(JavaVM* vm, <span class=\"keyword\">void</span>* reserved)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    JNIEnv* env = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (register_android_media_MediaPlayer(env) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">goto</span> bail;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>详细说一下<strong>register_android_media_MediaPlayer</strong></p>\n<p>[-&gt; android_media_MediaPlayer.cpp]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">register_android_media_MediaPlayer</span><span class=\"params\">(JNIEnv *env)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//【见3.4】</span></div><div class=\"line\">    <span class=\"keyword\">return</span> AndroidRuntime::registerNativeMethods(env,</div><div class=\"line\">                <span class=\"string\">\"android/media/MediaPlayer\"</span>, gMethods, NELEM(gMethods));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虚拟机相关的变量中有两个非常重要的量JavaVM和JNIEnv:</p>\n<ul>\n<li>1.JavaVM：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例</li>\n<li>2.JNIEnv：是指线程上下文环境，每个线程有且只有一个JNIEnv实例</li>\n</ul>\n<p>其中gMethods，记录java层和C/C++层方法的一一映射关系。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">    &#123;<span class=\"string\">\"prepare\"</span>,      <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_prepare&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"_start\"</span>,       <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_start&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"_stop\"</span>,        <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_stop&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"seekTo\"</span>,       <span class=\"string\">\"(I)V\"</span>, (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_seekTo&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"_release\"</span>,     <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_release&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"native_init\"</span>,  <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_native_init&#125;,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里涉及到结构体<strong>JNINativeMethod</strong>，其定义在jni.h文件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name;  <span class=\"comment\">//Java层native函数名</span></div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* signature; <span class=\"comment\">//Java函数签名，记录参数类型和个数，以及返回值类型</span></div><div class=\"line\">    <span class=\"keyword\">void</span>*       fnPtr; <span class=\"comment\">//Native层对应的函数指针</span></div><div class=\"line\">&#125; JNINativeMethod;</div></pre></td></tr></table></figure>\n<h3 id=\"2-JNI资源\"><a href=\"#2-JNI资源\" class=\"headerlink\" title=\"2.JNI资源\"></a>2.JNI资源</h3><p>JNINativeMethod结构体中有一个字段为<strong>signature(签名)</strong>，再介绍signature格式之前需要掌握各种数据类型在Java层、Native层以及签名所采用的签名格式。</p>\n<h4 id=\"2-1-数据类型\"><a href=\"#2-1-数据类型\" class=\"headerlink\" title=\"2.1 数据类型\"></a>2.1 数据类型</h4><ul>\n<li><strong>基本数据类型</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><em>Signature格式</em></th>\n<th style=\"text-align:center\"><em>Java</em></th>\n<th style=\"text-align:center\"><em>Native</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">byte</td>\n<td style=\"text-align:center\">jbyte</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">char</td>\n<td style=\"text-align:center\">jchar</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">double</td>\n<td style=\"text-align:center\">jdouble</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">float</td>\n<td style=\"text-align:center\">jfloat</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">I</td>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">jint</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:center\">short</td>\n<td style=\"text-align:center\">jshort</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">J</td>\n<td style=\"text-align:center\">long</td>\n<td style=\"text-align:center\">jlong</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Z</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">jboolean</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">V</td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">void</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>数组数据类型</strong></li>\n</ul>\n<p>数组简称则是在前面添加<strong>[</strong>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><em>Signature格式</em></th>\n<th style=\"text-align:center\"><em>Java</em></th>\n<th style=\"text-align:center\"><em>Native</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">[B</td>\n<td style=\"text-align:center\">byte[]</td>\n<td style=\"text-align:center\">jbyteArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[C</td>\n<td style=\"text-align:center\">char[]</td>\n<td style=\"text-align:center\">jcharArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[D</td>\n<td style=\"text-align:center\">double[]</td>\n<td style=\"text-align:center\">jdoubleArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[F</td>\n<td style=\"text-align:center\">float[]</td>\n<td style=\"text-align:center\">jfloatArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[I</td>\n<td style=\"text-align:center\">int[]</td>\n<td style=\"text-align:center\">jintArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[S</td>\n<td style=\"text-align:center\">short[]</td>\n<td style=\"text-align:center\">jshortArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[J</td>\n<td style=\"text-align:center\">long[]</td>\n<td style=\"text-align:center\">jlongArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[Z</td>\n<td style=\"text-align:center\">boolean[]</td>\n<td style=\"text-align:center\">jbooleanArray</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>复杂数据类型</strong></li>\n</ul>\n<p>对象类型简称：<strong>L+classname +</strong>;</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Signature格式</th>\n<th style=\"text-align:center\">Java</th>\n<th style=\"text-align:center\">Native</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Ljava/lang/String;</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">jstring</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">L+classname +;</td>\n<td style=\"text-align:center\">所有对象</td>\n<td style=\"text-align:center\">jobject</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[L+classname +;</td>\n<td style=\"text-align:center\">Object[]</td>\n<td style=\"text-align:center\">jobjectArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Ljava.lang.Class;</td>\n<td style=\"text-align:center\">Class</td>\n<td style=\"text-align:center\">jclass</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Ljava.lang.Throwable;</td>\n<td style=\"text-align:center\">Throwable</td>\n<td style=\"text-align:center\">jthrowable</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>Signature</strong></li>\n</ul>\n<p>有了前面的铺垫，那么再来通过实例说说函数签名： (输入参数…)返回值参数，这里用到的便是前面介绍的Signature格式。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Java函数</th>\n<th style=\"text-align:center\">对应的签名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">void foo()</td>\n<td style=\"text-align:center\">()V</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">float foo(int i)</td>\n<td style=\"text-align:center\">(I)F</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">long foo(int[] i)</td>\n<td style=\"text-align:center\">([I)J</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">double foo(Class c)</td>\n<td style=\"text-align:center\">(Ljava/lang/Class;)D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">boolean foo(int[] i,String s)</td>\n<td style=\"text-align:center\">([ILjava/lang/String;)Z</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">String foo(int i)</td>\n<td style=\"text-align:center\">(I)Ljava/lang/String;</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-2-其他\"><a href=\"#2-2-其他\" class=\"headerlink\" title=\"2.2 其他\"></a>2.2 其他</h4><ul>\n<li><p><strong>(一)垃圾回收</strong><br>对于Java开发人员来说无需关系垃圾回收，完全由虚拟机GC来负责垃圾回收，而对于JNI开发人员，对于内存释放需要谨慎处理，需要的时候申请，使用完记得释放内容，以免发生内存泄露。在JNI提供了三种Reference类型，Local Reference(本地引用)， Global Reference（全局引用）， Weak Global Reference(全局弱引用)。其中Global Reference如果不主动释放，则一直不会释放；对于其他两个类型的引用都是释放的可能性，那是不是意味着不需要手动释放呢？答案是否定的，不管是这三种类型的那种引用，都尽可能在某个内存不再需要时，立即释放，这对系统更为安全可靠，以减少不可预知的性能与稳定性问题。</p>\n<p>另外，ART虚拟机在GC算法有所优化，为了减少内存碎片化问题，在GC之后有可能会移动对象内存的位置，对于Java层程序并没有影响，但是对于JNI程序可要小心了，对于通过指针来直接访问内存对象是，Dalvik能正确运行的程序，ART下未必能正常运行。</p>\n</li>\n<li><p><strong>(二)异常处理</strong><br>Java层出现异常，虚拟机会直接抛出异常，这是需要try..catch或者继续往外throw。但是对于JNI出现异常时，即执行到JNIEnv中某个函数异常时，并不会立即抛出异常来中断程序的执行，还可以继续执行内存之类的清理工作，直到返回到Java层时才会抛出相应的异常。</p>\n<p>另外，Dalvik虚拟机有些情况下JNI函数出错可能返回NULL，但ART虚拟机在出错时更多的是抛出异常。这样导致的问题就可能是在Dalvik版本能正常运行的程序，在ART虚拟机上由于没有正确处理异常而崩溃。</p>\n</li>\n</ul>\n","excerpt":"<h3 id=\"1-Android-JNI调用过程\"><a href=\"#1-Android-JNI调用过程\" class=\"headerlink\" title=\"1.Android JNI调用过程\"></a>1.Android JNI调用过程</h3><h4 id=\"1-1-由Android系统加载的JNI\"><a href=\"#1-1-由Android系统加载的JNI\" class=\"headerlink\" title=\"1.1 由Android系统加载的JNI\"></a>1.1 由Android系统加载的JNI</h4><p>Android系统在启动启动过程中，先<strong>启动Kernel创建init进程</strong>，紧接着由init进程fork第一个横穿Java和C/C++的进程，即Zygote进程。Zygote启动过程中会<strong>AndroidRuntime.cpp中的startVm</strong>创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。</p>","more":"<p>在AndroidRuntime.cpp中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> AndroidRuntime::startReg(JNIEnv* env)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//设置线程创建方法为javaCreateThreadEtc</span></div><div class=\"line\">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</div><div class=\"line\"></div><div class=\"line\">    env-&gt;PushLocalFrame(<span class=\"number\">200</span>);</div><div class=\"line\">    <span class=\"comment\">//进程NI方法的注册</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        env-&gt;PopLocalFrame(<span class=\"literal\">NULL</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    env-&gt;PopLocalFrame(<span class=\"literal\">NULL</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>register_jni_procs(gRegJNI, NELEM(gRegJNI), env)</strong>这行代码的作用就是就是循环调用gRegJNI数组成员所对应的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">register_jni_procs</span><span class=\"params\">(<span class=\"keyword\">const</span> RegJNIRec <span class=\"built_in\">array</span>[], <span class=\"keyword\">size_t</span> count, JNIEnv* env)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>[i].mProc(env) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>   gRegJNI数组，有100多个成员变量，定义在AndroidRuntime.cpp：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> RegJNIRec gRegJNI[] = &#123;</div><div class=\"line\">    REG_JNI(register_android_os_MessageQueue),</div><div class=\"line\">    REG_JNI(register_android_os_Binder),</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>   该数组的每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，该宏的作用就是调用相应的方法。</p>\n<p>比如MessageQueue和Binder方法都是Android系统启动时就已经注册，所以在AndroidRuntime.cpp中可以找到相应的native方法，见<strong>AndroidRuntime.cpp的gRegJNI数组</strong>。这些注册方法命令格式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">register_[包名]_[类名]</div></pre></td></tr></table></figure>\n<h5 id=\"示例一：以MessageQueue-java中的nativePollOnce方法为例，\"><a href=\"#示例一：以MessageQueue-java中的nativePollOnce方法为例，\" class=\"headerlink\" title=\"示例一：以MessageQueue.java中的nativePollOnce方法为例，\"></a>示例一：以MessageQueue.java中的nativePollOnce方法为例，</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">nativePollOnce</span><span class=\"params\">(<span class=\"keyword\">long</span> ptr, <span class=\"keyword\">int</span> timeoutMillis)</span></span>;</div></pre></td></tr></table></figure>\n<p>方法名：<strong>android.os.MessageQueue.nativePollOnce()</strong>，而相对应的native层方法名只是将点号替换为下划线，可得<strong>android_os_MessageQueue_nativePollOnce()。</strong></p>\n<ul>\n<li>前面说MessageQueue.java所定义的jni注册方法名应该是<strong>register_android_os_MessageQueue</strong>，的确存在于gRegJNI数组，说明这次JNI注册过程是有开机过程完成的。该方法在AndroidRuntime.cpp申明为extern方法：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">register_android_os_MessageQueue</span><span class=\"params\">(JNIEnv* env)</span></span>;</div></pre></td></tr></table></figure>\n<p>这些extern方法绝大多数位于/framework/base/core/jni/目录，大多数情况下native文件命名方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">[包名]_[类名].cpp</div><div class=\"line\">[包名]_[类名].h</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Tips</strong>： MessageQueue.java ==&gt; android_os_MessageQueue.cpp</p>\n</blockquote>\n<ul>\n<li>打开android_os_MessageQueue.cpp文件，搜索android_os_MessageQueue_nativePollOnce方法，这便找到了目标方法：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,</div><div class=\"line\">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</div><div class=\"line\">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"示例二：对于native文件命名方式，有时并非-包名-类名-cpp，比如Binder-java\"><a href=\"#示例二：对于native文件命名方式，有时并非-包名-类名-cpp，比如Binder-java\" class=\"headerlink\" title=\"示例二：对于native文件命名方式，有时并非[包名]_[类名].cpp，比如Binder.java\"></a>示例二：对于native文件命名方式，有时并非[包名]_[类名].cpp，比如Binder.java</h5><p>Binder.java所对应的native文件：<strong>android_util_Binder.cpp</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">getCallingPid</span><span class=\"params\">()</span></span>;</div></pre></td></tr></table></figure>\n<p>   根据示例一方式，找到getCallingPid ==&gt; android_os_Binder_getCallingPid()，并且在AndroidRuntime.cpp中的gRegJNI数组中找到register_android_os_Binder。</p>\n<p>按实例(一)方式则native文名应该为android_os_Binder.cpp，可是在/framework/base/core/jni/目录下<strong>找不到该文件</strong>，这是例外的情况。其实真正的文件名为<strong>android_util_Binder.cpp</strong>，这就是例外，这一点有些费劲，不明白为何google要如此打破规律的命名。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> jint <span class=\"title\">android_os_Binder_getCallingPid</span><span class=\"params\">(JNIEnv* env, jobject clazz)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> IPCThreadState::self()-&gt;getCallingPid();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有人可能好奇，既然如何遇到打破常规的文件命令，怎么办？这个并不难，首先，可以尝试在/framework/base/core/jni/中搜索，对于binder.java，可以直接搜索binder关键字，其他也类似。如果这里也找不到，可以通过grep全局搜索android_os_Binder_getCallingPid这个方法在哪个文件。</p>\n<p>jni存在的常见目录：</p>\n<ul>\n<li>/framework/base/core/jni/</li>\n<li>/framework/base/services/core/jni/</li>\n<li>/framework/base/media/jni/</li>\n</ul>\n<h4 id=\"1-2-加载自定义的JNI方法\"><a href=\"#1-2-加载自定义的JNI方法\" class=\"headerlink\" title=\"1.2 加载自定义的JNI方法\"></a>1.2 加载自定义的JNI方法</h4><p>前面两种都是在Android系统启动之初，便已经注册过JNI所对应的方法。 那么如果程序自己定义的jni方法，该如何查看jni方法所在位置呢？下面以MediaPlayer.java为例，其包名为android.media：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MediaPlayer</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        System.loadLibrary(<span class=\"string\">\"media_jni\"</span>);</div><div class=\"line\">        native_init();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">native_init</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>通过static静态代码块中System.loadLibrary方法来加载动态库，库名为media_jni, Android平台则会自动扩展成所对应的libmedia_jni.so库</p>\n</li>\n<li><p>接下来便要查看libmedia_jni.so库定义所在文件，一般都是通过Android.mk文件定义<strong>LOCAL_MODULE:= libmedia_jni</strong>，可以采用grep或者mgrep来搜索包含libmedia_jni字段的Android.mk所在路径。</p>\n</li>\n</ul>\n<p>搜索可知，libmedia_jni.so位于/frameworks/base/media/jni/Android.mk。用前面实例(一)中的知识来查看相应的文件和方法名分别为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">android_media_MediaPlayer.<span class=\"function\">cpp</div><div class=\"line\"><span class=\"title\">android_media_MediaPlayer_native_init</span><span class=\"params\">()</span></span></div></pre></td></tr></table></figure>\n<ul>\n<li>再然后，你会发现果然在该Android.mk所在目录/frameworks/base/media/jni/中找到android_media_MediaPlayer.cpp文件，并在文件中存在相应的方法：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></div><div class=\"line\"><span class=\"title\">android_media_MediaPlayer_native_init</span><span class=\"params\">(JNIEnv *env)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    jclass clazz;</div><div class=\"line\">    clazz = env-&gt;FindClass(<span class=\"string\">\"android/media/MediaPlayer\"</span>);</div><div class=\"line\">    fields.context = env-&gt;GetFieldID(clazz, <span class=\"string\">\"mNativeContext\"</span>, <span class=\"string\">\"J\"</span>);</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Tips</strong>：MediaPlayer.java中的native_init方法所对应的native方法位于/frameworks/base/media/jni/目录下的android_media_MediaPlayer.cpp文件中的android_media_MediaPlayer_native_init方法。</p>\n</blockquote>\n<p><strong>总结：System.loadLibrary()的作用就是调用相应库中的JNI_OnLoad()方法</strong>。</p>\n<h4 id=\"1-3-说说JNI-OnLoad-过程。\"><a href=\"#1-3-说说JNI-OnLoad-过程。\" class=\"headerlink\" title=\"1.3 说说JNI_OnLoad()过程。\"></a>1.3 说说<strong>JNI_OnLoad()</strong>过程。</h4><p>[-&gt; android_media_MediaPlayer.cpp]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">jint <span class=\"title\">JNI_OnLoad</span><span class=\"params\">(JavaVM* vm, <span class=\"keyword\">void</span>* reserved)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    JNIEnv* env = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (register_android_media_MediaPlayer(env) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">goto</span> bail;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>详细说一下<strong>register_android_media_MediaPlayer</strong></p>\n<p>[-&gt; android_media_MediaPlayer.cpp]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">register_android_media_MediaPlayer</span><span class=\"params\">(JNIEnv *env)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//【见3.4】</span></div><div class=\"line\">    <span class=\"keyword\">return</span> AndroidRuntime::registerNativeMethods(env,</div><div class=\"line\">                <span class=\"string\">\"android/media/MediaPlayer\"</span>, gMethods, NELEM(gMethods));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虚拟机相关的变量中有两个非常重要的量JavaVM和JNIEnv:</p>\n<ul>\n<li>1.JavaVM：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例</li>\n<li>2.JNIEnv：是指线程上下文环境，每个线程有且只有一个JNIEnv实例</li>\n</ul>\n<p>其中gMethods，记录java层和C/C++层方法的一一映射关系。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> JNINativeMethod gMethods[] = &#123;</div><div class=\"line\">    &#123;<span class=\"string\">\"prepare\"</span>,      <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_prepare&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"_start\"</span>,       <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_start&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"_stop\"</span>,        <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_stop&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"seekTo\"</span>,       <span class=\"string\">\"(I)V\"</span>, (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_seekTo&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"_release\"</span>,     <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_release&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"native_init\"</span>,  <span class=\"string\">\"()V\"</span>,  (<span class=\"keyword\">void</span> *)android_media_MediaPlayer_native_init&#125;,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里涉及到结构体<strong>JNINativeMethod</strong>，其定义在jni.h文件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name;  <span class=\"comment\">//Java层native函数名</span></div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* signature; <span class=\"comment\">//Java函数签名，记录参数类型和个数，以及返回值类型</span></div><div class=\"line\">    <span class=\"keyword\">void</span>*       fnPtr; <span class=\"comment\">//Native层对应的函数指针</span></div><div class=\"line\">&#125; JNINativeMethod;</div></pre></td></tr></table></figure>\n<h3 id=\"2-JNI资源\"><a href=\"#2-JNI资源\" class=\"headerlink\" title=\"2.JNI资源\"></a>2.JNI资源</h3><p>JNINativeMethod结构体中有一个字段为<strong>signature(签名)</strong>，再介绍signature格式之前需要掌握各种数据类型在Java层、Native层以及签名所采用的签名格式。</p>\n<h4 id=\"2-1-数据类型\"><a href=\"#2-1-数据类型\" class=\"headerlink\" title=\"2.1 数据类型\"></a>2.1 数据类型</h4><ul>\n<li><strong>基本数据类型</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><em>Signature格式</em></th>\n<th style=\"text-align:center\"><em>Java</em></th>\n<th style=\"text-align:center\"><em>Native</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">byte</td>\n<td style=\"text-align:center\">jbyte</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">char</td>\n<td style=\"text-align:center\">jchar</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">double</td>\n<td style=\"text-align:center\">jdouble</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">float</td>\n<td style=\"text-align:center\">jfloat</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">I</td>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">jint</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:center\">short</td>\n<td style=\"text-align:center\">jshort</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">J</td>\n<td style=\"text-align:center\">long</td>\n<td style=\"text-align:center\">jlong</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Z</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">jboolean</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">V</td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">void</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>数组数据类型</strong></li>\n</ul>\n<p>数组简称则是在前面添加<strong>[</strong>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><em>Signature格式</em></th>\n<th style=\"text-align:center\"><em>Java</em></th>\n<th style=\"text-align:center\"><em>Native</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">[B</td>\n<td style=\"text-align:center\">byte[]</td>\n<td style=\"text-align:center\">jbyteArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[C</td>\n<td style=\"text-align:center\">char[]</td>\n<td style=\"text-align:center\">jcharArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[D</td>\n<td style=\"text-align:center\">double[]</td>\n<td style=\"text-align:center\">jdoubleArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[F</td>\n<td style=\"text-align:center\">float[]</td>\n<td style=\"text-align:center\">jfloatArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[I</td>\n<td style=\"text-align:center\">int[]</td>\n<td style=\"text-align:center\">jintArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[S</td>\n<td style=\"text-align:center\">short[]</td>\n<td style=\"text-align:center\">jshortArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[J</td>\n<td style=\"text-align:center\">long[]</td>\n<td style=\"text-align:center\">jlongArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[Z</td>\n<td style=\"text-align:center\">boolean[]</td>\n<td style=\"text-align:center\">jbooleanArray</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>复杂数据类型</strong></li>\n</ul>\n<p>对象类型简称：<strong>L+classname +</strong>;</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Signature格式</th>\n<th style=\"text-align:center\">Java</th>\n<th style=\"text-align:center\">Native</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Ljava/lang/String;</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">jstring</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">L+classname +;</td>\n<td style=\"text-align:center\">所有对象</td>\n<td style=\"text-align:center\">jobject</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[L+classname +;</td>\n<td style=\"text-align:center\">Object[]</td>\n<td style=\"text-align:center\">jobjectArray</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Ljava.lang.Class;</td>\n<td style=\"text-align:center\">Class</td>\n<td style=\"text-align:center\">jclass</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Ljava.lang.Throwable;</td>\n<td style=\"text-align:center\">Throwable</td>\n<td style=\"text-align:center\">jthrowable</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>Signature</strong></li>\n</ul>\n<p>有了前面的铺垫，那么再来通过实例说说函数签名： (输入参数…)返回值参数，这里用到的便是前面介绍的Signature格式。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Java函数</th>\n<th style=\"text-align:center\">对应的签名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">void foo()</td>\n<td style=\"text-align:center\">()V</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">float foo(int i)</td>\n<td style=\"text-align:center\">(I)F</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">long foo(int[] i)</td>\n<td style=\"text-align:center\">([I)J</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">double foo(Class c)</td>\n<td style=\"text-align:center\">(Ljava/lang/Class;)D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">boolean foo(int[] i,String s)</td>\n<td style=\"text-align:center\">([ILjava/lang/String;)Z</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">String foo(int i)</td>\n<td style=\"text-align:center\">(I)Ljava/lang/String;</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-2-其他\"><a href=\"#2-2-其他\" class=\"headerlink\" title=\"2.2 其他\"></a>2.2 其他</h4><ul>\n<li><p><strong>(一)垃圾回收</strong><br>对于Java开发人员来说无需关系垃圾回收，完全由虚拟机GC来负责垃圾回收，而对于JNI开发人员，对于内存释放需要谨慎处理，需要的时候申请，使用完记得释放内容，以免发生内存泄露。在JNI提供了三种Reference类型，Local Reference(本地引用)， Global Reference（全局引用）， Weak Global Reference(全局弱引用)。其中Global Reference如果不主动释放，则一直不会释放；对于其他两个类型的引用都是释放的可能性，那是不是意味着不需要手动释放呢？答案是否定的，不管是这三种类型的那种引用，都尽可能在某个内存不再需要时，立即释放，这对系统更为安全可靠，以减少不可预知的性能与稳定性问题。</p>\n<p>另外，ART虚拟机在GC算法有所优化，为了减少内存碎片化问题，在GC之后有可能会移动对象内存的位置，对于Java层程序并没有影响，但是对于JNI程序可要小心了，对于通过指针来直接访问内存对象是，Dalvik能正确运行的程序，ART下未必能正常运行。</p>\n</li>\n<li><p><strong>(二)异常处理</strong><br>Java层出现异常，虚拟机会直接抛出异常，这是需要try..catch或者继续往外throw。但是对于JNI出现异常时，即执行到JNIEnv中某个函数异常时，并不会立即抛出异常来中断程序的执行，还可以继续执行内存之类的清理工作，直到返回到Java层时才会抛出相应的异常。</p>\n<p>另外，Dalvik虚拟机有些情况下JNI函数出错可能返回NULL，但ART虚拟机在出错时更多的是抛出异常。这样导致的问题就可能是在Dalvik版本能正常运行的程序，在ART虚拟机上由于没有正确处理异常而崩溃。</p>\n</li>\n</ul>"},{"layout":"post","title":"Gson解析使用总结","keywords":"gson, json","description":"Gson解析使用总结","banner":"http://obxk8w81b.bkt.clouddn.com/Child%20with%20Orange.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Child%20with%20Orange.jpg","_content":"\n\n### 1.Gson解析总结，就两种情况\nGson 是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个JSON字符串转成一个Java对象，或者将Java对象转成一个JSON字符串。\n使用Gson来解析时，总结一下，就两句话：\n\n- 1.**遇到“{”字符，表示单个对象，直接用XXXBean.class类去映射**\n- 2.**遇到“[”字符，表示对象数组，要用XXXBean[].class或list<XXXBean>去映射**\n\n<!--more-->\n\n### 2.第一种情况，举例\n\n- json字符串是：\n\n~~~ javascript\n{\n    \"items\": [\n        {\n            \"key\": \"H60-L12__1464938219953__346589_483\",\n            \"hash\": \"Fip_In4BhB5syoZ28W3l_eb6rBDU\",\n            \"fsize\": 348120,\n            \"mimeType\": \"image/jpeg\",\n            \"putTime\": 14649382507765902\n        },\n        {\n            \"key\": \"H60-L12__1465352164202__397253_2946\",\n            \"hash\": \"Fs-UwiosdckN9kVY01GrOYC-b7a9\",\n            \"fsize\": 938413,\n            \"mimeType\": \"image/jpeg\",\n            \"putTime\": 14653521712332144\n        },\n        {\n            \"key\": \"H60-L12__1465352548728__322577_4114\",\n            \"hash\": \"Frga_QiMJVb9caiuwMlJABCsu1rc\",\n            \"fsize\": 506921,\n            \"mimeType\": \"image/jpeg\",\n            \"putTime\": 14653525989907168\n        }\n    ]\n}\n~~~\n\n\n- 分析\n\n最开始是一个“{”字符，所以需要用gson.fromJson(jsonstring, XXXBean.class)来解析。同时，XXXBean中只有一个字段items。\nitems里面是一个“[”字符，表示items里面是数组，可以用list去映射。\n\n\n- 解析时，\n\n最后对应的Gson对象就是：\n\n~~~ Java\npublic class XXXBean {\n\n    public List<XXXItem> items;\n\n    public List<XXXItem> getItems() {\n        return items;\n    }\n\n    public void setItems(List<XXXItem> items) {\n        this.items = items;\n    }\n\n    public static class XXXItem {\n        private String key;\n        private String hash;\n        private String fsize;\n        private String mimeType;\n        private String putTime;\n\n        ...\n\t}\n}\n\nGson gson = new Gson();\nList<XXXBean.XXXItem> list = gson.fromJson(jsonstring,XXXBean.class).getItems();\n~~~\n\n\n### 3.第二种情况，举例\n\njson字符串以“[”开头。\n\n例如，json==[{\"id\":1,\"name\":\"李坤\",\"birthDay\":\"Jun 22, 2012 8:28:52 AM\"},{\"id\":2,\"name\":\"曹贵生\",\"birthDay\":\"Jun 22, 2012 8:28:52 AM\"},{\"id\":3,\"name\":\"柳波\",\"birthDay\":\"Jun 22, 2012 8:28:52 AM\"}]\n\n- 解析时，需要使用list来接收。\n\n~~~ Java\n List<Student> retList = gson.fromJson(jsonstring2,  new TypeToken<List<Student>>(){}.getType());\n~~~\n\n\n- 也可以这样\n\n~~~ Java\nStudent[] students= gson.fromJson(jsonstring2,new Student[].class);\n~~~\n\n- 对应list为什么要使用TypeToken？\n\n\tTypeToken是Gson提供的，来实现对泛型的支持\n","source":"_posts/2016-06-08-gson-summary.md","raw":"---\nlayout: post\ntitle: Gson解析使用总结\ncategory: accumulation\ntags: accumulation\nkeywords: gson, json\ndescription: Gson解析使用总结\nbanner: http://obxk8w81b.bkt.clouddn.com/Child%20with%20Orange.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Child%20with%20Orange.jpg\n---\n\n\n### 1.Gson解析总结，就两种情况\nGson 是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个JSON字符串转成一个Java对象，或者将Java对象转成一个JSON字符串。\n使用Gson来解析时，总结一下，就两句话：\n\n- 1.**遇到“{”字符，表示单个对象，直接用XXXBean.class类去映射**\n- 2.**遇到“[”字符，表示对象数组，要用XXXBean[].class或list<XXXBean>去映射**\n\n<!--more-->\n\n### 2.第一种情况，举例\n\n- json字符串是：\n\n~~~ javascript\n{\n    \"items\": [\n        {\n            \"key\": \"H60-L12__1464938219953__346589_483\",\n            \"hash\": \"Fip_In4BhB5syoZ28W3l_eb6rBDU\",\n            \"fsize\": 348120,\n            \"mimeType\": \"image/jpeg\",\n            \"putTime\": 14649382507765902\n        },\n        {\n            \"key\": \"H60-L12__1465352164202__397253_2946\",\n            \"hash\": \"Fs-UwiosdckN9kVY01GrOYC-b7a9\",\n            \"fsize\": 938413,\n            \"mimeType\": \"image/jpeg\",\n            \"putTime\": 14653521712332144\n        },\n        {\n            \"key\": \"H60-L12__1465352548728__322577_4114\",\n            \"hash\": \"Frga_QiMJVb9caiuwMlJABCsu1rc\",\n            \"fsize\": 506921,\n            \"mimeType\": \"image/jpeg\",\n            \"putTime\": 14653525989907168\n        }\n    ]\n}\n~~~\n\n\n- 分析\n\n最开始是一个“{”字符，所以需要用gson.fromJson(jsonstring, XXXBean.class)来解析。同时，XXXBean中只有一个字段items。\nitems里面是一个“[”字符，表示items里面是数组，可以用list去映射。\n\n\n- 解析时，\n\n最后对应的Gson对象就是：\n\n~~~ Java\npublic class XXXBean {\n\n    public List<XXXItem> items;\n\n    public List<XXXItem> getItems() {\n        return items;\n    }\n\n    public void setItems(List<XXXItem> items) {\n        this.items = items;\n    }\n\n    public static class XXXItem {\n        private String key;\n        private String hash;\n        private String fsize;\n        private String mimeType;\n        private String putTime;\n\n        ...\n\t}\n}\n\nGson gson = new Gson();\nList<XXXBean.XXXItem> list = gson.fromJson(jsonstring,XXXBean.class).getItems();\n~~~\n\n\n### 3.第二种情况，举例\n\njson字符串以“[”开头。\n\n例如，json==[{\"id\":1,\"name\":\"李坤\",\"birthDay\":\"Jun 22, 2012 8:28:52 AM\"},{\"id\":2,\"name\":\"曹贵生\",\"birthDay\":\"Jun 22, 2012 8:28:52 AM\"},{\"id\":3,\"name\":\"柳波\",\"birthDay\":\"Jun 22, 2012 8:28:52 AM\"}]\n\n- 解析时，需要使用list来接收。\n\n~~~ Java\n List<Student> retList = gson.fromJson(jsonstring2,  new TypeToken<List<Student>>(){}.getType());\n~~~\n\n\n- 也可以这样\n\n~~~ Java\nStudent[] students= gson.fromJson(jsonstring2,new Student[].class);\n~~~\n\n- 对应list为什么要使用TypeToken？\n\n\tTypeToken是Gson提供的，来实现对泛型的支持\n","slug":"gson-summary","published":1,"date":"2016-06-07T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj4u000ubxs6w1vak2f1","content":"<h3 id=\"1-Gson解析总结，就两种情况\"><a href=\"#1-Gson解析总结，就两种情况\" class=\"headerlink\" title=\"1.Gson解析总结，就两种情况\"></a>1.Gson解析总结，就两种情况</h3><p>Gson 是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个JSON字符串转成一个Java对象，或者将Java对象转成一个JSON字符串。<br>使用Gson来解析时，总结一下，就两句话：</p>\n<ul>\n<li>1.<strong>遇到“{”字符，表示单个对象，直接用XXXBean.class类去映射</strong></li>\n<li>2.<strong>遇到“[”字符，表示对象数组，要用XXXBean[].class或list<xxxbean>去映射</xxxbean></strong></li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"2-第一种情况，举例\"><a href=\"#2-第一种情况，举例\" class=\"headerlink\" title=\"2.第一种情况，举例\"></a>2.第一种情况，举例</h3><ul>\n<li>json字符串是：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"items\"</span>: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"H60-L12__1464938219953__346589_483\"</span>,</div><div class=\"line\">            <span class=\"string\">\"hash\"</span>: <span class=\"string\">\"Fip_In4BhB5syoZ28W3l_eb6rBDU\"</span>,</div><div class=\"line\">            <span class=\"string\">\"fsize\"</span>: <span class=\"number\">348120</span>,</div><div class=\"line\">            <span class=\"string\">\"mimeType\"</span>: <span class=\"string\">\"image/jpeg\"</span>,</div><div class=\"line\">            <span class=\"string\">\"putTime\"</span>: <span class=\"number\">14649382507765902</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"H60-L12__1465352164202__397253_2946\"</span>,</div><div class=\"line\">            <span class=\"string\">\"hash\"</span>: <span class=\"string\">\"Fs-UwiosdckN9kVY01GrOYC-b7a9\"</span>,</div><div class=\"line\">            <span class=\"string\">\"fsize\"</span>: <span class=\"number\">938413</span>,</div><div class=\"line\">            <span class=\"string\">\"mimeType\"</span>: <span class=\"string\">\"image/jpeg\"</span>,</div><div class=\"line\">            <span class=\"string\">\"putTime\"</span>: <span class=\"number\">14653521712332144</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"H60-L12__1465352548728__322577_4114\"</span>,</div><div class=\"line\">            <span class=\"string\">\"hash\"</span>: <span class=\"string\">\"Frga_QiMJVb9caiuwMlJABCsu1rc\"</span>,</div><div class=\"line\">            <span class=\"string\">\"fsize\"</span>: <span class=\"number\">506921</span>,</div><div class=\"line\">            <span class=\"string\">\"mimeType\"</span>: <span class=\"string\">\"image/jpeg\"</span>,</div><div class=\"line\">            <span class=\"string\">\"putTime\"</span>: <span class=\"number\">14653525989907168</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>分析</li>\n</ul>\n<p>最开始是一个“{”字符，所以需要用gson.fromJson(jsonstring, XXXBean.class)来解析。同时，XXXBean中只有一个字段items。<br>items里面是一个“[”字符，表示items里面是数组，可以用list去映射。</p>\n<ul>\n<li>解析时，</li>\n</ul>\n<p>最后对应的Gson对象就是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXBean</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> List&lt;XXXItem&gt; items;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;XXXItem&gt; <span class=\"title\">getItems</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setItems</span><span class=\"params\">(List&lt;XXXItem&gt; items)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.items = items;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXItem</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> String key;</div><div class=\"line\">        <span class=\"keyword\">private</span> String hash;</div><div class=\"line\">        <span class=\"keyword\">private</span> String fsize;</div><div class=\"line\">        <span class=\"keyword\">private</span> String mimeType;</div><div class=\"line\">        <span class=\"keyword\">private</span> String putTime;</div><div class=\"line\"></div><div class=\"line\">        ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Gson gson = <span class=\"keyword\">new</span> Gson();</div><div class=\"line\">List&lt;XXXBean.XXXItem&gt; list = gson.fromJson(jsonstring,XXXBean.class).getItems();</div></pre></td></tr></table></figure>\n<h3 id=\"3-第二种情况，举例\"><a href=\"#3-第二种情况，举例\" class=\"headerlink\" title=\"3.第二种情况，举例\"></a>3.第二种情况，举例</h3><p>json字符串以“[”开头。</p>\n<p>例如，json==[{“id”:1,”name”:”李坤”,”birthDay”:”Jun 22, 2012 8:28:52 AM”},{“id”:2,”name”:”曹贵生”,”birthDay”:”Jun 22, 2012 8:28:52 AM”},{“id”:3,”name”:”柳波”,”birthDay”:”Jun 22, 2012 8:28:52 AM”}]</p>\n<ul>\n<li>解析时，需要使用list来接收。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">List&lt;Student&gt; retList = gson.fromJson(jsonstring2,  <span class=\"keyword\">new</span> TypeToken&lt;List&lt;Student&gt;&gt;()&#123;&#125;.getType());</div></pre></td></tr></table></figure>\n<ul>\n<li>也可以这样</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Student[] students= gson.fromJson(jsonstring2,<span class=\"keyword\">new</span> Student[].class);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>对应list为什么要使用TypeToken？</p>\n<p>  TypeToken是Gson提供的，来实现对泛型的支持</p>\n</li>\n</ul>\n","excerpt":"<h3 id=\"1-Gson解析总结，就两种情况\"><a href=\"#1-Gson解析总结，就两种情况\" class=\"headerlink\" title=\"1.Gson解析总结，就两种情况\"></a>1.Gson解析总结，就两种情况</h3><p>Gson 是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个JSON字符串转成一个Java对象，或者将Java对象转成一个JSON字符串。<br>使用Gson来解析时，总结一下，就两句话：</p>\n<ul>\n<li>1.<strong>遇到“{”字符，表示单个对象，直接用XXXBean.class类去映射</strong></li>\n<li>2.<strong>遇到“[”字符，表示对象数组，要用XXXBean[].class或list<XXXBean>去映射</strong></li>\n</ul>","more":"<h3 id=\"2-第一种情况，举例\"><a href=\"#2-第一种情况，举例\" class=\"headerlink\" title=\"2.第一种情况，举例\"></a>2.第一种情况，举例</h3><ul>\n<li>json字符串是：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"items\"</span>: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"H60-L12__1464938219953__346589_483\"</span>,</div><div class=\"line\">            <span class=\"string\">\"hash\"</span>: <span class=\"string\">\"Fip_In4BhB5syoZ28W3l_eb6rBDU\"</span>,</div><div class=\"line\">            <span class=\"string\">\"fsize\"</span>: <span class=\"number\">348120</span>,</div><div class=\"line\">            <span class=\"string\">\"mimeType\"</span>: <span class=\"string\">\"image/jpeg\"</span>,</div><div class=\"line\">            <span class=\"string\">\"putTime\"</span>: <span class=\"number\">14649382507765902</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"H60-L12__1465352164202__397253_2946\"</span>,</div><div class=\"line\">            <span class=\"string\">\"hash\"</span>: <span class=\"string\">\"Fs-UwiosdckN9kVY01GrOYC-b7a9\"</span>,</div><div class=\"line\">            <span class=\"string\">\"fsize\"</span>: <span class=\"number\">938413</span>,</div><div class=\"line\">            <span class=\"string\">\"mimeType\"</span>: <span class=\"string\">\"image/jpeg\"</span>,</div><div class=\"line\">            <span class=\"string\">\"putTime\"</span>: <span class=\"number\">14653521712332144</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"H60-L12__1465352548728__322577_4114\"</span>,</div><div class=\"line\">            <span class=\"string\">\"hash\"</span>: <span class=\"string\">\"Frga_QiMJVb9caiuwMlJABCsu1rc\"</span>,</div><div class=\"line\">            <span class=\"string\">\"fsize\"</span>: <span class=\"number\">506921</span>,</div><div class=\"line\">            <span class=\"string\">\"mimeType\"</span>: <span class=\"string\">\"image/jpeg\"</span>,</div><div class=\"line\">            <span class=\"string\">\"putTime\"</span>: <span class=\"number\">14653525989907168</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>分析</li>\n</ul>\n<p>最开始是一个“{”字符，所以需要用gson.fromJson(jsonstring, XXXBean.class)来解析。同时，XXXBean中只有一个字段items。<br>items里面是一个“[”字符，表示items里面是数组，可以用list去映射。</p>\n<ul>\n<li>解析时，</li>\n</ul>\n<p>最后对应的Gson对象就是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXBean</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> List&lt;XXXItem&gt; items;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;XXXItem&gt; <span class=\"title\">getItems</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setItems</span><span class=\"params\">(List&lt;XXXItem&gt; items)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.items = items;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXItem</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> String key;</div><div class=\"line\">        <span class=\"keyword\">private</span> String hash;</div><div class=\"line\">        <span class=\"keyword\">private</span> String fsize;</div><div class=\"line\">        <span class=\"keyword\">private</span> String mimeType;</div><div class=\"line\">        <span class=\"keyword\">private</span> String putTime;</div><div class=\"line\"></div><div class=\"line\">        ...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Gson gson = <span class=\"keyword\">new</span> Gson();</div><div class=\"line\">List&lt;XXXBean.XXXItem&gt; list = gson.fromJson(jsonstring,XXXBean.class).getItems();</div></pre></td></tr></table></figure>\n<h3 id=\"3-第二种情况，举例\"><a href=\"#3-第二种情况，举例\" class=\"headerlink\" title=\"3.第二种情况，举例\"></a>3.第二种情况，举例</h3><p>json字符串以“[”开头。</p>\n<p>例如，json==[{“id”:1,”name”:”李坤”,”birthDay”:”Jun 22, 2012 8:28:52 AM”},{“id”:2,”name”:”曹贵生”,”birthDay”:”Jun 22, 2012 8:28:52 AM”},{“id”:3,”name”:”柳波”,”birthDay”:”Jun 22, 2012 8:28:52 AM”}]</p>\n<ul>\n<li>解析时，需要使用list来接收。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">List&lt;Student&gt; retList = gson.fromJson(jsonstring2,  <span class=\"keyword\">new</span> TypeToken&lt;List&lt;Student&gt;&gt;()&#123;&#125;.getType());</div></pre></td></tr></table></figure>\n<ul>\n<li>也可以这样</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Student[] students= gson.fromJson(jsonstring2,<span class=\"keyword\">new</span> Student[].class);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>对应list为什么要使用TypeToken？</p>\n<p>  TypeToken是Gson提供的，来实现对泛型的支持</p>\n</li>\n</ul>"},{"layout":"post","title":"七牛android使用总结","keywords":"qiniu, android","description":"七牛android使用总结，包括list，delete，upload，download","banner":"http://obxk8w81b.bkt.clouddn.com/Avenue%20of%20Plane%20Trees%20near%20Arles%20Station.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Avenue%20of%20Plane%20Trees%20near%20Arles%20Station.jpg","_content":"\n\n\n### 1.在android上实现对七牛空间操作\n\n  在android上实现对七牛空间的各种操作，包括list，delete，upload，download。支持私有空间\n\n  注意：**官方不建议开发者把AccessKey和SecretKey放在前端的java文件里**，最好还是有一台应用服务器\n\n  如果只是想尝试一下，好吧:)  代码中都有说明，直接上代码\n\n<!--more-->\n\n### 2.代码\n\n一共有三个类：\n\n- 工具类：\n\n~~~ Java\n package com.qiniu.ui.utils;\n\n import android.graphics.Bitmap;\n import android.graphics.Bitmap.CompressFormat;\n import android.os.Environment;\n import android.util.Log;\n import com.loopj.android.http.AsyncHttpClient;\n import com.loopj.android.http.AsyncHttpResponseHandler;\n import com.loopj.android.http.RequestParams;\n import com.qiniu.android.storage.UpProgressHandler;\n import com.qiniu.android.storage.UploadManager;\n import com.qiniu.android.storage.UploadOptions;\n import com.qiniu.android.utils.UrlSafeBase64;\n import com.qiniu.api.auth.AuthException;\n import com.qiniu.api.auth.digest.Mac;\n import com.qiniu.api.rs.PutPolicy;\n import com.qiniu.ui.SHA;\n import com.qiniu.ui.contains.QiNiuConfig;\n import org.apache.http.Header;\n import org.json.JSONException;\n import java.io.BufferedOutputStream;\n import java.io.FileOutputStream;\n import java.util.Random;\n import static com.qiniu.ui.SHA.hMacSHA1Encrypt;\n\n\n /**\n  * @date 2016年5月26日 上午11:00:43\n  * @author lijixin\n  * @web https://agehua.github.io\n  * @Description: 七牛云图片操作\n  */\n public class QiniuUitls {\n\n \tprivate static final String fileName = \"temp.jpg\";\n \tprivate static final String tempJpeg = Environment.getExternalStorageDirectory().getPath() + \"/\" + fileName;\n\n \tprivate static int maxWidth = 720;\n \tprivate static int maxHeight = 1080;\n\n \tpublic interface QiniuUploadUitlsListener {\n \t\tvoid onSucess(String fileUrl);\n \t\tvoid onError(int errorCode, String msg);\n \t\tvoid onProgress(int progress);\n \t}\n\n \tpublic interface QiniuRequestListener {\n \t\tvoid onSucceed(byte[] bytes);\n \t\tvoid onFailed(byte[] bytes);\n \t}\n\n \t/**\n \t * 将bitmap转换成jpeg，控制图片大小不大于720*1080，可以指定图片压缩质量\n \t * @param bitmap\n \t * @param filePath\n \t * @param quality\n \t * @return\n \t */\n \tpublic static boolean saveBitmapToJpegFile(Bitmap bitmap, String filePath, int quality) {\n \t\ttry {\n \t\t\tFileOutputStream fileOutStr = new FileOutputStream(filePath);\n \t\t\tBufferedOutputStream bufOutStr = new BufferedOutputStream(fileOutStr);\n \t\t\tresizeBitmap(bitmap).compress(CompressFormat.JPEG, quality, bufOutStr);\n \t\t\tbufOutStr.flush();\n \t\t\tbufOutStr.close();\n \t\t} catch (Exception exception) {\n \t\t\treturn false;\n \t\t}\n \t\treturn true;\n \t}\n\n \t/**\n \t * 缩小图片\n \t *\n \t * @param bitmap\n \t * @return\n \t */\n \tpublic static Bitmap resizeBitmap(Bitmap bitmap) {\n \t\tif (bitmap != null) {\n \t\t\tint width = bitmap.getWidth();\n \t\t\tint height = bitmap.getHeight();\n \t\t\t//宽度大于720\n \t\t\tif (width > maxWidth) {\n \t\t\t\t//按宽度等比例压缩图片\n \t\t\t\tint pWidth = maxWidth;\n \t\t\t\tint pHeight = maxWidth * height / width;\n \t\t\t\tBitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, false);\n \t\t\t\tbitmap.recycle();\n \t\t\t\treturn result;\n \t\t\t}\n \t\t\tif (height > maxHeight) {\n \t\t\t\t//按高度等比例缩小图片\n \t\t\t\tint pHeight = maxHeight;\n \t\t\t\tint pWidth = maxHeight * width / height;\n \t\t\t\tBitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, false);\n \t\t\t\tbitmap.recycle();\n \t\t\t\treturn result;\n \t\t\t}\n \t\t}\n \t\treturn bitmap;\n \t}\n\n \tpublic static void uploadImage(Bitmap bitmap, QiniuUploadUitlsListener listener) {\n \t\tsaveBitmapToJpegFile(bitmap, tempJpeg,100);\n \t\tuploadImage(tempJpeg, listener);\n \t}\n\n \t/**\n \t * 上传图片选择jpg格式，七牛图片api目前支持对jpg格式进行指定图片质量请求\n \t * @param filePath\n \t * @param listener\n \t */\n \tpublic static void uploadImage(String filePath, final QiniuUploadUitlsListener listener) {\n \t\tfinal String fileUrlUUID = getFileUrlUUID();\n \t\tString token = getToken();\n \t\tif (token == null) {\n \t\t\tif (listener != null) {\n \t\t\t\tlistener.onError(-1, \"token is null\");\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tUploadManager uploadManager = new UploadManager();\n \t\tuploadManager.put(filePath, fileUrlUUID, token, (key, info, response) -> {\n \t\t\tSystem.out.println(\"debug:info = \" + info + \",response = \" + response);\n \t\t\tif (info != null && info.statusCode == 200) {// 上传成功\n \t\t\t\tString fileRealUrl = getRealUrl(fileUrlUUID);\n \t\t\t\tSystem.out.println(\"debug:fileRealUrl = \" + fileRealUrl);\n \t\t\t\tif (listener != null) {\n \t\t\t\t\tlistener.onSucess(fileRealUrl);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (listener != null) {\n \t\t\t\t\tlistener.onError(info.statusCode, info.error);\n \t\t\t\t}\n \t\t\t}\n \t\t}, new UploadOptions(null, null, false, new UpProgressHandler() {\n \t\t\tpublic void progress(String key, double percent) {\n \t\t\t\tif (listener != null) {\n \t\t\t\t\tlistener.onProgress((int) (percent * 100));\n \t\t\t\t}\n \t\t\t}\n \t\t}, null));\n \t}\n\n \t/**\n \t * 生成远程文件路径（全局唯一）\n \t * <p>格式类似：\t H60-L12__1464851303930__156750_1884</p>\n \t * @return\n \t */\n \tprivate static String getFileUrlUUID() {\n \t\tString filePath = android.os.Build.MODEL + \"__\" + System.currentTimeMillis() + \"__\" + (new Random().nextInt(500000))\n \t\t\t\t+ \"_\" + (new Random().nextInt(10000));\n \t\treturn filePath.replace(\".\", \"0\");\n \t}\n\n \tprivate static String getRealUrl(String fileUrlUUID) {\n \t\tString filePath = \"http://\" + QiNiuConfig.QINIU_BUCKNAME + \".qiniudn.com/\" + fileUrlUUID;\n \t\treturn filePath;\n \t}\n\n \t/**\n \t * 获取token 本地生成\n \t *\n \t * @return\n \t */\n \tprivate static String getToken() {\n \t\tMac mac = new Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK);\n \t\tPutPolicy putPolicy = new PutPolicy(QiNiuConfig.QINIU_BUCKNAME);\n \t\tputPolicy.returnBody = \"{\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)}\";\n \t\ttry {\n \t\t\tString uptoken = putPolicy.token(mac);\n \t\t\tSystem.out.println(\"debug:uptoken = \" + uptoken);\n \t\t\treturn uptoken;\n \t\t} catch (AuthException e) {\n \t\t\te.printStackTrace();\n \t\t} catch (JSONException e) {\n \t\t\te.printStackTrace();\n \t\t}\n \t\treturn null;\n \t}\n\n \t/**\n \t * 根据host和文件名，生成file的url下载地址，支持私有空间\n \t * @param domain host：七牛的私有空间域名\n \t * @param imgKey file key：空间里的文件名\n \t * @return url下载地址\n \t */\n \tpublic static String downloadFile(String domain,String imgKey){\n \t\t//密钥配置\n \t\t//构造私有空间的需要生成的下载的链接\n //\t\tString domain =\"http://example.xxx.clouddn.com/\";\n //\t\tString path =\"H60-L12__1464917382714__36888_5255\";\n \t\tStringBuilder sb =new StringBuilder();\n \t\t//加上过期时间戳字段\n \t\tString url = sb.append(domain).append(imgKey).append(\"?e=1478365261\").toString();\n \t\tLog.e(\"encodedEntryURI\",url);\n\n \t\tbyte[] sign =null;\n \t\ttry {\n \t\t\tsign = SHA.hMacSHA1Encrypt(url,QiNiuConfig.QINIU_SK);\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t}\n \t\tString encodedSign = UrlSafeBase64.encodeToString(sign);\n \t\tsb.append(\"&token=\").append(QiNiuConfig.QINIU_AK).append(\":\").append(encodedSign);\n \t\tLog.e(\"download token\",sb.toString());\n \t\treturn sb.toString();\n \t}\n\n \t/**\n \t * 列出空间中指定格式的文件\n \t * @param bucket 空间名\n \t * @param prefix 要指定的格式（前缀）\n \t * @param listener\n \t * @return\n \t */\n \tpublic static void listFile(String bucket, String prefix,final QiniuRequestListener listener){\n\n \t\ttry{\n \t\t\tStringBuilder sb = new StringBuilder();\n\n \t\t\tString entryUrl = sb.append(\"bucket=\").append(bucket)\n \t\t\t\t\t.append(\"&prefix=\").append(prefix).toString();\n \t\t\tString host = \"http://rsf.qbox.me\";\n \t\t\tString path = \"/list?\" +entryUrl;\n \t\t\tString url = host+path;\n \t\t\tLog.e(\"AAAAAAA\", url);\n \t\t\tbyte[] sign = SHA.hMacSHA1Encrypt(path+\"\\n\", QiNiuConfig.QINIU_SK);\n \t\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);\n \t\t\tString authorization = QiNiuConfig.QINIU_AK + ':' + encodedSign;\n \t\t\tAsyncHttpClient client = new AsyncHttpClient();\n \t\t\tclient.addHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\n \t\t\tclient.addHeader(\"Authorization\", \"QBox \"+authorization);\n \t\t\tRequestParams params = new RequestParams();\n \t\t\tclient.post(url, params, new AsyncHttpResponseHandler() {\n \t\t\t\t@Override\n \t\t\t\tpublic void onSuccess(int i, Header[] headers, byte[] bytes) {\n \t\t\t\t\tif (null!=listener)\n \t\t\t\t\t\tlistener.onSucceed(bytes);\n \t\t\t\t}\n\n \t\t\t\t@Override\n \t\t\t\tpublic void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) {\n \t\t\t\t\tif (null!=listener)\n \t\t\t\t\t\tlistener.onFailed(bytes);\n \t\t\t\t}\n \t\t\t});\n \t\t}catch(Exception e){\n \t\t\te.printStackTrace();\n \t\t}\n \t\treturn ;\n \t}\n\n \t/**\n \t * 删除空间中的文件\n \t * @param bucket 删除文件的空间\n \t * @param fileName 删除的文件\n \t * */\n \tpublic static boolean deleteFile(String bucket,String fileName,final QiniuRequestListener listener){\n \t\ttry{\n \t\t\tString entryUrl = bucket+\":\"+fileName;\n \t\t\tString encodedEntryURI = UrlSafeBase64.encodeToString(entryUrl.getBytes());\n \t\t\tString host = \"http://rs.qiniu.com\";\n \t\t\tString path = \"/delete/\"+encodedEntryURI;\n \t\t\tString url = host+path;\n \t\t\tLog.e(\"AAAAAAA\", url);\n \t\t\tbyte[] sign = hMacSHA1Encrypt(path+\"\\n\", QiNiuConfig.QINIU_SK);\n \t\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);\n \t\t\tString authorization = QiNiuConfig.QINIU_AK + ':' + encodedSign;\n\n \t\t\tAsyncHttpClient client = new AsyncHttpClient();\n \t\t\tclient.addHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\n \t\t\tclient.addHeader(\"Authorization\", \"QBox \"+authorization);\n \t\t\tRequestParams params = new RequestParams();\n \t\t\tclient.post(url, params, new AsyncHttpResponseHandler() {\n \t\t\t\t@Override\n \t\t\t\tpublic void onSuccess(int i, Header[] headers, byte[] bytes) {\n \t\t\t\t\tif (null!=listener)\n \t\t\t\t\t\tlistener.onSucceed(bytes);\n \t\t\t\t}\n\n \t\t\t\t@Override\n \t\t\t\tpublic void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) {\n \t\t\t\t\tif (null!=listener)\n \t\t\t\t\t\tlistener.onFailed(bytes);\n \t\t\t\t\tif (null!=bytes) {\n \t\t\t\t\t\tString s = new String(bytes);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t});\n\n \t\t}catch(Exception e){\n \t\t\te.printStackTrace();\n \t\t}\n \t\treturn false;\n \t}\n\n }\n~~~\n\n- HMAC-SHA1签名加密类\n\n使用下面方法生成对应七牛资源管理里用到的[管理凭证](http://developer.qiniu.com/article/developer/security/access-token.html)\n\n~~~ Java\n/**\n * 对外提供HMAC-SHA1签名方法\n * @author agehua\n *\n */\npublic class SHA {\n\n    private static final String MAC_NAME = \"HmacSHA1\";\n    private static final String ENCODING = \"UTF-8\";\n\n    /**\n     *\n     * 使用 HMAC-SHA1 签名方法对对encryptText进行签名\n     * @param encryptText 被签名的字符串\n     * @param encryptKey 密钥\n     * @return\n     * @throws Exception\n     */\n    public static byte[] hMacSHA1Encrypt(String encryptText, String encryptKey)\n            throws Exception {\n        byte[] data = encryptKey.getBytes(ENCODING);\n        // 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称\n        SecretKey secretKey = new SecretKeySpec(data, MAC_NAME);\n        // 生成一个指定 Mac 算法 的 Mac 对象\n        Mac mac = Mac.getInstance(MAC_NAME);\n        // 用给定密钥初始化 Mac 对象\n        mac.init(secretKey);\n        byte[] text = encryptText.getBytes(ENCODING);\n        // 完成 Mac 操作\n        return mac.doFinal(text);\n    }\n}  \n~~~  \n\n- 还有一个Config文件\n\n~~~ Java\npublic final class QiNiuConfig {\n\tpublic static final String token = getToken();\n\tpublic static final String QINIU_AK = \"Your_AccessKey\";\n\tpublic static final String QINIU_SK = \"Your_SecretKey\";\n\tpublic static final String QINIU_BUCKNAME = \"你的私有空间\";\n\n\tpublic static String getToken() {\n\t\tMac mac = new Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK);\n\t\tPutPolicy putPolicy = new PutPolicy(QiNiuConfig.QINIU_BUCKNAME);\n\t\tputPolicy.returnBody = \"{\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)}\";\n\t\ttry {\n\t\t\tString uptoken = putPolicy.token(mac);\n\t\t\tSystem.out.println(\"debug:uptoken = \" + uptoken);\n\t\t\treturn uptoken;\n\t\t} catch (AuthException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (JSONException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n}\n\n~~~\n\n [点击在Gist上查看上面这些代码](https://gist.github.com/agehua/f73bcb98af2c0c44a4c49c7c7b7e6bda)\n\n最后，如果有问题欢迎讨论，我的邮箱简介里有 :)  \n","source":"_posts/2016-05-28-qiniu-android-summary.md","raw":"---\nlayout: post\ntitle: 七牛android使用总结\ncategory: technology\ntags: technology\nkeywords: qiniu, android\ndescription: 七牛android使用总结，包括list，delete，upload，download\nbanner: http://obxk8w81b.bkt.clouddn.com/Avenue%20of%20Plane%20Trees%20near%20Arles%20Station.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Avenue%20of%20Plane%20Trees%20near%20Arles%20Station.jpg\n\n---\n\n\n\n### 1.在android上实现对七牛空间操作\n\n  在android上实现对七牛空间的各种操作，包括list，delete，upload，download。支持私有空间\n\n  注意：**官方不建议开发者把AccessKey和SecretKey放在前端的java文件里**，最好还是有一台应用服务器\n\n  如果只是想尝试一下，好吧:)  代码中都有说明，直接上代码\n\n<!--more-->\n\n### 2.代码\n\n一共有三个类：\n\n- 工具类：\n\n~~~ Java\n package com.qiniu.ui.utils;\n\n import android.graphics.Bitmap;\n import android.graphics.Bitmap.CompressFormat;\n import android.os.Environment;\n import android.util.Log;\n import com.loopj.android.http.AsyncHttpClient;\n import com.loopj.android.http.AsyncHttpResponseHandler;\n import com.loopj.android.http.RequestParams;\n import com.qiniu.android.storage.UpProgressHandler;\n import com.qiniu.android.storage.UploadManager;\n import com.qiniu.android.storage.UploadOptions;\n import com.qiniu.android.utils.UrlSafeBase64;\n import com.qiniu.api.auth.AuthException;\n import com.qiniu.api.auth.digest.Mac;\n import com.qiniu.api.rs.PutPolicy;\n import com.qiniu.ui.SHA;\n import com.qiniu.ui.contains.QiNiuConfig;\n import org.apache.http.Header;\n import org.json.JSONException;\n import java.io.BufferedOutputStream;\n import java.io.FileOutputStream;\n import java.util.Random;\n import static com.qiniu.ui.SHA.hMacSHA1Encrypt;\n\n\n /**\n  * @date 2016年5月26日 上午11:00:43\n  * @author lijixin\n  * @web https://agehua.github.io\n  * @Description: 七牛云图片操作\n  */\n public class QiniuUitls {\n\n \tprivate static final String fileName = \"temp.jpg\";\n \tprivate static final String tempJpeg = Environment.getExternalStorageDirectory().getPath() + \"/\" + fileName;\n\n \tprivate static int maxWidth = 720;\n \tprivate static int maxHeight = 1080;\n\n \tpublic interface QiniuUploadUitlsListener {\n \t\tvoid onSucess(String fileUrl);\n \t\tvoid onError(int errorCode, String msg);\n \t\tvoid onProgress(int progress);\n \t}\n\n \tpublic interface QiniuRequestListener {\n \t\tvoid onSucceed(byte[] bytes);\n \t\tvoid onFailed(byte[] bytes);\n \t}\n\n \t/**\n \t * 将bitmap转换成jpeg，控制图片大小不大于720*1080，可以指定图片压缩质量\n \t * @param bitmap\n \t * @param filePath\n \t * @param quality\n \t * @return\n \t */\n \tpublic static boolean saveBitmapToJpegFile(Bitmap bitmap, String filePath, int quality) {\n \t\ttry {\n \t\t\tFileOutputStream fileOutStr = new FileOutputStream(filePath);\n \t\t\tBufferedOutputStream bufOutStr = new BufferedOutputStream(fileOutStr);\n \t\t\tresizeBitmap(bitmap).compress(CompressFormat.JPEG, quality, bufOutStr);\n \t\t\tbufOutStr.flush();\n \t\t\tbufOutStr.close();\n \t\t} catch (Exception exception) {\n \t\t\treturn false;\n \t\t}\n \t\treturn true;\n \t}\n\n \t/**\n \t * 缩小图片\n \t *\n \t * @param bitmap\n \t * @return\n \t */\n \tpublic static Bitmap resizeBitmap(Bitmap bitmap) {\n \t\tif (bitmap != null) {\n \t\t\tint width = bitmap.getWidth();\n \t\t\tint height = bitmap.getHeight();\n \t\t\t//宽度大于720\n \t\t\tif (width > maxWidth) {\n \t\t\t\t//按宽度等比例压缩图片\n \t\t\t\tint pWidth = maxWidth;\n \t\t\t\tint pHeight = maxWidth * height / width;\n \t\t\t\tBitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, false);\n \t\t\t\tbitmap.recycle();\n \t\t\t\treturn result;\n \t\t\t}\n \t\t\tif (height > maxHeight) {\n \t\t\t\t//按高度等比例缩小图片\n \t\t\t\tint pHeight = maxHeight;\n \t\t\t\tint pWidth = maxHeight * width / height;\n \t\t\t\tBitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, false);\n \t\t\t\tbitmap.recycle();\n \t\t\t\treturn result;\n \t\t\t}\n \t\t}\n \t\treturn bitmap;\n \t}\n\n \tpublic static void uploadImage(Bitmap bitmap, QiniuUploadUitlsListener listener) {\n \t\tsaveBitmapToJpegFile(bitmap, tempJpeg,100);\n \t\tuploadImage(tempJpeg, listener);\n \t}\n\n \t/**\n \t * 上传图片选择jpg格式，七牛图片api目前支持对jpg格式进行指定图片质量请求\n \t * @param filePath\n \t * @param listener\n \t */\n \tpublic static void uploadImage(String filePath, final QiniuUploadUitlsListener listener) {\n \t\tfinal String fileUrlUUID = getFileUrlUUID();\n \t\tString token = getToken();\n \t\tif (token == null) {\n \t\t\tif (listener != null) {\n \t\t\t\tlistener.onError(-1, \"token is null\");\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tUploadManager uploadManager = new UploadManager();\n \t\tuploadManager.put(filePath, fileUrlUUID, token, (key, info, response) -> {\n \t\t\tSystem.out.println(\"debug:info = \" + info + \",response = \" + response);\n \t\t\tif (info != null && info.statusCode == 200) {// 上传成功\n \t\t\t\tString fileRealUrl = getRealUrl(fileUrlUUID);\n \t\t\t\tSystem.out.println(\"debug:fileRealUrl = \" + fileRealUrl);\n \t\t\t\tif (listener != null) {\n \t\t\t\t\tlistener.onSucess(fileRealUrl);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (listener != null) {\n \t\t\t\t\tlistener.onError(info.statusCode, info.error);\n \t\t\t\t}\n \t\t\t}\n \t\t}, new UploadOptions(null, null, false, new UpProgressHandler() {\n \t\t\tpublic void progress(String key, double percent) {\n \t\t\t\tif (listener != null) {\n \t\t\t\t\tlistener.onProgress((int) (percent * 100));\n \t\t\t\t}\n \t\t\t}\n \t\t}, null));\n \t}\n\n \t/**\n \t * 生成远程文件路径（全局唯一）\n \t * <p>格式类似：\t H60-L12__1464851303930__156750_1884</p>\n \t * @return\n \t */\n \tprivate static String getFileUrlUUID() {\n \t\tString filePath = android.os.Build.MODEL + \"__\" + System.currentTimeMillis() + \"__\" + (new Random().nextInt(500000))\n \t\t\t\t+ \"_\" + (new Random().nextInt(10000));\n \t\treturn filePath.replace(\".\", \"0\");\n \t}\n\n \tprivate static String getRealUrl(String fileUrlUUID) {\n \t\tString filePath = \"http://\" + QiNiuConfig.QINIU_BUCKNAME + \".qiniudn.com/\" + fileUrlUUID;\n \t\treturn filePath;\n \t}\n\n \t/**\n \t * 获取token 本地生成\n \t *\n \t * @return\n \t */\n \tprivate static String getToken() {\n \t\tMac mac = new Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK);\n \t\tPutPolicy putPolicy = new PutPolicy(QiNiuConfig.QINIU_BUCKNAME);\n \t\tputPolicy.returnBody = \"{\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)}\";\n \t\ttry {\n \t\t\tString uptoken = putPolicy.token(mac);\n \t\t\tSystem.out.println(\"debug:uptoken = \" + uptoken);\n \t\t\treturn uptoken;\n \t\t} catch (AuthException e) {\n \t\t\te.printStackTrace();\n \t\t} catch (JSONException e) {\n \t\t\te.printStackTrace();\n \t\t}\n \t\treturn null;\n \t}\n\n \t/**\n \t * 根据host和文件名，生成file的url下载地址，支持私有空间\n \t * @param domain host：七牛的私有空间域名\n \t * @param imgKey file key：空间里的文件名\n \t * @return url下载地址\n \t */\n \tpublic static String downloadFile(String domain,String imgKey){\n \t\t//密钥配置\n \t\t//构造私有空间的需要生成的下载的链接\n //\t\tString domain =\"http://example.xxx.clouddn.com/\";\n //\t\tString path =\"H60-L12__1464917382714__36888_5255\";\n \t\tStringBuilder sb =new StringBuilder();\n \t\t//加上过期时间戳字段\n \t\tString url = sb.append(domain).append(imgKey).append(\"?e=1478365261\").toString();\n \t\tLog.e(\"encodedEntryURI\",url);\n\n \t\tbyte[] sign =null;\n \t\ttry {\n \t\t\tsign = SHA.hMacSHA1Encrypt(url,QiNiuConfig.QINIU_SK);\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t}\n \t\tString encodedSign = UrlSafeBase64.encodeToString(sign);\n \t\tsb.append(\"&token=\").append(QiNiuConfig.QINIU_AK).append(\":\").append(encodedSign);\n \t\tLog.e(\"download token\",sb.toString());\n \t\treturn sb.toString();\n \t}\n\n \t/**\n \t * 列出空间中指定格式的文件\n \t * @param bucket 空间名\n \t * @param prefix 要指定的格式（前缀）\n \t * @param listener\n \t * @return\n \t */\n \tpublic static void listFile(String bucket, String prefix,final QiniuRequestListener listener){\n\n \t\ttry{\n \t\t\tStringBuilder sb = new StringBuilder();\n\n \t\t\tString entryUrl = sb.append(\"bucket=\").append(bucket)\n \t\t\t\t\t.append(\"&prefix=\").append(prefix).toString();\n \t\t\tString host = \"http://rsf.qbox.me\";\n \t\t\tString path = \"/list?\" +entryUrl;\n \t\t\tString url = host+path;\n \t\t\tLog.e(\"AAAAAAA\", url);\n \t\t\tbyte[] sign = SHA.hMacSHA1Encrypt(path+\"\\n\", QiNiuConfig.QINIU_SK);\n \t\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);\n \t\t\tString authorization = QiNiuConfig.QINIU_AK + ':' + encodedSign;\n \t\t\tAsyncHttpClient client = new AsyncHttpClient();\n \t\t\tclient.addHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\n \t\t\tclient.addHeader(\"Authorization\", \"QBox \"+authorization);\n \t\t\tRequestParams params = new RequestParams();\n \t\t\tclient.post(url, params, new AsyncHttpResponseHandler() {\n \t\t\t\t@Override\n \t\t\t\tpublic void onSuccess(int i, Header[] headers, byte[] bytes) {\n \t\t\t\t\tif (null!=listener)\n \t\t\t\t\t\tlistener.onSucceed(bytes);\n \t\t\t\t}\n\n \t\t\t\t@Override\n \t\t\t\tpublic void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) {\n \t\t\t\t\tif (null!=listener)\n \t\t\t\t\t\tlistener.onFailed(bytes);\n \t\t\t\t}\n \t\t\t});\n \t\t}catch(Exception e){\n \t\t\te.printStackTrace();\n \t\t}\n \t\treturn ;\n \t}\n\n \t/**\n \t * 删除空间中的文件\n \t * @param bucket 删除文件的空间\n \t * @param fileName 删除的文件\n \t * */\n \tpublic static boolean deleteFile(String bucket,String fileName,final QiniuRequestListener listener){\n \t\ttry{\n \t\t\tString entryUrl = bucket+\":\"+fileName;\n \t\t\tString encodedEntryURI = UrlSafeBase64.encodeToString(entryUrl.getBytes());\n \t\t\tString host = \"http://rs.qiniu.com\";\n \t\t\tString path = \"/delete/\"+encodedEntryURI;\n \t\t\tString url = host+path;\n \t\t\tLog.e(\"AAAAAAA\", url);\n \t\t\tbyte[] sign = hMacSHA1Encrypt(path+\"\\n\", QiNiuConfig.QINIU_SK);\n \t\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);\n \t\t\tString authorization = QiNiuConfig.QINIU_AK + ':' + encodedSign;\n\n \t\t\tAsyncHttpClient client = new AsyncHttpClient();\n \t\t\tclient.addHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\n \t\t\tclient.addHeader(\"Authorization\", \"QBox \"+authorization);\n \t\t\tRequestParams params = new RequestParams();\n \t\t\tclient.post(url, params, new AsyncHttpResponseHandler() {\n \t\t\t\t@Override\n \t\t\t\tpublic void onSuccess(int i, Header[] headers, byte[] bytes) {\n \t\t\t\t\tif (null!=listener)\n \t\t\t\t\t\tlistener.onSucceed(bytes);\n \t\t\t\t}\n\n \t\t\t\t@Override\n \t\t\t\tpublic void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) {\n \t\t\t\t\tif (null!=listener)\n \t\t\t\t\t\tlistener.onFailed(bytes);\n \t\t\t\t\tif (null!=bytes) {\n \t\t\t\t\t\tString s = new String(bytes);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t});\n\n \t\t}catch(Exception e){\n \t\t\te.printStackTrace();\n \t\t}\n \t\treturn false;\n \t}\n\n }\n~~~\n\n- HMAC-SHA1签名加密类\n\n使用下面方法生成对应七牛资源管理里用到的[管理凭证](http://developer.qiniu.com/article/developer/security/access-token.html)\n\n~~~ Java\n/**\n * 对外提供HMAC-SHA1签名方法\n * @author agehua\n *\n */\npublic class SHA {\n\n    private static final String MAC_NAME = \"HmacSHA1\";\n    private static final String ENCODING = \"UTF-8\";\n\n    /**\n     *\n     * 使用 HMAC-SHA1 签名方法对对encryptText进行签名\n     * @param encryptText 被签名的字符串\n     * @param encryptKey 密钥\n     * @return\n     * @throws Exception\n     */\n    public static byte[] hMacSHA1Encrypt(String encryptText, String encryptKey)\n            throws Exception {\n        byte[] data = encryptKey.getBytes(ENCODING);\n        // 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称\n        SecretKey secretKey = new SecretKeySpec(data, MAC_NAME);\n        // 生成一个指定 Mac 算法 的 Mac 对象\n        Mac mac = Mac.getInstance(MAC_NAME);\n        // 用给定密钥初始化 Mac 对象\n        mac.init(secretKey);\n        byte[] text = encryptText.getBytes(ENCODING);\n        // 完成 Mac 操作\n        return mac.doFinal(text);\n    }\n}  \n~~~  \n\n- 还有一个Config文件\n\n~~~ Java\npublic final class QiNiuConfig {\n\tpublic static final String token = getToken();\n\tpublic static final String QINIU_AK = \"Your_AccessKey\";\n\tpublic static final String QINIU_SK = \"Your_SecretKey\";\n\tpublic static final String QINIU_BUCKNAME = \"你的私有空间\";\n\n\tpublic static String getToken() {\n\t\tMac mac = new Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK);\n\t\tPutPolicy putPolicy = new PutPolicy(QiNiuConfig.QINIU_BUCKNAME);\n\t\tputPolicy.returnBody = \"{\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)}\";\n\t\ttry {\n\t\t\tString uptoken = putPolicy.token(mac);\n\t\t\tSystem.out.println(\"debug:uptoken = \" + uptoken);\n\t\t\treturn uptoken;\n\t\t} catch (AuthException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (JSONException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n}\n\n~~~\n\n [点击在Gist上查看上面这些代码](https://gist.github.com/agehua/f73bcb98af2c0c44a4c49c7c7b7e6bda)\n\n最后，如果有问题欢迎讨论，我的邮箱简介里有 :)  \n","slug":"qiniu-android-summary","published":1,"date":"2016-05-27T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj4x000zbxs6vij8wit7","content":"<h3 id=\"1-在android上实现对七牛空间操作\"><a href=\"#1-在android上实现对七牛空间操作\" class=\"headerlink\" title=\"1.在android上实现对七牛空间操作\"></a>1.在android上实现对七牛空间操作</h3><p>  在android上实现对七牛空间的各种操作，包括list，delete，upload，download。支持私有空间</p>\n<p>  注意：<strong>官方不建议开发者把AccessKey和SecretKey放在前端的java文件里</strong>，最好还是有一台应用服务器</p>\n<p>  如果只是想尝试一下，好吧:)  代码中都有说明，直接上代码</p>\n<a id=\"more\"></a>\n<h3 id=\"2-代码\"><a href=\"#2-代码\" class=\"headerlink\" title=\"2.代码\"></a>2.代码</h3><p>一共有三个类：</p>\n<ul>\n<li>工具类：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.qiniu.ui.utils;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Bitmap;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Bitmap.CompressFormat;</div><div class=\"line\"><span class=\"keyword\">import</span> android.os.Environment;</div><div class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</div><div class=\"line\"><span class=\"keyword\">import</span> com.loopj.android.http.AsyncHttpClient;</div><div class=\"line\"><span class=\"keyword\">import</span> com.loopj.android.http.AsyncHttpResponseHandler;</div><div class=\"line\"><span class=\"keyword\">import</span> com.loopj.android.http.RequestParams;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.android.storage.UpProgressHandler;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.android.storage.UploadManager;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.android.storage.UploadOptions;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.android.utils.UrlSafeBase64;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.api.auth.AuthException;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.api.auth.digest.Mac;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.api.rs.PutPolicy;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.ui.SHA;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.ui.contains.QiNiuConfig;</div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.http.Header;</div><div class=\"line\"><span class=\"keyword\">import</span> org.json.JSONException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedOutputStream;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.FileOutputStream;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> com.qiniu.ui.SHA.hMacSHA1Encrypt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * <span class=\"doctag\">@date</span> 2016年5月26日 上午11:00:43</div><div class=\"line\"> * <span class=\"doctag\">@author</span> lijixin</div><div class=\"line\"> * <span class=\"doctag\">@web</span> https://agehua.github.io</div><div class=\"line\"> * <span class=\"doctag\">@Description</span>: 七牛云图片操作</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QiniuUitls</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String fileName = <span class=\"string\">\"temp.jpg\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String tempJpeg = Environment.getExternalStorageDirectory().getPath() + <span class=\"string\">\"/\"</span> + fileName;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxWidth = <span class=\"number\">720</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxHeight = <span class=\"number\">1080</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">QiniuUploadUitlsListener</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSucess</span><span class=\"params\">(String fileUrl)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(<span class=\"keyword\">int</span> errorCode, String msg)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onProgress</span><span class=\"params\">(<span class=\"keyword\">int</span> progress)</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">QiniuRequestListener</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSucceed</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bytes)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onFailed</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bytes)</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 将bitmap转换成jpeg，控制图片大小不大于720*1080，可以指定图片压缩质量</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> bitmap</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> filePath</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> quality</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">saveBitmapToJpegFile</span><span class=\"params\">(Bitmap bitmap, String filePath, <span class=\"keyword\">int</span> quality)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tFileOutputStream fileOutStr = <span class=\"keyword\">new</span> FileOutputStream(filePath);</div><div class=\"line\">\t\t\tBufferedOutputStream bufOutStr = <span class=\"keyword\">new</span> BufferedOutputStream(fileOutStr);</div><div class=\"line\">\t\t\tresizeBitmap(bitmap).compress(CompressFormat.JPEG, quality, bufOutStr);</div><div class=\"line\">\t\t\tbufOutStr.flush();</div><div class=\"line\">\t\t\tbufOutStr.close();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 缩小图片</div><div class=\"line\">\t *</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> bitmap</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Bitmap <span class=\"title\">resizeBitmap</span><span class=\"params\">(Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> width = bitmap.getWidth();</div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> height = bitmap.getHeight();</div><div class=\"line\">\t\t\t<span class=\"comment\">//宽度大于720</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (width &gt; maxWidth) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//按宽度等比例压缩图片</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> pWidth = maxWidth;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> pHeight = maxWidth * height / width;</div><div class=\"line\">\t\t\t\tBitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t\t\tbitmap.recycle();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (height &gt; maxHeight) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//按高度等比例缩小图片</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> pHeight = maxHeight;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> pWidth = maxHeight * width / height;</div><div class=\"line\">\t\t\t\tBitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t\t\tbitmap.recycle();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">uploadImage</span><span class=\"params\">(Bitmap bitmap, QiniuUploadUitlsListener listener)</span> </span>&#123;</div><div class=\"line\">\t\tsaveBitmapToJpegFile(bitmap, tempJpeg,<span class=\"number\">100</span>);</div><div class=\"line\">\t\tuploadImage(tempJpeg, listener);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 上传图片选择jpg格式，七牛图片api目前支持对jpg格式进行指定图片质量请求</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> filePath</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> listener</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">uploadImage</span><span class=\"params\">(String filePath, <span class=\"keyword\">final</span> QiniuUploadUitlsListener listener)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> String fileUrlUUID = getFileUrlUUID();</div><div class=\"line\">\t\tString token = getToken();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (token == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tlistener.onError(-<span class=\"number\">1</span>, <span class=\"string\">\"token is null\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tUploadManager uploadManager = <span class=\"keyword\">new</span> UploadManager();</div><div class=\"line\">\t\tuploadManager.put(filePath, fileUrlUUID, token, (key, info, response) -&gt; &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"debug:info = \"</span> + info + <span class=\"string\">\",response = \"</span> + response);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span> &amp;&amp; info.statusCode == <span class=\"number\">200</span>) &#123;<span class=\"comment\">// 上传成功</span></div><div class=\"line\">\t\t\t\tString fileRealUrl = getRealUrl(fileUrlUUID);</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"debug:fileRealUrl = \"</span> + fileRealUrl);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlistener.onSucess(fileRealUrl);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlistener.onError(info.statusCode, info.error);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;, <span class=\"keyword\">new</span> UploadOptions(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> UpProgressHandler() &#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">progress</span><span class=\"params\">(String key, <span class=\"keyword\">double</span> percent)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlistener.onProgress((<span class=\"keyword\">int</span>) (percent * <span class=\"number\">100</span>));</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;, <span class=\"keyword\">null</span>));</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 生成远程文件路径（全局唯一）</div><div class=\"line\">\t * &lt;p&gt;格式类似：\t H60-L12__1464851303930__156750_1884&lt;/p&gt;</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getFileUrlUUID</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString filePath = android.os.Build.MODEL + <span class=\"string\">\"__\"</span> + System.currentTimeMillis() + <span class=\"string\">\"__\"</span> + (<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">500000</span>))</div><div class=\"line\">\t\t\t\t+ <span class=\"string\">\"_\"</span> + (<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">10000</span>));</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> filePath.replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"0\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getRealUrl</span><span class=\"params\">(String fileUrlUUID)</span> </span>&#123;</div><div class=\"line\">\t\tString filePath = <span class=\"string\">\"http://\"</span> + QiNiuConfig.QINIU_BUCKNAME + <span class=\"string\">\".qiniudn.com/\"</span> + fileUrlUUID;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> filePath;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 获取token 本地生成</div><div class=\"line\">\t *</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getToken</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tMac mac = <span class=\"keyword\">new</span> Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\tPutPolicy putPolicy = <span class=\"keyword\">new</span> PutPolicy(QiNiuConfig.QINIU_BUCKNAME);</div><div class=\"line\">\t\tputPolicy.returnBody = <span class=\"string\">\"&#123;\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)&#125;\"</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString uptoken = putPolicy.token(mac);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"debug:uptoken = \"</span> + uptoken);</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> uptoken;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (AuthException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 根据host和文件名，生成file的url下载地址，支持私有空间</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> domain host：七牛的私有空间域名</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> imgKey file key：空间里的文件名</div><div class=\"line\">\t * <span class=\"doctag\">@return</span> url下载地址</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">downloadFile</span><span class=\"params\">(String domain,String imgKey)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//密钥配置</span></div><div class=\"line\">\t\t<span class=\"comment\">//构造私有空间的需要生成的下载的链接</span></div><div class=\"line\"><span class=\"comment\">//\t\tString domain =\"http://example.xxx.clouddn.com/\";</span></div><div class=\"line\"><span class=\"comment\">//\t\tString path =\"H60-L12__1464917382714__36888_5255\";</span></div><div class=\"line\">\t\tStringBuilder sb =<span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">\t\t<span class=\"comment\">//加上过期时间戳字段</span></div><div class=\"line\">\t\tString url = sb.append(domain).append(imgKey).append(<span class=\"string\">\"?e=1478365261\"</span>).toString();</div><div class=\"line\">\t\tLog.e(<span class=\"string\">\"encodedEntryURI\"</span>,url);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">byte</span>[] sign =<span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsign = SHA.hMacSHA1Encrypt(url,QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);</div><div class=\"line\">\t\tsb.append(<span class=\"string\">\"&amp;token=\"</span>).append(QiNiuConfig.QINIU_AK).append(<span class=\"string\">\":\"</span>).append(encodedSign);</div><div class=\"line\">\t\tLog.e(<span class=\"string\">\"download token\"</span>,sb.toString());</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sb.toString();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 列出空间中指定格式的文件</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> bucket 空间名</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> prefix 要指定的格式（前缀）</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> listener</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">listFile</span><span class=\"params\">(String bucket, String prefix,<span class=\"keyword\">final</span> QiniuRequestListener listener)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">try</span>&#123;</div><div class=\"line\">\t\t\tStringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"></div><div class=\"line\">\t\t\tString entryUrl = sb.append(<span class=\"string\">\"bucket=\"</span>).append(bucket)</div><div class=\"line\">\t\t\t\t\t.append(<span class=\"string\">\"&amp;prefix=\"</span>).append(prefix).toString();</div><div class=\"line\">\t\t\tString host = <span class=\"string\">\"http://rsf.qbox.me\"</span>;</div><div class=\"line\">\t\t\tString path = <span class=\"string\">\"/list?\"</span> +entryUrl;</div><div class=\"line\">\t\t\tString url = host+path;</div><div class=\"line\">\t\t\tLog.e(<span class=\"string\">\"AAAAAAA\"</span>, url);</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] sign = SHA.hMacSHA1Encrypt(path+<span class=\"string\">\"\\n\"</span>, QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);</div><div class=\"line\">\t\t\tString authorization = QiNiuConfig.QINIU_AK + <span class=\"string\">':'</span> + encodedSign;</div><div class=\"line\">\t\t\tAsyncHttpClient client = <span class=\"keyword\">new</span> AsyncHttpClient();</div><div class=\"line\">\t\t\tclient.addHeader(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\">\t\t\tclient.addHeader(<span class=\"string\">\"Authorization\"</span>, <span class=\"string\">\"QBox \"</span>+authorization);</div><div class=\"line\">\t\t\tRequestParams params = <span class=\"keyword\">new</span> RequestParams();</div><div class=\"line\">\t\t\tclient.post(url, params, <span class=\"keyword\">new</span> AsyncHttpResponseHandler() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Header[] headers, <span class=\"keyword\">byte</span>[] bytes)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=listener)</div><div class=\"line\">\t\t\t\t\t\tlistener.onSucceed(bytes);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Header[] headers, <span class=\"keyword\">byte</span>[] bytes, Throwable throwable)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=listener)</div><div class=\"line\">\t\t\t\t\t\tlistener.onFailed(bytes);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 删除空间中的文件</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> bucket 删除文件的空间</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> fileName 删除的文件</div><div class=\"line\">\t * */</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deleteFile</span><span class=\"params\">(String bucket,String fileName,<span class=\"keyword\">final</span> QiniuRequestListener listener)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span>&#123;</div><div class=\"line\">\t\t\tString entryUrl = bucket+<span class=\"string\">\":\"</span>+fileName;</div><div class=\"line\">\t\t\tString encodedEntryURI = UrlSafeBase64.encodeToString(entryUrl.getBytes());</div><div class=\"line\">\t\t\tString host = <span class=\"string\">\"http://rs.qiniu.com\"</span>;</div><div class=\"line\">\t\t\tString path = <span class=\"string\">\"/delete/\"</span>+encodedEntryURI;</div><div class=\"line\">\t\t\tString url = host+path;</div><div class=\"line\">\t\t\tLog.e(<span class=\"string\">\"AAAAAAA\"</span>, url);</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] sign = hMacSHA1Encrypt(path+<span class=\"string\">\"\\n\"</span>, QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);</div><div class=\"line\">\t\t\tString authorization = QiNiuConfig.QINIU_AK + <span class=\"string\">':'</span> + encodedSign;</div><div class=\"line\"></div><div class=\"line\">\t\t\tAsyncHttpClient client = <span class=\"keyword\">new</span> AsyncHttpClient();</div><div class=\"line\">\t\t\tclient.addHeader(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\">\t\t\tclient.addHeader(<span class=\"string\">\"Authorization\"</span>, <span class=\"string\">\"QBox \"</span>+authorization);</div><div class=\"line\">\t\t\tRequestParams params = <span class=\"keyword\">new</span> RequestParams();</div><div class=\"line\">\t\t\tclient.post(url, params, <span class=\"keyword\">new</span> AsyncHttpResponseHandler() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Header[] headers, <span class=\"keyword\">byte</span>[] bytes)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=listener)</div><div class=\"line\">\t\t\t\t\t\tlistener.onSucceed(bytes);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Header[] headers, <span class=\"keyword\">byte</span>[] bytes, Throwable throwable)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=listener)</div><div class=\"line\">\t\t\t\t\t\tlistener.onFailed(bytes);</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=bytes) &#123;</div><div class=\"line\">\t\t\t\t\t\tString s = <span class=\"keyword\">new</span> String(bytes);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>HMAC-SHA1签名加密类</li>\n</ul>\n<p>使用下面方法生成对应七牛资源管理里用到的<a href=\"http://developer.qiniu.com/article/developer/security/access-token.html\" target=\"_blank\" rel=\"external\">管理凭证</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对外提供HMAC-SHA1签名方法</div><div class=\"line\"> * <span class=\"doctag\">@author</span> agehua</div><div class=\"line\"> *</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SHA</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String MAC_NAME = <span class=\"string\">\"HmacSHA1\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ENCODING = <span class=\"string\">\"UTF-8\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     *</div><div class=\"line\">     * 使用 HMAC-SHA1 签名方法对对encryptText进行签名</div><div class=\"line\">     * <span class=\"doctag\">@param</span> encryptText 被签名的字符串</div><div class=\"line\">     * <span class=\"doctag\">@param</span> encryptKey 密钥</div><div class=\"line\">     * <span class=\"doctag\">@return</span></div><div class=\"line\">     * <span class=\"doctag\">@throws</span> Exception</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] hMacSHA1Encrypt(String encryptText, String encryptKey)</div><div class=\"line\">            <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] data = encryptKey.getBytes(ENCODING);</div><div class=\"line\">        <span class=\"comment\">// 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称</span></div><div class=\"line\">        SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(data, MAC_NAME);</div><div class=\"line\">        <span class=\"comment\">// 生成一个指定 Mac 算法 的 Mac 对象</span></div><div class=\"line\">        Mac mac = Mac.getInstance(MAC_NAME);</div><div class=\"line\">        <span class=\"comment\">// 用给定密钥初始化 Mac 对象</span></div><div class=\"line\">        mac.init(secretKey);</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] text = encryptText.getBytes(ENCODING);</div><div class=\"line\">        <span class=\"comment\">// 完成 Mac 操作</span></div><div class=\"line\">        <span class=\"keyword\">return</span> mac.doFinal(text);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;  </div><div class=\"line\">~~~  </div><div class=\"line\"></div><div class=\"line\">- 还有一个Config文件</div><div class=\"line\"></div><div class=\"line\">~~~ Java</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QiNiuConfig</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String token = getToken();</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QINIU_AK = <span class=\"string\">\"Your_AccessKey\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QINIU_SK = <span class=\"string\">\"Your_SecretKey\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QINIU_BUCKNAME = <span class=\"string\">\"你的私有空间\"</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getToken</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tMac mac = <span class=\"keyword\">new</span> Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\tPutPolicy putPolicy = <span class=\"keyword\">new</span> PutPolicy(QiNiuConfig.QINIU_BUCKNAME);</div><div class=\"line\">\t\tputPolicy.returnBody = <span class=\"string\">\"&#123;\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)&#125;\"</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString uptoken = putPolicy.token(mac);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"debug:uptoken = \"</span> + uptoken);</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> uptoken;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (AuthException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <a href=\"https://gist.github.com/agehua/f73bcb98af2c0c44a4c49c7c7b7e6bda\" target=\"_blank\" rel=\"external\">点击在Gist上查看上面这些代码</a></p>\n<p>最后，如果有问题欢迎讨论，我的邮箱简介里有 :)  </p>\n","excerpt":"<h3 id=\"1-在android上实现对七牛空间操作\"><a href=\"#1-在android上实现对七牛空间操作\" class=\"headerlink\" title=\"1.在android上实现对七牛空间操作\"></a>1.在android上实现对七牛空间操作</h3><p>  在android上实现对七牛空间的各种操作，包括list，delete，upload，download。支持私有空间</p>\n<p>  注意：<strong>官方不建议开发者把AccessKey和SecretKey放在前端的java文件里</strong>，最好还是有一台应用服务器</p>\n<p>  如果只是想尝试一下，好吧:)  代码中都有说明，直接上代码</p>","more":"<h3 id=\"2-代码\"><a href=\"#2-代码\" class=\"headerlink\" title=\"2.代码\"></a>2.代码</h3><p>一共有三个类：</p>\n<ul>\n<li>工具类：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.qiniu.ui.utils;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Bitmap;</div><div class=\"line\"><span class=\"keyword\">import</span> android.graphics.Bitmap.CompressFormat;</div><div class=\"line\"><span class=\"keyword\">import</span> android.os.Environment;</div><div class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</div><div class=\"line\"><span class=\"keyword\">import</span> com.loopj.android.http.AsyncHttpClient;</div><div class=\"line\"><span class=\"keyword\">import</span> com.loopj.android.http.AsyncHttpResponseHandler;</div><div class=\"line\"><span class=\"keyword\">import</span> com.loopj.android.http.RequestParams;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.android.storage.UpProgressHandler;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.android.storage.UploadManager;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.android.storage.UploadOptions;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.android.utils.UrlSafeBase64;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.api.auth.AuthException;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.api.auth.digest.Mac;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.api.rs.PutPolicy;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.ui.SHA;</div><div class=\"line\"><span class=\"keyword\">import</span> com.qiniu.ui.contains.QiNiuConfig;</div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.http.Header;</div><div class=\"line\"><span class=\"keyword\">import</span> org.json.JSONException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedOutputStream;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.FileOutputStream;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> com.qiniu.ui.SHA.hMacSHA1Encrypt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * <span class=\"doctag\">@date</span> 2016年5月26日 上午11:00:43</div><div class=\"line\"> * <span class=\"doctag\">@author</span> lijixin</div><div class=\"line\"> * <span class=\"doctag\">@web</span> https://agehua.github.io</div><div class=\"line\"> * <span class=\"doctag\">@Description</span>: 七牛云图片操作</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QiniuUitls</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String fileName = <span class=\"string\">\"temp.jpg\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String tempJpeg = Environment.getExternalStorageDirectory().getPath() + <span class=\"string\">\"/\"</span> + fileName;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxWidth = <span class=\"number\">720</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> maxHeight = <span class=\"number\">1080</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">QiniuUploadUitlsListener</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSucess</span><span class=\"params\">(String fileUrl)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(<span class=\"keyword\">int</span> errorCode, String msg)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onProgress</span><span class=\"params\">(<span class=\"keyword\">int</span> progress)</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">QiniuRequestListener</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSucceed</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bytes)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onFailed</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bytes)</span></span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 将bitmap转换成jpeg，控制图片大小不大于720*1080，可以指定图片压缩质量</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> bitmap</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> filePath</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> quality</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">saveBitmapToJpegFile</span><span class=\"params\">(Bitmap bitmap, String filePath, <span class=\"keyword\">int</span> quality)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tFileOutputStream fileOutStr = <span class=\"keyword\">new</span> FileOutputStream(filePath);</div><div class=\"line\">\t\t\tBufferedOutputStream bufOutStr = <span class=\"keyword\">new</span> BufferedOutputStream(fileOutStr);</div><div class=\"line\">\t\t\tresizeBitmap(bitmap).compress(CompressFormat.JPEG, quality, bufOutStr);</div><div class=\"line\">\t\t\tbufOutStr.flush();</div><div class=\"line\">\t\t\tbufOutStr.close();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 缩小图片</div><div class=\"line\">\t *</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> bitmap</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Bitmap <span class=\"title\">resizeBitmap</span><span class=\"params\">(Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> width = bitmap.getWidth();</div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> height = bitmap.getHeight();</div><div class=\"line\">\t\t\t<span class=\"comment\">//宽度大于720</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (width &gt; maxWidth) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//按宽度等比例压缩图片</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> pWidth = maxWidth;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> pHeight = maxWidth * height / width;</div><div class=\"line\">\t\t\t\tBitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t\t\tbitmap.recycle();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (height &gt; maxHeight) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//按高度等比例缩小图片</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> pHeight = maxHeight;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> pWidth = maxHeight * width / height;</div><div class=\"line\">\t\t\t\tBitmap result = Bitmap.createScaledBitmap(bitmap, pWidth, pHeight, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t\t\tbitmap.recycle();</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">uploadImage</span><span class=\"params\">(Bitmap bitmap, QiniuUploadUitlsListener listener)</span> </span>&#123;</div><div class=\"line\">\t\tsaveBitmapToJpegFile(bitmap, tempJpeg,<span class=\"number\">100</span>);</div><div class=\"line\">\t\tuploadImage(tempJpeg, listener);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 上传图片选择jpg格式，七牛图片api目前支持对jpg格式进行指定图片质量请求</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> filePath</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> listener</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">uploadImage</span><span class=\"params\">(String filePath, <span class=\"keyword\">final</span> QiniuUploadUitlsListener listener)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">final</span> String fileUrlUUID = getFileUrlUUID();</div><div class=\"line\">\t\tString token = getToken();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (token == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tlistener.onError(-<span class=\"number\">1</span>, <span class=\"string\">\"token is null\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tUploadManager uploadManager = <span class=\"keyword\">new</span> UploadManager();</div><div class=\"line\">\t\tuploadManager.put(filePath, fileUrlUUID, token, (key, info, response) -&gt; &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"debug:info = \"</span> + info + <span class=\"string\">\",response = \"</span> + response);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span> &amp;&amp; info.statusCode == <span class=\"number\">200</span>) &#123;<span class=\"comment\">// 上传成功</span></div><div class=\"line\">\t\t\t\tString fileRealUrl = getRealUrl(fileUrlUUID);</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"debug:fileRealUrl = \"</span> + fileRealUrl);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlistener.onSucess(fileRealUrl);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlistener.onError(info.statusCode, info.error);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;, <span class=\"keyword\">new</span> UploadOptions(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> UpProgressHandler() &#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">progress</span><span class=\"params\">(String key, <span class=\"keyword\">double</span> percent)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\t\tlistener.onProgress((<span class=\"keyword\">int</span>) (percent * <span class=\"number\">100</span>));</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;, <span class=\"keyword\">null</span>));</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 生成远程文件路径（全局唯一）</div><div class=\"line\">\t * &lt;p&gt;格式类似：\t H60-L12__1464851303930__156750_1884&lt;/p&gt;</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getFileUrlUUID</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tString filePath = android.os.Build.MODEL + <span class=\"string\">\"__\"</span> + System.currentTimeMillis() + <span class=\"string\">\"__\"</span> + (<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">500000</span>))</div><div class=\"line\">\t\t\t\t+ <span class=\"string\">\"_\"</span> + (<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">10000</span>));</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> filePath.replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"0\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getRealUrl</span><span class=\"params\">(String fileUrlUUID)</span> </span>&#123;</div><div class=\"line\">\t\tString filePath = <span class=\"string\">\"http://\"</span> + QiNiuConfig.QINIU_BUCKNAME + <span class=\"string\">\".qiniudn.com/\"</span> + fileUrlUUID;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> filePath;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 获取token 本地生成</div><div class=\"line\">\t *</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getToken</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tMac mac = <span class=\"keyword\">new</span> Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\tPutPolicy putPolicy = <span class=\"keyword\">new</span> PutPolicy(QiNiuConfig.QINIU_BUCKNAME);</div><div class=\"line\">\t\tputPolicy.returnBody = <span class=\"string\">\"&#123;\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)&#125;\"</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString uptoken = putPolicy.token(mac);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"debug:uptoken = \"</span> + uptoken);</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> uptoken;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (AuthException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 根据host和文件名，生成file的url下载地址，支持私有空间</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> domain host：七牛的私有空间域名</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> imgKey file key：空间里的文件名</div><div class=\"line\">\t * <span class=\"doctag\">@return</span> url下载地址</div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">downloadFile</span><span class=\"params\">(String domain,String imgKey)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//密钥配置</span></div><div class=\"line\">\t\t<span class=\"comment\">//构造私有空间的需要生成的下载的链接</span></div><div class=\"line\"><span class=\"comment\">//\t\tString domain =\"http://example.xxx.clouddn.com/\";</span></div><div class=\"line\"><span class=\"comment\">//\t\tString path =\"H60-L12__1464917382714__36888_5255\";</span></div><div class=\"line\">\t\tStringBuilder sb =<span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">\t\t<span class=\"comment\">//加上过期时间戳字段</span></div><div class=\"line\">\t\tString url = sb.append(domain).append(imgKey).append(<span class=\"string\">\"?e=1478365261\"</span>).toString();</div><div class=\"line\">\t\tLog.e(<span class=\"string\">\"encodedEntryURI\"</span>,url);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">byte</span>[] sign =<span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tsign = SHA.hMacSHA1Encrypt(url,QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);</div><div class=\"line\">\t\tsb.append(<span class=\"string\">\"&amp;token=\"</span>).append(QiNiuConfig.QINIU_AK).append(<span class=\"string\">\":\"</span>).append(encodedSign);</div><div class=\"line\">\t\tLog.e(<span class=\"string\">\"download token\"</span>,sb.toString());</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sb.toString();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 列出空间中指定格式的文件</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> bucket 空间名</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> prefix 要指定的格式（前缀）</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> listener</div><div class=\"line\">\t * <span class=\"doctag\">@return</span></div><div class=\"line\">\t */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">listFile</span><span class=\"params\">(String bucket, String prefix,<span class=\"keyword\">final</span> QiniuRequestListener listener)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">try</span>&#123;</div><div class=\"line\">\t\t\tStringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"></div><div class=\"line\">\t\t\tString entryUrl = sb.append(<span class=\"string\">\"bucket=\"</span>).append(bucket)</div><div class=\"line\">\t\t\t\t\t.append(<span class=\"string\">\"&amp;prefix=\"</span>).append(prefix).toString();</div><div class=\"line\">\t\t\tString host = <span class=\"string\">\"http://rsf.qbox.me\"</span>;</div><div class=\"line\">\t\t\tString path = <span class=\"string\">\"/list?\"</span> +entryUrl;</div><div class=\"line\">\t\t\tString url = host+path;</div><div class=\"line\">\t\t\tLog.e(<span class=\"string\">\"AAAAAAA\"</span>, url);</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] sign = SHA.hMacSHA1Encrypt(path+<span class=\"string\">\"\\n\"</span>, QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);</div><div class=\"line\">\t\t\tString authorization = QiNiuConfig.QINIU_AK + <span class=\"string\">':'</span> + encodedSign;</div><div class=\"line\">\t\t\tAsyncHttpClient client = <span class=\"keyword\">new</span> AsyncHttpClient();</div><div class=\"line\">\t\t\tclient.addHeader(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\">\t\t\tclient.addHeader(<span class=\"string\">\"Authorization\"</span>, <span class=\"string\">\"QBox \"</span>+authorization);</div><div class=\"line\">\t\t\tRequestParams params = <span class=\"keyword\">new</span> RequestParams();</div><div class=\"line\">\t\t\tclient.post(url, params, <span class=\"keyword\">new</span> AsyncHttpResponseHandler() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Header[] headers, <span class=\"keyword\">byte</span>[] bytes)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=listener)</div><div class=\"line\">\t\t\t\t\t\tlistener.onSucceed(bytes);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Header[] headers, <span class=\"keyword\">byte</span>[] bytes, Throwable throwable)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=listener)</div><div class=\"line\">\t\t\t\t\t\tlistener.onFailed(bytes);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 删除空间中的文件</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> bucket 删除文件的空间</div><div class=\"line\">\t * <span class=\"doctag\">@param</span> fileName 删除的文件</div><div class=\"line\">\t * */</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deleteFile</span><span class=\"params\">(String bucket,String fileName,<span class=\"keyword\">final</span> QiniuRequestListener listener)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span>&#123;</div><div class=\"line\">\t\t\tString entryUrl = bucket+<span class=\"string\">\":\"</span>+fileName;</div><div class=\"line\">\t\t\tString encodedEntryURI = UrlSafeBase64.encodeToString(entryUrl.getBytes());</div><div class=\"line\">\t\t\tString host = <span class=\"string\">\"http://rs.qiniu.com\"</span>;</div><div class=\"line\">\t\t\tString path = <span class=\"string\">\"/delete/\"</span>+encodedEntryURI;</div><div class=\"line\">\t\t\tString url = host+path;</div><div class=\"line\">\t\t\tLog.e(<span class=\"string\">\"AAAAAAA\"</span>, url);</div><div class=\"line\">\t\t\t<span class=\"keyword\">byte</span>[] sign = hMacSHA1Encrypt(path+<span class=\"string\">\"\\n\"</span>, QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\t\tString encodedSign = UrlSafeBase64.encodeToString(sign);</div><div class=\"line\">\t\t\tString authorization = QiNiuConfig.QINIU_AK + <span class=\"string\">':'</span> + encodedSign;</div><div class=\"line\"></div><div class=\"line\">\t\t\tAsyncHttpClient client = <span class=\"keyword\">new</span> AsyncHttpClient();</div><div class=\"line\">\t\t\tclient.addHeader(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);</div><div class=\"line\">\t\t\tclient.addHeader(<span class=\"string\">\"Authorization\"</span>, <span class=\"string\">\"QBox \"</span>+authorization);</div><div class=\"line\">\t\t\tRequestParams params = <span class=\"keyword\">new</span> RequestParams();</div><div class=\"line\">\t\t\tclient.post(url, params, <span class=\"keyword\">new</span> AsyncHttpResponseHandler() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Header[] headers, <span class=\"keyword\">byte</span>[] bytes)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=listener)</div><div class=\"line\">\t\t\t\t\t\tlistener.onSucceed(bytes);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Header[] headers, <span class=\"keyword\">byte</span>[] bytes, Throwable throwable)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=listener)</div><div class=\"line\">\t\t\t\t\t\tlistener.onFailed(bytes);</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=bytes) &#123;</div><div class=\"line\">\t\t\t\t\t\tString s = <span class=\"keyword\">new</span> String(bytes);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>HMAC-SHA1签名加密类</li>\n</ul>\n<p>使用下面方法生成对应七牛资源管理里用到的<a href=\"http://developer.qiniu.com/article/developer/security/access-token.html\">管理凭证</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 对外提供HMAC-SHA1签名方法</div><div class=\"line\"> * <span class=\"doctag\">@author</span> agehua</div><div class=\"line\"> *</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SHA</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String MAC_NAME = <span class=\"string\">\"HmacSHA1\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ENCODING = <span class=\"string\">\"UTF-8\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     *</div><div class=\"line\">     * 使用 HMAC-SHA1 签名方法对对encryptText进行签名</div><div class=\"line\">     * <span class=\"doctag\">@param</span> encryptText 被签名的字符串</div><div class=\"line\">     * <span class=\"doctag\">@param</span> encryptKey 密钥</div><div class=\"line\">     * <span class=\"doctag\">@return</span></div><div class=\"line\">     * <span class=\"doctag\">@throws</span> Exception</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] hMacSHA1Encrypt(String encryptText, String encryptKey)</div><div class=\"line\">            <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] data = encryptKey.getBytes(ENCODING);</div><div class=\"line\">        <span class=\"comment\">// 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称</span></div><div class=\"line\">        SecretKey secretKey = <span class=\"keyword\">new</span> SecretKeySpec(data, MAC_NAME);</div><div class=\"line\">        <span class=\"comment\">// 生成一个指定 Mac 算法 的 Mac 对象</span></div><div class=\"line\">        Mac mac = Mac.getInstance(MAC_NAME);</div><div class=\"line\">        <span class=\"comment\">// 用给定密钥初始化 Mac 对象</span></div><div class=\"line\">        mac.init(secretKey);</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] text = encryptText.getBytes(ENCODING);</div><div class=\"line\">        <span class=\"comment\">// 完成 Mac 操作</span></div><div class=\"line\">        <span class=\"keyword\">return</span> mac.doFinal(text);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;  </div><div class=\"line\">~~~  </div><div class=\"line\"></div><div class=\"line\">- 还有一个Config文件</div><div class=\"line\"></div><div class=\"line\">~~~ Java</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QiNiuConfig</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String token = getToken();</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QINIU_AK = <span class=\"string\">\"Your_AccessKey\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QINIU_SK = <span class=\"string\">\"Your_SecretKey\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QINIU_BUCKNAME = <span class=\"string\">\"你的私有空间\"</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getToken</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tMac mac = <span class=\"keyword\">new</span> Mac(QiNiuConfig.QINIU_AK, QiNiuConfig.QINIU_SK);</div><div class=\"line\">\t\tPutPolicy putPolicy = <span class=\"keyword\">new</span> PutPolicy(QiNiuConfig.QINIU_BUCKNAME);</div><div class=\"line\">\t\tputPolicy.returnBody = <span class=\"string\">\"&#123;\\\"name\\\": $(fname),\\\"size\\\": \\\"$(fsize)\\\",\\\"w\\\": \\\"$(imageInfo.width)\\\",\\\"h\\\": \\\"$(imageInfo.height)\\\",\\\"key\\\":$(etag)&#125;\"</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\tString uptoken = putPolicy.token(mac);</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"debug:uptoken = \"</span> + uptoken);</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> uptoken;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (AuthException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <a href=\"https://gist.github.com/agehua/f73bcb98af2c0c44a4c49c7c7b7e6bda\">点击在Gist上查看上面这些代码</a></p>\n<p>最后，如果有问题欢迎讨论，我的邮箱简介里有 :)  </p>"},{"layout":"post","title":"Android Webview总结，不断更新中 :(","keywords":"Android Webview, js漏洞","description":"Android Webview总结，遇到问题就在这里记录 :(","banner":"http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg","_content":"\n\n### 1.Android Webview的坑\n\n- 1.webview再次加载页面空白\n\n  - 1.可以关闭掉硬件加速\n\n  - 2.不关闭硬件加速的情况下：在关闭Acivity之前手动调用下面方法，\n\n  <!--more-->\n\n  ~~~ Java\n   public void goFinish(){\n        isLoadWithError =false;\n        if (null!=jsCallBack)\n            mWebView.removeJavascriptInterface(\"XXX\");\n        mWebView.setFocusable(true);\n        mWebView.removeAllViews();\n        try {\n        \tmWebView.clearHistory(); //webview没有历史记录，这里会抛出异常\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        mWebView.destroy();\n\n        try {\n        \t//mWebView为WebView所在类的全局变量名，不可以混淆\n            Field fieldWebView = this.getClass().getDeclaredField(\"mWebView\");\n            fieldWebView.setAccessible(true);\n            WebView webView = (WebView) fieldWebView.get(this);\n            webView.removeAllViews();\n            webView.destroy();\n\n        }catch (NoSuchFieldException e) {\n            e.printStackTrace();\n\n        }catch (IllegalArgumentException e) {\n            e.printStackTrace();\n\n        }catch (IllegalAccessException e) {\n            e.printStackTrace();\n\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        this.finish();\n    }\n   ~~~\n\n> 注意：因为用到了反射去清理webview，所以混淆时，**这个方法所在的类不能混淆**\n\n\n- 2.部分手机h5 game屏幕闪烁\n\n\t在小米的某些手机上，会出现这种情况。抱歉，还没有好的解决办法。谁有好的解决办法可以邮件告知，多谢 :)\n\n- 3.android Webview替代品Crosswalk\n\n\tCrosswalk解决4,2以下的手机浏览器的兼容性问题。对html5的支持更好\n\n\t[Crosswalk官网](https://crosswalk-project.org/)\n\n\t但Crosswalk也有缺点，将Crosswalk嵌入App中，会使APK增加大约20M。具体可以看这个[知乎提问](https://www.zhihu.com/question/26484511)\n\n- 4.腾讯浏览服务\n\n\t[官网地址](http://x5.tencent.com/index)\n\n### 2.WebView防止远程代码攻击\n\n- 1.使用Android4.2以上的系统，通过在Java的远程方法上面声明一个@JavascriptInterface，可以预防改安全漏洞  \n\n- 2.低于Android4.2的系统，如果系统自己添加了一个叫searchBoxJavaBridge_的Js接口，则需要把这个接口删除\n\n  详情参见这篇文章：[Android WebView的Js对象注入漏洞解决方案](http://blog.csdn.net/leehong2005/article/details/11808557/)\n\n  这里贴一个自己整理的webview类：[BaseWebView](https://gist.github.com/agehua/99233b40e05db29ee0ed4f50fb2c7530)\n\n### 3.Android中WebView的JavaScript代码和本地代码交互的三种方式\n来自姜维的博客:[Android中WebView的JavaScript代码和本地代码交互的三种方式](http://blog.csdn.net/jiangwei0910410003/article/details/52687530)\n","source":"_posts/2016-07-25-android-webview-summary.md","raw":"---\nlayout: post\ntitle: Android Webview总结，不断更新中 :(\ncategory: accumulation\ntags: accumulation\nkeywords: Android Webview, js漏洞\ndescription: Android Webview总结，遇到问题就在这里记录 :(\nbanner: http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg\n---\n\n\n### 1.Android Webview的坑\n\n- 1.webview再次加载页面空白\n\n  - 1.可以关闭掉硬件加速\n\n  - 2.不关闭硬件加速的情况下：在关闭Acivity之前手动调用下面方法，\n\n  <!--more-->\n\n  ~~~ Java\n   public void goFinish(){\n        isLoadWithError =false;\n        if (null!=jsCallBack)\n            mWebView.removeJavascriptInterface(\"XXX\");\n        mWebView.setFocusable(true);\n        mWebView.removeAllViews();\n        try {\n        \tmWebView.clearHistory(); //webview没有历史记录，这里会抛出异常\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        mWebView.destroy();\n\n        try {\n        \t//mWebView为WebView所在类的全局变量名，不可以混淆\n            Field fieldWebView = this.getClass().getDeclaredField(\"mWebView\");\n            fieldWebView.setAccessible(true);\n            WebView webView = (WebView) fieldWebView.get(this);\n            webView.removeAllViews();\n            webView.destroy();\n\n        }catch (NoSuchFieldException e) {\n            e.printStackTrace();\n\n        }catch (IllegalArgumentException e) {\n            e.printStackTrace();\n\n        }catch (IllegalAccessException e) {\n            e.printStackTrace();\n\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        this.finish();\n    }\n   ~~~\n\n> 注意：因为用到了反射去清理webview，所以混淆时，**这个方法所在的类不能混淆**\n\n\n- 2.部分手机h5 game屏幕闪烁\n\n\t在小米的某些手机上，会出现这种情况。抱歉，还没有好的解决办法。谁有好的解决办法可以邮件告知，多谢 :)\n\n- 3.android Webview替代品Crosswalk\n\n\tCrosswalk解决4,2以下的手机浏览器的兼容性问题。对html5的支持更好\n\n\t[Crosswalk官网](https://crosswalk-project.org/)\n\n\t但Crosswalk也有缺点，将Crosswalk嵌入App中，会使APK增加大约20M。具体可以看这个[知乎提问](https://www.zhihu.com/question/26484511)\n\n- 4.腾讯浏览服务\n\n\t[官网地址](http://x5.tencent.com/index)\n\n### 2.WebView防止远程代码攻击\n\n- 1.使用Android4.2以上的系统，通过在Java的远程方法上面声明一个@JavascriptInterface，可以预防改安全漏洞  \n\n- 2.低于Android4.2的系统，如果系统自己添加了一个叫searchBoxJavaBridge_的Js接口，则需要把这个接口删除\n\n  详情参见这篇文章：[Android WebView的Js对象注入漏洞解决方案](http://blog.csdn.net/leehong2005/article/details/11808557/)\n\n  这里贴一个自己整理的webview类：[BaseWebView](https://gist.github.com/agehua/99233b40e05db29ee0ed4f50fb2c7530)\n\n### 3.Android中WebView的JavaScript代码和本地代码交互的三种方式\n来自姜维的博客:[Android中WebView的JavaScript代码和本地代码交互的三种方式](http://blog.csdn.net/jiangwei0910410003/article/details/52687530)\n","slug":"android-webview-summary","published":1,"date":"2016-07-24T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj4z0012bxs68t759qya","content":"<h3 id=\"1-Android-Webview的坑\"><a href=\"#1-Android-Webview的坑\" class=\"headerlink\" title=\"1.Android Webview的坑\"></a>1.Android Webview的坑</h3><ul>\n<li><p>1.webview再次加载页面空白</p>\n<ul>\n<li><p>1.可以关闭掉硬件加速</p>\n</li>\n<li><p>2.不关闭硬件加速的情况下：在关闭Acivity之前手动调用下面方法，</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">goFinish</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">     isLoadWithError =<span class=\"keyword\">false</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=jsCallBack)</div><div class=\"line\">         mWebView.removeJavascriptInterface(<span class=\"string\">\"XXX\"</span>);</div><div class=\"line\">     mWebView.setFocusable(<span class=\"keyword\">true</span>);</div><div class=\"line\">     mWebView.removeAllViews();</div><div class=\"line\">     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     \tmWebView.clearHistory(); <span class=\"comment\">//webview没有历史记录，这里会抛出异常</span></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\">     &#125;</div><div class=\"line\">     mWebView.destroy();</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     \t<span class=\"comment\">//mWebView为WebView所在类的全局变量名，不可以混淆</span></div><div class=\"line\">         Field fieldWebView = <span class=\"keyword\">this</span>.getClass().getDeclaredField(<span class=\"string\">\"mWebView\"</span>);</div><div class=\"line\">         fieldWebView.setAccessible(<span class=\"keyword\">true</span>);</div><div class=\"line\">         WebView webView = (WebView) fieldWebView.get(<span class=\"keyword\">this</span>);</div><div class=\"line\">         webView.removeAllViews();</div><div class=\"line\">         webView.destroy();</div><div class=\"line\"></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span> (IllegalArgumentException e) &#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">this</span>.finish();</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>注意：因为用到了反射去清理webview，所以混淆时，<strong>这个方法所在的类不能混淆</strong></p>\n</blockquote>\n<ul>\n<li><p>2.部分手机h5 game屏幕闪烁</p>\n<p>  在小米的某些手机上，会出现这种情况。抱歉，还没有好的解决办法。谁有好的解决办法可以邮件告知，多谢 :)</p>\n</li>\n<li><p>3.android Webview替代品Crosswalk</p>\n<p>  Crosswalk解决4,2以下的手机浏览器的兼容性问题。对html5的支持更好</p>\n<p>  <a href=\"https://crosswalk-project.org/\" target=\"_blank\" rel=\"external\">Crosswalk官网</a></p>\n<p>  但Crosswalk也有缺点，将Crosswalk嵌入App中，会使APK增加大约20M。具体可以看这个<a href=\"https://www.zhihu.com/question/26484511\" target=\"_blank\" rel=\"external\">知乎提问</a></p>\n</li>\n<li><p>4.腾讯浏览服务</p>\n<p>  <a href=\"http://x5.tencent.com/index\" target=\"_blank\" rel=\"external\">官网地址</a></p>\n</li>\n</ul>\n<h3 id=\"2-WebView防止远程代码攻击\"><a href=\"#2-WebView防止远程代码攻击\" class=\"headerlink\" title=\"2.WebView防止远程代码攻击\"></a>2.WebView防止远程代码攻击</h3><ul>\n<li><p>1.使用Android4.2以上的系统，通过在Java的远程方法上面声明一个@JavascriptInterface，可以预防改安全漏洞  </p>\n</li>\n<li><p>2.低于Android4.2的系统，如果系统自己添加了一个叫searchBoxJavaBridge_的Js接口，则需要把这个接口删除</p>\n<p>详情参见这篇文章：<a href=\"http://blog.csdn.net/leehong2005/article/details/11808557/\" target=\"_blank\" rel=\"external\">Android WebView的Js对象注入漏洞解决方案</a></p>\n<p>这里贴一个自己整理的webview类：<a href=\"https://gist.github.com/agehua/99233b40e05db29ee0ed4f50fb2c7530\" target=\"_blank\" rel=\"external\">BaseWebView</a></p>\n</li>\n</ul>\n<h3 id=\"3-Android中WebView的JavaScript代码和本地代码交互的三种方式\"><a href=\"#3-Android中WebView的JavaScript代码和本地代码交互的三种方式\" class=\"headerlink\" title=\"3.Android中WebView的JavaScript代码和本地代码交互的三种方式\"></a>3.Android中WebView的JavaScript代码和本地代码交互的三种方式</h3><p>来自姜维的博客:<a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/52687530\" target=\"_blank\" rel=\"external\">Android中WebView的JavaScript代码和本地代码交互的三种方式</a></p>\n","excerpt":"<h3 id=\"1-Android-Webview的坑\"><a href=\"#1-Android-Webview的坑\" class=\"headerlink\" title=\"1.Android Webview的坑\"></a>1.Android Webview的坑</h3><ul>\n<li><p>1.webview再次加载页面空白</p>\n<ul>\n<li><p>1.可以关闭掉硬件加速</p>\n</li>\n<li><p>2.不关闭硬件加速的情况下：在关闭Acivity之前手动调用下面方法，</p>\n</li>\n</ul>","more":"<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">goFinish</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">     isLoadWithError =<span class=\"keyword\">false</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=jsCallBack)</div><div class=\"line\">         mWebView.removeJavascriptInterface(<span class=\"string\">\"XXX\"</span>);</div><div class=\"line\">     mWebView.setFocusable(<span class=\"keyword\">true</span>);</div><div class=\"line\">     mWebView.removeAllViews();</div><div class=\"line\">     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     \tmWebView.clearHistory(); <span class=\"comment\">//webview没有历史记录，这里会抛出异常</span></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\">     &#125;</div><div class=\"line\">     mWebView.destroy();</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">     \t<span class=\"comment\">//mWebView为WebView所在类的全局变量名，不可以混淆</span></div><div class=\"line\">         Field fieldWebView = <span class=\"keyword\">this</span>.getClass().getDeclaredField(<span class=\"string\">\"mWebView\"</span>);</div><div class=\"line\">         fieldWebView.setAccessible(<span class=\"keyword\">true</span>);</div><div class=\"line\">         WebView webView = (WebView) fieldWebView.get(<span class=\"keyword\">this</span>);</div><div class=\"line\">         webView.removeAllViews();</div><div class=\"line\">         webView.destroy();</div><div class=\"line\"></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span> (IllegalArgumentException e) &#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">     &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">         e.printStackTrace();</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">this</span>.finish();</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>注意：因为用到了反射去清理webview，所以混淆时，<strong>这个方法所在的类不能混淆</strong></p>\n</blockquote>\n<ul>\n<li><p>2.部分手机h5 game屏幕闪烁</p>\n<p>  在小米的某些手机上，会出现这种情况。抱歉，还没有好的解决办法。谁有好的解决办法可以邮件告知，多谢 :)</p>\n</li>\n<li><p>3.android Webview替代品Crosswalk</p>\n<p>  Crosswalk解决4,2以下的手机浏览器的兼容性问题。对html5的支持更好</p>\n<p>  <a href=\"https://crosswalk-project.org/\">Crosswalk官网</a></p>\n<p>  但Crosswalk也有缺点，将Crosswalk嵌入App中，会使APK增加大约20M。具体可以看这个<a href=\"https://www.zhihu.com/question/26484511\">知乎提问</a></p>\n</li>\n<li><p>4.腾讯浏览服务</p>\n<p>  <a href=\"http://x5.tencent.com/index\">官网地址</a></p>\n</li>\n</ul>\n<h3 id=\"2-WebView防止远程代码攻击\"><a href=\"#2-WebView防止远程代码攻击\" class=\"headerlink\" title=\"2.WebView防止远程代码攻击\"></a>2.WebView防止远程代码攻击</h3><ul>\n<li><p>1.使用Android4.2以上的系统，通过在Java的远程方法上面声明一个@JavascriptInterface，可以预防改安全漏洞  </p>\n</li>\n<li><p>2.低于Android4.2的系统，如果系统自己添加了一个叫searchBoxJavaBridge_的Js接口，则需要把这个接口删除</p>\n<p>详情参见这篇文章：<a href=\"http://blog.csdn.net/leehong2005/article/details/11808557/\">Android WebView的Js对象注入漏洞解决方案</a></p>\n<p>这里贴一个自己整理的webview类：<a href=\"https://gist.github.com/agehua/99233b40e05db29ee0ed4f50fb2c7530\">BaseWebView</a></p>\n</li>\n</ul>\n<h3 id=\"3-Android中WebView的JavaScript代码和本地代码交互的三种方式\"><a href=\"#3-Android中WebView的JavaScript代码和本地代码交互的三种方式\" class=\"headerlink\" title=\"3.Android中WebView的JavaScript代码和本地代码交互的三种方式\"></a>3.Android中WebView的JavaScript代码和本地代码交互的三种方式</h3><p>来自姜维的博客:<a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/52687530\">Android中WebView的JavaScript代码和本地代码交互的三种方式</a></p>"},{"layout":"post","title":"Android手机定位服务","keywords":"LocationListener","description":"Android使用手机定位服务使用，GPS服务不可用则跳转到手机位置服务设置页面","banner":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Acacia%20Branches.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Acacia%20Branches.jpg","_content":"\n\n\n### 1.LocationListener使用\n\n优先使用网络定位服务，当GPS服务不可用则跳转到手机位置服务设置页面\n\n<!--more-->\n\n~~~ Java\n/**\n  * 使用手机定位服务\n  */\n  private void startLocationService(){\n      locationListener = new LocationListener() {\n\n          @Override\n          public void onStatusChanged(String provider, int status, Bundle extras) {\n          }\n          @Override\n          public void onProviderEnabled(String provider) {\n              // 当GPS LocationProvider可用时，更新位置\n              location = locManager.getLastKnownLocation(provider);\n          }\n          @Override\n          public void onProviderDisabled(String provider) {\n              isLocatedSuccess = false;\n              if (provider.equals(\"network\")) {\n                      locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3 * 1000, 8,locationListener);\n              }else if(provider.equals(\"gps\")){//GPS服务不可用，跳到位置服务设置页面\n                  startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));\n              }else {\n                  updateToNewLocation(null);\n              }\n          }\n          @Override\n          public void onLocationChanged(Location location) {\n              // 当定位信息发生改变时，更新位置\n              isLocatedSuccess = true;\n              updateToNewLocation(location);\n              locManager.removeUpdates(this);\n          }\n      };\n\n      if (locManager.getProvider(LocationManager.NETWORK_PROVIDER) != null)\n          locManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 3 * 1000, 8,locationListener);\n      else if (locManager.getProvider(LocationManager.GPS_PROVIDER) != null)\n          locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3 * 1000, 8,locationListener);\n      else Toast.makeText(mActivity(), \"获取手机位置信息错误\", Toast.LENGTH_SHORT).show();\n  }\n~~~  \n","source":"_posts/2016-08-03-android-LocationListener.md","raw":"---\nlayout: post\ntitle: Android手机定位服务\ncategory: technology\ntags: technology\nkeywords: LocationListener\ndescription: Android使用手机定位服务使用，GPS服务不可用则跳转到手机位置服务设置页面\nbanner: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Acacia%20Branches.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Acacia%20Branches.jpg\n---\n\n\n\n### 1.LocationListener使用\n\n优先使用网络定位服务，当GPS服务不可用则跳转到手机位置服务设置页面\n\n<!--more-->\n\n~~~ Java\n/**\n  * 使用手机定位服务\n  */\n  private void startLocationService(){\n      locationListener = new LocationListener() {\n\n          @Override\n          public void onStatusChanged(String provider, int status, Bundle extras) {\n          }\n          @Override\n          public void onProviderEnabled(String provider) {\n              // 当GPS LocationProvider可用时，更新位置\n              location = locManager.getLastKnownLocation(provider);\n          }\n          @Override\n          public void onProviderDisabled(String provider) {\n              isLocatedSuccess = false;\n              if (provider.equals(\"network\")) {\n                      locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3 * 1000, 8,locationListener);\n              }else if(provider.equals(\"gps\")){//GPS服务不可用，跳到位置服务设置页面\n                  startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));\n              }else {\n                  updateToNewLocation(null);\n              }\n          }\n          @Override\n          public void onLocationChanged(Location location) {\n              // 当定位信息发生改变时，更新位置\n              isLocatedSuccess = true;\n              updateToNewLocation(location);\n              locManager.removeUpdates(this);\n          }\n      };\n\n      if (locManager.getProvider(LocationManager.NETWORK_PROVIDER) != null)\n          locManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 3 * 1000, 8,locationListener);\n      else if (locManager.getProvider(LocationManager.GPS_PROVIDER) != null)\n          locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3 * 1000, 8,locationListener);\n      else Toast.makeText(mActivity(), \"获取手机位置信息错误\", Toast.LENGTH_SHORT).show();\n  }\n~~~  \n","slug":"android-LocationListener","published":1,"date":"2016-08-02T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj500017bxs6rrenl4zl","content":"<h3 id=\"1-LocationListener使用\"><a href=\"#1-LocationListener使用\" class=\"headerlink\" title=\"1.LocationListener使用\"></a>1.LocationListener使用</h3><p>优先使用网络定位服务，当GPS服务不可用则跳转到手机位置服务设置页面</p>\n<a id=\"more\"></a>\n<pre><code class=\"Java\"><span class=\"comment\">/**\n  * 使用手机定位服务\n  */</span>\n  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startLocationService</span><span class=\"params\">()</span></span>{\n      locationListener = <span class=\"keyword\">new</span> LocationListener() {\n\n          <span class=\"meta\">@Override</span>\n          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStatusChanged</span><span class=\"params\">(String provider, <span class=\"keyword\">int</span> status, Bundle extras)</span> </span>{\n          }\n          <span class=\"meta\">@Override</span>\n          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProviderEnabled</span><span class=\"params\">(String provider)</span> </span>{\n              <span class=\"comment\">// 当GPS LocationProvider可用时，更新位置</span>\n              location = locManager.getLastKnownLocation(provider);\n          }\n          <span class=\"meta\">@Override</span>\n          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProviderDisabled</span><span class=\"params\">(String provider)</span> </span>{\n              isLocatedSuccess = <span class=\"keyword\">false</span>;\n              <span class=\"keyword\">if</span> (provider.equals(<span class=\"string\">\"network\"</span>)) {\n                      locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class=\"number\">3</span> * <span class=\"number\">1000</span>, <span class=\"number\">8</span>,locationListener);\n              }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(provider.equals(<span class=\"string\">\"gps\"</span>)){<span class=\"comment\">//GPS服务不可用，跳到位置服务设置页面</span>\n                  startActivity(<span class=\"keyword\">new</span> Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));\n              }<span class=\"keyword\">else</span> {\n                  updateToNewLocation(<span class=\"keyword\">null</span>);\n              }\n          }\n          <span class=\"meta\">@Override</span>\n          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLocationChanged</span><span class=\"params\">(Location location)</span> </span>{\n              <span class=\"comment\">// 当定位信息发生改变时，更新位置</span>\n              isLocatedSuccess = <span class=\"keyword\">true</span>;\n              updateToNewLocation(location);\n              locManager.removeUpdates(<span class=\"keyword\">this</span>);\n          }\n      };\n\n      <span class=\"keyword\">if</span> (locManager.getProvider(LocationManager.NETWORK_PROVIDER) != <span class=\"keyword\">null</span>)\n          locManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, <span class=\"number\">3</span> * <span class=\"number\">1000</span>, <span class=\"number\">8</span>,locationListener);\n      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (locManager.getProvider(LocationManager.GPS_PROVIDER) != <span class=\"keyword\">null</span>)\n          locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class=\"number\">3</span> * <span class=\"number\">1000</span>, <span class=\"number\">8</span>,locationListener);\n      <span class=\"keyword\">else</span> Toast.makeText(mActivity(), <span class=\"string\">\"获取手机位置信息错误\"</span>, Toast.LENGTH_SHORT).show();\n  }\n</code></pre>\n","excerpt":"<h3 id=\"1-LocationListener使用\"><a href=\"#1-LocationListener使用\" class=\"headerlink\" title=\"1.LocationListener使用\"></a>1.LocationListener使用</h3><p>优先使用网络定位服务，当GPS服务不可用则跳转到手机位置服务设置页面</p>","more":"<pre><code class=\"Java\"><span class=\"comment\">/**\n  * 使用手机定位服务\n  */</span>\n  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startLocationService</span><span class=\"params\">()</span></span>{\n      locationListener = <span class=\"keyword\">new</span> LocationListener() {\n\n          <span class=\"meta\">@Override</span>\n          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStatusChanged</span><span class=\"params\">(String provider, <span class=\"keyword\">int</span> status, Bundle extras)</span> </span>{\n          }\n          <span class=\"meta\">@Override</span>\n          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProviderEnabled</span><span class=\"params\">(String provider)</span> </span>{\n              <span class=\"comment\">// 当GPS LocationProvider可用时，更新位置</span>\n              location = locManager.getLastKnownLocation(provider);\n          }\n          <span class=\"meta\">@Override</span>\n          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProviderDisabled</span><span class=\"params\">(String provider)</span> </span>{\n              isLocatedSuccess = <span class=\"keyword\">false</span>;\n              <span class=\"keyword\">if</span> (provider.equals(<span class=\"string\">\"network\"</span>)) {\n                      locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class=\"number\">3</span> * <span class=\"number\">1000</span>, <span class=\"number\">8</span>,locationListener);\n              }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(provider.equals(<span class=\"string\">\"gps\"</span>)){<span class=\"comment\">//GPS服务不可用，跳到位置服务设置页面</span>\n                  startActivity(<span class=\"keyword\">new</span> Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));\n              }<span class=\"keyword\">else</span> {\n                  updateToNewLocation(<span class=\"keyword\">null</span>);\n              }\n          }\n          <span class=\"meta\">@Override</span>\n          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLocationChanged</span><span class=\"params\">(Location location)</span> </span>{\n              <span class=\"comment\">// 当定位信息发生改变时，更新位置</span>\n              isLocatedSuccess = <span class=\"keyword\">true</span>;\n              updateToNewLocation(location);\n              locManager.removeUpdates(<span class=\"keyword\">this</span>);\n          }\n      };\n\n      <span class=\"keyword\">if</span> (locManager.getProvider(LocationManager.NETWORK_PROVIDER) != <span class=\"keyword\">null</span>)\n          locManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, <span class=\"number\">3</span> * <span class=\"number\">1000</span>, <span class=\"number\">8</span>,locationListener);\n      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (locManager.getProvider(LocationManager.GPS_PROVIDER) != <span class=\"keyword\">null</span>)\n          locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class=\"number\">3</span> * <span class=\"number\">1000</span>, <span class=\"number\">8</span>,locationListener);\n      <span class=\"keyword\">else</span> Toast.makeText(mActivity(), <span class=\"string\">\"获取手机位置信息错误\"</span>, Toast.LENGTH_SHORT).show();\n  }\n</code></pre>"},{"layout":"post","title":"RxJava 学习","keywords":"RxJava RxAndroid","description":"RxAndroid学习","banner":"http://obxk8w81b.bkt.clouddn.com/Bulb%20Fields.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Bulb%20Fields.jpg","_content":"\n\n### 1.向前辈致敬\n[给Android开发者的RxJava详解](http://gank.io/post/560e15be2dca930e00da1083)，这篇文章讲解详细，如果耐心看完，相信肯定收获不小\n\n    本篇博文用作学习RxJava过程中，记录知识和心得，如有冒犯还请见谅！\n\n### 2.简单介绍\nRxJava是通过一种扩展的观察者模式来实现的。\nRxJava有四个基本概念：Observable(可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。\n\n<!--more-->\n\n与传统观察者模式不同， RxJava 的事件回调方法除了普通事件onNext()（相当于onClick()/onEvent()）之外，还定义了两个特殊的事件：onCompleted()和onError()。\n\n> RxJava的基本实现主要有三点：Observer的创建、Observable的创建、Scheduler线程控制\n\n### 3.Observer的创建方法\n\nObserver 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：\n\n~~~ Java\nObserver<String> observer = new Observer<String>() {\n    @Override\n    public void onNext(String s) {\n        Log.d(tag, \"Item: \" + s);\n    }\n\n    @Override\n    public void onCompleted() {\n        Log.d(tag, \"Completed!\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(tag, \"Error!\");\n    }\n};\n~~~\n除了 Observer 接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber。 Subscriber对Observer接口进行了一些扩展，但他们的基本使用方式是完全一样的：\n\n~~~ Java\nSubscriber<String> subscriber = new Subscriber<String>() {\n    @Override\n    public void onNext(String s) {\n        Log.d(tag, \"Item: \" + s);\n    }\n\n    @Override\n    public void onCompleted() {\n        Log.d(tag, \"Completed!\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(tag, \"Error!\");\n    }\n};\n~~~\n\nObserver和Subscriber区别对于使用者来说主要有两点：\n\n- onStart(): 这是Subscriber增加的方法。\n\n    它会在subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。\n    > 需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart()就不适用了，因为它总是在subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法。\n\n- unsubscribe(): 这是Subscriber所实现的另一个接口Subscription的方法，用于取消订阅。\n\n    在这个方法被调用后，Subscriber将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 **unsubscribe()**这个方法很重要，因为在subscribe()之后，Observable会持有 Subscriber 的引用，这个引用**如果不能及时被释放**，将有**内存泄露的风险**。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。\n\n### 4.Observable的几种创建方法：\n\n#### **1.Observable.just(T...)和from(T[])/from(Iterable<? extends T>)**\n\n  - 1). just(T...): 将传入的参数依次发送出来\n\n  - 2). from(T[])/from(Iterable<? extends T>): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。\n\n  - 3). 由这两个方法创建的Observable对象的特点是：所有Observer一旦订阅这个Observable就会立即调用onNext()方法并传入Observable.just()/from()的参数，而后因为Observable没有数据可以发送了，onComplete()方法会被调用。\n\n  ~~~ Java\n  Observable<List<String>> listObservable = Observable.just(getColorList());\n  ~~~\n\n  > 注意，如果just()中传入的是耗时方法，该方法会被立即执行并阻塞UI线程。这里的getColorList()是一个不耗时的方法.\n\n    下一步，我们写一个Observer来观察Observable。\n\n~~~ Java\nlistObservable.subscribe(new Observer<List<String>>() {\n\n    @Override\n    public void onCompleted() { }\n\n    @Override\n    public void onError(Throwable e) { }\n\n    @Override\n    public void onNext(List<String> colors) {\n        mSimpleStringAdapter.setStrings(colors);\n    }\n});\n~~~\n  在这个例子中我们不关心Observable何时完成数据的传输，所以我们不用在onComplete()方法里写代码。而且在这里不会有异常抛出，所以我们也不用管onError()方法\n\n#### **2.Observable.fromCallable()**\n\n  先看代码：\n\n~~~ Java\nObservable<List<String>> tvShowObservable = Observable.fromCallable(new Callable<List<String>>() {\n\n      @Override\n      public List<String> call() {\n          return mRestClient.getFavoriteTvShows();\n      }\n});\n~~~\n\n使用Observable.fromCallable()方法有两点好处：\n\n  - 1).获取要发送的数据的代码只会在有Observer订阅之后执行。\n\n  - 2).获取数据的代码（指的是call()方法）可以在子线程中执行。对比just()中传入的方法只能运行在主线程。\n\n    这两点好处有时可能非常重要。\n\n现在让我们订阅这个Observable。\n\n~~~ Java\nmTvShowSubscription = tvShowObservable\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Observer<List<String>>() {\n\n        @Override\n        public void onCompleted() { }\n\n        @Override\n        public void onError(Throwable e) { }\n\n        @Override\n        public void onNext(List<String> tvShows){\n            displayTvShows(tvShows);\n        }\n});\n~~~\n\n  上面代码逐一介绍：\n\n  - 1).subscribeOn() 指定事件发生的线程\n\n    在默认情况下Observable的所有代码，都会在执行subscribe()方法的线程中运行。而通过subscribeOn()方法，这些代码可以在其他线程中执行。在上面的例子中，我们让代码在\"IO Scheduler\"中执行（Schedulers.io()）。现在我们可以只把Scheduler当做一个可以工作的子线程。\n\n  - 2).observeOn() 会指定onNext()方法发生的线程\n\n    通过在observeOn()方法中指定另一个Scheduler来完成onNext()的内容，在这里也就是AndroidSchedules.mainThread()所返回的Scheduler(UI线程的Scheduler)。\n\n  - 3).subscribe() Callable只会在有在Observable调用subscribe()后执行。\n\n    Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）：\n\n~~~ Java  \n// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。\n// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。\npublic Subscription subscribe(Subscriber subscriber) {\n    subscriber.onStart();\n    onSubscribe.call(subscriber);\n    return subscriber;\n}\n~~~\n  可以看到，subscriber()做了3件事：\n\n>   ①.调用Subscriber.onStart()。这个方法在前面已经介绍过，是一个可选的准备方法。\n   ②.调用Observable中的OnSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在RxJava中， Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。\n   ③.将传入的Subscriber作为Subscription返回。这是为了方便unsubscribe().\n\n  - 4).mTvShowSubscription\n\n    每当Observer订阅Observable时就会生成一个Subscription对象。一个Subscription代表了一个Observer与Observable之间的连接。有时我们需要操作这个连接，这里拿在Activity的onDestroy()方法中的代码举个例子：\n\n~~~ Java  \nif (mTvShowSubscription != null && !mTvShowSubscription.isUnsubscribed()) {\n      mTvShowSubscription.unsubscribe(); //取消订阅\n}\n~~~\n   unsubscribe()方法告诉Observable它所发送的数据不再被Observer所接收。在调用unsubscribe()方法后，我们创建的Observer就不再会收到数据了，以免Observable异步加载数据时发生意外。\n\n#### **3.使用Single**\n\nSingle是Observable的精简版，一种特殊的只发射单个值的Observable，几乎和Observable一模一样，但其回调方法不是onComplete()/onNext()/onError()，而是onSuccess()/onError()。\n\n  我们现在把刚才写过的Observable用Single重写一遍。首先我们要创建一个Single:\n\n~~~ Java\nSingle<List<String>> tvShowSingle = Single.fromCallable(new Callable<List<String>>() {\n    @Override\n    public List<String> call() throws Exception {\n        mRestClient.getFavoriteTvShows();\n    }\n});\n~~~\n\n  然后订阅一下\n\n~~~ Java\nmTvShowSubscription = tvShowSingle\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new SingleSubscriber<List<String>>() {\n\n        @Override\n        public void onSuccess(List<String> tvShows) {\n            displayTvShows(tvShows);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            displayErrorMessage();\n        }\n});\n~~~\n\n\n但这次我们不再使用Observer，而是使用一个叫SingleSubscriber的类。这个类和Observer非常像，只不过它只有上述两个方法：onSuccess()和onError()。SingleSubscriber之于Single就如Observer之于Observable。\n\n订阅一个Single的同时也会自动创建一个Subscription对象。这里的Subscription和上面的例子没有区别，一定要在onDestroy()中解除订阅。\n\n### 5.线程控制——Scheduler\n\n  RxJava已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：\n\n> - 1.Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n- 2.Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n- 3.Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n- 4.Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n- 5.另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。\n\n### 6.特殊的情况\n\n1.Subject Observable和Observer的复合体，也是二者的桥梁\n\n  Subjects = Observable + Observer，Subject继承自Observable实现了Observer\n\n  Rxjava提供的四种Subject:\n\n>    ①PublishSubject ： subject的基础子类。\n    ②BehaviorSubject : 会首先向它的订阅者发送截止订阅前最新的一个数据，然后正常发送订阅后的数据流。\n    ③ReplaySubject ： 会缓存它所订阅的所有数据，向所有订阅它的观察者重发。\n    ④AsyncSubject ： 只会发布最后一个数据给已经订阅的每一个观察者。\n","source":"_posts/2016-08-16-RxAndroid-Learning.md","raw":"---\nlayout: post\ntitle: RxJava 学习\ncategory: technology\ntags: RxJava\nkeywords: RxJava RxAndroid\ndescription: RxAndroid学习\nbanner: http://obxk8w81b.bkt.clouddn.com/Bulb%20Fields.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Bulb%20Fields.jpg\n---\n\n\n### 1.向前辈致敬\n[给Android开发者的RxJava详解](http://gank.io/post/560e15be2dca930e00da1083)，这篇文章讲解详细，如果耐心看完，相信肯定收获不小\n\n    本篇博文用作学习RxJava过程中，记录知识和心得，如有冒犯还请见谅！\n\n### 2.简单介绍\nRxJava是通过一种扩展的观察者模式来实现的。\nRxJava有四个基本概念：Observable(可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。\n\n<!--more-->\n\n与传统观察者模式不同， RxJava 的事件回调方法除了普通事件onNext()（相当于onClick()/onEvent()）之外，还定义了两个特殊的事件：onCompleted()和onError()。\n\n> RxJava的基本实现主要有三点：Observer的创建、Observable的创建、Scheduler线程控制\n\n### 3.Observer的创建方法\n\nObserver 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：\n\n~~~ Java\nObserver<String> observer = new Observer<String>() {\n    @Override\n    public void onNext(String s) {\n        Log.d(tag, \"Item: \" + s);\n    }\n\n    @Override\n    public void onCompleted() {\n        Log.d(tag, \"Completed!\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(tag, \"Error!\");\n    }\n};\n~~~\n除了 Observer 接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber。 Subscriber对Observer接口进行了一些扩展，但他们的基本使用方式是完全一样的：\n\n~~~ Java\nSubscriber<String> subscriber = new Subscriber<String>() {\n    @Override\n    public void onNext(String s) {\n        Log.d(tag, \"Item: \" + s);\n    }\n\n    @Override\n    public void onCompleted() {\n        Log.d(tag, \"Completed!\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(tag, \"Error!\");\n    }\n};\n~~~\n\nObserver和Subscriber区别对于使用者来说主要有两点：\n\n- onStart(): 这是Subscriber增加的方法。\n\n    它会在subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。\n    > 需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart()就不适用了，因为它总是在subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法。\n\n- unsubscribe(): 这是Subscriber所实现的另一个接口Subscription的方法，用于取消订阅。\n\n    在这个方法被调用后，Subscriber将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 **unsubscribe()**这个方法很重要，因为在subscribe()之后，Observable会持有 Subscriber 的引用，这个引用**如果不能及时被释放**，将有**内存泄露的风险**。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。\n\n### 4.Observable的几种创建方法：\n\n#### **1.Observable.just(T...)和from(T[])/from(Iterable<? extends T>)**\n\n  - 1). just(T...): 将传入的参数依次发送出来\n\n  - 2). from(T[])/from(Iterable<? extends T>): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。\n\n  - 3). 由这两个方法创建的Observable对象的特点是：所有Observer一旦订阅这个Observable就会立即调用onNext()方法并传入Observable.just()/from()的参数，而后因为Observable没有数据可以发送了，onComplete()方法会被调用。\n\n  ~~~ Java\n  Observable<List<String>> listObservable = Observable.just(getColorList());\n  ~~~\n\n  > 注意，如果just()中传入的是耗时方法，该方法会被立即执行并阻塞UI线程。这里的getColorList()是一个不耗时的方法.\n\n    下一步，我们写一个Observer来观察Observable。\n\n~~~ Java\nlistObservable.subscribe(new Observer<List<String>>() {\n\n    @Override\n    public void onCompleted() { }\n\n    @Override\n    public void onError(Throwable e) { }\n\n    @Override\n    public void onNext(List<String> colors) {\n        mSimpleStringAdapter.setStrings(colors);\n    }\n});\n~~~\n  在这个例子中我们不关心Observable何时完成数据的传输，所以我们不用在onComplete()方法里写代码。而且在这里不会有异常抛出，所以我们也不用管onError()方法\n\n#### **2.Observable.fromCallable()**\n\n  先看代码：\n\n~~~ Java\nObservable<List<String>> tvShowObservable = Observable.fromCallable(new Callable<List<String>>() {\n\n      @Override\n      public List<String> call() {\n          return mRestClient.getFavoriteTvShows();\n      }\n});\n~~~\n\n使用Observable.fromCallable()方法有两点好处：\n\n  - 1).获取要发送的数据的代码只会在有Observer订阅之后执行。\n\n  - 2).获取数据的代码（指的是call()方法）可以在子线程中执行。对比just()中传入的方法只能运行在主线程。\n\n    这两点好处有时可能非常重要。\n\n现在让我们订阅这个Observable。\n\n~~~ Java\nmTvShowSubscription = tvShowObservable\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Observer<List<String>>() {\n\n        @Override\n        public void onCompleted() { }\n\n        @Override\n        public void onError(Throwable e) { }\n\n        @Override\n        public void onNext(List<String> tvShows){\n            displayTvShows(tvShows);\n        }\n});\n~~~\n\n  上面代码逐一介绍：\n\n  - 1).subscribeOn() 指定事件发生的线程\n\n    在默认情况下Observable的所有代码，都会在执行subscribe()方法的线程中运行。而通过subscribeOn()方法，这些代码可以在其他线程中执行。在上面的例子中，我们让代码在\"IO Scheduler\"中执行（Schedulers.io()）。现在我们可以只把Scheduler当做一个可以工作的子线程。\n\n  - 2).observeOn() 会指定onNext()方法发生的线程\n\n    通过在observeOn()方法中指定另一个Scheduler来完成onNext()的内容，在这里也就是AndroidSchedules.mainThread()所返回的Scheduler(UI线程的Scheduler)。\n\n  - 3).subscribe() Callable只会在有在Observable调用subscribe()后执行。\n\n    Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）：\n\n~~~ Java  \n// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。\n// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。\npublic Subscription subscribe(Subscriber subscriber) {\n    subscriber.onStart();\n    onSubscribe.call(subscriber);\n    return subscriber;\n}\n~~~\n  可以看到，subscriber()做了3件事：\n\n>   ①.调用Subscriber.onStart()。这个方法在前面已经介绍过，是一个可选的准备方法。\n   ②.调用Observable中的OnSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在RxJava中， Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。\n   ③.将传入的Subscriber作为Subscription返回。这是为了方便unsubscribe().\n\n  - 4).mTvShowSubscription\n\n    每当Observer订阅Observable时就会生成一个Subscription对象。一个Subscription代表了一个Observer与Observable之间的连接。有时我们需要操作这个连接，这里拿在Activity的onDestroy()方法中的代码举个例子：\n\n~~~ Java  \nif (mTvShowSubscription != null && !mTvShowSubscription.isUnsubscribed()) {\n      mTvShowSubscription.unsubscribe(); //取消订阅\n}\n~~~\n   unsubscribe()方法告诉Observable它所发送的数据不再被Observer所接收。在调用unsubscribe()方法后，我们创建的Observer就不再会收到数据了，以免Observable异步加载数据时发生意外。\n\n#### **3.使用Single**\n\nSingle是Observable的精简版，一种特殊的只发射单个值的Observable，几乎和Observable一模一样，但其回调方法不是onComplete()/onNext()/onError()，而是onSuccess()/onError()。\n\n  我们现在把刚才写过的Observable用Single重写一遍。首先我们要创建一个Single:\n\n~~~ Java\nSingle<List<String>> tvShowSingle = Single.fromCallable(new Callable<List<String>>() {\n    @Override\n    public List<String> call() throws Exception {\n        mRestClient.getFavoriteTvShows();\n    }\n});\n~~~\n\n  然后订阅一下\n\n~~~ Java\nmTvShowSubscription = tvShowSingle\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new SingleSubscriber<List<String>>() {\n\n        @Override\n        public void onSuccess(List<String> tvShows) {\n            displayTvShows(tvShows);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            displayErrorMessage();\n        }\n});\n~~~\n\n\n但这次我们不再使用Observer，而是使用一个叫SingleSubscriber的类。这个类和Observer非常像，只不过它只有上述两个方法：onSuccess()和onError()。SingleSubscriber之于Single就如Observer之于Observable。\n\n订阅一个Single的同时也会自动创建一个Subscription对象。这里的Subscription和上面的例子没有区别，一定要在onDestroy()中解除订阅。\n\n### 5.线程控制——Scheduler\n\n  RxJava已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：\n\n> - 1.Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n- 2.Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n- 3.Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n- 4.Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n- 5.另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。\n\n### 6.特殊的情况\n\n1.Subject Observable和Observer的复合体，也是二者的桥梁\n\n  Subjects = Observable + Observer，Subject继承自Observable实现了Observer\n\n  Rxjava提供的四种Subject:\n\n>    ①PublishSubject ： subject的基础子类。\n    ②BehaviorSubject : 会首先向它的订阅者发送截止订阅前最新的一个数据，然后正常发送订阅后的数据流。\n    ③ReplaySubject ： 会缓存它所订阅的所有数据，向所有订阅它的观察者重发。\n    ④AsyncSubject ： 只会发布最后一个数据给已经订阅的每一个观察者。\n","slug":"RxAndroid-Learning","published":1,"date":"2016-08-15T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj52001abxs625fljjiq","content":"<h3 id=\"1-向前辈致敬\"><a href=\"#1-向前辈致敬\" class=\"headerlink\" title=\"1.向前辈致敬\"></a>1.向前辈致敬</h3><p><a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\">给Android开发者的RxJava详解</a>，这篇文章讲解详细，如果耐心看完，相信肯定收获不小</p>\n<pre><code>本篇博文用作学习RxJava过程中，记录知识和心得，如有冒犯还请见谅！\n</code></pre><h3 id=\"2-简单介绍\"><a href=\"#2-简单介绍\" class=\"headerlink\" title=\"2.简单介绍\"></a>2.简单介绍</h3><p>RxJava是通过一种扩展的观察者模式来实现的。<br>RxJava有四个基本概念：Observable(可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。</p>\n<a id=\"more\"></a>\n<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件onNext()（相当于onClick()/onEvent()）之外，还定义了两个特殊的事件：onCompleted()和onError()。</p>\n<blockquote>\n<p>RxJava的基本实现主要有三点：Observer的创建、Observable的创建、Scheduler线程控制</p>\n</blockquote>\n<h3 id=\"3-Observer的创建方法\"><a href=\"#3-Observer的创建方法\" class=\"headerlink\" title=\"3.Observer的创建方法\"></a>3.Observer的创建方法</h3><p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observer&lt;String&gt; observer = <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Item: \"</span> + s);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Error!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>除了 Observer 接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber。 Subscriber对Observer接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Subscriber&lt;String&gt; subscriber = <span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Item: \"</span> + s);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Error!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Observer和Subscriber区别对于使用者来说主要有两点：</p>\n<ul>\n<li><p>onStart(): 这是Subscriber增加的方法。</p>\n<p>  它会在subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。</p>\n<blockquote>\n<p>需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart()就不适用了，因为它总是在subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法。</p>\n</blockquote>\n</li>\n<li><p>unsubscribe(): 这是Subscriber所实现的另一个接口Subscription的方法，用于取消订阅。</p>\n<p>  在这个方法被调用后，Subscriber将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 <strong>unsubscribe()</strong>这个方法很重要，因为在subscribe()之后，Observable会持有 Subscriber 的引用，这个引用<strong>如果不能及时被释放</strong>，将有<strong>内存泄露的风险</strong>。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p>\n</li>\n</ul>\n<h3 id=\"4-Observable的几种创建方法：\"><a href=\"#4-Observable的几种创建方法：\" class=\"headerlink\" title=\"4.Observable的几种创建方法：\"></a>4.Observable的几种创建方法：</h3><h4 id=\"1-Observable-just-T…-和from-T-from-Iterable-lt-extends-T-gt\"><a href=\"#1-Observable-just-T…-和from-T-from-Iterable-lt-extends-T-gt\" class=\"headerlink\" title=\"1.Observable.just(T…)和from(T[])/from(Iterable&lt;? extends T&gt;)\"></a><strong>1.Observable.just(T…)和from(T[])/from(Iterable&lt;? extends T&gt;)</strong></h4><ul>\n<li><p>1). just(T…): 将传入的参数依次发送出来</p>\n</li>\n<li><p>2). from(T[])/from(Iterable&lt;? extends T&gt;): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</p>\n</li>\n<li><p>3). 由这两个方法创建的Observable对象的特点是：所有Observer一旦订阅这个Observable就会立即调用onNext()方法并传入Observable.just()/from()的参数，而后因为Observable没有数据可以发送了，onComplete()方法会被调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable&lt;List&lt;String&gt;&gt; listObservable = Observable.just(getColorList());</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，如果just()中传入的是耗时方法，该方法会被立即执行并阻塞UI线程。这里的getColorList()是一个不耗时的方法.</p>\n</blockquote>\n<p>下一步，我们写一个Observer来观察Observable。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">listObservable.subscribe(<span class=\"keyword\">new</span> Observer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(List&lt;String&gt; colors)</span> </span>&#123;</div><div class=\"line\">        mSimpleStringAdapter.setStrings(colors);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>  在这个例子中我们不关心Observable何时完成数据的传输，所以我们不用在onComplete()方法里写代码。而且在这里不会有异常抛出，所以我们也不用管onError()方法</p>\n<h4 id=\"2-Observable-fromCallable\"><a href=\"#2-Observable-fromCallable\" class=\"headerlink\" title=\"2.Observable.fromCallable()\"></a><strong>2.Observable.fromCallable()</strong></h4><p>  先看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable&lt;List&lt;String&gt;&gt; tvShowObservable = Observable.fromCallable(<span class=\"keyword\">new</span> Callable&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> mRestClient.getFavoriteTvShows();</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>使用Observable.fromCallable()方法有两点好处：</p>\n<ul>\n<li><p>1).获取要发送的数据的代码只会在有Observer订阅之后执行。</p>\n</li>\n<li><p>2).获取数据的代码（指的是call()方法）可以在子线程中执行。对比just()中传入的方法只能运行在主线程。</p>\n<p>这两点好处有时可能非常重要。</p>\n</li>\n</ul>\n<p>现在让我们订阅这个Observable。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mTvShowSubscription = tvShowObservable</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(<span class=\"keyword\">new</span> Observer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(List&lt;String&gt; tvShows)</span></span>&#123;</div><div class=\"line\">            displayTvShows(tvShows);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>  上面代码逐一介绍：</p>\n<ul>\n<li><p>1).subscribeOn() 指定事件发生的线程</p>\n<p>在默认情况下Observable的所有代码，都会在执行subscribe()方法的线程中运行。而通过subscribeOn()方法，这些代码可以在其他线程中执行。在上面的例子中，我们让代码在”IO Scheduler”中执行（Schedulers.io()）。现在我们可以只把Scheduler当做一个可以工作的子线程。</p>\n</li>\n<li><p>2).observeOn() 会指定onNext()方法发生的线程</p>\n<p>通过在observeOn()方法中指定另一个Scheduler来完成onNext()的内容，在这里也就是AndroidSchedules.mainThread()所返回的Scheduler(UI线程的Scheduler)。</p>\n</li>\n<li><p>3).subscribe() Callable只会在有在Observable调用subscribe()后执行。</p>\n<p>Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></div><div class=\"line\"><span class=\"comment\">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber subscriber)</span> </span>&#123;</div><div class=\"line\">    subscriber.onStart();</div><div class=\"line\">    onSubscribe.call(subscriber);</div><div class=\"line\">    <span class=\"keyword\">return</span> subscriber;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  可以看到，subscriber()做了3件事：</p>\n<blockquote>\n<p>  ①.调用Subscriber.onStart()。这个方法在前面已经介绍过，是一个可选的准备方法。<br>   ②.调用Observable中的OnSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在RxJava中， Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。<br>   ③.将传入的Subscriber作为Subscription返回。这是为了方便unsubscribe().</p>\n</blockquote>\n<ul>\n<li><p>4).mTvShowSubscription</p>\n<p>每当Observer订阅Observable时就会生成一个Subscription对象。一个Subscription代表了一个Observer与Observable之间的连接。有时我们需要操作这个连接，这里拿在Activity的onDestroy()方法中的代码举个例子：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (mTvShowSubscription != <span class=\"keyword\">null</span> &amp;&amp; !mTvShowSubscription.isUnsubscribed()) &#123;</div><div class=\"line\">      mTvShowSubscription.unsubscribe(); <span class=\"comment\">//取消订阅</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>   unsubscribe()方法告诉Observable它所发送的数据不再被Observer所接收。在调用unsubscribe()方法后，我们创建的Observer就不再会收到数据了，以免Observable异步加载数据时发生意外。</p>\n<h4 id=\"3-使用Single\"><a href=\"#3-使用Single\" class=\"headerlink\" title=\"3.使用Single\"></a><strong>3.使用Single</strong></h4><p>Single是Observable的精简版，一种特殊的只发射单个值的Observable，几乎和Observable一模一样，但其回调方法不是onComplete()/onNext()/onError()，而是onSuccess()/onError()。</p>\n<p>  我们现在把刚才写过的Observable用Single重写一遍。首先我们要创建一个Single:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Single&lt;List&lt;String&gt;&gt; tvShowSingle = Single.fromCallable(<span class=\"keyword\">new</span> Callable&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        mRestClient.getFavoriteTvShows();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>  然后订阅一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mTvShowSubscription = tvShowSingle</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(<span class=\"keyword\">new</span> SingleSubscriber&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(List&lt;String&gt; tvShows)</span> </span>&#123;</div><div class=\"line\">            displayTvShows(tvShows);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable error)</span> </span>&#123;</div><div class=\"line\">            displayErrorMessage();</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但这次我们不再使用Observer，而是使用一个叫SingleSubscriber的类。这个类和Observer非常像，只不过它只有上述两个方法：onSuccess()和onError()。SingleSubscriber之于Single就如Observer之于Observable。</p>\n<p>订阅一个Single的同时也会自动创建一个Subscription对象。这里的Subscription和上面的例子没有区别，一定要在onDestroy()中解除订阅。</p>\n<h3 id=\"5-线程控制——Scheduler\"><a href=\"#5-线程控制——Scheduler\" class=\"headerlink\" title=\"5.线程控制——Scheduler\"></a>5.线程控制——Scheduler</h3><p>  RxJava已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：</p>\n<blockquote>\n<ul>\n<li>1.Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>\n<li>2.Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li>\n<li>3.Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>\n<li>4.Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>\n<li>5.另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</li>\n</ul>\n</blockquote>\n<h3 id=\"6-特殊的情况\"><a href=\"#6-特殊的情况\" class=\"headerlink\" title=\"6.特殊的情况\"></a>6.特殊的情况</h3><p>1.Subject Observable和Observer的复合体，也是二者的桥梁</p>\n<p>  Subjects = Observable + Observer，Subject继承自Observable实现了Observer</p>\n<p>  Rxjava提供的四种Subject:</p>\n<blockquote>\n<p>   ①PublishSubject ： subject的基础子类。<br>    ②BehaviorSubject : 会首先向它的订阅者发送截止订阅前最新的一个数据，然后正常发送订阅后的数据流。<br>    ③ReplaySubject ： 会缓存它所订阅的所有数据，向所有订阅它的观察者重发。<br>    ④AsyncSubject ： 只会发布最后一个数据给已经订阅的每一个观察者。</p>\n</blockquote>\n","excerpt":"<h3 id=\"1-向前辈致敬\"><a href=\"#1-向前辈致敬\" class=\"headerlink\" title=\"1.向前辈致敬\"></a>1.向前辈致敬</h3><p><a href=\"http://gank.io/post/560e15be2dca930e00da1083\">给Android开发者的RxJava详解</a>，这篇文章讲解详细，如果耐心看完，相信肯定收获不小</p>\n<pre><code>本篇博文用作学习RxJava过程中，记录知识和心得，如有冒犯还请见谅！\n</code></pre><h3 id=\"2-简单介绍\"><a href=\"#2-简单介绍\" class=\"headerlink\" title=\"2.简单介绍\"></a>2.简单介绍</h3><p>RxJava是通过一种扩展的观察者模式来实现的。<br>RxJava有四个基本概念：Observable(可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer。</p>","more":"<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件onNext()（相当于onClick()/onEvent()）之外，还定义了两个特殊的事件：onCompleted()和onError()。</p>\n<blockquote>\n<p>RxJava的基本实现主要有三点：Observer的创建、Observable的创建、Scheduler线程控制</p>\n</blockquote>\n<h3 id=\"3-Observer的创建方法\"><a href=\"#3-Observer的创建方法\" class=\"headerlink\" title=\"3.Observer的创建方法\"></a>3.Observer的创建方法</h3><p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observer&lt;String&gt; observer = <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Item: \"</span> + s);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Error!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>除了 Observer 接口之外，RxJava还内置了一个实现了Observer的抽象类：Subscriber。 Subscriber对Observer接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Subscriber&lt;String&gt; subscriber = <span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Item: \"</span> + s);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        Log.d(tag, <span class=\"string\">\"Error!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Observer和Subscriber区别对于使用者来说主要有两点：</p>\n<ul>\n<li><p>onStart(): 这是Subscriber增加的方法。</p>\n<p>  它会在subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。</p>\n<blockquote>\n<p>需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart()就不适用了，因为它总是在subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法。</p>\n</blockquote>\n</li>\n<li><p>unsubscribe(): 这是Subscriber所实现的另一个接口Subscription的方法，用于取消订阅。</p>\n<p>  在这个方法被调用后，Subscriber将不再接收事件。一般在这个方法调用前，可以使用isUnsubscribed()先判断一下状态。 <strong>unsubscribe()</strong>这个方法很重要，因为在subscribe()之后，Observable会持有 Subscriber 的引用，这个引用<strong>如果不能及时被释放</strong>，将有<strong>内存泄露的风险</strong>。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p>\n</li>\n</ul>\n<h3 id=\"4-Observable的几种创建方法：\"><a href=\"#4-Observable的几种创建方法：\" class=\"headerlink\" title=\"4.Observable的几种创建方法：\"></a>4.Observable的几种创建方法：</h3><h4 id=\"1-Observable-just-T…-和from-T-from-Iterable-lt-extends-T-gt\"><a href=\"#1-Observable-just-T…-和from-T-from-Iterable-lt-extends-T-gt\" class=\"headerlink\" title=\"1.Observable.just(T…)和from(T[])/from(Iterable&lt;? extends T&gt;)\"></a><strong>1.Observable.just(T…)和from(T[])/from(Iterable&lt;? extends T&gt;)</strong></h4><ul>\n<li><p>1). just(T…): 将传入的参数依次发送出来</p>\n</li>\n<li><p>2). from(T[])/from(Iterable&lt;? extends T&gt;): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</p>\n</li>\n<li><p>3). 由这两个方法创建的Observable对象的特点是：所有Observer一旦订阅这个Observable就会立即调用onNext()方法并传入Observable.just()/from()的参数，而后因为Observable没有数据可以发送了，onComplete()方法会被调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable&lt;List&lt;String&gt;&gt; listObservable = Observable.just(getColorList());</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，如果just()中传入的是耗时方法，该方法会被立即执行并阻塞UI线程。这里的getColorList()是一个不耗时的方法.</p>\n</blockquote>\n<p>下一步，我们写一个Observer来观察Observable。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">listObservable.subscribe(<span class=\"keyword\">new</span> Observer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(List&lt;String&gt; colors)</span> </span>&#123;</div><div class=\"line\">        mSimpleStringAdapter.setStrings(colors);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>  在这个例子中我们不关心Observable何时完成数据的传输，所以我们不用在onComplete()方法里写代码。而且在这里不会有异常抛出，所以我们也不用管onError()方法</p>\n<h4 id=\"2-Observable-fromCallable\"><a href=\"#2-Observable-fromCallable\" class=\"headerlink\" title=\"2.Observable.fromCallable()\"></a><strong>2.Observable.fromCallable()</strong></h4><p>  先看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable&lt;List&lt;String&gt;&gt; tvShowObservable = Observable.fromCallable(<span class=\"keyword\">new</span> Callable&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> mRestClient.getFavoriteTvShows();</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>使用Observable.fromCallable()方法有两点好处：</p>\n<ul>\n<li><p>1).获取要发送的数据的代码只会在有Observer订阅之后执行。</p>\n</li>\n<li><p>2).获取数据的代码（指的是call()方法）可以在子线程中执行。对比just()中传入的方法只能运行在主线程。</p>\n<p>这两点好处有时可能非常重要。</p>\n</li>\n</ul>\n<p>现在让我们订阅这个Observable。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mTvShowSubscription = tvShowObservable</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(<span class=\"keyword\">new</span> Observer&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(List&lt;String&gt; tvShows)</span></span>&#123;</div><div class=\"line\">            displayTvShows(tvShows);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>  上面代码逐一介绍：</p>\n<ul>\n<li><p>1).subscribeOn() 指定事件发生的线程</p>\n<p>在默认情况下Observable的所有代码，都会在执行subscribe()方法的线程中运行。而通过subscribeOn()方法，这些代码可以在其他线程中执行。在上面的例子中，我们让代码在”IO Scheduler”中执行（Schedulers.io()）。现在我们可以只把Scheduler当做一个可以工作的子线程。</p>\n</li>\n<li><p>2).observeOn() 会指定onNext()方法发生的线程</p>\n<p>通过在observeOn()方法中指定另一个Scheduler来完成onNext()的内容，在这里也就是AndroidSchedules.mainThread()所返回的Scheduler(UI线程的Scheduler)。</p>\n</li>\n<li><p>3).subscribe() Callable只会在有在Observable调用subscribe()后执行。</p>\n<p>Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></div><div class=\"line\"><span class=\"comment\">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber subscriber)</span> </span>&#123;</div><div class=\"line\">    subscriber.onStart();</div><div class=\"line\">    onSubscribe.call(subscriber);</div><div class=\"line\">    <span class=\"keyword\">return</span> subscriber;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  可以看到，subscriber()做了3件事：</p>\n<blockquote>\n<p>  ①.调用Subscriber.onStart()。这个方法在前面已经介绍过，是一个可选的准备方法。<br>   ②.调用Observable中的OnSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在RxJava中， Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。<br>   ③.将传入的Subscriber作为Subscription返回。这是为了方便unsubscribe().</p>\n</blockquote>\n<ul>\n<li><p>4).mTvShowSubscription</p>\n<p>每当Observer订阅Observable时就会生成一个Subscription对象。一个Subscription代表了一个Observer与Observable之间的连接。有时我们需要操作这个连接，这里拿在Activity的onDestroy()方法中的代码举个例子：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (mTvShowSubscription != <span class=\"keyword\">null</span> &amp;&amp; !mTvShowSubscription.isUnsubscribed()) &#123;</div><div class=\"line\">      mTvShowSubscription.unsubscribe(); <span class=\"comment\">//取消订阅</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>   unsubscribe()方法告诉Observable它所发送的数据不再被Observer所接收。在调用unsubscribe()方法后，我们创建的Observer就不再会收到数据了，以免Observable异步加载数据时发生意外。</p>\n<h4 id=\"3-使用Single\"><a href=\"#3-使用Single\" class=\"headerlink\" title=\"3.使用Single\"></a><strong>3.使用Single</strong></h4><p>Single是Observable的精简版，一种特殊的只发射单个值的Observable，几乎和Observable一模一样，但其回调方法不是onComplete()/onNext()/onError()，而是onSuccess()/onError()。</p>\n<p>  我们现在把刚才写过的Observable用Single重写一遍。首先我们要创建一个Single:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Single&lt;List&lt;String&gt;&gt; tvShowSingle = Single.fromCallable(<span class=\"keyword\">new</span> Callable&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        mRestClient.getFavoriteTvShows();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>  然后订阅一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mTvShowSubscription = tvShowSingle</div><div class=\"line\">    .subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(<span class=\"keyword\">new</span> SingleSubscriber&lt;List&lt;String&gt;&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(List&lt;String&gt; tvShows)</span> </span>&#123;</div><div class=\"line\">            displayTvShows(tvShows);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable error)</span> </span>&#123;</div><div class=\"line\">            displayErrorMessage();</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但这次我们不再使用Observer，而是使用一个叫SingleSubscriber的类。这个类和Observer非常像，只不过它只有上述两个方法：onSuccess()和onError()。SingleSubscriber之于Single就如Observer之于Observable。</p>\n<p>订阅一个Single的同时也会自动创建一个Subscription对象。这里的Subscription和上面的例子没有区别，一定要在onDestroy()中解除订阅。</p>\n<h3 id=\"5-线程控制——Scheduler\"><a href=\"#5-线程控制——Scheduler\" class=\"headerlink\" title=\"5.线程控制——Scheduler\"></a>5.线程控制——Scheduler</h3><p>  RxJava已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：</p>\n<blockquote>\n<ul>\n<li>1.Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>\n<li>2.Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li>\n<li>3.Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>\n<li>4.Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>\n<li>5.另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</li>\n</ul>\n</blockquote>\n<h3 id=\"6-特殊的情况\"><a href=\"#6-特殊的情况\" class=\"headerlink\" title=\"6.特殊的情况\"></a>6.特殊的情况</h3><p>1.Subject Observable和Observer的复合体，也是二者的桥梁</p>\n<p>  Subjects = Observable + Observer，Subject继承自Observable实现了Observer</p>\n<p>  Rxjava提供的四种Subject:</p>\n<blockquote>\n<p>   ①PublishSubject ： subject的基础子类。<br>    ②BehaviorSubject : 会首先向它的订阅者发送截止订阅前最新的一个数据，然后正常发送订阅后的数据流。<br>    ③ReplaySubject ： 会缓存它所订阅的所有数据，向所有订阅它的观察者重发。<br>    ④AsyncSubject ： 只会发布最后一个数据给已经订阅的每一个观察者。</p>\n</blockquote>"},{"layout":"post","title":"ThreadLocal、HandlerThread、Lopper区别","keywords":"ThreadLocal, HandlerThread, Lopper","banner":"http://obxk8w81b.bkt.clouddn.com/A%20Lane%20in%20the%20Public%20Garden%20at%20Arles.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/A%20Lane%20in%20the%20Public%20Garden%20at%20Arles.jpg","_content":"\n\n### 1.前言\n\n    Android中非UI线程（WorkThread）不能操作UI线程（MainThread）\n\nhandler 发送Message 给MessageQueue，Looper 来轮询消息，如果有Message，然后再发送给Handler，Handler 拿到消息就可以所在的线程执行了。\n\n### 2.ThreadLocal<T>\n\nThread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals ，这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal  put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。\n\n<!--more-->\n\n简单理解就是每个线程维护一个map，然后可以用一定的关键字取出这个map里的目标类（比如一个bean），这个“一定的关键字”说的就是这个ThreadLocal 。\n\nThreadLocal隔离了各个线程，让各线程之间没有什么共享的问题。\n\n参考：[Android 中 Handler，Looper，HandlerThread 的使用](http://www.jianshu.com/p/08cb3665972f)\n\n\n### 3.Looper\nLooper是Android handler机制的重要组成部分，Looper这个名字起的很形象，翻译过来是：打环的人，就是维护一个循环的人。\nLooper里有一个静态变量：private static final ThreadLocal sThreadLocal = new ThreadLocal();\n这是典型的Android里用到ThreadLocal的一个情况，调用Looper.prepare的时候，唯一做的事情就是把sThreadLocal作为key，把一个new出来的looper对象作为value put到相应线程的map里。然后以后用到Looper.loop的时候，就从这个sThreadLocal里取出这个Looper，然后死循环（阻塞循环）MessageQueue，取出Message并执行message指向的Handler。\n\n### 4.Handler\nSDK中关于Handler的说明如下：\n\n    A Handler allows you to sendand process Messageand Runnable objects associated\n    with a thread's MessageQueue.Each Handler instance is associated with a single\n    thread and that thread'smessage queue. When you create a new Handler, it is bound\n    to the thread /message queue of the thread that is creating it -- from that point\n    on, it willdeliver messages and runnables to that message queue and execute them\n    as theycome out of the message queue.\n\n#### 4.1 Handler的作用\n\n    There are two main uses for aHandler: (1) to schedule messages and runnables to be\n    executed as some point inthe future; and (2) to enqueue an action to be performed\n    on a different thread than your own.\n\n在线程中实例化Handler需要保证线程当中包含Looper(注意：UI-Thread默认包含Looper)。\n\n#### 4.2 不是所有的Handler都能更新UI\n\nHandler处理消息总是在创建Handler的线程里运行。而我们的消息处理中，不乏更新UI的操作，不正确的线程直接更新UI将引发异常。因此，需要时刻关心Handler在哪个线程里创建的。如何更新UI才能不出异常呢？SDK告诉我们，有以下4种方式可以从其它线程访问UI线程(也即线程间通信)：\n\n    - Activity.runOnUiThread(Runnable)\n    - View.post(Runnable)\n    - View.postDelayed(Runnable, long)\n    - 在UI线程中创建的Handler\n\n几点小结\n    - Handler的处理过程运行在创建Handler的线程里\n    - 一个Looper对应一个MessageQueue，一个线程对应一个Looper，一个Looper可以对应多个Handler\n    - 不确定当前线程时，更新UI时尽量调用View.post方法\n    - handler应该由处理消息的线程创建。\n    - handler与创建它的线程相关联，而且也只与创建它的线程相关联。handler运行在创建它的线程中，所以，如果在handler中进行耗时的操作，会阻塞创建它的线程。\n    - Android的线程分为有消息循环的线程和没有消息循环的线程，有消息循环的线程一般都会有一个Looper。主线程（UI线程）就是一个消息循环的线程。\n    - Looper.myLooper();      //获得当前的Looper\n        Looper.getMainLooper() //获得UI线程的Lopper\n    - Handle的初始化函数（构造函数），如果没有参数，那么他就默认使用的是当前的Looper，如果有Looper参数，就是用对应的线程的Looper。\n    - 如果一个线程中调用Looper.prepare()，那么系统就会自动的为该线程建立一个消息队列，然后调用Looper.loop();之后就进入了消息循环，这个之后就可以发消息、取消息、和处理消息。\n\n### 5.消息的发送与处理\n\n我们简单地看一下消息的循环过程：\n\n#### 5.1 消息的生成\n~~~ Java\nMessage msg =mHandler.obtainMessage();\nmsg.what = what;\nmsg.sendToTarget();\n~~~\n\n#### 5.2 消息的发送\n\n~~~ Java\nMessageQueue queue= mQueue;\n  if (queue != null){\n  msg.target =this;\n  sent =queue.enqueueMessage(msg, uptimeMillis);\n}\n~~~\n在Handler.java的sendMessageAtTime(Messagemsg, long uptimeMillis)方法中，我们看到，它找到它所引用的MessageQueue，然后将Message的target设定成自己（目的是为了在处理消息环节，Message能找到正确的Handler），再将这个Message纳入到消息队列中。\n\n#### 5.3 消息的抽取\n~~~ Java\nLooper me =myLooper();\nMessageQueue queue= me.mQueue;\nwhile (true) {\n  Message msg =queue.next(); // might block\n  if (msg !=null) {\n    if(msg.target == null) {\n      // Notarget is a magic identifier for the quit message.\n      return;\n    }\n    msg.target.dispatchMessage(msg);\n    msg.recycle();\n  }\n}\n~~~\n\n在Looper.java的loop()函数里，我们看到，这里有一个死循环，不断地从MessageQueue中获取下一个（next方法）Message，然后通过Message中携带的target信息，交由正确的Handler处理（dispatchMessage方法）。\n\n#### 5.4 消息的处理\n~~~ Java\nif (msg.callback!= null) {\n  handleCallback(msg);\n} else {\n  if (mCallback!= null) {\n    if(mCallback.handleMessage(msg)) {\n      return;\n    }\n  }\n handleMessage(msg);\n}\n~~~\n在Handler.java的dispatchMessage(Messagemsg)方法里，其中的一个分支就是调用handleMessage方法来处理这条Message，而这也正是我们在职责处描述使用Handler时需要实现handleMessage(Messagemsg)的原因。\n至于dispatchMessage方法中的另外一个分支，我将会在后面的内容中说明。\n至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。\n\n参考上面的消息的发送与处理，这里再解释一下View.post(Runnable)方法。\n\n    在post(Runnableaction)方法里，View获得当前线程（即UI线程）的Handler，然后将action对\n    象post到Handler里。在Handler里，它将传递过来的action对象包装成一个Message（Message\n    的callback为action），然后将其投入UI线程的消息循环中。在 Handler再次处理该Message时，有\n    一条分支就是为它所设，直接调用mCallback.handleMessage的方法，返回到runnable的run方法。\n    而此时，已经路由到UI线程里，因此，我们可以毫无顾虑的来更新UI。\n\n\n### 5.HandlerThread\nHandlerThread就是在普通的Thread基础上加上了Looper的支持，让用户不必自己去创建Looper了，同时方便了Handler的使用。\n\n创建HandlerThread时需要把它启动了，即调用start()方法。然后创建Handler时将HandlerThread中的looper对象传入。\n\n~~~ Java\nHandlerThread thread = new HandlerThread(\"MyHandlerThread\");\nthread.start();\nmHandler = new Handler(thread.getLooper());\nmHandler.post(new Runnable(){...});\n~~~\n\n那么这个Handler对象就是与HandlerThread这个线程绑定了（这时就不再是与UI线程绑定了，这样在Handler中处理耗时操作将不会阻塞UI）。\n\n如果想让HandlerThread退出，则需要调用handlerThread.quit()。\n\n具体可以看下面代码：\n\n~~~ Java\npublic class HandlerThreadActivity extends Activity {\n    private static final String TAG = \"HandlerThreadActivity\";\n    private HandlerThreadmHandlerThread;\n    private MyHandler mMyHandler;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n       // TODO Auto-generatedmethod stub\n       super.onCreate(savedInstanceState);\n       TextView text = new TextView(this);\n       text.setText(\"HandlerThreadActivity\");\n       setContentView(text);\n\n       Log.d(TAG, \"The mainthread id = \" + Thread.currentThread().getId());\n\n       //生成一个HandlerThread对象，实现了使用Looper来处理消息队列的功能，\n       //这个类由Android应用程序框架提供\n       mHandlerThread = new HandlerThread(\"handler_thread\");\n\n       //在使用HandlerThread的getLooper()方法之前，必须先调用该类的start();\n       mHandlerThread.start();\n       //即这个Handler是运行在mHandlerThread这个线程中\n       mMyHandler = new MyHandler(mHandlerThread.getLooper());\n\n       mMyHandler.sendEmptyMessage(1);\n    }\n\n    private class MyHandler extends Handler {\n\n       public MyHandler(Looper looper) {\n           super(looper);\n       }\n\n       @Override\n       public void handleMessage(Message msg) {\n           Log.d(TAG, \"MyHandler-->handleMessage-->threadid = \" + Thread.currentThread().getId());\n           super.handleMessage(msg);\n       }\n    }\n}\n~~~\n","source":"_posts/2016-09-05-ThreadLocal-HandlerThread-Lopper.md","raw":"---\nlayout: post\ntitle:  ThreadLocal、HandlerThread、Lopper区别\ncategory: accumulation\ntags: accumulation\nkeywords: ThreadLocal, HandlerThread, Lopper\nbanner: http://obxk8w81b.bkt.clouddn.com/A%20Lane%20in%20the%20Public%20Garden%20at%20Arles.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/A%20Lane%20in%20the%20Public%20Garden%20at%20Arles.jpg\n---\n\n\n### 1.前言\n\n    Android中非UI线程（WorkThread）不能操作UI线程（MainThread）\n\nhandler 发送Message 给MessageQueue，Looper 来轮询消息，如果有Message，然后再发送给Handler，Handler 拿到消息就可以所在的线程执行了。\n\n### 2.ThreadLocal<T>\n\nThread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals ，这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal  put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。\n\n<!--more-->\n\n简单理解就是每个线程维护一个map，然后可以用一定的关键字取出这个map里的目标类（比如一个bean），这个“一定的关键字”说的就是这个ThreadLocal 。\n\nThreadLocal隔离了各个线程，让各线程之间没有什么共享的问题。\n\n参考：[Android 中 Handler，Looper，HandlerThread 的使用](http://www.jianshu.com/p/08cb3665972f)\n\n\n### 3.Looper\nLooper是Android handler机制的重要组成部分，Looper这个名字起的很形象，翻译过来是：打环的人，就是维护一个循环的人。\nLooper里有一个静态变量：private static final ThreadLocal sThreadLocal = new ThreadLocal();\n这是典型的Android里用到ThreadLocal的一个情况，调用Looper.prepare的时候，唯一做的事情就是把sThreadLocal作为key，把一个new出来的looper对象作为value put到相应线程的map里。然后以后用到Looper.loop的时候，就从这个sThreadLocal里取出这个Looper，然后死循环（阻塞循环）MessageQueue，取出Message并执行message指向的Handler。\n\n### 4.Handler\nSDK中关于Handler的说明如下：\n\n    A Handler allows you to sendand process Messageand Runnable objects associated\n    with a thread's MessageQueue.Each Handler instance is associated with a single\n    thread and that thread'smessage queue. When you create a new Handler, it is bound\n    to the thread /message queue of the thread that is creating it -- from that point\n    on, it willdeliver messages and runnables to that message queue and execute them\n    as theycome out of the message queue.\n\n#### 4.1 Handler的作用\n\n    There are two main uses for aHandler: (1) to schedule messages and runnables to be\n    executed as some point inthe future; and (2) to enqueue an action to be performed\n    on a different thread than your own.\n\n在线程中实例化Handler需要保证线程当中包含Looper(注意：UI-Thread默认包含Looper)。\n\n#### 4.2 不是所有的Handler都能更新UI\n\nHandler处理消息总是在创建Handler的线程里运行。而我们的消息处理中，不乏更新UI的操作，不正确的线程直接更新UI将引发异常。因此，需要时刻关心Handler在哪个线程里创建的。如何更新UI才能不出异常呢？SDK告诉我们，有以下4种方式可以从其它线程访问UI线程(也即线程间通信)：\n\n    - Activity.runOnUiThread(Runnable)\n    - View.post(Runnable)\n    - View.postDelayed(Runnable, long)\n    - 在UI线程中创建的Handler\n\n几点小结\n    - Handler的处理过程运行在创建Handler的线程里\n    - 一个Looper对应一个MessageQueue，一个线程对应一个Looper，一个Looper可以对应多个Handler\n    - 不确定当前线程时，更新UI时尽量调用View.post方法\n    - handler应该由处理消息的线程创建。\n    - handler与创建它的线程相关联，而且也只与创建它的线程相关联。handler运行在创建它的线程中，所以，如果在handler中进行耗时的操作，会阻塞创建它的线程。\n    - Android的线程分为有消息循环的线程和没有消息循环的线程，有消息循环的线程一般都会有一个Looper。主线程（UI线程）就是一个消息循环的线程。\n    - Looper.myLooper();      //获得当前的Looper\n        Looper.getMainLooper() //获得UI线程的Lopper\n    - Handle的初始化函数（构造函数），如果没有参数，那么他就默认使用的是当前的Looper，如果有Looper参数，就是用对应的线程的Looper。\n    - 如果一个线程中调用Looper.prepare()，那么系统就会自动的为该线程建立一个消息队列，然后调用Looper.loop();之后就进入了消息循环，这个之后就可以发消息、取消息、和处理消息。\n\n### 5.消息的发送与处理\n\n我们简单地看一下消息的循环过程：\n\n#### 5.1 消息的生成\n~~~ Java\nMessage msg =mHandler.obtainMessage();\nmsg.what = what;\nmsg.sendToTarget();\n~~~\n\n#### 5.2 消息的发送\n\n~~~ Java\nMessageQueue queue= mQueue;\n  if (queue != null){\n  msg.target =this;\n  sent =queue.enqueueMessage(msg, uptimeMillis);\n}\n~~~\n在Handler.java的sendMessageAtTime(Messagemsg, long uptimeMillis)方法中，我们看到，它找到它所引用的MessageQueue，然后将Message的target设定成自己（目的是为了在处理消息环节，Message能找到正确的Handler），再将这个Message纳入到消息队列中。\n\n#### 5.3 消息的抽取\n~~~ Java\nLooper me =myLooper();\nMessageQueue queue= me.mQueue;\nwhile (true) {\n  Message msg =queue.next(); // might block\n  if (msg !=null) {\n    if(msg.target == null) {\n      // Notarget is a magic identifier for the quit message.\n      return;\n    }\n    msg.target.dispatchMessage(msg);\n    msg.recycle();\n  }\n}\n~~~\n\n在Looper.java的loop()函数里，我们看到，这里有一个死循环，不断地从MessageQueue中获取下一个（next方法）Message，然后通过Message中携带的target信息，交由正确的Handler处理（dispatchMessage方法）。\n\n#### 5.4 消息的处理\n~~~ Java\nif (msg.callback!= null) {\n  handleCallback(msg);\n} else {\n  if (mCallback!= null) {\n    if(mCallback.handleMessage(msg)) {\n      return;\n    }\n  }\n handleMessage(msg);\n}\n~~~\n在Handler.java的dispatchMessage(Messagemsg)方法里，其中的一个分支就是调用handleMessage方法来处理这条Message，而这也正是我们在职责处描述使用Handler时需要实现handleMessage(Messagemsg)的原因。\n至于dispatchMessage方法中的另外一个分支，我将会在后面的内容中说明。\n至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。\n\n参考上面的消息的发送与处理，这里再解释一下View.post(Runnable)方法。\n\n    在post(Runnableaction)方法里，View获得当前线程（即UI线程）的Handler，然后将action对\n    象post到Handler里。在Handler里，它将传递过来的action对象包装成一个Message（Message\n    的callback为action），然后将其投入UI线程的消息循环中。在 Handler再次处理该Message时，有\n    一条分支就是为它所设，直接调用mCallback.handleMessage的方法，返回到runnable的run方法。\n    而此时，已经路由到UI线程里，因此，我们可以毫无顾虑的来更新UI。\n\n\n### 5.HandlerThread\nHandlerThread就是在普通的Thread基础上加上了Looper的支持，让用户不必自己去创建Looper了，同时方便了Handler的使用。\n\n创建HandlerThread时需要把它启动了，即调用start()方法。然后创建Handler时将HandlerThread中的looper对象传入。\n\n~~~ Java\nHandlerThread thread = new HandlerThread(\"MyHandlerThread\");\nthread.start();\nmHandler = new Handler(thread.getLooper());\nmHandler.post(new Runnable(){...});\n~~~\n\n那么这个Handler对象就是与HandlerThread这个线程绑定了（这时就不再是与UI线程绑定了，这样在Handler中处理耗时操作将不会阻塞UI）。\n\n如果想让HandlerThread退出，则需要调用handlerThread.quit()。\n\n具体可以看下面代码：\n\n~~~ Java\npublic class HandlerThreadActivity extends Activity {\n    private static final String TAG = \"HandlerThreadActivity\";\n    private HandlerThreadmHandlerThread;\n    private MyHandler mMyHandler;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n       // TODO Auto-generatedmethod stub\n       super.onCreate(savedInstanceState);\n       TextView text = new TextView(this);\n       text.setText(\"HandlerThreadActivity\");\n       setContentView(text);\n\n       Log.d(TAG, \"The mainthread id = \" + Thread.currentThread().getId());\n\n       //生成一个HandlerThread对象，实现了使用Looper来处理消息队列的功能，\n       //这个类由Android应用程序框架提供\n       mHandlerThread = new HandlerThread(\"handler_thread\");\n\n       //在使用HandlerThread的getLooper()方法之前，必须先调用该类的start();\n       mHandlerThread.start();\n       //即这个Handler是运行在mHandlerThread这个线程中\n       mMyHandler = new MyHandler(mHandlerThread.getLooper());\n\n       mMyHandler.sendEmptyMessage(1);\n    }\n\n    private class MyHandler extends Handler {\n\n       public MyHandler(Looper looper) {\n           super(looper);\n       }\n\n       @Override\n       public void handleMessage(Message msg) {\n           Log.d(TAG, \"MyHandler-->handleMessage-->threadid = \" + Thread.currentThread().getId());\n           super.handleMessage(msg);\n       }\n    }\n}\n~~~\n","slug":"ThreadLocal-HandlerThread-Lopper","published":1,"date":"2016-09-04T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj56001fbxs6k185lj0f","content":"<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><pre><code>Android中非UI线程（WorkThread）不能操作UI线程（MainThread）\n</code></pre><p>handler 发送Message 给MessageQueue，Looper 来轮询消息，如果有Message，然后再发送给Handler，Handler 拿到消息就可以所在的线程执行了。</p>\n<h3 id=\"2-ThreadLocal\"><a href=\"#2-ThreadLocal\" class=\"headerlink\" title=\"2.ThreadLocal\"></a>2.ThreadLocal<t></t></h3><p>Thread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals ，这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal  put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。</p>\n<a id=\"more\"></a>\n<p>简单理解就是每个线程维护一个map，然后可以用一定的关键字取出这个map里的目标类（比如一个bean），这个“一定的关键字”说的就是这个ThreadLocal 。</p>\n<p>ThreadLocal隔离了各个线程，让各线程之间没有什么共享的问题。</p>\n<p>参考：<a href=\"http://www.jianshu.com/p/08cb3665972f\" target=\"_blank\" rel=\"external\">Android 中 Handler，Looper，HandlerThread 的使用</a></p>\n<h3 id=\"3-Looper\"><a href=\"#3-Looper\" class=\"headerlink\" title=\"3.Looper\"></a>3.Looper</h3><p>Looper是Android handler机制的重要组成部分，Looper这个名字起的很形象，翻译过来是：打环的人，就是维护一个循环的人。<br>Looper里有一个静态变量：private static final ThreadLocal sThreadLocal = new ThreadLocal();<br>这是典型的Android里用到ThreadLocal的一个情况，调用Looper.prepare的时候，唯一做的事情就是把sThreadLocal作为key，把一个new出来的looper对象作为value put到相应线程的map里。然后以后用到Looper.loop的时候，就从这个sThreadLocal里取出这个Looper，然后死循环（阻塞循环）MessageQueue，取出Message并执行message指向的Handler。</p>\n<h3 id=\"4-Handler\"><a href=\"#4-Handler\" class=\"headerlink\" title=\"4.Handler\"></a>4.Handler</h3><p>SDK中关于Handler的说明如下：</p>\n<pre><code>A Handler allows you to sendand process Messageand Runnable objects associated\nwith a thread&apos;s MessageQueue.Each Handler instance is associated with a single\nthread and that thread&apos;smessage queue. When you create a new Handler, it is bound\nto the thread /message queue of the thread that is creating it -- from that point\non, it willdeliver messages and runnables to that message queue and execute them\nas theycome out of the message queue.\n</code></pre><h4 id=\"4-1-Handler的作用\"><a href=\"#4-1-Handler的作用\" class=\"headerlink\" title=\"4.1 Handler的作用\"></a>4.1 Handler的作用</h4><pre><code>There are two main uses for aHandler: (1) to schedule messages and runnables to be\nexecuted as some point inthe future; and (2) to enqueue an action to be performed\non a different thread than your own.\n</code></pre><p>在线程中实例化Handler需要保证线程当中包含Looper(注意：UI-Thread默认包含Looper)。</p>\n<h4 id=\"4-2-不是所有的Handler都能更新UI\"><a href=\"#4-2-不是所有的Handler都能更新UI\" class=\"headerlink\" title=\"4.2 不是所有的Handler都能更新UI\"></a>4.2 不是所有的Handler都能更新UI</h4><p>Handler处理消息总是在创建Handler的线程里运行。而我们的消息处理中，不乏更新UI的操作，不正确的线程直接更新UI将引发异常。因此，需要时刻关心Handler在哪个线程里创建的。如何更新UI才能不出异常呢？SDK告诉我们，有以下4种方式可以从其它线程访问UI线程(也即线程间通信)：</p>\n<pre><code>- Activity.runOnUiThread(Runnable)\n- View.post(Runnable)\n- View.postDelayed(Runnable, long)\n- 在UI线程中创建的Handler\n</code></pre><p>几点小结</p>\n<pre><code>- Handler的处理过程运行在创建Handler的线程里\n- 一个Looper对应一个MessageQueue，一个线程对应一个Looper，一个Looper可以对应多个Handler\n- 不确定当前线程时，更新UI时尽量调用View.post方法\n- handler应该由处理消息的线程创建。\n- handler与创建它的线程相关联，而且也只与创建它的线程相关联。handler运行在创建它的线程中，所以，如果在handler中进行耗时的操作，会阻塞创建它的线程。\n- Android的线程分为有消息循环的线程和没有消息循环的线程，有消息循环的线程一般都会有一个Looper。主线程（UI线程）就是一个消息循环的线程。\n- Looper.myLooper();      //获得当前的Looper\n    Looper.getMainLooper() //获得UI线程的Lopper\n- Handle的初始化函数（构造函数），如果没有参数，那么他就默认使用的是当前的Looper，如果有Looper参数，就是用对应的线程的Looper。\n- 如果一个线程中调用Looper.prepare()，那么系统就会自动的为该线程建立一个消息队列，然后调用Looper.loop();之后就进入了消息循环，这个之后就可以发消息、取消息、和处理消息。\n</code></pre><h3 id=\"5-消息的发送与处理\"><a href=\"#5-消息的发送与处理\" class=\"headerlink\" title=\"5.消息的发送与处理\"></a>5.消息的发送与处理</h3><p>我们简单地看一下消息的循环过程：</p>\n<h4 id=\"5-1-消息的生成\"><a href=\"#5-1-消息的生成\" class=\"headerlink\" title=\"5.1 消息的生成\"></a>5.1 消息的生成</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Message msg =mHandler.obtainMessage();</div><div class=\"line\">msg.what = what;</div><div class=\"line\">msg.sendToTarget();</div></pre></td></tr></table></figure>\n<h4 id=\"5-2-消息的发送\"><a href=\"#5-2-消息的发送\" class=\"headerlink\" title=\"5.2 消息的发送\"></a>5.2 消息的发送</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">MessageQueue queue= mQueue;</div><div class=\"line\">  <span class=\"keyword\">if</span> (queue != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">  msg.target =<span class=\"keyword\">this</span>;</div><div class=\"line\">  sent =queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Handler.java的sendMessageAtTime(Messagemsg, long uptimeMillis)方法中，我们看到，它找到它所引用的MessageQueue，然后将Message的target设定成自己（目的是为了在处理消息环节，Message能找到正确的Handler），再将这个Message纳入到消息队列中。</p>\n<h4 id=\"5-3-消息的抽取\"><a href=\"#5-3-消息的抽取\" class=\"headerlink\" title=\"5.3 消息的抽取\"></a>5.3 消息的抽取</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Looper me =myLooper();</div><div class=\"line\">MessageQueue queue= me.mQueue;</div><div class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">  Message msg =queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (msg !=<span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(msg.target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// Notarget is a magic identifier for the quit message.</span></div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    msg.target.dispatchMessage(msg);</div><div class=\"line\">    msg.recycle();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Looper.java的loop()函数里，我们看到，这里有一个死循环，不断地从MessageQueue中获取下一个（next方法）Message，然后通过Message中携带的target信息，交由正确的Handler处理（dispatchMessage方法）。</p>\n<h4 id=\"5-4-消息的处理\"><a href=\"#5-4-消息的处理\" class=\"headerlink\" title=\"5.4 消息的处理\"></a>5.4 消息的处理</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (msg.callback!= <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">  handleCallback(msg);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (mCallback!= <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"> handleMessage(msg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Handler.java的dispatchMessage(Messagemsg)方法里，其中的一个分支就是调用handleMessage方法来处理这条Message，而这也正是我们在职责处描述使用Handler时需要实现handleMessage(Messagemsg)的原因。<br>至于dispatchMessage方法中的另外一个分支，我将会在后面的内容中说明。<br>至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。</p>\n<p>参考上面的消息的发送与处理，这里再解释一下View.post(Runnable)方法。</p>\n<pre><code>在post(Runnableaction)方法里，View获得当前线程（即UI线程）的Handler，然后将action对\n象post到Handler里。在Handler里，它将传递过来的action对象包装成一个Message（Message\n的callback为action），然后将其投入UI线程的消息循环中。在 Handler再次处理该Message时，有\n一条分支就是为它所设，直接调用mCallback.handleMessage的方法，返回到runnable的run方法。\n而此时，已经路由到UI线程里，因此，我们可以毫无顾虑的来更新UI。\n</code></pre><h3 id=\"5-HandlerThread\"><a href=\"#5-HandlerThread\" class=\"headerlink\" title=\"5.HandlerThread\"></a>5.HandlerThread</h3><p>HandlerThread就是在普通的Thread基础上加上了Looper的支持，让用户不必自己去创建Looper了，同时方便了Handler的使用。</p>\n<p>创建HandlerThread时需要把它启动了，即调用start()方法。然后创建Handler时将HandlerThread中的looper对象传入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">HandlerThread thread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"MyHandlerThread\"</span>);</div><div class=\"line\">thread.start();</div><div class=\"line\">mHandler = <span class=\"keyword\">new</span> Handler(thread.getLooper());</div><div class=\"line\">mHandler.post(<span class=\"keyword\">new</span> Runnable()&#123;...&#125;);</div></pre></td></tr></table></figure>\n<p>那么这个Handler对象就是与HandlerThread这个线程绑定了（这时就不再是与UI线程绑定了，这样在Handler中处理耗时操作将不会阻塞UI）。</p>\n<p>如果想让HandlerThread退出，则需要调用handlerThread.quit()。</p>\n<p>具体可以看下面代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerThreadActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"HandlerThreadActivity\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> HandlerThreadmHandlerThread;</div><div class=\"line\">    <span class=\"keyword\">private</span> MyHandler mMyHandler;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generatedmethod stub</span></div><div class=\"line\">       <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">       TextView text = <span class=\"keyword\">new</span> TextView(<span class=\"keyword\">this</span>);</div><div class=\"line\">       text.setText(<span class=\"string\">\"HandlerThreadActivity\"</span>);</div><div class=\"line\">       setContentView(text);</div><div class=\"line\"></div><div class=\"line\">       Log.d(TAG, <span class=\"string\">\"The mainthread id = \"</span> + Thread.currentThread().getId());</div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//生成一个HandlerThread对象，实现了使用Looper来处理消息队列的功能，</span></div><div class=\"line\">       <span class=\"comment\">//这个类由Android应用程序框架提供</span></div><div class=\"line\">       mHandlerThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"handler_thread\"</span>);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//在使用HandlerThread的getLooper()方法之前，必须先调用该类的start();</span></div><div class=\"line\">       mHandlerThread.start();</div><div class=\"line\">       <span class=\"comment\">//即这个Handler是运行在mHandlerThread这个线程中</span></div><div class=\"line\">       mMyHandler = <span class=\"keyword\">new</span> MyHandler(mHandlerThread.getLooper());</div><div class=\"line\"></div><div class=\"line\">       mMyHandler.sendEmptyMessage(<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyHandler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">super</span>(looper);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"meta\">@Override</span></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">           Log.d(TAG, <span class=\"string\">\"MyHandler--&gt;handleMessage--&gt;threadid = \"</span> + Thread.currentThread().getId());</div><div class=\"line\">           <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><pre><code>Android中非UI线程（WorkThread）不能操作UI线程（MainThread）\n</code></pre><p>handler 发送Message 给MessageQueue，Looper 来轮询消息，如果有Message，然后再发送给Handler，Handler 拿到消息就可以所在的线程执行了。</p>\n<h3 id=\"2-ThreadLocal\"><a href=\"#2-ThreadLocal\" class=\"headerlink\" title=\"2.ThreadLocal\"></a>2.ThreadLocal<T></h3><p>Thread这个类有一个变量：ThreadLocal.ThreadLocalMap threadLocals ，这是一个map的数据结构，里面的元素的key就是ThreadLocal，value就是我们自定义的一些目标类。我们可以在自己的多线程类中定义好几个ThreadLocal，然后每一个ThreadLocal  put一个特定的目标类，然后以后可以用ThreadLocal get到目标类（用自己作为Thread里map的key），因为每个Thread有自己独自的map，所以这样可以实现每个线程有自己的LocalThread，并且一个Thread里可以有多个LocalThread。</p>","more":"<p>简单理解就是每个线程维护一个map，然后可以用一定的关键字取出这个map里的目标类（比如一个bean），这个“一定的关键字”说的就是这个ThreadLocal 。</p>\n<p>ThreadLocal隔离了各个线程，让各线程之间没有什么共享的问题。</p>\n<p>参考：<a href=\"http://www.jianshu.com/p/08cb3665972f\">Android 中 Handler，Looper，HandlerThread 的使用</a></p>\n<h3 id=\"3-Looper\"><a href=\"#3-Looper\" class=\"headerlink\" title=\"3.Looper\"></a>3.Looper</h3><p>Looper是Android handler机制的重要组成部分，Looper这个名字起的很形象，翻译过来是：打环的人，就是维护一个循环的人。<br>Looper里有一个静态变量：private static final ThreadLocal sThreadLocal = new ThreadLocal();<br>这是典型的Android里用到ThreadLocal的一个情况，调用Looper.prepare的时候，唯一做的事情就是把sThreadLocal作为key，把一个new出来的looper对象作为value put到相应线程的map里。然后以后用到Looper.loop的时候，就从这个sThreadLocal里取出这个Looper，然后死循环（阻塞循环）MessageQueue，取出Message并执行message指向的Handler。</p>\n<h3 id=\"4-Handler\"><a href=\"#4-Handler\" class=\"headerlink\" title=\"4.Handler\"></a>4.Handler</h3><p>SDK中关于Handler的说明如下：</p>\n<pre><code>A Handler allows you to sendand process Messageand Runnable objects associated\nwith a thread&apos;s MessageQueue.Each Handler instance is associated with a single\nthread and that thread&apos;smessage queue. When you create a new Handler, it is bound\nto the thread /message queue of the thread that is creating it -- from that point\non, it willdeliver messages and runnables to that message queue and execute them\nas theycome out of the message queue.\n</code></pre><h4 id=\"4-1-Handler的作用\"><a href=\"#4-1-Handler的作用\" class=\"headerlink\" title=\"4.1 Handler的作用\"></a>4.1 Handler的作用</h4><pre><code>There are two main uses for aHandler: (1) to schedule messages and runnables to be\nexecuted as some point inthe future; and (2) to enqueue an action to be performed\non a different thread than your own.\n</code></pre><p>在线程中实例化Handler需要保证线程当中包含Looper(注意：UI-Thread默认包含Looper)。</p>\n<h4 id=\"4-2-不是所有的Handler都能更新UI\"><a href=\"#4-2-不是所有的Handler都能更新UI\" class=\"headerlink\" title=\"4.2 不是所有的Handler都能更新UI\"></a>4.2 不是所有的Handler都能更新UI</h4><p>Handler处理消息总是在创建Handler的线程里运行。而我们的消息处理中，不乏更新UI的操作，不正确的线程直接更新UI将引发异常。因此，需要时刻关心Handler在哪个线程里创建的。如何更新UI才能不出异常呢？SDK告诉我们，有以下4种方式可以从其它线程访问UI线程(也即线程间通信)：</p>\n<pre><code>- Activity.runOnUiThread(Runnable)\n- View.post(Runnable)\n- View.postDelayed(Runnable, long)\n- 在UI线程中创建的Handler\n</code></pre><p>几点小结</p>\n<pre><code>- Handler的处理过程运行在创建Handler的线程里\n- 一个Looper对应一个MessageQueue，一个线程对应一个Looper，一个Looper可以对应多个Handler\n- 不确定当前线程时，更新UI时尽量调用View.post方法\n- handler应该由处理消息的线程创建。\n- handler与创建它的线程相关联，而且也只与创建它的线程相关联。handler运行在创建它的线程中，所以，如果在handler中进行耗时的操作，会阻塞创建它的线程。\n- Android的线程分为有消息循环的线程和没有消息循环的线程，有消息循环的线程一般都会有一个Looper。主线程（UI线程）就是一个消息循环的线程。\n- Looper.myLooper();      //获得当前的Looper\n    Looper.getMainLooper() //获得UI线程的Lopper\n- Handle的初始化函数（构造函数），如果没有参数，那么他就默认使用的是当前的Looper，如果有Looper参数，就是用对应的线程的Looper。\n- 如果一个线程中调用Looper.prepare()，那么系统就会自动的为该线程建立一个消息队列，然后调用Looper.loop();之后就进入了消息循环，这个之后就可以发消息、取消息、和处理消息。\n</code></pre><h3 id=\"5-消息的发送与处理\"><a href=\"#5-消息的发送与处理\" class=\"headerlink\" title=\"5.消息的发送与处理\"></a>5.消息的发送与处理</h3><p>我们简单地看一下消息的循环过程：</p>\n<h4 id=\"5-1-消息的生成\"><a href=\"#5-1-消息的生成\" class=\"headerlink\" title=\"5.1 消息的生成\"></a>5.1 消息的生成</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Message msg =mHandler.obtainMessage();</div><div class=\"line\">msg.what = what;</div><div class=\"line\">msg.sendToTarget();</div></pre></td></tr></table></figure>\n<h4 id=\"5-2-消息的发送\"><a href=\"#5-2-消息的发送\" class=\"headerlink\" title=\"5.2 消息的发送\"></a>5.2 消息的发送</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">MessageQueue queue= mQueue;</div><div class=\"line\">  <span class=\"keyword\">if</span> (queue != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">  msg.target =<span class=\"keyword\">this</span>;</div><div class=\"line\">  sent =queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Handler.java的sendMessageAtTime(Messagemsg, long uptimeMillis)方法中，我们看到，它找到它所引用的MessageQueue，然后将Message的target设定成自己（目的是为了在处理消息环节，Message能找到正确的Handler），再将这个Message纳入到消息队列中。</p>\n<h4 id=\"5-3-消息的抽取\"><a href=\"#5-3-消息的抽取\" class=\"headerlink\" title=\"5.3 消息的抽取\"></a>5.3 消息的抽取</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Looper me =myLooper();</div><div class=\"line\">MessageQueue queue= me.mQueue;</div><div class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">  Message msg =queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (msg !=<span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(msg.target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// Notarget is a magic identifier for the quit message.</span></div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    msg.target.dispatchMessage(msg);</div><div class=\"line\">    msg.recycle();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Looper.java的loop()函数里，我们看到，这里有一个死循环，不断地从MessageQueue中获取下一个（next方法）Message，然后通过Message中携带的target信息，交由正确的Handler处理（dispatchMessage方法）。</p>\n<h4 id=\"5-4-消息的处理\"><a href=\"#5-4-消息的处理\" class=\"headerlink\" title=\"5.4 消息的处理\"></a>5.4 消息的处理</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (msg.callback!= <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">  handleCallback(msg);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (mCallback!= <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"> handleMessage(msg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Handler.java的dispatchMessage(Messagemsg)方法里，其中的一个分支就是调用handleMessage方法来处理这条Message，而这也正是我们在职责处描述使用Handler时需要实现handleMessage(Messagemsg)的原因。<br>至于dispatchMessage方法中的另外一个分支，我将会在后面的内容中说明。<br>至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。</p>\n<p>参考上面的消息的发送与处理，这里再解释一下View.post(Runnable)方法。</p>\n<pre><code>在post(Runnableaction)方法里，View获得当前线程（即UI线程）的Handler，然后将action对\n象post到Handler里。在Handler里，它将传递过来的action对象包装成一个Message（Message\n的callback为action），然后将其投入UI线程的消息循环中。在 Handler再次处理该Message时，有\n一条分支就是为它所设，直接调用mCallback.handleMessage的方法，返回到runnable的run方法。\n而此时，已经路由到UI线程里，因此，我们可以毫无顾虑的来更新UI。\n</code></pre><h3 id=\"5-HandlerThread\"><a href=\"#5-HandlerThread\" class=\"headerlink\" title=\"5.HandlerThread\"></a>5.HandlerThread</h3><p>HandlerThread就是在普通的Thread基础上加上了Looper的支持，让用户不必自己去创建Looper了，同时方便了Handler的使用。</p>\n<p>创建HandlerThread时需要把它启动了，即调用start()方法。然后创建Handler时将HandlerThread中的looper对象传入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">HandlerThread thread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"MyHandlerThread\"</span>);</div><div class=\"line\">thread.start();</div><div class=\"line\">mHandler = <span class=\"keyword\">new</span> Handler(thread.getLooper());</div><div class=\"line\">mHandler.post(<span class=\"keyword\">new</span> Runnable()&#123;...&#125;);</div></pre></td></tr></table></figure>\n<p>那么这个Handler对象就是与HandlerThread这个线程绑定了（这时就不再是与UI线程绑定了，这样在Handler中处理耗时操作将不会阻塞UI）。</p>\n<p>如果想让HandlerThread退出，则需要调用handlerThread.quit()。</p>\n<p>具体可以看下面代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerThreadActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"HandlerThreadActivity\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> HandlerThreadmHandlerThread;</div><div class=\"line\">    <span class=\"keyword\">private</span> MyHandler mMyHandler;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generatedmethod stub</span></div><div class=\"line\">       <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">       TextView text = <span class=\"keyword\">new</span> TextView(<span class=\"keyword\">this</span>);</div><div class=\"line\">       text.setText(<span class=\"string\">\"HandlerThreadActivity\"</span>);</div><div class=\"line\">       setContentView(text);</div><div class=\"line\"></div><div class=\"line\">       Log.d(TAG, <span class=\"string\">\"The mainthread id = \"</span> + Thread.currentThread().getId());</div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//生成一个HandlerThread对象，实现了使用Looper来处理消息队列的功能，</span></div><div class=\"line\">       <span class=\"comment\">//这个类由Android应用程序框架提供</span></div><div class=\"line\">       mHandlerThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"handler_thread\"</span>);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//在使用HandlerThread的getLooper()方法之前，必须先调用该类的start();</span></div><div class=\"line\">       mHandlerThread.start();</div><div class=\"line\">       <span class=\"comment\">//即这个Handler是运行在mHandlerThread这个线程中</span></div><div class=\"line\">       mMyHandler = <span class=\"keyword\">new</span> MyHandler(mHandlerThread.getLooper());</div><div class=\"line\"></div><div class=\"line\">       mMyHandler.sendEmptyMessage(<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyHandler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">super</span>(looper);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"meta\">@Override</span></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">           Log.d(TAG, <span class=\"string\">\"MyHandler--&gt;handleMessage--&gt;threadid = \"</span> + Thread.currentThread().getId());</div><div class=\"line\">           <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"apk中含有admob广告插件","keywords":"admob, 去除广告插件","banner":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Pear%20Tree.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Pear%20Tree.jpg","_content":"\n\n### 问题出现\n\n使用这个杀毒软件[antivirus-for-android](http://www.avg.com/no-en/antivirus-for-android)，检测我们团队的apk后，AVG提示警告unwanted software。\n\n生成的报告说是：\nBeware of Adware! 1 Types of Adware Detected\nLast reported adware activity:\tSep 16\nDays with adware in last 30:\t1 days\n\n见下图：\n\n<!--more-->\n\n![avg_warning](/images/blogimages/2016/avg_warning.PNG)\n\n### 排查\n\n使用这个广告插件检测工具[全能工具箱](https://play.google.com/store/apps/details?id=imoblife.toolbox.full&hl=zh)，检测后，确实提示我们的apk含有广告“admob”\n\n但是这个apk是我们团队自己开发的，有项目源码，AndroidManifest文件中没有网络上说的Google AdMob注册，更没有com.google.ads.AdView这个布局文件\n\n代码中没有，可能在第三方库中？\n\n结果就是在排查第三方库的过程中，发现google service的jar包中有名字是ads的文件夹。如下图：\n![google_servcie_ads](/images/blogimages/2016/google_servcie_ads.PNG)\n\n删除后上图中的两个ads文件夹，再打包apk后，用软件检测，果然没有admob插件了。哈哈，恼人的问题解决了。\n","source":"_posts/2016-09-20-AVG-unwanted-software.md","raw":"---\nlayout: post\ntitle:  apk中含有admob广告插件\ncategory: accumulation\ntags: accumulation\nkeywords: admob, 去除广告插件\nbanner: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Pear%20Tree.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Pear%20Tree.jpg\n---\n\n\n### 问题出现\n\n使用这个杀毒软件[antivirus-for-android](http://www.avg.com/no-en/antivirus-for-android)，检测我们团队的apk后，AVG提示警告unwanted software。\n\n生成的报告说是：\nBeware of Adware! 1 Types of Adware Detected\nLast reported adware activity:\tSep 16\nDays with adware in last 30:\t1 days\n\n见下图：\n\n<!--more-->\n\n![avg_warning](/images/blogimages/2016/avg_warning.PNG)\n\n### 排查\n\n使用这个广告插件检测工具[全能工具箱](https://play.google.com/store/apps/details?id=imoblife.toolbox.full&hl=zh)，检测后，确实提示我们的apk含有广告“admob”\n\n但是这个apk是我们团队自己开发的，有项目源码，AndroidManifest文件中没有网络上说的Google AdMob注册，更没有com.google.ads.AdView这个布局文件\n\n代码中没有，可能在第三方库中？\n\n结果就是在排查第三方库的过程中，发现google service的jar包中有名字是ads的文件夹。如下图：\n![google_servcie_ads](/images/blogimages/2016/google_servcie_ads.PNG)\n\n删除后上图中的两个ads文件夹，再打包apk后，用软件检测，果然没有admob插件了。哈哈，恼人的问题解决了。\n","slug":"AVG-unwanted-software","published":1,"date":"2016-09-19T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj59001ibxs622pi4num","content":"<h3 id=\"问题出现\"><a href=\"#问题出现\" class=\"headerlink\" title=\"问题出现\"></a>问题出现</h3><p>使用这个杀毒软件<a href=\"http://www.avg.com/no-en/antivirus-for-android\" target=\"_blank\" rel=\"external\">antivirus-for-android</a>，检测我们团队的apk后，AVG提示警告unwanted software。</p>\n<p>生成的报告说是：<br>Beware of Adware! 1 Types of Adware Detected<br>Last reported adware activity:    Sep 16<br>Days with adware in last 30:    1 days</p>\n<p>见下图：</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/blogimages/2016/avg_warning.PNG\" alt=\"avg_warning\"></p>\n<h3 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h3><p>使用这个广告插件检测工具<a href=\"https://play.google.com/store/apps/details?id=imoblife.toolbox.full&amp;hl=zh\" target=\"_blank\" rel=\"external\">全能工具箱</a>，检测后，确实提示我们的apk含有广告“admob”</p>\n<p>但是这个apk是我们团队自己开发的，有项目源码，AndroidManifest文件中没有网络上说的Google AdMob注册，更没有com.google.ads.AdView这个布局文件</p>\n<p>代码中没有，可能在第三方库中？</p>\n<p>结果就是在排查第三方库的过程中，发现google service的jar包中有名字是ads的文件夹。如下图：<br><img src=\"/images/blogimages/2016/google_servcie_ads.PNG\" alt=\"google_servcie_ads\"></p>\n<p>删除后上图中的两个ads文件夹，再打包apk后，用软件检测，果然没有admob插件了。哈哈，恼人的问题解决了。</p>\n","excerpt":"<h3 id=\"问题出现\"><a href=\"#问题出现\" class=\"headerlink\" title=\"问题出现\"></a>问题出现</h3><p>使用这个杀毒软件<a href=\"http://www.avg.com/no-en/antivirus-for-android\">antivirus-for-android</a>，检测我们团队的apk后，AVG提示警告unwanted software。</p>\n<p>生成的报告说是：<br>Beware of Adware! 1 Types of Adware Detected<br>Last reported adware activity:    Sep 16<br>Days with adware in last 30:    1 days</p>\n<p>见下图：</p>","more":"<p><img src=\"/images/blogimages/2016/avg_warning.PNG\" alt=\"avg_warning\"></p>\n<h3 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h3><p>使用这个广告插件检测工具<a href=\"https://play.google.com/store/apps/details?id=imoblife.toolbox.full&amp;hl=zh\">全能工具箱</a>，检测后，确实提示我们的apk含有广告“admob”</p>\n<p>但是这个apk是我们团队自己开发的，有项目源码，AndroidManifest文件中没有网络上说的Google AdMob注册，更没有com.google.ads.AdView这个布局文件</p>\n<p>代码中没有，可能在第三方库中？</p>\n<p>结果就是在排查第三方库的过程中，发现google service的jar包中有名字是ads的文件夹。如下图：<br><img src=\"/images/blogimages/2016/google_servcie_ads.PNG\" alt=\"google_servcie_ads\"></p>\n<p>删除后上图中的两个ads文件夹，再打包apk后，用软件检测，果然没有admob插件了。哈哈，恼人的问题解决了。</p>"},{"layout":"post","title":"ANDROID设计模式之单例模式","keywords":"单例模式, ANDROID","banner":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Almond%20Tree.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Almond%20Tree.jpg","_content":"\n### 向大神致敬\n\n本文转载自[stormzhang ANDROID设计模式之单例模式 ](http://stormzhang.com/designpattern/2016/03/27/android-design-pattern-singleton/)，\n稍有修改\n\n### 常用单例模式\n\n什么是设计模式？其实简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式的意思，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，但是我只会针对Android平台上常用的一些设计模式做分享，今天就先来分享下最常用的单例模式。\n\n<!--more-->\n#### 饿汉式\n\n~~~ Java\npublic class Singleton{\n\n    private static Singleton instance = new Singleton();\n\n    private Singleton(){}\n\n    public static Singleton newInstance(){\n        return instance;\n    }\n}\n~~~\n\n饿汉式 是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用饿汉式的单例模式就是不合适的，这时候就需要用到懒汉式的方式去按需延迟加载单例。\n\n#### 懒汉式\n\n~~~ Java\npublic class Singleton{\n    private static Singleton instance = null;\n\n    private Singleton(){}\n\n    public static Singleton newInstance(){\n        if(null == instance){\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n~~~\n\n懒汉式与饿汉式的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用懒汉式就是非常不错的选择。\n\n### 多线程下的单例模式\n\n上面介绍了一些单例模式的基本应用方法，但是上面所说的那些使用方式都是有一个隐含的前提，那就是他们都是应用在单线程条件下，一旦换成了多线程就有出错的风险。\n\n如果在多线程的情况下，饿汉式不会出现问题，因为JVM只会加载一次单例类，但是懒汉式可能就会出现重复创建单例对象的问题。为什么会有这样的问题呢？因为懒汉式在创建单例时是 线程不安全的，多个线程可能会并发调用他的newInstance方法导致多个线程可能会创建多份相同的单例出来。\n\n那有没有办法，使懒汉式的单利模式也是线程安全的呢？答案肯定是有的，就是使用加同步锁的方式去实现。\n\n#### 懒汉式同步锁\n\n~~~ Java\npublic class Singleton {\n\n    private static Singleton instance = null;\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance() {\n        synchronized (Singleton.class) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n\n        return instance;\n    }\n}\n~~~\n\n这种是最常见的解决同步问题的一种方式，使用同步锁synchronized (Singleton.class)防止多线程同时进入造成instance被多次实例化。举个在Android使用这种方式的例子：\n\n#### InputMethodManager示例\n\n~~~ Java\npublic final class InputMethodManager {\n    //内部全局唯一实例  \n    static InputMethodManager sInstance;\n\n    //对外api  \n    public static InputMethodManager getInstance() {\n        synchronized (InputMethodManager.class) {\n            if (sInstance == null) {\n                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n            }\n            return sInstance;\n        }\n    }\n}\n~~~\n\n以上是Android源码中输入法类相关的单例使用方式。\n\n但其实还有一种更好的方式如下：\n\n#### 双重校验锁\n\n~~~ Java\npublic class Singleton {\n\n    private static volatile Singleton instance = null;\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance() {\n        // if already inited, no need to get lock everytime\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n\n        return instance;\n    }\n}\n~~~\n\n可以看到上面在synchronized (Singleton.class)外又添加了一层if，这是为了在instance已经实例化后下次进入不必执行synchronized (Singleton.class)获取对象锁，从而提高性能。\n\n以上两种方式还是挺麻烦的，我们不禁要问，有没有更好的实现方式呢？答案是肯定的。 我们可以利用JVM的类加载机制去实现。在很多情况下JVM已经为我们提供了同步控制，比如：\n\n在static{}区块中初始化的数据\n访问final字段时\n等等\n因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：\n\n采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载和线程安全。\n\n实现代码如下：\n\n#### 静态内部类\n\n~~~ Java\npublic class Singleton{\n    //内部类，在装载该内部类时才会去创建单利对象\n    private static class SingletonHolder{\n        public static Singleton instance = new Singleton();\n    }\n\n    private Singleton(){}\n\n    public static Singleton newInstance(){\n        return SingletonHolder.instance;\n    }\n\n    public void doSomething(){\n        //do something\n    }\n}\n~~~\n\n这样实现出来的单例类就是线程安全的，而且使用起来很简洁，麻麻再也不用担心我的单例不是单例了。\n\n然而这还不是最简单的方式，Effective Java中推荐了一种更简洁方便的使用方式，就是使用枚举。\n\n#### 枚举类型单例模式\n\n~~~ Java\npublic enum Singleton{\n    //定义一个枚举的元素，它就是Singleton的一个实例\n    instance;\n\n    public void doSomething(){\n        // do something ...\n    }    \n}\n~~~\n\n使用方法如下：\n\n~~~ Java\npublic static void main(String[] args){\n   Singleton singleton = Singleton.instance;\n   singleton.doSomething();\n}\n~~~\n\n默认枚举实例的创建是线程安全的(创建枚举类的单例在JVM层面也是能保证线程安全的), 所以不需要担心线程安全的问题，所以理论上枚举类来实现单例模式是最简单的方式。\n\n### 总结\n\n一般单例模式包含了5种写法，分别是饿汉、懒汉、双重校验锁、静态内部类和枚举。相信看完之后你对单例模式有了充分的理解了，根据不同的场景选择最你最喜欢的一种单例模式吧！\n","source":"_posts/2016-09-20-android-design-pattern-singleton.md","raw":"---\nlayout: post\ntitle:  ANDROID设计模式之单例模式\ncategory: accumulation\ntags: Android design pattern\nkeywords: 单例模式, ANDROID\nbanner: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Almond%20Tree.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Almond%20Tree.jpg\n---\n\n### 向大神致敬\n\n本文转载自[stormzhang ANDROID设计模式之单例模式 ](http://stormzhang.com/designpattern/2016/03/27/android-design-pattern-singleton/)，\n稍有修改\n\n### 常用单例模式\n\n什么是设计模式？其实简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式的意思，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，但是我只会针对Android平台上常用的一些设计模式做分享，今天就先来分享下最常用的单例模式。\n\n<!--more-->\n#### 饿汉式\n\n~~~ Java\npublic class Singleton{\n\n    private static Singleton instance = new Singleton();\n\n    private Singleton(){}\n\n    public static Singleton newInstance(){\n        return instance;\n    }\n}\n~~~\n\n饿汉式 是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用饿汉式的单例模式就是不合适的，这时候就需要用到懒汉式的方式去按需延迟加载单例。\n\n#### 懒汉式\n\n~~~ Java\npublic class Singleton{\n    private static Singleton instance = null;\n\n    private Singleton(){}\n\n    public static Singleton newInstance(){\n        if(null == instance){\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n~~~\n\n懒汉式与饿汉式的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用懒汉式就是非常不错的选择。\n\n### 多线程下的单例模式\n\n上面介绍了一些单例模式的基本应用方法，但是上面所说的那些使用方式都是有一个隐含的前提，那就是他们都是应用在单线程条件下，一旦换成了多线程就有出错的风险。\n\n如果在多线程的情况下，饿汉式不会出现问题，因为JVM只会加载一次单例类，但是懒汉式可能就会出现重复创建单例对象的问题。为什么会有这样的问题呢？因为懒汉式在创建单例时是 线程不安全的，多个线程可能会并发调用他的newInstance方法导致多个线程可能会创建多份相同的单例出来。\n\n那有没有办法，使懒汉式的单利模式也是线程安全的呢？答案肯定是有的，就是使用加同步锁的方式去实现。\n\n#### 懒汉式同步锁\n\n~~~ Java\npublic class Singleton {\n\n    private static Singleton instance = null;\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance() {\n        synchronized (Singleton.class) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n\n        return instance;\n    }\n}\n~~~\n\n这种是最常见的解决同步问题的一种方式，使用同步锁synchronized (Singleton.class)防止多线程同时进入造成instance被多次实例化。举个在Android使用这种方式的例子：\n\n#### InputMethodManager示例\n\n~~~ Java\npublic final class InputMethodManager {\n    //内部全局唯一实例  \n    static InputMethodManager sInstance;\n\n    //对外api  \n    public static InputMethodManager getInstance() {\n        synchronized (InputMethodManager.class) {\n            if (sInstance == null) {\n                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n            }\n            return sInstance;\n        }\n    }\n}\n~~~\n\n以上是Android源码中输入法类相关的单例使用方式。\n\n但其实还有一种更好的方式如下：\n\n#### 双重校验锁\n\n~~~ Java\npublic class Singleton {\n\n    private static volatile Singleton instance = null;\n\n    private Singleton(){\n    }\n\n    public static Singleton getInstance() {\n        // if already inited, no need to get lock everytime\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n\n        return instance;\n    }\n}\n~~~\n\n可以看到上面在synchronized (Singleton.class)外又添加了一层if，这是为了在instance已经实例化后下次进入不必执行synchronized (Singleton.class)获取对象锁，从而提高性能。\n\n以上两种方式还是挺麻烦的，我们不禁要问，有没有更好的实现方式呢？答案是肯定的。 我们可以利用JVM的类加载机制去实现。在很多情况下JVM已经为我们提供了同步控制，比如：\n\n在static{}区块中初始化的数据\n访问final字段时\n等等\n因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：\n\n采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载和线程安全。\n\n实现代码如下：\n\n#### 静态内部类\n\n~~~ Java\npublic class Singleton{\n    //内部类，在装载该内部类时才会去创建单利对象\n    private static class SingletonHolder{\n        public static Singleton instance = new Singleton();\n    }\n\n    private Singleton(){}\n\n    public static Singleton newInstance(){\n        return SingletonHolder.instance;\n    }\n\n    public void doSomething(){\n        //do something\n    }\n}\n~~~\n\n这样实现出来的单例类就是线程安全的，而且使用起来很简洁，麻麻再也不用担心我的单例不是单例了。\n\n然而这还不是最简单的方式，Effective Java中推荐了一种更简洁方便的使用方式，就是使用枚举。\n\n#### 枚举类型单例模式\n\n~~~ Java\npublic enum Singleton{\n    //定义一个枚举的元素，它就是Singleton的一个实例\n    instance;\n\n    public void doSomething(){\n        // do something ...\n    }    \n}\n~~~\n\n使用方法如下：\n\n~~~ Java\npublic static void main(String[] args){\n   Singleton singleton = Singleton.instance;\n   singleton.doSomething();\n}\n~~~\n\n默认枚举实例的创建是线程安全的(创建枚举类的单例在JVM层面也是能保证线程安全的), 所以不需要担心线程安全的问题，所以理论上枚举类来实现单例模式是最简单的方式。\n\n### 总结\n\n一般单例模式包含了5种写法，分别是饿汉、懒汉、双重校验锁、静态内部类和枚举。相信看完之后你对单例模式有了充分的理解了，根据不同的场景选择最你最喜欢的一种单例模式吧！\n","slug":"android-design-pattern-singleton","published":1,"date":"2016-09-19T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5d001nbxs6s1m2yhg0","content":"<h3 id=\"向大神致敬\"><a href=\"#向大神致敬\" class=\"headerlink\" title=\"向大神致敬\"></a>向大神致敬</h3><p>本文转载自<a href=\"http://stormzhang.com/designpattern/2016/03/27/android-design-pattern-singleton/\" target=\"_blank\" rel=\"external\">stormzhang ANDROID设计模式之单例模式 </a>，<br>稍有修改</p>\n<h3 id=\"常用单例模式\"><a href=\"#常用单例模式\" class=\"headerlink\" title=\"常用单例模式\"></a>常用单例模式</h3><p>什么是设计模式？其实简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式的意思，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，但是我只会针对Android平台上常用的一些设计模式做分享，今天就先来分享下最常用的单例模式。</p>\n<a id=\"more\"></a>\n<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">newInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>饿汉式 是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用饿汉式的单例模式就是不合适的，这时候就需要用到懒汉式的方式去按需延迟加载单例。</p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">newInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> == instance)&#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>懒汉式与饿汉式的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用懒汉式就是非常不错的选择。</p>\n<h3 id=\"多线程下的单例模式\"><a href=\"#多线程下的单例模式\" class=\"headerlink\" title=\"多线程下的单例模式\"></a>多线程下的单例模式</h3><p>上面介绍了一些单例模式的基本应用方法，但是上面所说的那些使用方式都是有一个隐含的前提，那就是他们都是应用在单线程条件下，一旦换成了多线程就有出错的风险。</p>\n<p>如果在多线程的情况下，饿汉式不会出现问题，因为JVM只会加载一次单例类，但是懒汉式可能就会出现重复创建单例对象的问题。为什么会有这样的问题呢？因为懒汉式在创建单例时是 线程不安全的，多个线程可能会并发调用他的newInstance方法导致多个线程可能会创建多份相同的单例出来。</p>\n<p>那有没有办法，使懒汉式的单利模式也是线程安全的呢？答案肯定是有的，就是使用加同步锁的方式去实现。</p>\n<h4 id=\"懒汉式同步锁\"><a href=\"#懒汉式同步锁\" class=\"headerlink\" title=\"懒汉式同步锁\"></a>懒汉式同步锁</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种是最常见的解决同步问题的一种方式，使用同步锁synchronized (Singleton.class)防止多线程同时进入造成instance被多次实例化。举个在Android使用这种方式的例子：</p>\n<h4 id=\"InputMethodManager示例\"><a href=\"#InputMethodManager示例\" class=\"headerlink\" title=\"InputMethodManager示例\"></a>InputMethodManager示例</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputMethodManager</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//内部全局唯一实例  </span></div><div class=\"line\">    <span class=\"keyword\">static</span> InputMethodManager sInstance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//对外api  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> InputMethodManager <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (InputMethodManager.class) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (sInstance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</div><div class=\"line\">                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</div><div class=\"line\">                sInstance = <span class=\"keyword\">new</span> InputMethodManager(service, Looper.getMainLooper());</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> sInstance;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上是Android源码中输入法类相关的单例使用方式。</p>\n<p>但其实还有一种更好的方式如下：</p>\n<h4 id=\"双重校验锁\"><a href=\"#双重校验锁\" class=\"headerlink\" title=\"双重校验锁\"></a>双重校验锁</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// if already inited, no need to get lock everytime</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到上面在synchronized (Singleton.class)外又添加了一层if，这是为了在instance已经实例化后下次进入不必执行synchronized (Singleton.class)获取对象锁，从而提高性能。</p>\n<p>以上两种方式还是挺麻烦的，我们不禁要问，有没有更好的实现方式呢？答案是肯定的。 我们可以利用JVM的类加载机制去实现。在很多情况下JVM已经为我们提供了同步控制，比如：</p>\n<p>在static{}区块中初始化的数据<br>访问final字段时<br>等等<br>因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：</p>\n<p>采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载和线程安全。</p>\n<p>实现代码如下：</p>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//内部类，在装载该内部类时才会去创建单利对象</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">newInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"comment\">//do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样实现出来的单例类就是线程安全的，而且使用起来很简洁，麻麻再也不用担心我的单例不是单例了。</p>\n<p>然而这还不是最简单的方式，Effective Java中推荐了一种更简洁方便的使用方式，就是使用枚举。</p>\n<h4 id=\"枚举类型单例模式\"><a href=\"#枚举类型单例模式\" class=\"headerlink\" title=\"枚举类型单例模式\"></a>枚举类型单例模式</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton&#123;</div><div class=\"line\">    <span class=\"comment\">//定义一个枚举的元素，它就是Singleton的一个实例</span></div><div class=\"line\">    instance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"comment\">// do something ...</span></div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">   Singleton singleton = Singleton.instance;</div><div class=\"line\">   singleton.doSomething();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>默认枚举实例的创建是线程安全的(创建枚举类的单例在JVM层面也是能保证线程安全的), 所以不需要担心线程安全的问题，所以理论上枚举类来实现单例模式是最简单的方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>一般单例模式包含了5种写法，分别是饿汉、懒汉、双重校验锁、静态内部类和枚举。相信看完之后你对单例模式有了充分的理解了，根据不同的场景选择最你最喜欢的一种单例模式吧！</p>\n","excerpt":"<h3 id=\"向大神致敬\"><a href=\"#向大神致敬\" class=\"headerlink\" title=\"向大神致敬\"></a>向大神致敬</h3><p>本文转载自<a href=\"http://stormzhang.com/designpattern/2016/03/27/android-design-pattern-singleton/\">stormzhang ANDROID设计模式之单例模式 </a>，<br>稍有修改</p>\n<h3 id=\"常用单例模式\"><a href=\"#常用单例模式\" class=\"headerlink\" title=\"常用单例模式\"></a>常用单例模式</h3><p>什么是设计模式？其实简单的理解就是前人留下来的一些经验总结而已，然后把这些经验起了个名字叫Design Pattern，翻译过来就是设计模式的意思，通过使用设计模式可以让我们的代码复用性更高，可维护性更高，让你的代码写的更优雅。设计模式理论上有23种，但是我只会针对Android平台上常用的一些设计模式做分享，今天就先来分享下最常用的单例模式。</p>","more":"<h4 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">newInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>饿汉式 是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。 但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用饿汉式的单例模式就是不合适的，这时候就需要用到懒汉式的方式去按需延迟加载单例。</p>\n<h4 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">newInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> == instance)&#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>懒汉式与饿汉式的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用懒汉式就是非常不错的选择。</p>\n<h3 id=\"多线程下的单例模式\"><a href=\"#多线程下的单例模式\" class=\"headerlink\" title=\"多线程下的单例模式\"></a>多线程下的单例模式</h3><p>上面介绍了一些单例模式的基本应用方法，但是上面所说的那些使用方式都是有一个隐含的前提，那就是他们都是应用在单线程条件下，一旦换成了多线程就有出错的风险。</p>\n<p>如果在多线程的情况下，饿汉式不会出现问题，因为JVM只会加载一次单例类，但是懒汉式可能就会出现重复创建单例对象的问题。为什么会有这样的问题呢？因为懒汉式在创建单例时是 线程不安全的，多个线程可能会并发调用他的newInstance方法导致多个线程可能会创建多份相同的单例出来。</p>\n<p>那有没有办法，使懒汉式的单利模式也是线程安全的呢？答案肯定是有的，就是使用加同步锁的方式去实现。</p>\n<h4 id=\"懒汉式同步锁\"><a href=\"#懒汉式同步锁\" class=\"headerlink\" title=\"懒汉式同步锁\"></a>懒汉式同步锁</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种是最常见的解决同步问题的一种方式，使用同步锁synchronized (Singleton.class)防止多线程同时进入造成instance被多次实例化。举个在Android使用这种方式的例子：</p>\n<h4 id=\"InputMethodManager示例\"><a href=\"#InputMethodManager示例\" class=\"headerlink\" title=\"InputMethodManager示例\"></a>InputMethodManager示例</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputMethodManager</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//内部全局唯一实例  </span></div><div class=\"line\">    <span class=\"keyword\">static</span> InputMethodManager sInstance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//对外api  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> InputMethodManager <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (InputMethodManager.class) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (sInstance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</div><div class=\"line\">                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</div><div class=\"line\">                sInstance = <span class=\"keyword\">new</span> InputMethodManager(service, Looper.getMainLooper());</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> sInstance;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上是Android源码中输入法类相关的单例使用方式。</p>\n<p>但其实还有一种更好的方式如下：</p>\n<h4 id=\"双重校验锁\"><a href=\"#双重校验锁\" class=\"headerlink\" title=\"双重校验锁\"></a>双重校验锁</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// if already inited, no need to get lock everytime</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到上面在synchronized (Singleton.class)外又添加了一层if，这是为了在instance已经实例化后下次进入不必执行synchronized (Singleton.class)获取对象锁，从而提高性能。</p>\n<p>以上两种方式还是挺麻烦的，我们不禁要问，有没有更好的实现方式呢？答案是肯定的。 我们可以利用JVM的类加载机制去实现。在很多情况下JVM已经为我们提供了同步控制，比如：</p>\n<p>在static{}区块中初始化的数据<br>访问final字段时<br>等等<br>因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：</p>\n<p>采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载和线程安全。</p>\n<p>实现代码如下：</p>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//内部类，在装载该内部类时才会去创建单利对象</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">newInstance</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"comment\">//do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样实现出来的单例类就是线程安全的，而且使用起来很简洁，麻麻再也不用担心我的单例不是单例了。</p>\n<p>然而这还不是最简单的方式，Effective Java中推荐了一种更简洁方便的使用方式，就是使用枚举。</p>\n<h4 id=\"枚举类型单例模式\"><a href=\"#枚举类型单例模式\" class=\"headerlink\" title=\"枚举类型单例模式\"></a>枚举类型单例模式</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton&#123;</div><div class=\"line\">    <span class=\"comment\">//定义一个枚举的元素，它就是Singleton的一个实例</span></div><div class=\"line\">    instance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"comment\">// do something ...</span></div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">   Singleton singleton = Singleton.instance;</div><div class=\"line\">   singleton.doSomething();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>默认枚举实例的创建是线程安全的(创建枚举类的单例在JVM层面也是能保证线程安全的), 所以不需要担心线程安全的问题，所以理论上枚举类来实现单例模式是最简单的方式。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>一般单例模式包含了5种写法，分别是饿汉、懒汉、双重校验锁、静态内部类和枚举。相信看完之后你对单例模式有了充分的理解了，根据不同的场景选择最你最喜欢的一种单例模式吧！</p>"},{"layout":"post","title":"使用JNI获取publickey实现","keywords":"JNI, publickey","banner":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Almond%20Branch%20in%20a%20Glass%20with%20a%20Book.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Blossoming%20Almond%20Branch%20in%20a%20Glass%20with%20a%20Book.jpg","_content":"\n\n### 1.前言\n之前写过一篇文件是关于[JNI学习和积累](http://agehua.github.io/2016/JNI-Learning)的文章。\n这篇文章主要讲在使用JNI取得Publickey过程中遇到的问题和一些总结。\n\n### 2.JNI获取Publickey实现\n在上篇文章中，最终采用的加密方法来自[github项目](https://github.com/MasonLiuChn/AndroidUltimateEncrypt)。\n\n但该项目中在4.0.4版本的手机上，取得publickey遇到兼容性问题。\n\n<!--more-->\n\n正常的Publickey字段样式是这样的：\n\n~~~ Java\nOpenSSLRSAPublicKey{modulus=a0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb26a73305eea631ab18ec3ce746eb253e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9480cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a312c73cf0b98e0ce9a8cf6a682fa,publicExponent=10001}\n~~~\n\n但是某些低版本手机上（我遇到的是三星GT-S7568 Android版本4.0.4）的Publickey字段样式是：\n\n~~~ Java\nRSA Public Key\n      modulus: a0d169cedabdaac3527c2099eeaca0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb6a73305eea631ab18ec3ce746eb23e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9410cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a313c73cf0b98e0ce9a8cf6a682aff0b98e0ce9a8cf6a682fa\n      public exponent: 10001\n~~~\n第一个字段modulus是一致的，第二个字段一个是“**publicExponent**”，另一个是“**public exponent**”。\n\n所以我在代码中的处理是这样的\n\n~~~ C++\njmethodID substring_mid = env->GetMethodID(string_cls,\"substring\", \"(II)Ljava/lang/String;\");\njmethodID indexOf_mid = env->GetMethodID(string_cls,\"indexOf\", \"(Ljava/lang/String;)I\");\n\njint bb = env->CallIntMethod(publicKey_str,indexOf_mid,param2);\njstring publicKey2_str =NULL;\nif (bb ==-1){\n\tjstring param3 = env->NewStringUTF(\"public exponent\");\n\tjint cc = env->CallIntMethod(publicKey_str,indexOf_mid,param3);\n\t__android_log_print(ANDROID_LOG_ERROR, TAG, \"CC value is %d\", cc);\n\tpublicKey2_str= static_cast<jstring>(env->CallObjectMethod(publicKey_str,substring_mid,aa+8,cc-1));\n}else {\n\tpublicKey2_str = static_cast<jstring>(env->CallObjectMethod(publicKey_str,substring_mid,aa+8,bb-1));\n}\n~~~\n\n#### 2.1 在JNI native代码中打印日志\n\n上面提供的JNI方法中涉及到了JNI日志打印（“\\__android_log_print”）\n\n~~~ C++\n__android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey value is %s\",  jstringTostring(env,publicKey2_str));\n~~~\n\n- 该方法第一个参数以日志级别，有：ANDROID_LOG_INFO，ANDROID_LOG_DEBUG和ANDROID_LOG_ERROR\n- 第二个参数设置过滤的标签，可以在LogCat视图中过滤。\n- 后面参数是具体的日志内容\n\njstringTostring是将jstring转换成char*的方法：\n\n~~~ C++\nchar* jstringTostring(JNIEnv* env, jstring jstr)\n{\n\tchar* rtn = NULL;\n  jclass clsstring = env->FindClass(\"java/lang/String\");\n  jstring strencode = env->NewStringUTF(\"utf-8\");\n  jmethodID mid = env->GetMethodID(clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\");\n  jbyteArray barr= (jbyteArray)env->CallObjectMethod(jstr, mid, strencode);\n  jsize alen = env->GetArrayLength(barr);\n  jbyte* ba = env->GetByteArrayElements(barr, JNI_FALSE);\n  if (alen > 0)\n  {\n  rtn = (char*)malloc(alen + 1);\n\n  memcpy(rtn, ba, alen);\n  rtn[alen] = 0;\n  }\n  env->ReleaseByteArrayElements(barr, ba, 0);\n  return rtn;\n}\n~~~\n\njstring是Java提供的一个本地类型（Native Type），对应Java语言中的string类型\n\n想了解JNI其他数据类型的，请看这里\n[JNI学习积累之二 ---- 数据类型映射、域描述符说明](http://blog.csdn.net/qinjuning/article/details/7599796)\n\n要使用JNI日志打印还需要：\n\n- 1.导入.h文件及定义宏\n在输出日志的.c文件中加入:\n\n~~~ C++\n#include <android/log.h>\n\n#define LOG_TAG   \"From JNI ===>>\"\n~~~\n\n- 2.在Android.mk中引用日志库\n加入下面这行代码:\n\n~~~ C++\nLOCAL_LDLIBS   := -lm -llog -ljnigraphics\n~~~\n\n具体学习可以移步这两篇文章：\n\n[JNI的native代码中打印日志到eclipse的logcat中](http://www.cnblogs.com/liuling/p/2015-8-5-1.html)\n\n[JNI中使用LOGCAT 进行Debug](http://blog.csdn.net/llwdslal/article/details/31733035)\n\n#### 2.2 完整代码\n\n下面是我修改后的完整代码\n\n~~~ C++\njstring getPublicKey(JNIEnv* env, jobject thiz,jobject context) {\n\tjclass context_cls = env->GetObjectClass(context);\n\n\tjmethodID get_package_manager_mid = env->GetMethodID(context_cls,\n\t\t\t\"getPackageManager\", \"()Landroid/content/pm/PackageManager;\");\n\n\tjmethodID get_package_name_mid = env->GetMethodID(context_cls,\n\t\t\t\"getPackageName\", \"()Ljava/lang/String;\");\n\tenv->DeleteLocalRef(context_cls);\n\tjobject pm_obj = env->CallObjectMethod(context, get_package_manager_mid);\n\tjclass pm_cls = env->FindClass(\"android/content/pm/PackageManager\");\n\n\tjmethodID get_package_info_mid = env->GetMethodID(pm_cls, \"getPackageInfo\",\n\t\t\t\"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\");\n\tjstring package_name = reinterpret_cast<jstring>(env->CallObjectMethod(\n\t\t\tcontext, get_package_name_mid));\n\tjfieldID flag_fid = env->GetStaticFieldID(pm_cls, \"GET_SIGNATURES\", \"I\");\n\tjint flag = env->GetStaticIntField(pm_cls, flag_fid);\n\tenv->DeleteLocalRef(pm_cls);\n\tjobject pi_obj = env->CallObjectMethod(pm_obj, get_package_info_mid,\n\t\t\tpackage_name, flag);\n\tenv->DeleteLocalRef(package_name);\n\n\tjclass pi_cls = env->FindClass(\"android/content/pm/PackageInfo\");\n\tjfieldID signatures_fid = env->GetFieldID(pi_cls, \"signatures\",\n\t\t\t\"[Landroid/content/pm/Signature;\");\n\tenv->DeleteLocalRef(pi_cls);\n\tjobject sig_obj = env->GetObjectField(pi_obj, signatures_fid);\n\tenv->DeleteLocalRef(pi_obj);\n\n\tjobjectArray sigs = reinterpret_cast<jobjectArray>(sig_obj);\n\n\tjclass signature_cls = env->FindClass(\"android/content/pm/Signature\");\n\tjmethodID to_byte_array_mid = env->GetMethodID(signature_cls, \"toByteArray\",\n\t\t\t\"()[B\");\n\n\tjbyteArray sig_bytes = reinterpret_cast<jbyteArray>(env->CallObjectMethod(\n\t\t\tenv->GetObjectArrayElement(sigs, 0), to_byte_array_mid));\n\tjclass certificate_factory_cls = env->FindClass(\n\t\t\t\"java/security/cert/CertificateFactory\");\n\tjmethodID get_certificate_instance_mid = env->GetStaticMethodID(\n\t\t\tcertificate_factory_cls, \"getInstance\",\n\t\t\t\"(Ljava/lang/String;)Ljava/security/cert/CertificateFactory;\");\n\n\tjobject certificate_factory_obj = env->CallStaticObjectMethod(\n\t\t\tcertificate_factory_cls, get_certificate_instance_mid,\n\t\t\tenv->NewStringUTF(\"X509\"));\n\tjmethodID generate_certificate_mid = env->GetMethodID(\n\t\t\tcertificate_factory_cls, \"generateCertificate\",\n\t\t\t\"(Ljava/io/InputStream;)Ljava/security/cert/Certificate;\");\n\tenv->DeleteLocalRef(certificate_factory_cls);\n\n\tjclass certificate_cls = env->FindClass(\"java/security/cert/Certificate\");\n\tjclass byte_input_stream_cls = env->FindClass(\n\t\t\t\"java/io/ByteArrayInputStream\");\n\tjmethodID new_sig_bytes_is_mid = env->GetMethodID(byte_input_stream_cls,\n\t\t\t\"<init>\", \"([B)V\");\n\tjobject sig_bytes_is = env->NewObject(byte_input_stream_cls,\n\t\t\tnew_sig_bytes_is_mid, sig_bytes);\n\tenv->DeleteLocalRef(sig_bytes);\n\tenv->DeleteLocalRef(byte_input_stream_cls);\n\tjobject cert = env->CallObjectMethod(certificate_factory_obj,\n\t\t\tgenerate_certificate_mid, sig_bytes_is);\n\tenv->DeleteLocalRef(sig_bytes_is);\n\tenv->DeleteLocalRef(certificate_factory_obj);\n\tjmethodID get_pubic_key_mid = env->GetMethodID(certificate_cls,\n\t\t\t\"getPublicKey\", \"()Ljava/security/PublicKey;\");\n\tenv->DeleteLocalRef(certificate_cls);\n\n\tjobject publicKey  = env->CallObjectMethod(cert, get_pubic_key_mid);\n\tjclass publicKey_cls = env->GetObjectClass(publicKey);\n\tjmethodID toString_mid = env->GetMethodID(publicKey_cls,\"toString\", \"()Ljava/lang/String;\");\n\tjstring publicKey_str = static_cast<jstring>(env->CallObjectMethod(publicKey,toString_mid));\n\tenv->DeleteLocalRef(cert);\n\tenv->DeleteLocalRef(publicKey_cls);\n\tenv->DeleteLocalRef(publicKey);\n\n\n\tjclass string_cls = env->GetObjectClass(publicKey_str);\n\tjmethodID indexOf_mid = env->GetMethodID(string_cls,\"indexOf\", \"(Ljava/lang/String;)I\");\n\tjstring param = env->NewStringUTF(\"modulus\");\n\tjint aa = env->CallIntMethod(publicKey_str,indexOf_mid,param);\n\tjstring param2 = env->NewStringUTF(\"publicExponent\");\n\n\tjmethodID substring_mid = env->GetMethodID(string_cls,\"substring\", \"(II)Ljava/lang/String;\");\n\n\t__android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey String is %s\", jstringTostring(env,publicKey_str));\n\n\tjint bb = env->CallIntMethod(publicKey_str,indexOf_mid,param2);\n\tjstring publicKey2_str =NULL;\n\tif (bb ==-1){\n\t\tjstring param3 = env->NewStringUTF(\"public exponent\");\n\t\tjint cc = env->CallIntMethod(publicKey_str,indexOf_mid,param3);\n\t\t__android_log_print(ANDROID_LOG_ERROR, TAG, \"CC value is %d\", cc);\n\t\tpublicKey2_str= static_cast<jstring>(env->CallObjectMethod(publicKey_str,substring_mid,aa+8,cc-1));\n\t}else {\n\t\tpublicKey2_str = static_cast<jstring>(env->CallObjectMethod(publicKey_str,substring_mid,aa+8,bb-1));\n\t}\n\n\t__android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey value is %s\",  jstringTostring(env,publicKey2_str));\n\treturn publicKey2_str;\n}\n~~~\n\n\n### 3.附赠版本兼容的方法问题（随时更新）\n\n低于Jellybean版本报如下错误：\n\n    01-20 08:53:00.141: E/AndroidRuntime(24005): java.lang.NoSuchMethodError:\n\t\tandroid.view.ViewTreeObserver.removeOnGlobalLayoutListener\n\n正确调用方式应该是：\n\n~~~ Java\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {\n\t\tViewTreeObserver.removeGlobalOnLayoutListener(this);\n}else\n\t\tViewTreeObserver.removeOnGlobalLayoutListener(this);\n~~~\n\n还有一个setBackground方法：\n\n~~~ Java\nif(Build.VERSION.SzDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n\t\tView.setBackground(new ColorDrawable(Color.parseColor(\"#CCCCCC\")));\n} else {\n\t\tView.setBackgroundColor(Color.parseColor(\"#CCCCCC\"));\n}\n~~~\n","source":"_posts/2016-09-22-JNI-get-publickey.md","raw":"---\nlayout: post\ntitle:  使用JNI获取publickey实现\ncategory: technology\ntags: Android JNI\nkeywords: JNI, publickey\nbanner: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Almond%20Branch%20in%20a%20Glass%20with%20a%20Book.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Blossoming%20Almond%20Branch%20in%20a%20Glass%20with%20a%20Book.jpg\n---\n\n\n### 1.前言\n之前写过一篇文件是关于[JNI学习和积累](http://agehua.github.io/2016/JNI-Learning)的文章。\n这篇文章主要讲在使用JNI取得Publickey过程中遇到的问题和一些总结。\n\n### 2.JNI获取Publickey实现\n在上篇文章中，最终采用的加密方法来自[github项目](https://github.com/MasonLiuChn/AndroidUltimateEncrypt)。\n\n但该项目中在4.0.4版本的手机上，取得publickey遇到兼容性问题。\n\n<!--more-->\n\n正常的Publickey字段样式是这样的：\n\n~~~ Java\nOpenSSLRSAPublicKey{modulus=a0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb26a73305eea631ab18ec3ce746eb253e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9480cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a312c73cf0b98e0ce9a8cf6a682fa,publicExponent=10001}\n~~~\n\n但是某些低版本手机上（我遇到的是三星GT-S7568 Android版本4.0.4）的Publickey字段样式是：\n\n~~~ Java\nRSA Public Key\n      modulus: a0d169cedabdaac3527c2099eeaca0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb6a73305eea631ab18ec3ce746eb23e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9410cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a313c73cf0b98e0ce9a8cf6a682aff0b98e0ce9a8cf6a682fa\n      public exponent: 10001\n~~~\n第一个字段modulus是一致的，第二个字段一个是“**publicExponent**”，另一个是“**public exponent**”。\n\n所以我在代码中的处理是这样的\n\n~~~ C++\njmethodID substring_mid = env->GetMethodID(string_cls,\"substring\", \"(II)Ljava/lang/String;\");\njmethodID indexOf_mid = env->GetMethodID(string_cls,\"indexOf\", \"(Ljava/lang/String;)I\");\n\njint bb = env->CallIntMethod(publicKey_str,indexOf_mid,param2);\njstring publicKey2_str =NULL;\nif (bb ==-1){\n\tjstring param3 = env->NewStringUTF(\"public exponent\");\n\tjint cc = env->CallIntMethod(publicKey_str,indexOf_mid,param3);\n\t__android_log_print(ANDROID_LOG_ERROR, TAG, \"CC value is %d\", cc);\n\tpublicKey2_str= static_cast<jstring>(env->CallObjectMethod(publicKey_str,substring_mid,aa+8,cc-1));\n}else {\n\tpublicKey2_str = static_cast<jstring>(env->CallObjectMethod(publicKey_str,substring_mid,aa+8,bb-1));\n}\n~~~\n\n#### 2.1 在JNI native代码中打印日志\n\n上面提供的JNI方法中涉及到了JNI日志打印（“\\__android_log_print”）\n\n~~~ C++\n__android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey value is %s\",  jstringTostring(env,publicKey2_str));\n~~~\n\n- 该方法第一个参数以日志级别，有：ANDROID_LOG_INFO，ANDROID_LOG_DEBUG和ANDROID_LOG_ERROR\n- 第二个参数设置过滤的标签，可以在LogCat视图中过滤。\n- 后面参数是具体的日志内容\n\njstringTostring是将jstring转换成char*的方法：\n\n~~~ C++\nchar* jstringTostring(JNIEnv* env, jstring jstr)\n{\n\tchar* rtn = NULL;\n  jclass clsstring = env->FindClass(\"java/lang/String\");\n  jstring strencode = env->NewStringUTF(\"utf-8\");\n  jmethodID mid = env->GetMethodID(clsstring, \"getBytes\", \"(Ljava/lang/String;)[B\");\n  jbyteArray barr= (jbyteArray)env->CallObjectMethod(jstr, mid, strencode);\n  jsize alen = env->GetArrayLength(barr);\n  jbyte* ba = env->GetByteArrayElements(barr, JNI_FALSE);\n  if (alen > 0)\n  {\n  rtn = (char*)malloc(alen + 1);\n\n  memcpy(rtn, ba, alen);\n  rtn[alen] = 0;\n  }\n  env->ReleaseByteArrayElements(barr, ba, 0);\n  return rtn;\n}\n~~~\n\njstring是Java提供的一个本地类型（Native Type），对应Java语言中的string类型\n\n想了解JNI其他数据类型的，请看这里\n[JNI学习积累之二 ---- 数据类型映射、域描述符说明](http://blog.csdn.net/qinjuning/article/details/7599796)\n\n要使用JNI日志打印还需要：\n\n- 1.导入.h文件及定义宏\n在输出日志的.c文件中加入:\n\n~~~ C++\n#include <android/log.h>\n\n#define LOG_TAG   \"From JNI ===>>\"\n~~~\n\n- 2.在Android.mk中引用日志库\n加入下面这行代码:\n\n~~~ C++\nLOCAL_LDLIBS   := -lm -llog -ljnigraphics\n~~~\n\n具体学习可以移步这两篇文章：\n\n[JNI的native代码中打印日志到eclipse的logcat中](http://www.cnblogs.com/liuling/p/2015-8-5-1.html)\n\n[JNI中使用LOGCAT 进行Debug](http://blog.csdn.net/llwdslal/article/details/31733035)\n\n#### 2.2 完整代码\n\n下面是我修改后的完整代码\n\n~~~ C++\njstring getPublicKey(JNIEnv* env, jobject thiz,jobject context) {\n\tjclass context_cls = env->GetObjectClass(context);\n\n\tjmethodID get_package_manager_mid = env->GetMethodID(context_cls,\n\t\t\t\"getPackageManager\", \"()Landroid/content/pm/PackageManager;\");\n\n\tjmethodID get_package_name_mid = env->GetMethodID(context_cls,\n\t\t\t\"getPackageName\", \"()Ljava/lang/String;\");\n\tenv->DeleteLocalRef(context_cls);\n\tjobject pm_obj = env->CallObjectMethod(context, get_package_manager_mid);\n\tjclass pm_cls = env->FindClass(\"android/content/pm/PackageManager\");\n\n\tjmethodID get_package_info_mid = env->GetMethodID(pm_cls, \"getPackageInfo\",\n\t\t\t\"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\");\n\tjstring package_name = reinterpret_cast<jstring>(env->CallObjectMethod(\n\t\t\tcontext, get_package_name_mid));\n\tjfieldID flag_fid = env->GetStaticFieldID(pm_cls, \"GET_SIGNATURES\", \"I\");\n\tjint flag = env->GetStaticIntField(pm_cls, flag_fid);\n\tenv->DeleteLocalRef(pm_cls);\n\tjobject pi_obj = env->CallObjectMethod(pm_obj, get_package_info_mid,\n\t\t\tpackage_name, flag);\n\tenv->DeleteLocalRef(package_name);\n\n\tjclass pi_cls = env->FindClass(\"android/content/pm/PackageInfo\");\n\tjfieldID signatures_fid = env->GetFieldID(pi_cls, \"signatures\",\n\t\t\t\"[Landroid/content/pm/Signature;\");\n\tenv->DeleteLocalRef(pi_cls);\n\tjobject sig_obj = env->GetObjectField(pi_obj, signatures_fid);\n\tenv->DeleteLocalRef(pi_obj);\n\n\tjobjectArray sigs = reinterpret_cast<jobjectArray>(sig_obj);\n\n\tjclass signature_cls = env->FindClass(\"android/content/pm/Signature\");\n\tjmethodID to_byte_array_mid = env->GetMethodID(signature_cls, \"toByteArray\",\n\t\t\t\"()[B\");\n\n\tjbyteArray sig_bytes = reinterpret_cast<jbyteArray>(env->CallObjectMethod(\n\t\t\tenv->GetObjectArrayElement(sigs, 0), to_byte_array_mid));\n\tjclass certificate_factory_cls = env->FindClass(\n\t\t\t\"java/security/cert/CertificateFactory\");\n\tjmethodID get_certificate_instance_mid = env->GetStaticMethodID(\n\t\t\tcertificate_factory_cls, \"getInstance\",\n\t\t\t\"(Ljava/lang/String;)Ljava/security/cert/CertificateFactory;\");\n\n\tjobject certificate_factory_obj = env->CallStaticObjectMethod(\n\t\t\tcertificate_factory_cls, get_certificate_instance_mid,\n\t\t\tenv->NewStringUTF(\"X509\"));\n\tjmethodID generate_certificate_mid = env->GetMethodID(\n\t\t\tcertificate_factory_cls, \"generateCertificate\",\n\t\t\t\"(Ljava/io/InputStream;)Ljava/security/cert/Certificate;\");\n\tenv->DeleteLocalRef(certificate_factory_cls);\n\n\tjclass certificate_cls = env->FindClass(\"java/security/cert/Certificate\");\n\tjclass byte_input_stream_cls = env->FindClass(\n\t\t\t\"java/io/ByteArrayInputStream\");\n\tjmethodID new_sig_bytes_is_mid = env->GetMethodID(byte_input_stream_cls,\n\t\t\t\"<init>\", \"([B)V\");\n\tjobject sig_bytes_is = env->NewObject(byte_input_stream_cls,\n\t\t\tnew_sig_bytes_is_mid, sig_bytes);\n\tenv->DeleteLocalRef(sig_bytes);\n\tenv->DeleteLocalRef(byte_input_stream_cls);\n\tjobject cert = env->CallObjectMethod(certificate_factory_obj,\n\t\t\tgenerate_certificate_mid, sig_bytes_is);\n\tenv->DeleteLocalRef(sig_bytes_is);\n\tenv->DeleteLocalRef(certificate_factory_obj);\n\tjmethodID get_pubic_key_mid = env->GetMethodID(certificate_cls,\n\t\t\t\"getPublicKey\", \"()Ljava/security/PublicKey;\");\n\tenv->DeleteLocalRef(certificate_cls);\n\n\tjobject publicKey  = env->CallObjectMethod(cert, get_pubic_key_mid);\n\tjclass publicKey_cls = env->GetObjectClass(publicKey);\n\tjmethodID toString_mid = env->GetMethodID(publicKey_cls,\"toString\", \"()Ljava/lang/String;\");\n\tjstring publicKey_str = static_cast<jstring>(env->CallObjectMethod(publicKey,toString_mid));\n\tenv->DeleteLocalRef(cert);\n\tenv->DeleteLocalRef(publicKey_cls);\n\tenv->DeleteLocalRef(publicKey);\n\n\n\tjclass string_cls = env->GetObjectClass(publicKey_str);\n\tjmethodID indexOf_mid = env->GetMethodID(string_cls,\"indexOf\", \"(Ljava/lang/String;)I\");\n\tjstring param = env->NewStringUTF(\"modulus\");\n\tjint aa = env->CallIntMethod(publicKey_str,indexOf_mid,param);\n\tjstring param2 = env->NewStringUTF(\"publicExponent\");\n\n\tjmethodID substring_mid = env->GetMethodID(string_cls,\"substring\", \"(II)Ljava/lang/String;\");\n\n\t__android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey String is %s\", jstringTostring(env,publicKey_str));\n\n\tjint bb = env->CallIntMethod(publicKey_str,indexOf_mid,param2);\n\tjstring publicKey2_str =NULL;\n\tif (bb ==-1){\n\t\tjstring param3 = env->NewStringUTF(\"public exponent\");\n\t\tjint cc = env->CallIntMethod(publicKey_str,indexOf_mid,param3);\n\t\t__android_log_print(ANDROID_LOG_ERROR, TAG, \"CC value is %d\", cc);\n\t\tpublicKey2_str= static_cast<jstring>(env->CallObjectMethod(publicKey_str,substring_mid,aa+8,cc-1));\n\t}else {\n\t\tpublicKey2_str = static_cast<jstring>(env->CallObjectMethod(publicKey_str,substring_mid,aa+8,bb-1));\n\t}\n\n\t__android_log_print(ANDROID_LOG_ERROR, TAG, \"PublicKey value is %s\",  jstringTostring(env,publicKey2_str));\n\treturn publicKey2_str;\n}\n~~~\n\n\n### 3.附赠版本兼容的方法问题（随时更新）\n\n低于Jellybean版本报如下错误：\n\n    01-20 08:53:00.141: E/AndroidRuntime(24005): java.lang.NoSuchMethodError:\n\t\tandroid.view.ViewTreeObserver.removeOnGlobalLayoutListener\n\n正确调用方式应该是：\n\n~~~ Java\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {\n\t\tViewTreeObserver.removeGlobalOnLayoutListener(this);\n}else\n\t\tViewTreeObserver.removeOnGlobalLayoutListener(this);\n~~~\n\n还有一个setBackground方法：\n\n~~~ Java\nif(Build.VERSION.SzDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n\t\tView.setBackground(new ColorDrawable(Color.parseColor(\"#CCCCCC\")));\n} else {\n\t\tView.setBackgroundColor(Color.parseColor(\"#CCCCCC\"));\n}\n~~~\n","slug":"JNI-get-publickey","published":1,"date":"2016-09-21T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5f001qbxs670lmwfes","content":"<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>之前写过一篇文件是关于<a href=\"http://agehua.github.io/2016/JNI-Learning\">JNI学习和积累</a>的文章。<br>这篇文章主要讲在使用JNI取得Publickey过程中遇到的问题和一些总结。</p>\n<h3 id=\"2-JNI获取Publickey实现\"><a href=\"#2-JNI获取Publickey实现\" class=\"headerlink\" title=\"2.JNI获取Publickey实现\"></a>2.JNI获取Publickey实现</h3><p>在上篇文章中，最终采用的加密方法来自<a href=\"https://github.com/MasonLiuChn/AndroidUltimateEncrypt\" target=\"_blank\" rel=\"external\">github项目</a>。</p>\n<p>但该项目中在4.0.4版本的手机上，取得publickey遇到兼容性问题。</p>\n<a id=\"more\"></a>\n<p>正常的Publickey字段样式是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">OpenSSLRSAPublicKey&#123;modulus=a0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb26a73305eea631ab18ec3ce746eb253e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9480cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a312c73cf0b98e0ce9a8cf6a682fa,publicExponent=<span class=\"number\">10001</span>&#125;</div></pre></td></tr></table></figure>\n<p>但是某些低版本手机上（我遇到的是三星GT-S7568 Android版本4.0.4）的Publickey字段样式是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">RSA Public Key</div><div class=\"line\">      modulus: a0d169cedabdaac3527c2099eeaca0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb6a73305eea631ab18ec3ce746eb23e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9410cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a313c73cf0b98e0ce9a8cf6a682aff0b98e0ce9a8cf6a682fa</div><div class=\"line\">      <span class=\"keyword\">public</span> exponent: <span class=\"number\">10001</span></div></pre></td></tr></table></figure>\n<p>第一个字段modulus是一致的，第二个字段一个是“<strong>publicExponent</strong>”，另一个是“<strong>public exponent</strong>”。</p>\n<p>所以我在代码中的处理是这样的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">jmethodID substring_mid = env-&gt;GetMethodID(string_cls,<span class=\"string\">\"substring\"</span>, <span class=\"string\">\"(II)Ljava/lang/String;\"</span>);</div><div class=\"line\">jmethodID indexOf_mid = env-&gt;GetMethodID(string_cls,<span class=\"string\">\"indexOf\"</span>, <span class=\"string\">\"(Ljava/lang/String;)I\"</span>);</div><div class=\"line\"></div><div class=\"line\">jint bb = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param2);</div><div class=\"line\">jstring publicKey2_str =<span class=\"literal\">NULL</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (bb ==<span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\tjstring param3 = env-&gt;NewStringUTF(<span class=\"string\">\"public exponent\"</span>);</div><div class=\"line\">\tjint cc = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param3);</div><div class=\"line\">\t__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"CC value is %d\"</span>, cc);</div><div class=\"line\">\tpublicKey2_str= <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+<span class=\"number\">8</span>,cc<span class=\"number\">-1</span>));</div><div class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\tpublicKey2_str = <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+<span class=\"number\">8</span>,bb<span class=\"number\">-1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-1-在JNI-native代码中打印日志\"><a href=\"#2-1-在JNI-native代码中打印日志\" class=\"headerlink\" title=\"2.1 在JNI native代码中打印日志\"></a>2.1 在JNI native代码中打印日志</h4><p>上面提供的JNI方法中涉及到了JNI日志打印（“__android_log_print”）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"PublicKey value is %s\"</span>,  jstringTostring(env,publicKey2_str));</div></pre></td></tr></table></figure>\n<ul>\n<li>该方法第一个参数以日志级别，有：ANDROID_LOG_INFO，ANDROID_LOG_DEBUG和ANDROID_LOG_ERROR</li>\n<li>第二个参数设置过滤的标签，可以在LogCat视图中过滤。</li>\n<li>后面参数是具体的日志内容</li>\n</ul>\n<p>jstringTostring是将jstring转换成char*的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">jstringTostring</span><span class=\"params\">(JNIEnv* env, jstring jstr)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span>* rtn = <span class=\"literal\">NULL</span>;</div><div class=\"line\">  jclass clsstring = env-&gt;FindClass(<span class=\"string\">\"java/lang/String\"</span>);</div><div class=\"line\">  jstring strencode = env-&gt;NewStringUTF(<span class=\"string\">\"utf-8\"</span>);</div><div class=\"line\">  jmethodID mid = env-&gt;GetMethodID(clsstring, <span class=\"string\">\"getBytes\"</span>, <span class=\"string\">\"(Ljava/lang/String;)[B\"</span>);</div><div class=\"line\">  jbyteArray barr= (jbyteArray)env-&gt;CallObjectMethod(jstr, mid, strencode);</div><div class=\"line\">  jsize alen = env-&gt;GetArrayLength(barr);</div><div class=\"line\">  jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE);</div><div class=\"line\">  <span class=\"keyword\">if</span> (alen &gt; <span class=\"number\">0</span>)</div><div class=\"line\">  &#123;</div><div class=\"line\">  rtn = (<span class=\"keyword\">char</span>*)<span class=\"built_in\">malloc</span>(alen + <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">memcpy</span>(rtn, ba, alen);</div><div class=\"line\">  rtn[alen] = <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  env-&gt;ReleaseByteArrayElements(barr, ba, <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> rtn;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>jstring是Java提供的一个本地类型（Native Type），对应Java语言中的string类型</p>\n<p>想了解JNI其他数据类型的，请看这里<br><a href=\"http://blog.csdn.net/qinjuning/article/details/7599796\" target=\"_blank\" rel=\"external\">JNI学习积累之二 —- 数据类型映射、域描述符说明</a></p>\n<p>要使用JNI日志打印还需要：</p>\n<ul>\n<li>1.导入.h文件及定义宏<br>在输出日志的.c文件中加入:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;android/log.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOG_TAG   <span class=\"meta-string\">\"From JNI ===&gt;&gt;\"</span></span></div></pre></td></tr></table></figure>\n<ul>\n<li>2.在Android.mk中引用日志库<br>加入下面这行代码:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">LOCAL_LDLIBS   := -lm -llog -ljnigraphics</div></pre></td></tr></table></figure>\n<p>具体学习可以移步这两篇文章：</p>\n<p><a href=\"http://www.cnblogs.com/liuling/p/2015-8-5-1.html\" target=\"_blank\" rel=\"external\">JNI的native代码中打印日志到eclipse的logcat中</a></p>\n<p><a href=\"http://blog.csdn.net/llwdslal/article/details/31733035\" target=\"_blank\" rel=\"external\">JNI中使用LOGCAT 进行Debug</a></p>\n<h4 id=\"2-2-完整代码\"><a href=\"#2-2-完整代码\" class=\"headerlink\" title=\"2.2 完整代码\"></a>2.2 完整代码</h4><p>下面是我修改后的完整代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">jstring <span class=\"title\">getPublicKey</span><span class=\"params\">(JNIEnv* env, jobject thiz,jobject context)</span> </span>&#123;</div><div class=\"line\">\tjclass context_cls = env-&gt;GetObjectClass(context);</div><div class=\"line\"></div><div class=\"line\">\tjmethodID get_package_manager_mid = env-&gt;GetMethodID(context_cls,</div><div class=\"line\">\t\t\t<span class=\"string\">\"getPackageManager\"</span>, <span class=\"string\">\"()Landroid/content/pm/PackageManager;\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjmethodID get_package_name_mid = env-&gt;GetMethodID(context_cls,</div><div class=\"line\">\t\t\t<span class=\"string\">\"getPackageName\"</span>, <span class=\"string\">\"()Ljava/lang/String;\"</span>);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(context_cls);</div><div class=\"line\">\tjobject pm_obj = env-&gt;CallObjectMethod(context, get_package_manager_mid);</div><div class=\"line\">\tjclass pm_cls = env-&gt;FindClass(<span class=\"string\">\"android/content/pm/PackageManager\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjmethodID get_package_info_mid = env-&gt;GetMethodID(pm_cls, <span class=\"string\">\"getPackageInfo\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\"</span>);</div><div class=\"line\">\tjstring package_name = <span class=\"keyword\">reinterpret_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(</div><div class=\"line\">\t\t\tcontext, get_package_name_mid));</div><div class=\"line\">\tjfieldID flag_fid = env-&gt;GetStaticFieldID(pm_cls, <span class=\"string\">\"GET_SIGNATURES\"</span>, <span class=\"string\">\"I\"</span>);</div><div class=\"line\">\tjint flag = env-&gt;GetStaticIntField(pm_cls, flag_fid);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(pm_cls);</div><div class=\"line\">\tjobject pi_obj = env-&gt;CallObjectMethod(pm_obj, get_package_info_mid,</div><div class=\"line\">\t\t\tpackage_name, flag);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(package_name);</div><div class=\"line\"></div><div class=\"line\">\tjclass pi_cls = env-&gt;FindClass(<span class=\"string\">\"android/content/pm/PackageInfo\"</span>);</div><div class=\"line\">\tjfieldID signatures_fid = env-&gt;GetFieldID(pi_cls, <span class=\"string\">\"signatures\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"[Landroid/content/pm/Signature;\"</span>);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(pi_cls);</div><div class=\"line\">\tjobject sig_obj = env-&gt;GetObjectField(pi_obj, signatures_fid);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(pi_obj);</div><div class=\"line\"></div><div class=\"line\">\tjobjectArray sigs = <span class=\"keyword\">reinterpret_cast</span>&lt;jobjectArray&gt;(sig_obj);</div><div class=\"line\"></div><div class=\"line\">\tjclass signature_cls = env-&gt;FindClass(<span class=\"string\">\"android/content/pm/Signature\"</span>);</div><div class=\"line\">\tjmethodID to_byte_array_mid = env-&gt;GetMethodID(signature_cls, <span class=\"string\">\"toByteArray\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"()[B\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjbyteArray sig_bytes = <span class=\"keyword\">reinterpret_cast</span>&lt;jbyteArray&gt;(env-&gt;CallObjectMethod(</div><div class=\"line\">\t\t\tenv-&gt;GetObjectArrayElement(sigs, <span class=\"number\">0</span>), to_byte_array_mid));</div><div class=\"line\">\tjclass certificate_factory_cls = env-&gt;FindClass(</div><div class=\"line\">\t\t\t<span class=\"string\">\"java/security/cert/CertificateFactory\"</span>);</div><div class=\"line\">\tjmethodID get_certificate_instance_mid = env-&gt;GetStaticMethodID(</div><div class=\"line\">\t\t\tcertificate_factory_cls, <span class=\"string\">\"getInstance\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"(Ljava/lang/String;)Ljava/security/cert/CertificateFactory;\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjobject certificate_factory_obj = env-&gt;CallStaticObjectMethod(</div><div class=\"line\">\t\t\tcertificate_factory_cls, get_certificate_instance_mid,</div><div class=\"line\">\t\t\tenv-&gt;NewStringUTF(<span class=\"string\">\"X509\"</span>));</div><div class=\"line\">\tjmethodID generate_certificate_mid = env-&gt;GetMethodID(</div><div class=\"line\">\t\t\tcertificate_factory_cls, <span class=\"string\">\"generateCertificate\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"(Ljava/io/InputStream;)Ljava/security/cert/Certificate;\"</span>);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(certificate_factory_cls);</div><div class=\"line\"></div><div class=\"line\">\tjclass certificate_cls = env-&gt;FindClass(<span class=\"string\">\"java/security/cert/Certificate\"</span>);</div><div class=\"line\">\tjclass byte_input_stream_cls = env-&gt;FindClass(</div><div class=\"line\">\t\t\t<span class=\"string\">\"java/io/ByteArrayInputStream\"</span>);</div><div class=\"line\">\tjmethodID new_sig_bytes_is_mid = env-&gt;GetMethodID(byte_input_stream_cls,</div><div class=\"line\">\t\t\t<span class=\"string\">\"&lt;init&gt;\"</span>, <span class=\"string\">\"([B)V\"</span>);</div><div class=\"line\">\tjobject sig_bytes_is = env-&gt;NewObject(byte_input_stream_cls,</div><div class=\"line\">\t\t\tnew_sig_bytes_is_mid, sig_bytes);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(sig_bytes);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(byte_input_stream_cls);</div><div class=\"line\">\tjobject cert = env-&gt;CallObjectMethod(certificate_factory_obj,</div><div class=\"line\">\t\t\tgenerate_certificate_mid, sig_bytes_is);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(sig_bytes_is);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(certificate_factory_obj);</div><div class=\"line\">\tjmethodID get_pubic_key_mid = env-&gt;GetMethodID(certificate_cls,</div><div class=\"line\">\t\t\t<span class=\"string\">\"getPublicKey\"</span>, <span class=\"string\">\"()Ljava/security/PublicKey;\"</span>);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(certificate_cls);</div><div class=\"line\"></div><div class=\"line\">\tjobject publicKey  = env-&gt;CallObjectMethod(cert, get_pubic_key_mid);</div><div class=\"line\">\tjclass publicKey_cls = env-&gt;GetObjectClass(publicKey);</div><div class=\"line\">\tjmethodID toString_mid = env-&gt;GetMethodID(publicKey_cls,<span class=\"string\">\"toString\"</span>, <span class=\"string\">\"()Ljava/lang/String;\"</span>);</div><div class=\"line\">\tjstring publicKey_str = <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey,toString_mid));</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(cert);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(publicKey_cls);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(publicKey);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tjclass string_cls = env-&gt;GetObjectClass(publicKey_str);</div><div class=\"line\">\tjmethodID indexOf_mid = env-&gt;GetMethodID(string_cls,<span class=\"string\">\"indexOf\"</span>, <span class=\"string\">\"(Ljava/lang/String;)I\"</span>);</div><div class=\"line\">\tjstring param = env-&gt;NewStringUTF(<span class=\"string\">\"modulus\"</span>);</div><div class=\"line\">\tjint aa = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param);</div><div class=\"line\">\tjstring param2 = env-&gt;NewStringUTF(<span class=\"string\">\"publicExponent\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjmethodID substring_mid = env-&gt;GetMethodID(string_cls,<span class=\"string\">\"substring\"</span>, <span class=\"string\">\"(II)Ljava/lang/String;\"</span>);</div><div class=\"line\"></div><div class=\"line\">\t__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"PublicKey String is %s\"</span>, jstringTostring(env,publicKey_str));</div><div class=\"line\"></div><div class=\"line\">\tjint bb = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param2);</div><div class=\"line\">\tjstring publicKey2_str =<span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (bb ==<span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\t\tjstring param3 = env-&gt;NewStringUTF(<span class=\"string\">\"public exponent\"</span>);</div><div class=\"line\">\t\tjint cc = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param3);</div><div class=\"line\">\t\t__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"CC value is %d\"</span>, cc);</div><div class=\"line\">\t\tpublicKey2_str= <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+<span class=\"number\">8</span>,cc<span class=\"number\">-1</span>));</div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\tpublicKey2_str = <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+<span class=\"number\">8</span>,bb<span class=\"number\">-1</span>));</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"PublicKey value is %s\"</span>,  jstringTostring(env,publicKey2_str));</div><div class=\"line\">\t<span class=\"keyword\">return</span> publicKey2_str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-附赠版本兼容的方法问题（随时更新）\"><a href=\"#3-附赠版本兼容的方法问题（随时更新）\" class=\"headerlink\" title=\"3.附赠版本兼容的方法问题（随时更新）\"></a>3.附赠版本兼容的方法问题（随时更新）</h3><p>低于Jellybean版本报如下错误：</p>\n<pre><code>01-20 08:53:00.141: E/AndroidRuntime(24005): java.lang.NoSuchMethodError:\n    android.view.ViewTreeObserver.removeOnGlobalLayoutListener\n</code></pre><p>正确调用方式应该是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class=\"line\">\t\tViewTreeObserver.removeGlobalOnLayoutListener(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;<span class=\"keyword\">else</span></div><div class=\"line\">\t\tViewTreeObserver.removeOnGlobalLayoutListener(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>还有一个setBackground方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(Build.VERSION.SzDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class=\"line\">\t\tView.setBackground(<span class=\"keyword\">new</span> ColorDrawable(Color.parseColor(<span class=\"string\">\"#CCCCCC\"</span>)));</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\tView.setBackgroundColor(Color.parseColor(<span class=\"string\">\"#CCCCCC\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h3><p>之前写过一篇文件是关于<a href=\"http://agehua.github.io/2016/JNI-Learning\">JNI学习和积累</a>的文章。<br>这篇文章主要讲在使用JNI取得Publickey过程中遇到的问题和一些总结。</p>\n<h3 id=\"2-JNI获取Publickey实现\"><a href=\"#2-JNI获取Publickey实现\" class=\"headerlink\" title=\"2.JNI获取Publickey实现\"></a>2.JNI获取Publickey实现</h3><p>在上篇文章中，最终采用的加密方法来自<a href=\"https://github.com/MasonLiuChn/AndroidUltimateEncrypt\">github项目</a>。</p>\n<p>但该项目中在4.0.4版本的手机上，取得publickey遇到兼容性问题。</p>","more":"<p>正常的Publickey字段样式是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">OpenSSLRSAPublicKey&#123;modulus=a0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb26a73305eea631ab18ec3ce746eb253e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9480cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a312c73cf0b98e0ce9a8cf6a682fa,publicExponent=<span class=\"number\">10001</span>&#125;</div></pre></td></tr></table></figure>\n<p>但是某些低版本手机上（我遇到的是三星GT-S7568 Android版本4.0.4）的Publickey字段样式是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">RSA Public Key</div><div class=\"line\">      modulus: a0d169cedabdaac3527c2099eeaca0d169cedabdaac3527c2099eeac4cbd74bb9b14c2571bcf6755f49e1d8c8439a37e009b0cb1b1ae9bf164dc976ddc4ee050621c746610d995185accbe8b3c09cc4f8c7afd990db47be814f7f45ec9c489be5b0933e89ff58070c29c98199331160bdb3a19e0687d36e850ee686c565737be4f61328264a58792e198d873b023ec11cb6a73305eea631ab18ec3ce746eb23e47c145503e933ee5da892326ecbb29b5a005aacef2d30d720611f7014aa3f2e40954b9e4deeaca1823dd2f7b2230670acabda70d2f14b1adc9410cf0a48d47866a1aa745ae97d0ab906cd76e5ab76916d03ef153b35edc2ae7284a613b3a3a313c73cf0b98e0ce9a8cf6a682aff0b98e0ce9a8cf6a682fa</div><div class=\"line\">      <span class=\"keyword\">public</span> exponent: <span class=\"number\">10001</span></div></pre></td></tr></table></figure>\n<p>第一个字段modulus是一致的，第二个字段一个是“<strong>publicExponent</strong>”，另一个是“<strong>public exponent</strong>”。</p>\n<p>所以我在代码中的处理是这样的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">jmethodID substring_mid = env-&gt;GetMethodID(string_cls,<span class=\"string\">\"substring\"</span>, <span class=\"string\">\"(II)Ljava/lang/String;\"</span>);</div><div class=\"line\">jmethodID indexOf_mid = env-&gt;GetMethodID(string_cls,<span class=\"string\">\"indexOf\"</span>, <span class=\"string\">\"(Ljava/lang/String;)I\"</span>);</div><div class=\"line\"></div><div class=\"line\">jint bb = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param2);</div><div class=\"line\">jstring publicKey2_str =<span class=\"literal\">NULL</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (bb ==<span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\tjstring param3 = env-&gt;NewStringUTF(<span class=\"string\">\"public exponent\"</span>);</div><div class=\"line\">\tjint cc = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param3);</div><div class=\"line\">\t__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"CC value is %d\"</span>, cc);</div><div class=\"line\">\tpublicKey2_str= <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+<span class=\"number\">8</span>,cc<span class=\"number\">-1</span>));</div><div class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\tpublicKey2_str = <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+<span class=\"number\">8</span>,bb<span class=\"number\">-1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-1-在JNI-native代码中打印日志\"><a href=\"#2-1-在JNI-native代码中打印日志\" class=\"headerlink\" title=\"2.1 在JNI native代码中打印日志\"></a>2.1 在JNI native代码中打印日志</h4><p>上面提供的JNI方法中涉及到了JNI日志打印（“__android_log_print”）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"PublicKey value is %s\"</span>,  jstringTostring(env,publicKey2_str));</div></pre></td></tr></table></figure>\n<ul>\n<li>该方法第一个参数以日志级别，有：ANDROID_LOG_INFO，ANDROID_LOG_DEBUG和ANDROID_LOG_ERROR</li>\n<li>第二个参数设置过滤的标签，可以在LogCat视图中过滤。</li>\n<li>后面参数是具体的日志内容</li>\n</ul>\n<p>jstringTostring是将jstring转换成char*的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">jstringTostring</span><span class=\"params\">(JNIEnv* env, jstring jstr)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span>* rtn = <span class=\"literal\">NULL</span>;</div><div class=\"line\">  jclass clsstring = env-&gt;FindClass(<span class=\"string\">\"java/lang/String\"</span>);</div><div class=\"line\">  jstring strencode = env-&gt;NewStringUTF(<span class=\"string\">\"utf-8\"</span>);</div><div class=\"line\">  jmethodID mid = env-&gt;GetMethodID(clsstring, <span class=\"string\">\"getBytes\"</span>, <span class=\"string\">\"(Ljava/lang/String;)[B\"</span>);</div><div class=\"line\">  jbyteArray barr= (jbyteArray)env-&gt;CallObjectMethod(jstr, mid, strencode);</div><div class=\"line\">  jsize alen = env-&gt;GetArrayLength(barr);</div><div class=\"line\">  jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE);</div><div class=\"line\">  <span class=\"keyword\">if</span> (alen &gt; <span class=\"number\">0</span>)</div><div class=\"line\">  &#123;</div><div class=\"line\">  rtn = (<span class=\"keyword\">char</span>*)<span class=\"built_in\">malloc</span>(alen + <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">memcpy</span>(rtn, ba, alen);</div><div class=\"line\">  rtn[alen] = <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  env-&gt;ReleaseByteArrayElements(barr, ba, <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> rtn;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>jstring是Java提供的一个本地类型（Native Type），对应Java语言中的string类型</p>\n<p>想了解JNI其他数据类型的，请看这里<br><a href=\"http://blog.csdn.net/qinjuning/article/details/7599796\">JNI学习积累之二 —- 数据类型映射、域描述符说明</a></p>\n<p>要使用JNI日志打印还需要：</p>\n<ul>\n<li>1.导入.h文件及定义宏<br>在输出日志的.c文件中加入:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;android/log.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOG_TAG   <span class=\"meta-string\">\"From JNI ===&gt;&gt;\"</span></span></div></pre></td></tr></table></figure>\n<ul>\n<li>2.在Android.mk中引用日志库<br>加入下面这行代码:</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\">LOCAL_LDLIBS   := -lm -llog -ljnigraphics</div></pre></td></tr></table></figure>\n<p>具体学习可以移步这两篇文章：</p>\n<p><a href=\"http://www.cnblogs.com/liuling/p/2015-8-5-1.html\">JNI的native代码中打印日志到eclipse的logcat中</a></p>\n<p><a href=\"http://blog.csdn.net/llwdslal/article/details/31733035\">JNI中使用LOGCAT 进行Debug</a></p>\n<h4 id=\"2-2-完整代码\"><a href=\"#2-2-完整代码\" class=\"headerlink\" title=\"2.2 完整代码\"></a>2.2 完整代码</h4><p>下面是我修改后的完整代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">jstring <span class=\"title\">getPublicKey</span><span class=\"params\">(JNIEnv* env, jobject thiz,jobject context)</span> </span>&#123;</div><div class=\"line\">\tjclass context_cls = env-&gt;GetObjectClass(context);</div><div class=\"line\"></div><div class=\"line\">\tjmethodID get_package_manager_mid = env-&gt;GetMethodID(context_cls,</div><div class=\"line\">\t\t\t<span class=\"string\">\"getPackageManager\"</span>, <span class=\"string\">\"()Landroid/content/pm/PackageManager;\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjmethodID get_package_name_mid = env-&gt;GetMethodID(context_cls,</div><div class=\"line\">\t\t\t<span class=\"string\">\"getPackageName\"</span>, <span class=\"string\">\"()Ljava/lang/String;\"</span>);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(context_cls);</div><div class=\"line\">\tjobject pm_obj = env-&gt;CallObjectMethod(context, get_package_manager_mid);</div><div class=\"line\">\tjclass pm_cls = env-&gt;FindClass(<span class=\"string\">\"android/content/pm/PackageManager\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjmethodID get_package_info_mid = env-&gt;GetMethodID(pm_cls, <span class=\"string\">\"getPackageInfo\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;\"</span>);</div><div class=\"line\">\tjstring package_name = <span class=\"keyword\">reinterpret_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(</div><div class=\"line\">\t\t\tcontext, get_package_name_mid));</div><div class=\"line\">\tjfieldID flag_fid = env-&gt;GetStaticFieldID(pm_cls, <span class=\"string\">\"GET_SIGNATURES\"</span>, <span class=\"string\">\"I\"</span>);</div><div class=\"line\">\tjint flag = env-&gt;GetStaticIntField(pm_cls, flag_fid);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(pm_cls);</div><div class=\"line\">\tjobject pi_obj = env-&gt;CallObjectMethod(pm_obj, get_package_info_mid,</div><div class=\"line\">\t\t\tpackage_name, flag);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(package_name);</div><div class=\"line\"></div><div class=\"line\">\tjclass pi_cls = env-&gt;FindClass(<span class=\"string\">\"android/content/pm/PackageInfo\"</span>);</div><div class=\"line\">\tjfieldID signatures_fid = env-&gt;GetFieldID(pi_cls, <span class=\"string\">\"signatures\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"[Landroid/content/pm/Signature;\"</span>);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(pi_cls);</div><div class=\"line\">\tjobject sig_obj = env-&gt;GetObjectField(pi_obj, signatures_fid);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(pi_obj);</div><div class=\"line\"></div><div class=\"line\">\tjobjectArray sigs = <span class=\"keyword\">reinterpret_cast</span>&lt;jobjectArray&gt;(sig_obj);</div><div class=\"line\"></div><div class=\"line\">\tjclass signature_cls = env-&gt;FindClass(<span class=\"string\">\"android/content/pm/Signature\"</span>);</div><div class=\"line\">\tjmethodID to_byte_array_mid = env-&gt;GetMethodID(signature_cls, <span class=\"string\">\"toByteArray\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"()[B\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjbyteArray sig_bytes = <span class=\"keyword\">reinterpret_cast</span>&lt;jbyteArray&gt;(env-&gt;CallObjectMethod(</div><div class=\"line\">\t\t\tenv-&gt;GetObjectArrayElement(sigs, <span class=\"number\">0</span>), to_byte_array_mid));</div><div class=\"line\">\tjclass certificate_factory_cls = env-&gt;FindClass(</div><div class=\"line\">\t\t\t<span class=\"string\">\"java/security/cert/CertificateFactory\"</span>);</div><div class=\"line\">\tjmethodID get_certificate_instance_mid = env-&gt;GetStaticMethodID(</div><div class=\"line\">\t\t\tcertificate_factory_cls, <span class=\"string\">\"getInstance\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"(Ljava/lang/String;)Ljava/security/cert/CertificateFactory;\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjobject certificate_factory_obj = env-&gt;CallStaticObjectMethod(</div><div class=\"line\">\t\t\tcertificate_factory_cls, get_certificate_instance_mid,</div><div class=\"line\">\t\t\tenv-&gt;NewStringUTF(<span class=\"string\">\"X509\"</span>));</div><div class=\"line\">\tjmethodID generate_certificate_mid = env-&gt;GetMethodID(</div><div class=\"line\">\t\t\tcertificate_factory_cls, <span class=\"string\">\"generateCertificate\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"(Ljava/io/InputStream;)Ljava/security/cert/Certificate;\"</span>);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(certificate_factory_cls);</div><div class=\"line\"></div><div class=\"line\">\tjclass certificate_cls = env-&gt;FindClass(<span class=\"string\">\"java/security/cert/Certificate\"</span>);</div><div class=\"line\">\tjclass byte_input_stream_cls = env-&gt;FindClass(</div><div class=\"line\">\t\t\t<span class=\"string\">\"java/io/ByteArrayInputStream\"</span>);</div><div class=\"line\">\tjmethodID new_sig_bytes_is_mid = env-&gt;GetMethodID(byte_input_stream_cls,</div><div class=\"line\">\t\t\t<span class=\"string\">\"&lt;init&gt;\"</span>, <span class=\"string\">\"([B)V\"</span>);</div><div class=\"line\">\tjobject sig_bytes_is = env-&gt;NewObject(byte_input_stream_cls,</div><div class=\"line\">\t\t\tnew_sig_bytes_is_mid, sig_bytes);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(sig_bytes);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(byte_input_stream_cls);</div><div class=\"line\">\tjobject cert = env-&gt;CallObjectMethod(certificate_factory_obj,</div><div class=\"line\">\t\t\tgenerate_certificate_mid, sig_bytes_is);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(sig_bytes_is);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(certificate_factory_obj);</div><div class=\"line\">\tjmethodID get_pubic_key_mid = env-&gt;GetMethodID(certificate_cls,</div><div class=\"line\">\t\t\t<span class=\"string\">\"getPublicKey\"</span>, <span class=\"string\">\"()Ljava/security/PublicKey;\"</span>);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(certificate_cls);</div><div class=\"line\"></div><div class=\"line\">\tjobject publicKey  = env-&gt;CallObjectMethod(cert, get_pubic_key_mid);</div><div class=\"line\">\tjclass publicKey_cls = env-&gt;GetObjectClass(publicKey);</div><div class=\"line\">\tjmethodID toString_mid = env-&gt;GetMethodID(publicKey_cls,<span class=\"string\">\"toString\"</span>, <span class=\"string\">\"()Ljava/lang/String;\"</span>);</div><div class=\"line\">\tjstring publicKey_str = <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey,toString_mid));</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(cert);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(publicKey_cls);</div><div class=\"line\">\tenv-&gt;DeleteLocalRef(publicKey);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tjclass string_cls = env-&gt;GetObjectClass(publicKey_str);</div><div class=\"line\">\tjmethodID indexOf_mid = env-&gt;GetMethodID(string_cls,<span class=\"string\">\"indexOf\"</span>, <span class=\"string\">\"(Ljava/lang/String;)I\"</span>);</div><div class=\"line\">\tjstring param = env-&gt;NewStringUTF(<span class=\"string\">\"modulus\"</span>);</div><div class=\"line\">\tjint aa = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param);</div><div class=\"line\">\tjstring param2 = env-&gt;NewStringUTF(<span class=\"string\">\"publicExponent\"</span>);</div><div class=\"line\"></div><div class=\"line\">\tjmethodID substring_mid = env-&gt;GetMethodID(string_cls,<span class=\"string\">\"substring\"</span>, <span class=\"string\">\"(II)Ljava/lang/String;\"</span>);</div><div class=\"line\"></div><div class=\"line\">\t__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"PublicKey String is %s\"</span>, jstringTostring(env,publicKey_str));</div><div class=\"line\"></div><div class=\"line\">\tjint bb = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param2);</div><div class=\"line\">\tjstring publicKey2_str =<span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (bb ==<span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\t\tjstring param3 = env-&gt;NewStringUTF(<span class=\"string\">\"public exponent\"</span>);</div><div class=\"line\">\t\tjint cc = env-&gt;CallIntMethod(publicKey_str,indexOf_mid,param3);</div><div class=\"line\">\t\t__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"CC value is %d\"</span>, cc);</div><div class=\"line\">\t\tpublicKey2_str= <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+<span class=\"number\">8</span>,cc<span class=\"number\">-1</span>));</div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\tpublicKey2_str = <span class=\"keyword\">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(publicKey_str,substring_mid,aa+<span class=\"number\">8</span>,bb<span class=\"number\">-1</span>));</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t__android_log_print(ANDROID_LOG_ERROR, TAG, <span class=\"string\">\"PublicKey value is %s\"</span>,  jstringTostring(env,publicKey2_str));</div><div class=\"line\">\t<span class=\"keyword\">return</span> publicKey2_str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-附赠版本兼容的方法问题（随时更新）\"><a href=\"#3-附赠版本兼容的方法问题（随时更新）\" class=\"headerlink\" title=\"3.附赠版本兼容的方法问题（随时更新）\"></a>3.附赠版本兼容的方法问题（随时更新）</h3><p>低于Jellybean版本报如下错误：</p>\n<pre><code>01-20 08:53:00.141: E/AndroidRuntime(24005): java.lang.NoSuchMethodError:\n    android.view.ViewTreeObserver.removeOnGlobalLayoutListener\n</code></pre><p>正确调用方式应该是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class=\"line\">\t\tViewTreeObserver.removeGlobalOnLayoutListener(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;<span class=\"keyword\">else</span></div><div class=\"line\">\t\tViewTreeObserver.removeOnGlobalLayoutListener(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>还有一个setBackground方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(Build.VERSION.SzDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class=\"line\">\t\tView.setBackground(<span class=\"keyword\">new</span> ColorDrawable(Color.parseColor(<span class=\"string\">\"#CCCCCC\"</span>)));</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\tView.setBackgroundColor(Color.parseColor(<span class=\"string\">\"#CCCCCC\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Android 退出整个应用程序解决方案","keywords":"Android,退出整个应用","banner":"http://obxk8w81b.bkt.clouddn.com/Enclosed%20Field%20with%20Ploughman.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Enclosed%20Field%20with%20Ploughman.jpg","_content":"\n\n关于这个功能，每个公司项目都有自己的解决方案\n\n搜索了一下，网上大概有以下几种方法解决这个问题：\n\n- (1)System.exit(0);\n\n- (2)Process.killProcess(Process.myPid());\n\n- (3)ActivityManager activityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);\n\n    activityManager.restartPackage(\"packagename\");\n\n\n但这些貌似不是万能的，有的说在2.2版本后就失效了，那我们怎么办呢？\n\n<!--more-->\n\n### 1、通过广播\n\n在起初的一个项目里我用了一个比较笨的方法，我用一个类来专门管理所有的Activity。这个类里有一个List，每打开一个Activity我就把这个Activity放到这个List中，当退出时再将List中所有的Activity一个一个的关闭。\n\n在后来的项目中发现了一个更好地方法，就是通过广播来完成退出功能，具体实现过程是这样的：在每个Activity创建时（onCreate时）给Activity注册一个广播接收器，当退出时发送该广播即可。大概的代码如下：\n\n~~~ Java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\n       super.onCreate(savedInstanceState);\n       IntentFilter filter = new IntentFilter();\n       filter.addAction(\"finish\");\n       registerReceiver(mFinishReceiver, filter);\n       ……\n}\n\nprivate BroadcastReceiver mFinishReceiver = new BroadcastReceiver() {\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n           if(\"finish\".equals(intent.getAction())) {\n              Log.e(\"#########\", \"I am \" + getLocalClassName()\n                     + \",now finishing myself...\");\n              finish();\n       }\n    }\n};\n~~~\n\n相信聪明的大家会把上面的代码写在一个基类里面，因为如果你的项目中Activity很多的话，写起来很麻烦，而且也不符合代码规范。\n\n在退出时执行以下代码即可关闭所有界面完全退出程序：\n\ngetApplicationContext().sendBroadcast(new Intent(\"finish\"));\n\n转载：http://www.cnblogs.com/wader2011/archive/2011/10/10/2205161.html\n\n### 2、使用退出类\n\n~~~ Java\npublic class CloseActivity\n{\n    private static LinkedList<Activity> acys = new LinkedList<Activity>();\n\n    public static Activity curActivity;\n\n    public static void add(Activity acy)\n    {\n        acys.add(acy);\n    }\n\n    public static void remove(Activity acy) {\n        acys.remove(acy);\n    }\n\n    public static void close()\n    {\n        Activity acy;\n        while (acys.size() != 0)\n        {\n            acy = acys.poll();\n            if (!acy.isFinishing())\n            {\n                acy.finish();\n            }\n        }\n//        android.os.Process.killProcess(android.os.Process.myPid());\n    }\n}\n~~~\n\n### 3.利用activity stack的原理\n我们知道Android的窗口类提供了历史栈，我们可以通过stack的原理来巧妙的实现，\n这里我们在D窗口打开A窗口时在Intent中直接加入标志Intent.FLAG_ACTIVITY_CLEAR_TOP，再次开启A时将会清除该进程空间的所有Activity。\n\n在D中使用下面的代码:\n\n~~~ Java\nIntent intent = new Intent();\nintent.setClass(D.this, A.class);\nintent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);  //注意本行的FLAG设置\nstartActivity(intent);\nfinish();\n~~~\n\n关掉自己，在A中加入代码：\n\n~~~ Java\n@Override\nprotected void onNewIntent(Intent intent) { // TODO Auto-generated method stub\n    super.onNewIntent(intent);\n        //退出\n    if ((Intent.FLAG_ACTIVITY_CLEAR_TOP & intent.getFlags()) != 0) {\n         finish();\n    }\n}\n~~~\n\n      A的Manifest.xml配置成android:launchMode=\"singleTop\"\n\n原理总结： 一般A是程序的入口点，从D起一个A的activity，加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP这个过程中会把栈中B，C，都清理掉。因为A是android:launchMode=\"singleTop\" 不会调用oncreate(),而是响应onNewIntent（）这时候判断Intent.FLAG_ACTIVITY_CLEAR_TOP，然后把A finish（）掉。 栈中A,B,C,D全部被清理。所以整个程序退出了。\n\n\n### 4.JNI实现守护进程\n请看这篇博客[Android 通过JNI实现守护进程](http://blog.csdn.net/yyh352091626/article/details/50542554)\n","source":"_posts/2016-09-22-quit-whole-application.md","raw":"---\nlayout: post\ntitle:  Android 退出整个应用程序解决方案\ncategory: technology\ntags: technology\nkeywords: Android,退出整个应用\nbanner: http://obxk8w81b.bkt.clouddn.com/Enclosed%20Field%20with%20Ploughman.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Enclosed%20Field%20with%20Ploughman.jpg\n---\n\n\n关于这个功能，每个公司项目都有自己的解决方案\n\n搜索了一下，网上大概有以下几种方法解决这个问题：\n\n- (1)System.exit(0);\n\n- (2)Process.killProcess(Process.myPid());\n\n- (3)ActivityManager activityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);\n\n    activityManager.restartPackage(\"packagename\");\n\n\n但这些貌似不是万能的，有的说在2.2版本后就失效了，那我们怎么办呢？\n\n<!--more-->\n\n### 1、通过广播\n\n在起初的一个项目里我用了一个比较笨的方法，我用一个类来专门管理所有的Activity。这个类里有一个List，每打开一个Activity我就把这个Activity放到这个List中，当退出时再将List中所有的Activity一个一个的关闭。\n\n在后来的项目中发现了一个更好地方法，就是通过广播来完成退出功能，具体实现过程是这样的：在每个Activity创建时（onCreate时）给Activity注册一个广播接收器，当退出时发送该广播即可。大概的代码如下：\n\n~~~ Java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\n       super.onCreate(savedInstanceState);\n       IntentFilter filter = new IntentFilter();\n       filter.addAction(\"finish\");\n       registerReceiver(mFinishReceiver, filter);\n       ……\n}\n\nprivate BroadcastReceiver mFinishReceiver = new BroadcastReceiver() {\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n           if(\"finish\".equals(intent.getAction())) {\n              Log.e(\"#########\", \"I am \" + getLocalClassName()\n                     + \",now finishing myself...\");\n              finish();\n       }\n    }\n};\n~~~\n\n相信聪明的大家会把上面的代码写在一个基类里面，因为如果你的项目中Activity很多的话，写起来很麻烦，而且也不符合代码规范。\n\n在退出时执行以下代码即可关闭所有界面完全退出程序：\n\ngetApplicationContext().sendBroadcast(new Intent(\"finish\"));\n\n转载：http://www.cnblogs.com/wader2011/archive/2011/10/10/2205161.html\n\n### 2、使用退出类\n\n~~~ Java\npublic class CloseActivity\n{\n    private static LinkedList<Activity> acys = new LinkedList<Activity>();\n\n    public static Activity curActivity;\n\n    public static void add(Activity acy)\n    {\n        acys.add(acy);\n    }\n\n    public static void remove(Activity acy) {\n        acys.remove(acy);\n    }\n\n    public static void close()\n    {\n        Activity acy;\n        while (acys.size() != 0)\n        {\n            acy = acys.poll();\n            if (!acy.isFinishing())\n            {\n                acy.finish();\n            }\n        }\n//        android.os.Process.killProcess(android.os.Process.myPid());\n    }\n}\n~~~\n\n### 3.利用activity stack的原理\n我们知道Android的窗口类提供了历史栈，我们可以通过stack的原理来巧妙的实现，\n这里我们在D窗口打开A窗口时在Intent中直接加入标志Intent.FLAG_ACTIVITY_CLEAR_TOP，再次开启A时将会清除该进程空间的所有Activity。\n\n在D中使用下面的代码:\n\n~~~ Java\nIntent intent = new Intent();\nintent.setClass(D.this, A.class);\nintent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);  //注意本行的FLAG设置\nstartActivity(intent);\nfinish();\n~~~\n\n关掉自己，在A中加入代码：\n\n~~~ Java\n@Override\nprotected void onNewIntent(Intent intent) { // TODO Auto-generated method stub\n    super.onNewIntent(intent);\n        //退出\n    if ((Intent.FLAG_ACTIVITY_CLEAR_TOP & intent.getFlags()) != 0) {\n         finish();\n    }\n}\n~~~\n\n      A的Manifest.xml配置成android:launchMode=\"singleTop\"\n\n原理总结： 一般A是程序的入口点，从D起一个A的activity，加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP这个过程中会把栈中B，C，都清理掉。因为A是android:launchMode=\"singleTop\" 不会调用oncreate(),而是响应onNewIntent（）这时候判断Intent.FLAG_ACTIVITY_CLEAR_TOP，然后把A finish（）掉。 栈中A,B,C,D全部被清理。所以整个程序退出了。\n\n\n### 4.JNI实现守护进程\n请看这篇博客[Android 通过JNI实现守护进程](http://blog.csdn.net/yyh352091626/article/details/50542554)\n","slug":"quit-whole-application","published":1,"date":"2016-09-21T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5h001ubxs6eflf9zga","content":"<p>关于这个功能，每个公司项目都有自己的解决方案</p>\n<p>搜索了一下，网上大概有以下几种方法解决这个问题：</p>\n<ul>\n<li><p>(1)System.exit(0);</p>\n</li>\n<li><p>(2)Process.killProcess(Process.myPid());</p>\n</li>\n<li><p>(3)ActivityManager activityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);</p>\n<p>  activityManager.restartPackage(“packagename”);</p>\n</li>\n</ul>\n<p>但这些貌似不是万能的，有的说在2.2版本后就失效了，那我们怎么办呢？</p>\n<a id=\"more\"></a>\n<h3 id=\"1、通过广播\"><a href=\"#1、通过广播\" class=\"headerlink\" title=\"1、通过广播\"></a>1、通过广播</h3><p>在起初的一个项目里我用了一个比较笨的方法，我用一个类来专门管理所有的Activity。这个类里有一个List，每打开一个Activity我就把这个Activity放到这个List中，当退出时再将List中所有的Activity一个一个的关闭。</p>\n<p>在后来的项目中发现了一个更好地方法，就是通过广播来完成退出功能，具体实现过程是这样的：在每个Activity创建时（onCreate时）给Activity注册一个广播接收器，当退出时发送该广播即可。大概的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">       IntentFilter filter = <span class=\"keyword\">new</span> IntentFilter();</div><div class=\"line\">       filter.addAction(<span class=\"string\">\"finish\"</span>);</div><div class=\"line\">       registerReceiver(mFinishReceiver, filter);</div><div class=\"line\">       ……</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> BroadcastReceiver mFinishReceiver = <span class=\"keyword\">new</span> BroadcastReceiver() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">if</span>(<span class=\"string\">\"finish\"</span>.equals(intent.getAction())) &#123;</div><div class=\"line\">              Log.e(<span class=\"string\">\"#########\"</span>, <span class=\"string\">\"I am \"</span> + getLocalClassName()</div><div class=\"line\">                     + <span class=\"string\">\",now finishing myself...\"</span>);</div><div class=\"line\">              finish();</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>相信聪明的大家会把上面的代码写在一个基类里面，因为如果你的项目中Activity很多的话，写起来很麻烦，而且也不符合代码规范。</p>\n<p>在退出时执行以下代码即可关闭所有界面完全退出程序：</p>\n<p>getApplicationContext().sendBroadcast(new Intent(“finish”));</p>\n<p>转载：<a href=\"http://www.cnblogs.com/wader2011/archive/2011/10/10/2205161.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/wader2011/archive/2011/10/10/2205161.html</a></p>\n<h3 id=\"2、使用退出类\"><a href=\"#2、使用退出类\" class=\"headerlink\" title=\"2、使用退出类\"></a>2、使用退出类</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloseActivity</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LinkedList&lt;Activity&gt; acys = <span class=\"keyword\">new</span> LinkedList&lt;Activity&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Activity curActivity;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Activity acy)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        acys.add(acy);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Activity acy)</span> </span>&#123;</div><div class=\"line\">        acys.remove(acy);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        Activity acy;</div><div class=\"line\">        <span class=\"keyword\">while</span> (acys.size() != <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            acy = acys.poll();</div><div class=\"line\">            <span class=\"keyword\">if</span> (!acy.isFinishing())</div><div class=\"line\">            &#123;</div><div class=\"line\">                acy.finish();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"><span class=\"comment\">//        android.os.Process.killProcess(android.os.Process.myPid());</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-利用activity-stack的原理\"><a href=\"#3-利用activity-stack的原理\" class=\"headerlink\" title=\"3.利用activity stack的原理\"></a>3.利用activity stack的原理</h3><p>我们知道Android的窗口类提供了历史栈，我们可以通过stack的原理来巧妙的实现，<br>这里我们在D窗口打开A窗口时在Intent中直接加入标志Intent.FLAG_ACTIVITY_CLEAR_TOP，再次开启A时将会清除该进程空间的所有Activity。</p>\n<p>在D中使用下面的代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">intent.setClass(D.<span class=\"keyword\">this</span>, A.class);</div><div class=\"line\">intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);  <span class=\"comment\">//注意本行的FLAG设置</span></div><div class=\"line\">startActivity(intent);</div><div class=\"line\">finish();</div></pre></td></tr></table></figure>\n<p>关掉自己，在A中加入代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewIntent</span><span class=\"params\">(Intent intent)</span> </span>&#123; <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">    <span class=\"keyword\">super</span>.onNewIntent(intent);</div><div class=\"line\">        <span class=\"comment\">//退出</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((Intent.FLAG_ACTIVITY_CLEAR_TOP &amp; intent.getFlags()) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">         finish();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>A的Manifest.xml配置成android:launchMode=&quot;singleTop&quot;\n</code></pre><p>原理总结： 一般A是程序的入口点，从D起一个A的activity，加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP这个过程中会把栈中B，C，都清理掉。因为A是android:launchMode=”singleTop” 不会调用oncreate(),而是响应onNewIntent（）这时候判断Intent.FLAG_ACTIVITY_CLEAR_TOP，然后把A finish（）掉。 栈中A,B,C,D全部被清理。所以整个程序退出了。</p>\n<h3 id=\"4-JNI实现守护进程\"><a href=\"#4-JNI实现守护进程\" class=\"headerlink\" title=\"4.JNI实现守护进程\"></a>4.JNI实现守护进程</h3><p>请看这篇博客<a href=\"http://blog.csdn.net/yyh352091626/article/details/50542554\" target=\"_blank\" rel=\"external\">Android 通过JNI实现守护进程</a></p>\n","excerpt":"<p>关于这个功能，每个公司项目都有自己的解决方案</p>\n<p>搜索了一下，网上大概有以下几种方法解决这个问题：</p>\n<ul>\n<li><p>(1)System.exit(0);</p>\n</li>\n<li><p>(2)Process.killProcess(Process.myPid());</p>\n</li>\n<li><p>(3)ActivityManager activityManager = (ActivityManager) this.getSystemService(Context.ACTIVITY_SERVICE);</p>\n<p>  activityManager.restartPackage(“packagename”);</p>\n</li>\n</ul>\n<p>但这些貌似不是万能的，有的说在2.2版本后就失效了，那我们怎么办呢？</p>","more":"<h3 id=\"1、通过广播\"><a href=\"#1、通过广播\" class=\"headerlink\" title=\"1、通过广播\"></a>1、通过广播</h3><p>在起初的一个项目里我用了一个比较笨的方法，我用一个类来专门管理所有的Activity。这个类里有一个List，每打开一个Activity我就把这个Activity放到这个List中，当退出时再将List中所有的Activity一个一个的关闭。</p>\n<p>在后来的项目中发现了一个更好地方法，就是通过广播来完成退出功能，具体实现过程是这样的：在每个Activity创建时（onCreate时）给Activity注册一个广播接收器，当退出时发送该广播即可。大概的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">       IntentFilter filter = <span class=\"keyword\">new</span> IntentFilter();</div><div class=\"line\">       filter.addAction(<span class=\"string\">\"finish\"</span>);</div><div class=\"line\">       registerReceiver(mFinishReceiver, filter);</div><div class=\"line\">       ……</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> BroadcastReceiver mFinishReceiver = <span class=\"keyword\">new</span> BroadcastReceiver() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">if</span>(<span class=\"string\">\"finish\"</span>.equals(intent.getAction())) &#123;</div><div class=\"line\">              Log.e(<span class=\"string\">\"#########\"</span>, <span class=\"string\">\"I am \"</span> + getLocalClassName()</div><div class=\"line\">                     + <span class=\"string\">\",now finishing myself...\"</span>);</div><div class=\"line\">              finish();</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>相信聪明的大家会把上面的代码写在一个基类里面，因为如果你的项目中Activity很多的话，写起来很麻烦，而且也不符合代码规范。</p>\n<p>在退出时执行以下代码即可关闭所有界面完全退出程序：</p>\n<p>getApplicationContext().sendBroadcast(new Intent(“finish”));</p>\n<p>转载：<a href=\"http://www.cnblogs.com/wader2011/archive/2011/10/10/2205161.html\">http://www.cnblogs.com/wader2011/archive/2011/10/10/2205161.html</a></p>\n<h3 id=\"2、使用退出类\"><a href=\"#2、使用退出类\" class=\"headerlink\" title=\"2、使用退出类\"></a>2、使用退出类</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloseActivity</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LinkedList&lt;Activity&gt; acys = <span class=\"keyword\">new</span> LinkedList&lt;Activity&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Activity curActivity;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Activity acy)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        acys.add(acy);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Activity acy)</span> </span>&#123;</div><div class=\"line\">        acys.remove(acy);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        Activity acy;</div><div class=\"line\">        <span class=\"keyword\">while</span> (acys.size() != <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            acy = acys.poll();</div><div class=\"line\">            <span class=\"keyword\">if</span> (!acy.isFinishing())</div><div class=\"line\">            &#123;</div><div class=\"line\">                acy.finish();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"><span class=\"comment\">//        android.os.Process.killProcess(android.os.Process.myPid());</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-利用activity-stack的原理\"><a href=\"#3-利用activity-stack的原理\" class=\"headerlink\" title=\"3.利用activity stack的原理\"></a>3.利用activity stack的原理</h3><p>我们知道Android的窗口类提供了历史栈，我们可以通过stack的原理来巧妙的实现，<br>这里我们在D窗口打开A窗口时在Intent中直接加入标志Intent.FLAG_ACTIVITY_CLEAR_TOP，再次开启A时将会清除该进程空间的所有Activity。</p>\n<p>在D中使用下面的代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">intent.setClass(D.<span class=\"keyword\">this</span>, A.class);</div><div class=\"line\">intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);  <span class=\"comment\">//注意本行的FLAG设置</span></div><div class=\"line\">startActivity(intent);</div><div class=\"line\">finish();</div></pre></td></tr></table></figure>\n<p>关掉自己，在A中加入代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewIntent</span><span class=\"params\">(Intent intent)</span> </span>&#123; <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">    <span class=\"keyword\">super</span>.onNewIntent(intent);</div><div class=\"line\">        <span class=\"comment\">//退出</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((Intent.FLAG_ACTIVITY_CLEAR_TOP &amp; intent.getFlags()) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">         finish();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>A的Manifest.xml配置成android:launchMode=&quot;singleTop&quot;\n</code></pre><p>原理总结： 一般A是程序的入口点，从D起一个A的activity，加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP这个过程中会把栈中B，C，都清理掉。因为A是android:launchMode=”singleTop” 不会调用oncreate(),而是响应onNewIntent（）这时候判断Intent.FLAG_ACTIVITY_CLEAR_TOP，然后把A finish（）掉。 栈中A,B,C,D全部被清理。所以整个程序退出了。</p>\n<h3 id=\"4-JNI实现守护进程\"><a href=\"#4-JNI实现守护进程\" class=\"headerlink\" title=\"4.JNI实现守护进程\"></a>4.JNI实现守护进程</h3><p>请看这篇博客<a href=\"http://blog.csdn.net/yyh352091626/article/details/50542554\">Android 通过JNI实现守护进程</a></p>"},{"layout":"post","title":"Android面试知识点整理","keywords":"Android,面试题","banner":"http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg","_content":"\n\n只整理android面试中涉及到的知识点。不断补充中。。。\n\n#### 1.Android事件传递机制\n下面内容摘选自《Android开发艺术探索》\n\n- (1) 当一个点击事件发生之后，传递过程遵循如下顺序：**Activity -> Window -> View**。\n如果一个view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent方法将会被调用，依此类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理(调用Activity的onTouchEvent方法)。\n\n<!--more-->\n- (2) 正常情况下，一个事件序列只能被一个view拦截并消耗，因为一旦某个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，并且该元素的**onInterceptTouchEvent**方法不会再被调用了。\n- (3) 某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么**同一事件序列的其他事件都不会再交给它来处理**，并且事件将重新交给它的**父容器去处理**(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，**当前view依然可以收到后续的事件**，但是这些事件最后都会传递给Activity处理。\n- (4) ViewGroup默认不拦截任何事件，因为它的**onInterceptTouchEvent**方法默认返回false。view没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。\n- (5) View的**onTouchEvent**默认都会消耗事件(返回true)，除非它是不可点击的(clickable和longClickable都为false)。view的longClickable默认是false的，clickable则不一定，Button默认是true，而TextView默认是false。\n- (6) **View的enable属性不影响onTouchEvent的默认返回值**。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。\n- (7) 事件传递过程总是**先传递给父元素**，然后再由**父元素分发给子view**，通过**requestDisallowInterceptTouchEvent**方法可以在**子元素中干预父元素的事件分发过程**，但是**ACTION_DOWN事件除外**，即当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。\nViewGroup的dispatchTouchEvent方法中有一个标志位**FLAG_DISALLOW_INTERCEPT**，这个标志位就是通过**子view调用requestDisallowInterceptTouchEvent方法**来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。\n- (8) 以上结论均可以在书中的源码解析部分得到解释。Window的实现类为PhoneWindow，获取Activity的contentView的方法\n\n~~~ Java\n((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0);\n~~~\n\n#### 2.OnTouchListener、onTouchEvent、OnClickListener优先级顺序\n如果给一个view设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看**onTouch**的返回值，如果返回false，那么当前view的**onTouchEvent方法**会被调用；如果返回true，那么onTouchEvent方法将不会被调用。\n在onTouchEvent方法中，如果当前view设置了OnClickListener，那么它的onClick方法会被调用，所以OnClickListener的优先级最低。\n\n#### 3.AsyncTask的方法介绍\n\n#### 4.项目中Handler怎么使用？\n\n#### 5.项目中图片的适配问题怎么解决？\n\n#### 6.Android存储敏感信息的方式有？\n\n#### 7.自定义广播\n- 继承自BroadcastReceiver\n- 重写onReceive(Context,Intent)\n      Intent.getAction\n- 动态注册（Context.registerReceiver()），静态注册（使用IntentFilter指定action）\n\n\n#### 8.加分项\n- JNI开发\n- 性能优化\n- 优秀作品\n\n#### 9.Sqlite数据库更新并保留升级前的数据\n我们知道在SQLiteOpenHelper的构造方法:\n\n    super(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)\n\n中最后一个参数表示数据库的版本号.当新的版本号大于当前的version时会调用方法:\n\n    onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)\n\n所以我们的重点是在该方法中实现SQLite数据库版本升级的管理\n\n对于保留升级前的数据，有两种解决办法：\n\n**SQLite提供了ALTER TABLE命令**，允许用户重命名或添加新的字段到已有表中，但是不能从表中删除字段。并且只能在表的末尾添加字段，比如，为Subscription添加两个字段：\n\n- ALTER TABLE Subscription ADD COLUMN Activation BLOB;\n- ALTER TABLE Subscription ADD COLUMN Key BLOB;\n\n**注释**：Sqlite支持BLOB(二进制大对象)数据类型\n\n**保留数据删除原表创建新表**，具体思路是：\n\n- 1：将表A重新命名：例如重新命名为：temp_A\n- 2：创建新表A\n- 3：将temp_A中的数据【也就是更新前的数据】插入到新表A\n\n具体操作如下：\n\n~~~ Java\n//重命名原来的数据表\npublic static final String TEMP_SQL_CREATE_TABLE_SUBSCRIBE = \"alter table \"\n            + A + \" rename to temp_A\";\n\n//然后把备份表temp_A中的数据copy到新创建的数据库表A中，这个表A没发生结构上的变化\npublic static final String INSERT_SUBSCRIBE = \"select 'insert into A (code,name,username,tablename)\n                        values (\"code\",\"name\",\"cnki\",\"tablename\")' as insertSQL from temp_A\";\n\n//删除备份表\npublic static final String DELETE_TEMP_SUBSCRIBE = \"delete from temp_A \";\npublic static final String DROP_TEMP_SUBSCRIBE = \"drop table if exists temp_A\";\n\n@Override\npublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n        for (int j = oldVersion; j <= newVersion; j++) {\n            switch (j) {\n            case 2:\n　　　　　　　　　//创建临时表\n                db.execSQL(TEMP_SQL_CREATE_TABLE_SUBSCRIBE);\n　　 　　　　　　//执行OnCreate方法，这个方法中放的是表的初始化操作工作，比如创建新表之类的\n                onCreate(db);\n　　　　　　　　　//删除之前的表里面的默认数据\n                for (int i = 0; i < arrWhereAct.length; i++) {\n                    db.execSQL(DELETE_TEMP_SUBSCRIBE + arrWhereAct[i]);\n                }\n\n                //将临时表中的数据放入表A\n　　　　　　　　　Cursor cursor = db.rawQuery(INSERT_SUBSCRIBE, null);\n                if (cursor.moveToFirst()) {\n                    do {\n                        db.execSQL(cursor.getString(cursor\n                                .getColumnIndex(\"insertSQL\")));\n                    } while (cursor.moveToNext());\n                }\n\n                cursor.close();\n　　　　　　　　　//将临时表删除掉\n                db.execSQL(DROP_TEMP_SUBSCRIBE);\n\n                break;\n\n            default:\n                break;\n            }\n        }\n}\n~~~\n\n> **注意**，为什么要在方法里写for循环，主要是考虑到跨版本升级，比如有的用户一直不升级版本，数据库版本号一直是1，而客户端最新版本其实对应的数据库版本已经是4了，那么我中途可能对数据库做了很多修改，通过这个for循环，可以迭代升级，不会发生错误。\n\n\n#### 10.AIDL支持的数据类型\n其实AIDL这门语言非常的简单，基本上它的语法和 Java 是一样的，只是在一些细微处有些许差别——毕竟它只是被创造出来简化Android程序员工作的，太复杂不好——所以在这里我就着重的说一下它和 Java 不一样的地方。主要有下面这些点：\n\n**文件类型**：用AIDL书写的文件的后缀是 .aidl，而不是 .java。\n\n**数据类型**：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，就算目标文件与当前正在编写的 .aidl 文件在同一个包下——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文件，一个叫做Book.java ，另一个叫做 BookManager.aidl，它们都在 com.lypeer.aidldemo 包下 ，现在我们需要在 .aidl 文件里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 import com.lypeer.aidldemo.Book; 哪怕 .java 文件和 .aidl 文件就在一个包下。\n\n   默认支持的数据类型包括：\n\n- Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char。\n- String 类型。\n- CharSequence类型。\n- List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable（下文关于这个会有详解）。List可以使用泛型。\n- Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的。\n\n**定向tag**：这是一个极易被忽略的点——这里的“被忽略”指的不是大家都不知道，而是很少人会正确的使用它。在我的理解里，定向tag是这样的：AIDL中的定向tag表示了在跨进程通信中数据的流向，其中**in表示数据只能由客户端流向服务端**，**out表示数据只能由服务端流向客户端**，**而inout则表示数据可在服务端与客户端之间双向流通**。其中，**数据流向是针对在客户端中的那个传入方法的对象而言的**。in为定向tag的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；out的话表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；inout为定向tag的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。\n\n另外，Java 中的基本类型和String，CharSequence的定向tag默认且只能是in。还有，请注意，请不要滥用定向tag，而是要根据需要选取合适的——要是不管三七二十一，全都一上来就用inout，等工程大了系统的开销就会大很多——因为排列整理参数的开销是很昂贵的。\n\n**两种AIDL文件**：在我的理解里，所有的AIDL文件大致可以分为两类。**一类是用来定义parcelable对象**，以供其他AIDL文件使用AIDL中非默认支持的数据类型的。**一类是用来定义方法接口**，以供系统使用来完成跨进程通信的。可以看到，两类文件都是在“定义”些什么，而不涉及具体的实现，这就是为什么它叫做“Android接口定义语言”。\n注：所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。\n\n下面是两个例子，对于常见的AIDL文件都有所涉及：\n\n~~~ Java\n// Book.aidl\n//第一类AIDL文件的例子\n//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用\n//注意：Book.aidl与Book.java的包名应当是一样的\npackage com.lypeer.ipcclient;\n\n//注意parcelable是小写\nparcelable Book;\n\n// BookManager.aidl\n//第二类AIDL文件的例子\npackage com.lypeer.ipcclient;\n//导入所需要使用的非默认支持数据类型的包\nimport com.lypeer.ipcclient.Book;\n\ninterface BookManager {\n\n    //所有的返回值前都不需要加任何东西，不管是什么数据类型\n    List<Book> getBooks();\n    Book getBook();\n    int getBookCount();\n\n    //传参时除了Java基本类型以及String，CharSequence之外的类型\n    //都需要在前面加上定向tag，具体加什么量需而定\n    void setBookPrice(in Book book , int price)\n    void setBookName(in Book book , String name)\n    void addBookIn(in Book book);\n    void addBookOut(out Book book);\n    void addBookInout(inout Book book);\n}\n~~~\n\n\n#### 11.Android布局的优化方案\n\n- 层级观察器(Hierarchy Viewer)：\n- 使用layoutopt工具输出\n- 重用布局文件：<include>\n- 使用< merge />标签减少布局的嵌套层次；\n- 仅在需要时才加载布局，ViewStub\n\n#### 12.Android性能调优\n- UI卡顿\n- ANR异常\n- 内存性能优化\n- Android API使用：\n        StringBuffer/String、HashMap/ArrayMap/SparseArray\n\n性能调优参考这篇博客[Andoid应用开发性能优化完全分析](http://blog.csdn.net/yanbober/article/details/48394201)\n","source":"_posts/2016-09-28-Android-interview-questions.md","raw":"---\nlayout: post\ntitle:  Android面试知识点整理\ncategory: accumulation\ntags: accumulation\nkeywords: Android,面试题\nbanner: http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Cottages%20Reminiscence%20of%20the%20North.jpg\n---\n\n\n只整理android面试中涉及到的知识点。不断补充中。。。\n\n#### 1.Android事件传递机制\n下面内容摘选自《Android开发艺术探索》\n\n- (1) 当一个点击事件发生之后，传递过程遵循如下顺序：**Activity -> Window -> View**。\n如果一个view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent方法将会被调用，依此类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理(调用Activity的onTouchEvent方法)。\n\n<!--more-->\n- (2) 正常情况下，一个事件序列只能被一个view拦截并消耗，因为一旦某个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，并且该元素的**onInterceptTouchEvent**方法不会再被调用了。\n- (3) 某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么**同一事件序列的其他事件都不会再交给它来处理**，并且事件将重新交给它的**父容器去处理**(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，**当前view依然可以收到后续的事件**，但是这些事件最后都会传递给Activity处理。\n- (4) ViewGroup默认不拦截任何事件，因为它的**onInterceptTouchEvent**方法默认返回false。view没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。\n- (5) View的**onTouchEvent**默认都会消耗事件(返回true)，除非它是不可点击的(clickable和longClickable都为false)。view的longClickable默认是false的，clickable则不一定，Button默认是true，而TextView默认是false。\n- (6) **View的enable属性不影响onTouchEvent的默认返回值**。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。\n- (7) 事件传递过程总是**先传递给父元素**，然后再由**父元素分发给子view**，通过**requestDisallowInterceptTouchEvent**方法可以在**子元素中干预父元素的事件分发过程**，但是**ACTION_DOWN事件除外**，即当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。\nViewGroup的dispatchTouchEvent方法中有一个标志位**FLAG_DISALLOW_INTERCEPT**，这个标志位就是通过**子view调用requestDisallowInterceptTouchEvent方法**来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。\n- (8) 以上结论均可以在书中的源码解析部分得到解释。Window的实现类为PhoneWindow，获取Activity的contentView的方法\n\n~~~ Java\n((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0);\n~~~\n\n#### 2.OnTouchListener、onTouchEvent、OnClickListener优先级顺序\n如果给一个view设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看**onTouch**的返回值，如果返回false，那么当前view的**onTouchEvent方法**会被调用；如果返回true，那么onTouchEvent方法将不会被调用。\n在onTouchEvent方法中，如果当前view设置了OnClickListener，那么它的onClick方法会被调用，所以OnClickListener的优先级最低。\n\n#### 3.AsyncTask的方法介绍\n\n#### 4.项目中Handler怎么使用？\n\n#### 5.项目中图片的适配问题怎么解决？\n\n#### 6.Android存储敏感信息的方式有？\n\n#### 7.自定义广播\n- 继承自BroadcastReceiver\n- 重写onReceive(Context,Intent)\n      Intent.getAction\n- 动态注册（Context.registerReceiver()），静态注册（使用IntentFilter指定action）\n\n\n#### 8.加分项\n- JNI开发\n- 性能优化\n- 优秀作品\n\n#### 9.Sqlite数据库更新并保留升级前的数据\n我们知道在SQLiteOpenHelper的构造方法:\n\n    super(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)\n\n中最后一个参数表示数据库的版本号.当新的版本号大于当前的version时会调用方法:\n\n    onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)\n\n所以我们的重点是在该方法中实现SQLite数据库版本升级的管理\n\n对于保留升级前的数据，有两种解决办法：\n\n**SQLite提供了ALTER TABLE命令**，允许用户重命名或添加新的字段到已有表中，但是不能从表中删除字段。并且只能在表的末尾添加字段，比如，为Subscription添加两个字段：\n\n- ALTER TABLE Subscription ADD COLUMN Activation BLOB;\n- ALTER TABLE Subscription ADD COLUMN Key BLOB;\n\n**注释**：Sqlite支持BLOB(二进制大对象)数据类型\n\n**保留数据删除原表创建新表**，具体思路是：\n\n- 1：将表A重新命名：例如重新命名为：temp_A\n- 2：创建新表A\n- 3：将temp_A中的数据【也就是更新前的数据】插入到新表A\n\n具体操作如下：\n\n~~~ Java\n//重命名原来的数据表\npublic static final String TEMP_SQL_CREATE_TABLE_SUBSCRIBE = \"alter table \"\n            + A + \" rename to temp_A\";\n\n//然后把备份表temp_A中的数据copy到新创建的数据库表A中，这个表A没发生结构上的变化\npublic static final String INSERT_SUBSCRIBE = \"select 'insert into A (code,name,username,tablename)\n                        values (\"code\",\"name\",\"cnki\",\"tablename\")' as insertSQL from temp_A\";\n\n//删除备份表\npublic static final String DELETE_TEMP_SUBSCRIBE = \"delete from temp_A \";\npublic static final String DROP_TEMP_SUBSCRIBE = \"drop table if exists temp_A\";\n\n@Override\npublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n        for (int j = oldVersion; j <= newVersion; j++) {\n            switch (j) {\n            case 2:\n　　　　　　　　　//创建临时表\n                db.execSQL(TEMP_SQL_CREATE_TABLE_SUBSCRIBE);\n　　 　　　　　　//执行OnCreate方法，这个方法中放的是表的初始化操作工作，比如创建新表之类的\n                onCreate(db);\n　　　　　　　　　//删除之前的表里面的默认数据\n                for (int i = 0; i < arrWhereAct.length; i++) {\n                    db.execSQL(DELETE_TEMP_SUBSCRIBE + arrWhereAct[i]);\n                }\n\n                //将临时表中的数据放入表A\n　　　　　　　　　Cursor cursor = db.rawQuery(INSERT_SUBSCRIBE, null);\n                if (cursor.moveToFirst()) {\n                    do {\n                        db.execSQL(cursor.getString(cursor\n                                .getColumnIndex(\"insertSQL\")));\n                    } while (cursor.moveToNext());\n                }\n\n                cursor.close();\n　　　　　　　　　//将临时表删除掉\n                db.execSQL(DROP_TEMP_SUBSCRIBE);\n\n                break;\n\n            default:\n                break;\n            }\n        }\n}\n~~~\n\n> **注意**，为什么要在方法里写for循环，主要是考虑到跨版本升级，比如有的用户一直不升级版本，数据库版本号一直是1，而客户端最新版本其实对应的数据库版本已经是4了，那么我中途可能对数据库做了很多修改，通过这个for循环，可以迭代升级，不会发生错误。\n\n\n#### 10.AIDL支持的数据类型\n其实AIDL这门语言非常的简单，基本上它的语法和 Java 是一样的，只是在一些细微处有些许差别——毕竟它只是被创造出来简化Android程序员工作的，太复杂不好——所以在这里我就着重的说一下它和 Java 不一样的地方。主要有下面这些点：\n\n**文件类型**：用AIDL书写的文件的后缀是 .aidl，而不是 .java。\n\n**数据类型**：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，就算目标文件与当前正在编写的 .aidl 文件在同一个包下——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文件，一个叫做Book.java ，另一个叫做 BookManager.aidl，它们都在 com.lypeer.aidldemo 包下 ，现在我们需要在 .aidl 文件里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 import com.lypeer.aidldemo.Book; 哪怕 .java 文件和 .aidl 文件就在一个包下。\n\n   默认支持的数据类型包括：\n\n- Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char。\n- String 类型。\n- CharSequence类型。\n- List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable（下文关于这个会有详解）。List可以使用泛型。\n- Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的。\n\n**定向tag**：这是一个极易被忽略的点——这里的“被忽略”指的不是大家都不知道，而是很少人会正确的使用它。在我的理解里，定向tag是这样的：AIDL中的定向tag表示了在跨进程通信中数据的流向，其中**in表示数据只能由客户端流向服务端**，**out表示数据只能由服务端流向客户端**，**而inout则表示数据可在服务端与客户端之间双向流通**。其中，**数据流向是针对在客户端中的那个传入方法的对象而言的**。in为定向tag的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；out的话表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；inout为定向tag的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。\n\n另外，Java 中的基本类型和String，CharSequence的定向tag默认且只能是in。还有，请注意，请不要滥用定向tag，而是要根据需要选取合适的——要是不管三七二十一，全都一上来就用inout，等工程大了系统的开销就会大很多——因为排列整理参数的开销是很昂贵的。\n\n**两种AIDL文件**：在我的理解里，所有的AIDL文件大致可以分为两类。**一类是用来定义parcelable对象**，以供其他AIDL文件使用AIDL中非默认支持的数据类型的。**一类是用来定义方法接口**，以供系统使用来完成跨进程通信的。可以看到，两类文件都是在“定义”些什么，而不涉及具体的实现，这就是为什么它叫做“Android接口定义语言”。\n注：所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。\n\n下面是两个例子，对于常见的AIDL文件都有所涉及：\n\n~~~ Java\n// Book.aidl\n//第一类AIDL文件的例子\n//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用\n//注意：Book.aidl与Book.java的包名应当是一样的\npackage com.lypeer.ipcclient;\n\n//注意parcelable是小写\nparcelable Book;\n\n// BookManager.aidl\n//第二类AIDL文件的例子\npackage com.lypeer.ipcclient;\n//导入所需要使用的非默认支持数据类型的包\nimport com.lypeer.ipcclient.Book;\n\ninterface BookManager {\n\n    //所有的返回值前都不需要加任何东西，不管是什么数据类型\n    List<Book> getBooks();\n    Book getBook();\n    int getBookCount();\n\n    //传参时除了Java基本类型以及String，CharSequence之外的类型\n    //都需要在前面加上定向tag，具体加什么量需而定\n    void setBookPrice(in Book book , int price)\n    void setBookName(in Book book , String name)\n    void addBookIn(in Book book);\n    void addBookOut(out Book book);\n    void addBookInout(inout Book book);\n}\n~~~\n\n\n#### 11.Android布局的优化方案\n\n- 层级观察器(Hierarchy Viewer)：\n- 使用layoutopt工具输出\n- 重用布局文件：<include>\n- 使用< merge />标签减少布局的嵌套层次；\n- 仅在需要时才加载布局，ViewStub\n\n#### 12.Android性能调优\n- UI卡顿\n- ANR异常\n- 内存性能优化\n- Android API使用：\n        StringBuffer/String、HashMap/ArrayMap/SparseArray\n\n性能调优参考这篇博客[Andoid应用开发性能优化完全分析](http://blog.csdn.net/yanbober/article/details/48394201)\n","slug":"Android-interview-questions","published":1,"date":"2016-09-27T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5i001xbxs6o2vmlkf1","content":"<p>只整理android面试中涉及到的知识点。不断补充中。。。</p>\n<h4 id=\"1-Android事件传递机制\"><a href=\"#1-Android事件传递机制\" class=\"headerlink\" title=\"1.Android事件传递机制\"></a>1.Android事件传递机制</h4><p>下面内容摘选自《Android开发艺术探索》</p>\n<ul>\n<li>(1) 当一个点击事件发生之后，传递过程遵循如下顺序：<strong>Activity -&gt; Window -&gt; View</strong>。<br>如果一个view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent方法将会被调用，依此类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理(调用Activity的onTouchEvent方法)。</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>(2) 正常情况下，一个事件序列只能被一个view拦截并消耗，因为一旦某个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，并且该元素的<strong>onInterceptTouchEvent</strong>方法不会再被调用了。</li>\n<li>(3) 某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么<strong>同一事件序列的其他事件都不会再交给它来处理</strong>，并且事件将重新交给它的<strong>父容器去处理</strong>(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，<strong>当前view依然可以收到后续的事件</strong>，但是这些事件最后都会传递给Activity处理。</li>\n<li>(4) ViewGroup默认不拦截任何事件，因为它的<strong>onInterceptTouchEvent</strong>方法默认返回false。view没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。</li>\n<li>(5) View的<strong>onTouchEvent</strong>默认都会消耗事件(返回true)，除非它是不可点击的(clickable和longClickable都为false)。view的longClickable默认是false的，clickable则不一定，Button默认是true，而TextView默认是false。</li>\n<li>(6) <strong>View的enable属性不影响onTouchEvent的默认返回值</strong>。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。</li>\n<li>(7) 事件传递过程总是<strong>先传递给父元素</strong>，然后再由<strong>父元素分发给子view</strong>，通过<strong>requestDisallowInterceptTouchEvent</strong>方法可以在<strong>子元素中干预父元素的事件分发过程</strong>，但是<strong>ACTION_DOWN事件除外</strong>，即当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。<br>ViewGroup的dispatchTouchEvent方法中有一个标志位<strong>FLAG_DISALLOW_INTERCEPT</strong>，这个标志位就是通过<strong>子view调用requestDisallowInterceptTouchEvent方法</strong>来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。</li>\n<li>(8) 以上结论均可以在书中的源码解析部分得到解释。Window的实现类为PhoneWindow，获取Activity的contentView的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(<span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"2-OnTouchListener、onTouchEvent、OnClickListener优先级顺序\"><a href=\"#2-OnTouchListener、onTouchEvent、OnClickListener优先级顺序\" class=\"headerlink\" title=\"2.OnTouchListener、onTouchEvent、OnClickListener优先级顺序\"></a>2.OnTouchListener、onTouchEvent、OnClickListener优先级顺序</h4><p>如果给一个view设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看<strong>onTouch</strong>的返回值，如果返回false，那么当前view的<strong>onTouchEvent方法</strong>会被调用；如果返回true，那么onTouchEvent方法将不会被调用。<br>在onTouchEvent方法中，如果当前view设置了OnClickListener，那么它的onClick方法会被调用，所以OnClickListener的优先级最低。</p>\n<h4 id=\"3-AsyncTask的方法介绍\"><a href=\"#3-AsyncTask的方法介绍\" class=\"headerlink\" title=\"3.AsyncTask的方法介绍\"></a>3.AsyncTask的方法介绍</h4><h4 id=\"4-项目中Handler怎么使用？\"><a href=\"#4-项目中Handler怎么使用？\" class=\"headerlink\" title=\"4.项目中Handler怎么使用？\"></a>4.项目中Handler怎么使用？</h4><h4 id=\"5-项目中图片的适配问题怎么解决？\"><a href=\"#5-项目中图片的适配问题怎么解决？\" class=\"headerlink\" title=\"5.项目中图片的适配问题怎么解决？\"></a>5.项目中图片的适配问题怎么解决？</h4><h4 id=\"6-Android存储敏感信息的方式有？\"><a href=\"#6-Android存储敏感信息的方式有？\" class=\"headerlink\" title=\"6.Android存储敏感信息的方式有？\"></a>6.Android存储敏感信息的方式有？</h4><h4 id=\"7-自定义广播\"><a href=\"#7-自定义广播\" class=\"headerlink\" title=\"7.自定义广播\"></a>7.自定义广播</h4><ul>\n<li>继承自BroadcastReceiver</li>\n<li>重写onReceive(Context,Intent)<pre><code>Intent.getAction\n</code></pre></li>\n<li>动态注册（Context.registerReceiver()），静态注册（使用IntentFilter指定action）</li>\n</ul>\n<h4 id=\"8-加分项\"><a href=\"#8-加分项\" class=\"headerlink\" title=\"8.加分项\"></a>8.加分项</h4><ul>\n<li>JNI开发</li>\n<li>性能优化</li>\n<li>优秀作品</li>\n</ul>\n<h4 id=\"9-Sqlite数据库更新并保留升级前的数据\"><a href=\"#9-Sqlite数据库更新并保留升级前的数据\" class=\"headerlink\" title=\"9.Sqlite数据库更新并保留升级前的数据\"></a>9.Sqlite数据库更新并保留升级前的数据</h4><p>我们知道在SQLiteOpenHelper的构造方法:</p>\n<pre><code>super(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)\n</code></pre><p>中最后一个参数表示数据库的版本号.当新的版本号大于当前的version时会调用方法:</p>\n<pre><code>onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)\n</code></pre><p>所以我们的重点是在该方法中实现SQLite数据库版本升级的管理</p>\n<p>对于保留升级前的数据，有两种解决办法：</p>\n<p><strong>SQLite提供了ALTER TABLE命令</strong>，允许用户重命名或添加新的字段到已有表中，但是不能从表中删除字段。并且只能在表的末尾添加字段，比如，为Subscription添加两个字段：</p>\n<ul>\n<li>ALTER TABLE Subscription ADD COLUMN Activation BLOB;</li>\n<li>ALTER TABLE Subscription ADD COLUMN Key BLOB;</li>\n</ul>\n<p><strong>注释</strong>：Sqlite支持BLOB(二进制大对象)数据类型</p>\n<p><strong>保留数据删除原表创建新表</strong>，具体思路是：</p>\n<ul>\n<li>1：将表A重新命名：例如重新命名为：temp_A</li>\n<li>2：创建新表A</li>\n<li>3：将temp_A中的数据【也就是更新前的数据】插入到新表A</li>\n</ul>\n<p>具体操作如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//重命名原来的数据表</div><div class=\"line\">public static final String TEMP_SQL_CREATE_TABLE_SUBSCRIBE = \"alter table \"</div><div class=\"line\">            + A + \" rename to temp_A\";</div><div class=\"line\"></div><div class=\"line\">//然后把备份表temp_A中的数据copy到新创建的数据库表A中，这个表A没发生结构上的变化</div><div class=\"line\">public static final String INSERT_SUBSCRIBE = \"select 'insert into A (code,name,username,tablename)</div><div class=\"line\">                        values (\"code\",\"name\",\"cnki\",\"tablename\")' as insertSQL from temp_A\";</div><div class=\"line\"></div><div class=\"line\">//删除备份表</div><div class=\"line\">public static final String DELETE_TEMP_SUBSCRIBE = \"delete from temp_A \";</div><div class=\"line\">public static final String DROP_TEMP_SUBSCRIBE = \"drop table if exists temp_A\";</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</div><div class=\"line\"></div><div class=\"line\">        for (int j = oldVersion; j &lt;= newVersion; j++) &#123;</div><div class=\"line\">            switch (j) &#123;</div><div class=\"line\">            case 2:</div><div class=\"line\">　　　　　　　　　//创建临时表</div><div class=\"line\">                db.execSQL(TEMP_SQL_CREATE_TABLE_SUBSCRIBE);</div><div class=\"line\">　　 　　　　　　//执行OnCreate方法，这个方法中放的是表的初始化操作工作，比如创建新表之类的</div><div class=\"line\">                onCreate(db);</div><div class=\"line\">　　　　　　　　　//删除之前的表里面的默认数据</div><div class=\"line\">                for (int i = 0; i &lt; arrWhereAct.length; i++) &#123;</div><div class=\"line\">                    db.execSQL(DELETE_TEMP_SUBSCRIBE + arrWhereAct[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                //将临时表中的数据放入表A</div><div class=\"line\">　　　　　　　　　Cursor cursor = db.rawQuery(INSERT_SUBSCRIBE, null);</div><div class=\"line\">                if (cursor.moveToFirst()) &#123;</div><div class=\"line\">                    do &#123;</div><div class=\"line\">                        db.execSQL(cursor.getString(cursor</div><div class=\"line\">                                .getColumnIndex(\"insertSQL\")));</div><div class=\"line\">                    &#125; while (cursor.moveToNext());</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                cursor.close();</div><div class=\"line\">　　　　　　　　　//将临时表删除掉</div><div class=\"line\">                db.execSQL(DROP_TEMP_SUBSCRIBE);</div><div class=\"line\"></div><div class=\"line\">                break;</div><div class=\"line\"></div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意</strong>，为什么要在方法里写for循环，主要是考虑到跨版本升级，比如有的用户一直不升级版本，数据库版本号一直是1，而客户端最新版本其实对应的数据库版本已经是4了，那么我中途可能对数据库做了很多修改，通过这个for循环，可以迭代升级，不会发生错误。</p>\n</blockquote>\n<h4 id=\"10-AIDL支持的数据类型\"><a href=\"#10-AIDL支持的数据类型\" class=\"headerlink\" title=\"10.AIDL支持的数据类型\"></a>10.AIDL支持的数据类型</h4><p>其实AIDL这门语言非常的简单，基本上它的语法和 Java 是一样的，只是在一些细微处有些许差别——毕竟它只是被创造出来简化Android程序员工作的，太复杂不好——所以在这里我就着重的说一下它和 Java 不一样的地方。主要有下面这些点：</p>\n<p><strong>文件类型</strong>：用AIDL书写的文件的后缀是 .aidl，而不是 .java。</p>\n<p><strong>数据类型</strong>：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，就算目标文件与当前正在编写的 .aidl 文件在同一个包下——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文件，一个叫做Book.java ，另一个叫做 BookManager.aidl，它们都在 com.lypeer.aidldemo 包下 ，现在我们需要在 .aidl 文件里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 import com.lypeer.aidldemo.Book; 哪怕 .java 文件和 .aidl 文件就在一个包下。</p>\n<p>   默认支持的数据类型包括：</p>\n<ul>\n<li>Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char。</li>\n<li>String 类型。</li>\n<li>CharSequence类型。</li>\n<li>List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable（下文关于这个会有详解）。List可以使用泛型。</li>\n<li>Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的。</li>\n</ul>\n<p><strong>定向tag</strong>：这是一个极易被忽略的点——这里的“被忽略”指的不是大家都不知道，而是很少人会正确的使用它。在我的理解里，定向tag是这样的：AIDL中的定向tag表示了在跨进程通信中数据的流向，其中<strong>in表示数据只能由客户端流向服务端</strong>，<strong>out表示数据只能由服务端流向客户端</strong>，<strong>而inout则表示数据可在服务端与客户端之间双向流通</strong>。其中，<strong>数据流向是针对在客户端中的那个传入方法的对象而言的</strong>。in为定向tag的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；out的话表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；inout为定向tag的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。</p>\n<p>另外，Java 中的基本类型和String，CharSequence的定向tag默认且只能是in。还有，请注意，请不要滥用定向tag，而是要根据需要选取合适的——要是不管三七二十一，全都一上来就用inout，等工程大了系统的开销就会大很多——因为排列整理参数的开销是很昂贵的。</p>\n<p><strong>两种AIDL文件</strong>：在我的理解里，所有的AIDL文件大致可以分为两类。<strong>一类是用来定义parcelable对象</strong>，以供其他AIDL文件使用AIDL中非默认支持的数据类型的。<strong>一类是用来定义方法接口</strong>，以供系统使用来完成跨进程通信的。可以看到，两类文件都是在“定义”些什么，而不涉及具体的实现，这就是为什么它叫做“Android接口定义语言”。<br>注：所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。</p>\n<p>下面是两个例子，对于常见的AIDL文件都有所涉及：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Book.aidl</span></div><div class=\"line\"><span class=\"comment\">//第一类AIDL文件的例子</span></div><div class=\"line\"><span class=\"comment\">//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></div><div class=\"line\"><span class=\"comment\">//注意：Book.aidl与Book.java的包名应当是一样的</span></div><div class=\"line\"><span class=\"keyword\">package</span> com.lypeer.ipcclient;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//注意parcelable是小写</span></div><div class=\"line\">parcelable Book;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// BookManager.aidl</span></div><div class=\"line\"><span class=\"comment\">//第二类AIDL文件的例子</span></div><div class=\"line\"><span class=\"keyword\">package</span> com.lypeer.ipcclient;</div><div class=\"line\"><span class=\"comment\">//导入所需要使用的非默认支持数据类型的包</span></div><div class=\"line\"><span class=\"keyword\">import</span> com.lypeer.ipcclient.Book;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BookManager</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//所有的返回值前都不需要加任何东西，不管是什么数据类型</span></div><div class=\"line\">    <span class=\"function\">List&lt;Book&gt; <span class=\"title\">getBooks</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\">Book <span class=\"title\">getBook</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBookCount</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//传参时除了Java基本类型以及String，CharSequence之外的类型</span></div><div class=\"line\">    <span class=\"comment\">//都需要在前面加上定向tag，具体加什么量需而定</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBookPrice</span><span class=\"params\">(in Book book , <span class=\"keyword\">int</span> price)</span></span></div><div class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title\">setBookName</span><span class=\"params\">(in Book book , String name)</span></div><div class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title\">addBookIn</span><span class=\"params\">(in Book book)</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookOut</span><span class=\"params\">(out Book book)</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookInout</span><span class=\"params\">(inout Book book)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"11-Android布局的优化方案\"><a href=\"#11-Android布局的优化方案\" class=\"headerlink\" title=\"11.Android布局的优化方案\"></a>11.Android布局的优化方案</h4><ul>\n<li>层级观察器(Hierarchy Viewer)：</li>\n<li>使用layoutopt工具输出</li>\n<li>重用布局文件：<include></include></li>\n<li>使用&lt; merge /&gt;标签减少布局的嵌套层次；</li>\n<li>仅在需要时才加载布局，ViewStub</li>\n</ul>\n<h4 id=\"12-Android性能调优\"><a href=\"#12-Android性能调优\" class=\"headerlink\" title=\"12.Android性能调优\"></a>12.Android性能调优</h4><ul>\n<li>UI卡顿</li>\n<li>ANR异常</li>\n<li>内存性能优化</li>\n<li>Android API使用：<pre><code>StringBuffer/String、HashMap/ArrayMap/SparseArray\n</code></pre></li>\n</ul>\n<p>性能调优参考这篇博客<a href=\"http://blog.csdn.net/yanbober/article/details/48394201\" target=\"_blank\" rel=\"external\">Andoid应用开发性能优化完全分析</a></p>\n","excerpt":"<p>只整理android面试中涉及到的知识点。不断补充中。。。</p>\n<h4 id=\"1-Android事件传递机制\"><a href=\"#1-Android事件传递机制\" class=\"headerlink\" title=\"1.Android事件传递机制\"></a>1.Android事件传递机制</h4><p>下面内容摘选自《Android开发艺术探索》</p>\n<ul>\n<li>(1) 当一个点击事件发生之后，传递过程遵循如下顺序：<strong>Activity -&gt; Window -&gt; View</strong>。<br>如果一个view的onTouchEvent方法返回false，那么它的父容器的onTouchEvent方法将会被调用，依此类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理(调用Activity的onTouchEvent方法)。</li>\n</ul>","more":"<ul>\n<li>(2) 正常情况下，一个事件序列只能被一个view拦截并消耗，因为一旦某个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，并且该元素的<strong>onInterceptTouchEvent</strong>方法不会再被调用了。</li>\n<li>(3) 某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么<strong>同一事件序列的其他事件都不会再交给它来处理</strong>，并且事件将重新交给它的<strong>父容器去处理</strong>(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，<strong>当前view依然可以收到后续的事件</strong>，但是这些事件最后都会传递给Activity处理。</li>\n<li>(4) ViewGroup默认不拦截任何事件，因为它的<strong>onInterceptTouchEvent</strong>方法默认返回false。view没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。</li>\n<li>(5) View的<strong>onTouchEvent</strong>默认都会消耗事件(返回true)，除非它是不可点击的(clickable和longClickable都为false)。view的longClickable默认是false的，clickable则不一定，Button默认是true，而TextView默认是false。</li>\n<li>(6) <strong>View的enable属性不影响onTouchEvent的默认返回值</strong>。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。</li>\n<li>(7) 事件传递过程总是<strong>先传递给父元素</strong>，然后再由<strong>父元素分发给子view</strong>，通过<strong>requestDisallowInterceptTouchEvent</strong>方法可以在<strong>子元素中干预父元素的事件分发过程</strong>，但是<strong>ACTION_DOWN事件除外</strong>，即当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。<br>ViewGroup的dispatchTouchEvent方法中有一个标志位<strong>FLAG_DISALLOW_INTERCEPT</strong>，这个标志位就是通过<strong>子view调用requestDisallowInterceptTouchEvent方法</strong>来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。</li>\n<li>(8) 以上结论均可以在书中的源码解析部分得到解释。Window的实现类为PhoneWindow，获取Activity的contentView的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(<span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"2-OnTouchListener、onTouchEvent、OnClickListener优先级顺序\"><a href=\"#2-OnTouchListener、onTouchEvent、OnClickListener优先级顺序\" class=\"headerlink\" title=\"2.OnTouchListener、onTouchEvent、OnClickListener优先级顺序\"></a>2.OnTouchListener、onTouchEvent、OnClickListener优先级顺序</h4><p>如果给一个view设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看<strong>onTouch</strong>的返回值，如果返回false，那么当前view的<strong>onTouchEvent方法</strong>会被调用；如果返回true，那么onTouchEvent方法将不会被调用。<br>在onTouchEvent方法中，如果当前view设置了OnClickListener，那么它的onClick方法会被调用，所以OnClickListener的优先级最低。</p>\n<h4 id=\"3-AsyncTask的方法介绍\"><a href=\"#3-AsyncTask的方法介绍\" class=\"headerlink\" title=\"3.AsyncTask的方法介绍\"></a>3.AsyncTask的方法介绍</h4><h4 id=\"4-项目中Handler怎么使用？\"><a href=\"#4-项目中Handler怎么使用？\" class=\"headerlink\" title=\"4.项目中Handler怎么使用？\"></a>4.项目中Handler怎么使用？</h4><h4 id=\"5-项目中图片的适配问题怎么解决？\"><a href=\"#5-项目中图片的适配问题怎么解决？\" class=\"headerlink\" title=\"5.项目中图片的适配问题怎么解决？\"></a>5.项目中图片的适配问题怎么解决？</h4><h4 id=\"6-Android存储敏感信息的方式有？\"><a href=\"#6-Android存储敏感信息的方式有？\" class=\"headerlink\" title=\"6.Android存储敏感信息的方式有？\"></a>6.Android存储敏感信息的方式有？</h4><h4 id=\"7-自定义广播\"><a href=\"#7-自定义广播\" class=\"headerlink\" title=\"7.自定义广播\"></a>7.自定义广播</h4><ul>\n<li>继承自BroadcastReceiver</li>\n<li>重写onReceive(Context,Intent)<pre><code>Intent.getAction\n</code></pre></li>\n<li>动态注册（Context.registerReceiver()），静态注册（使用IntentFilter指定action）</li>\n</ul>\n<h4 id=\"8-加分项\"><a href=\"#8-加分项\" class=\"headerlink\" title=\"8.加分项\"></a>8.加分项</h4><ul>\n<li>JNI开发</li>\n<li>性能优化</li>\n<li>优秀作品</li>\n</ul>\n<h4 id=\"9-Sqlite数据库更新并保留升级前的数据\"><a href=\"#9-Sqlite数据库更新并保留升级前的数据\" class=\"headerlink\" title=\"9.Sqlite数据库更新并保留升级前的数据\"></a>9.Sqlite数据库更新并保留升级前的数据</h4><p>我们知道在SQLiteOpenHelper的构造方法:</p>\n<pre><code>super(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)\n</code></pre><p>中最后一个参数表示数据库的版本号.当新的版本号大于当前的version时会调用方法:</p>\n<pre><code>onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)\n</code></pre><p>所以我们的重点是在该方法中实现SQLite数据库版本升级的管理</p>\n<p>对于保留升级前的数据，有两种解决办法：</p>\n<p><strong>SQLite提供了ALTER TABLE命令</strong>，允许用户重命名或添加新的字段到已有表中，但是不能从表中删除字段。并且只能在表的末尾添加字段，比如，为Subscription添加两个字段：</p>\n<ul>\n<li>ALTER TABLE Subscription ADD COLUMN Activation BLOB;</li>\n<li>ALTER TABLE Subscription ADD COLUMN Key BLOB;</li>\n</ul>\n<p><strong>注释</strong>：Sqlite支持BLOB(二进制大对象)数据类型</p>\n<p><strong>保留数据删除原表创建新表</strong>，具体思路是：</p>\n<ul>\n<li>1：将表A重新命名：例如重新命名为：temp_A</li>\n<li>2：创建新表A</li>\n<li>3：将temp_A中的数据【也就是更新前的数据】插入到新表A</li>\n</ul>\n<p>具体操作如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//重命名原来的数据表</div><div class=\"line\">public static final String TEMP_SQL_CREATE_TABLE_SUBSCRIBE = \"alter table \"</div><div class=\"line\">            + A + \" rename to temp_A\";</div><div class=\"line\"></div><div class=\"line\">//然后把备份表temp_A中的数据copy到新创建的数据库表A中，这个表A没发生结构上的变化</div><div class=\"line\">public static final String INSERT_SUBSCRIBE = \"select 'insert into A (code,name,username,tablename)</div><div class=\"line\">                        values (\"code\",\"name\",\"cnki\",\"tablename\")' as insertSQL from temp_A\";</div><div class=\"line\"></div><div class=\"line\">//删除备份表</div><div class=\"line\">public static final String DELETE_TEMP_SUBSCRIBE = \"delete from temp_A \";</div><div class=\"line\">public static final String DROP_TEMP_SUBSCRIBE = \"drop table if exists temp_A\";</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</div><div class=\"line\"></div><div class=\"line\">        for (int j = oldVersion; j &lt;= newVersion; j++) &#123;</div><div class=\"line\">            switch (j) &#123;</div><div class=\"line\">            case 2:</div><div class=\"line\">　　　　　　　　　//创建临时表</div><div class=\"line\">                db.execSQL(TEMP_SQL_CREATE_TABLE_SUBSCRIBE);</div><div class=\"line\">　　 　　　　　　//执行OnCreate方法，这个方法中放的是表的初始化操作工作，比如创建新表之类的</div><div class=\"line\">                onCreate(db);</div><div class=\"line\">　　　　　　　　　//删除之前的表里面的默认数据</div><div class=\"line\">                for (int i = 0; i &lt; arrWhereAct.length; i++) &#123;</div><div class=\"line\">                    db.execSQL(DELETE_TEMP_SUBSCRIBE + arrWhereAct[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                //将临时表中的数据放入表A</div><div class=\"line\">　　　　　　　　　Cursor cursor = db.rawQuery(INSERT_SUBSCRIBE, null);</div><div class=\"line\">                if (cursor.moveToFirst()) &#123;</div><div class=\"line\">                    do &#123;</div><div class=\"line\">                        db.execSQL(cursor.getString(cursor</div><div class=\"line\">                                .getColumnIndex(\"insertSQL\")));</div><div class=\"line\">                    &#125; while (cursor.moveToNext());</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                cursor.close();</div><div class=\"line\">　　　　　　　　　//将临时表删除掉</div><div class=\"line\">                db.execSQL(DROP_TEMP_SUBSCRIBE);</div><div class=\"line\"></div><div class=\"line\">                break;</div><div class=\"line\"></div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意</strong>，为什么要在方法里写for循环，主要是考虑到跨版本升级，比如有的用户一直不升级版本，数据库版本号一直是1，而客户端最新版本其实对应的数据库版本已经是4了，那么我中途可能对数据库做了很多修改，通过这个for循环，可以迭代升级，不会发生错误。</p>\n</blockquote>\n<h4 id=\"10-AIDL支持的数据类型\"><a href=\"#10-AIDL支持的数据类型\" class=\"headerlink\" title=\"10.AIDL支持的数据类型\"></a>10.AIDL支持的数据类型</h4><p>其实AIDL这门语言非常的简单，基本上它的语法和 Java 是一样的，只是在一些细微处有些许差别——毕竟它只是被创造出来简化Android程序员工作的，太复杂不好——所以在这里我就着重的说一下它和 Java 不一样的地方。主要有下面这些点：</p>\n<p><strong>文件类型</strong>：用AIDL书写的文件的后缀是 .aidl，而不是 .java。</p>\n<p><strong>数据类型</strong>：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，就算目标文件与当前正在编写的 .aidl 文件在同一个包下——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文件，一个叫做Book.java ，另一个叫做 BookManager.aidl，它们都在 com.lypeer.aidldemo 包下 ，现在我们需要在 .aidl 文件里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 import com.lypeer.aidldemo.Book; 哪怕 .java 文件和 .aidl 文件就在一个包下。</p>\n<p>   默认支持的数据类型包括：</p>\n<ul>\n<li>Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char。</li>\n<li>String 类型。</li>\n<li>CharSequence类型。</li>\n<li>List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable（下文关于这个会有详解）。List可以使用泛型。</li>\n<li>Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的。</li>\n</ul>\n<p><strong>定向tag</strong>：这是一个极易被忽略的点——这里的“被忽略”指的不是大家都不知道，而是很少人会正确的使用它。在我的理解里，定向tag是这样的：AIDL中的定向tag表示了在跨进程通信中数据的流向，其中<strong>in表示数据只能由客户端流向服务端</strong>，<strong>out表示数据只能由服务端流向客户端</strong>，<strong>而inout则表示数据可在服务端与客户端之间双向流通</strong>。其中，<strong>数据流向是针对在客户端中的那个传入方法的对象而言的</strong>。in为定向tag的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；out的话表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；inout为定向tag的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。</p>\n<p>另外，Java 中的基本类型和String，CharSequence的定向tag默认且只能是in。还有，请注意，请不要滥用定向tag，而是要根据需要选取合适的——要是不管三七二十一，全都一上来就用inout，等工程大了系统的开销就会大很多——因为排列整理参数的开销是很昂贵的。</p>\n<p><strong>两种AIDL文件</strong>：在我的理解里，所有的AIDL文件大致可以分为两类。<strong>一类是用来定义parcelable对象</strong>，以供其他AIDL文件使用AIDL中非默认支持的数据类型的。<strong>一类是用来定义方法接口</strong>，以供系统使用来完成跨进程通信的。可以看到，两类文件都是在“定义”些什么，而不涉及具体的实现，这就是为什么它叫做“Android接口定义语言”。<br>注：所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。</p>\n<p>下面是两个例子，对于常见的AIDL文件都有所涉及：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Book.aidl</span></div><div class=\"line\"><span class=\"comment\">//第一类AIDL文件的例子</span></div><div class=\"line\"><span class=\"comment\">//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></div><div class=\"line\"><span class=\"comment\">//注意：Book.aidl与Book.java的包名应当是一样的</span></div><div class=\"line\"><span class=\"keyword\">package</span> com.lypeer.ipcclient;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//注意parcelable是小写</span></div><div class=\"line\">parcelable Book;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// BookManager.aidl</span></div><div class=\"line\"><span class=\"comment\">//第二类AIDL文件的例子</span></div><div class=\"line\"><span class=\"keyword\">package</span> com.lypeer.ipcclient;</div><div class=\"line\"><span class=\"comment\">//导入所需要使用的非默认支持数据类型的包</span></div><div class=\"line\"><span class=\"keyword\">import</span> com.lypeer.ipcclient.Book;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BookManager</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//所有的返回值前都不需要加任何东西，不管是什么数据类型</span></div><div class=\"line\">    <span class=\"function\">List&lt;Book&gt; <span class=\"title\">getBooks</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\">Book <span class=\"title\">getBook</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBookCount</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//传参时除了Java基本类型以及String，CharSequence之外的类型</span></div><div class=\"line\">    <span class=\"comment\">//都需要在前面加上定向tag，具体加什么量需而定</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBookPrice</span><span class=\"params\">(in Book book , <span class=\"keyword\">int</span> price)</span></div><div class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title\">setBookName</span><span class=\"params\">(in Book book , String name)</span></div><div class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title\">addBookIn</span><span class=\"params\">(in Book book)</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookOut</span><span class=\"params\">(out Book book)</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBookInout</span><span class=\"params\">(inout Book book)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"11-Android布局的优化方案\"><a href=\"#11-Android布局的优化方案\" class=\"headerlink\" title=\"11.Android布局的优化方案\"></a>11.Android布局的优化方案</h4><ul>\n<li>层级观察器(Hierarchy Viewer)：</li>\n<li>使用layoutopt工具输出</li>\n<li>重用布局文件：<include></li>\n<li>使用&lt; merge /&gt;标签减少布局的嵌套层次；</li>\n<li>仅在需要时才加载布局，ViewStub</li>\n</ul>\n<h4 id=\"12-Android性能调优\"><a href=\"#12-Android性能调优\" class=\"headerlink\" title=\"12.Android性能调优\"></a>12.Android性能调优</h4><ul>\n<li>UI卡顿</li>\n<li>ANR异常</li>\n<li>内存性能优化</li>\n<li>Android API使用：<pre><code>StringBuffer/String、HashMap/ArrayMap/SparseArray\n</code></pre></li>\n</ul>\n<p>性能调优参考这篇博客<a href=\"http://blog.csdn.net/yanbober/article/details/48394201\">Andoid应用开发性能优化完全分析</a></p>"},{"layout":"post","title":"gradle 学习","keywords":"Android,gradle","banner":"http://obxk8w81b.bkt.clouddn.com/Crab%20on%20Its%20Back.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Crab%20on%20Its%20Back.jpg","_content":"\n\nGradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库\n\n### Gradle的基本组成\n\n> 项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。\n\n<!--more-->\n\n- 项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。\n\n- 任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。\n\n- 每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）\n\n![basic structure](/images/blogimages/2016/gradle_structure1.png)\n\n一个工程的Build，是由多个Project组成，而一个Project又是由task组成的\n\n任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。\n\n#### Gradle构建系统的组成\n\nGradle的构建系统是由以下几个文件组成\n\n- build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的\n\n- settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的\n\n- gradle.properties 用来配置构建属性，这个不是必须的\n\n### Gradle插件\nGradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 apply plugin: 'java'\n\n这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task:\n\n- 1.gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等\n- 2.gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试\n- 3.gradle clean：删除 build 生成的目录和所有生成的文件\n- 4.gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs\n\nGradle各个task的关系图：\n\n![basic task](/images/blogimages/2016/gradle_task.png)\n\n从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。\n\n#### 外部依赖\n\n通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。\n\n首先，指定maven的仓库地址：\n\n~~~ Java\nrepositories {\n\tmavenCentral()\n}\n~~~\nmavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。\n\n~~~ Java\ndependencies {\n\tcompile group: 'commons-collections', name: 'commons-collections', version: '3.2'\n\t// 简化写法\n\t// compile 'commons-collections:commons-collections:3.2'\n}\n~~~\n引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。\n\n#### 本地依赖\n\nGradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包\n\n~~~ Java\ndependencies {\n\tcompile files('dir/file.jar')\n\tcompile fileTree(dir: 'libs', include: '*.jar')\n}\n~~~\n#### 项目依赖\n\n往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。\n\n~~~ Java\ninclude 'sub-project1', 'sub-project2', 'sub-project3'\n~~~\n如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可：\n\n~~~ Java\ndependencies {\n\tcompile project(':sub-project2')\n}\n~~~\n#### 依赖关系管理\n\n从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。\n\n例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如：\n\n~~~ Java\napply plugin: 'java'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n    testCompile group: 'junit', name: 'junit', version: '4.+'\n}\n~~~\n在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活\n\nJava 插件中定义了许多标准的配置，例如如下：\n\n> - compile\n\t用来编译项目源代码的\n- runtime\n\t在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。\n- testCompile\n\t编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。\n- testRuntime\n\t运行测试所需要的依赖。 默认的, 包含上面三个依赖。\n","source":"_posts/2016-10-12-gradle-learning.md","raw":"---\nlayout: post\ntitle:  gradle 学习\ncategory: accumulation\ntags: gradle\nkeywords: Android,gradle\nbanner: http://obxk8w81b.bkt.clouddn.com/Crab%20on%20Its%20Back.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Crab%20on%20Its%20Back.jpg\n---\n\n\nGradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库\n\n### Gradle的基本组成\n\n> 项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。\n\n<!--more-->\n\n- 项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。\n\n- 任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。\n\n- 每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）\n\n![basic structure](/images/blogimages/2016/gradle_structure1.png)\n\n一个工程的Build，是由多个Project组成，而一个Project又是由task组成的\n\n任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。\n\n#### Gradle构建系统的组成\n\nGradle的构建系统是由以下几个文件组成\n\n- build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的\n\n- settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的\n\n- gradle.properties 用来配置构建属性，这个不是必须的\n\n### Gradle插件\nGradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 apply plugin: 'java'\n\n这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task:\n\n- 1.gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等\n- 2.gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试\n- 3.gradle clean：删除 build 生成的目录和所有生成的文件\n- 4.gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs\n\nGradle各个task的关系图：\n\n![basic task](/images/blogimages/2016/gradle_task.png)\n\n从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。\n\n#### 外部依赖\n\n通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。\n\n首先，指定maven的仓库地址：\n\n~~~ Java\nrepositories {\n\tmavenCentral()\n}\n~~~\nmavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。\n\n~~~ Java\ndependencies {\n\tcompile group: 'commons-collections', name: 'commons-collections', version: '3.2'\n\t// 简化写法\n\t// compile 'commons-collections:commons-collections:3.2'\n}\n~~~\n引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。\n\n#### 本地依赖\n\nGradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包\n\n~~~ Java\ndependencies {\n\tcompile files('dir/file.jar')\n\tcompile fileTree(dir: 'libs', include: '*.jar')\n}\n~~~\n#### 项目依赖\n\n往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。\n\n~~~ Java\ninclude 'sub-project1', 'sub-project2', 'sub-project3'\n~~~\n如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可：\n\n~~~ Java\ndependencies {\n\tcompile project(':sub-project2')\n}\n~~~\n#### 依赖关系管理\n\n从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。\n\n例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如：\n\n~~~ Java\napply plugin: 'java'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'\n    testCompile group: 'junit', name: 'junit', version: '4.+'\n}\n~~~\n在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活\n\nJava 插件中定义了许多标准的配置，例如如下：\n\n> - compile\n\t用来编译项目源代码的\n- runtime\n\t在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。\n- testCompile\n\t编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。\n- testRuntime\n\t运行测试所需要的依赖。 默认的, 包含上面三个依赖。\n","slug":"gradle-learning","published":1,"date":"2016-10-11T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5m0021bxs6vcvynsxr","content":"<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>\n<h3 id=\"Gradle的基本组成\"><a href=\"#Gradle的基本组成\" class=\"headerlink\" title=\"Gradle的基本组成\"></a>Gradle的基本组成</h3><blockquote>\n<p>项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li><p>项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。</p>\n</li>\n<li><p>任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。</p>\n</li>\n<li><p>每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）</p>\n</li>\n</ul>\n<p><img src=\"/images/blogimages/2016/gradle_structure1.png\" alt=\"basic structure\"></p>\n<p>一个工程的Build，是由多个Project组成，而一个Project又是由task组成的</p>\n<p>任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。</p>\n<h4 id=\"Gradle构建系统的组成\"><a href=\"#Gradle构建系统的组成\" class=\"headerlink\" title=\"Gradle构建系统的组成\"></a>Gradle构建系统的组成</h4><p>Gradle的构建系统是由以下几个文件组成</p>\n<ul>\n<li><p>build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的</p>\n</li>\n<li><p>settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的</p>\n</li>\n<li><p>gradle.properties 用来配置构建属性，这个不是必须的</p>\n</li>\n</ul>\n<h3 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h3><p>Gradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 apply plugin: ‘java’</p>\n<p>这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task:</p>\n<ul>\n<li>1.gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等</li>\n<li>2.gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试</li>\n<li>3.gradle clean：删除 build 生成的目录和所有生成的文件</li>\n<li>4.gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs</li>\n</ul>\n<p>Gradle各个task的关系图：</p>\n<p><img src=\"/images/blogimages/2016/gradle_task.png\" alt=\"basic task\"></p>\n<p>从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。</p>\n<h4 id=\"外部依赖\"><a href=\"#外部依赖\" class=\"headerlink\" title=\"外部依赖\"></a>外部依赖</h4><p>通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。</p>\n<p>首先，指定maven的仓库地址：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">\tmavenCentral()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>mavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">\tcompile group: <span class=\"string\">'commons-collections'</span>, name: <span class=\"string\">'commons-collections'</span>, version: <span class=\"string\">'3.2'</span></div><div class=\"line\">\t<span class=\"comment\">// 简化写法</span></div><div class=\"line\">\t<span class=\"comment\">// compile 'commons-collections:commons-collections:3.2'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。</p>\n<h4 id=\"本地依赖\"><a href=\"#本地依赖\" class=\"headerlink\" title=\"本地依赖\"></a>本地依赖</h4><p>Gradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">\t<span class=\"function\">compile <span class=\"title\">files</span><span class=\"params\">(<span class=\"string\">'dir/file.jar'</span>)</span></span></div><div class=\"line\">\tcompile <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: <span class=\"string\">'*.jar'</span>)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"项目依赖\"><a href=\"#项目依赖\" class=\"headerlink\" title=\"项目依赖\"></a>项目依赖</h4><p>往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">include <span class=\"string\">'sub-project1'</span>, <span class=\"string\">'sub-project2'</span>, <span class=\"string\">'sub-project3'</span></div></pre></td></tr></table></figure>\n<p>如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">\t<span class=\"function\">compile <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">':sub-project2'</span>)</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"依赖关系管理\"><a href=\"#依赖关系管理\" class=\"headerlink\" title=\"依赖关系管理\"></a>依赖关系管理</h4><p>从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。</p>\n<p>例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">apply plugin: <span class=\"string\">'java'</span></div><div class=\"line\"></div><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile group: <span class=\"string\">'org.hibernate'</span>, name: <span class=\"string\">'hibernate-core'</span>, version: <span class=\"string\">'3.6.7.Final'</span></div><div class=\"line\">    testCompile group: <span class=\"string\">'junit'</span>, name: <span class=\"string\">'junit'</span>, version: <span class=\"string\">'4.+'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活</p>\n<p>Java 插件中定义了许多标准的配置，例如如下：</p>\n<blockquote>\n<ul>\n<li>compile<br>  用来编译项目源代码的</li>\n<li>runtime<br>  在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。</li>\n<li>testCompile<br>  编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。</li>\n<li>testRuntime<br>  运行测试所需要的依赖。 默认的, 包含上面三个依赖。</li>\n</ul>\n</blockquote>\n","excerpt":"<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>\n<h3 id=\"Gradle的基本组成\"><a href=\"#Gradle的基本组成\" class=\"headerlink\" title=\"Gradle的基本组成\"></a>Gradle的基本组成</h3><blockquote>\n<p>项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。</p>\n</blockquote>","more":"<ul>\n<li><p>项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。</p>\n</li>\n<li><p>任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。</p>\n</li>\n<li><p>每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）</p>\n</li>\n</ul>\n<p><img src=\"/images/blogimages/2016/gradle_structure1.png\" alt=\"basic structure\"></p>\n<p>一个工程的Build，是由多个Project组成，而一个Project又是由task组成的</p>\n<p>任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。</p>\n<h4 id=\"Gradle构建系统的组成\"><a href=\"#Gradle构建系统的组成\" class=\"headerlink\" title=\"Gradle构建系统的组成\"></a>Gradle构建系统的组成</h4><p>Gradle的构建系统是由以下几个文件组成</p>\n<ul>\n<li><p>build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的</p>\n</li>\n<li><p>settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的</p>\n</li>\n<li><p>gradle.properties 用来配置构建属性，这个不是必须的</p>\n</li>\n</ul>\n<h3 id=\"Gradle插件\"><a href=\"#Gradle插件\" class=\"headerlink\" title=\"Gradle插件\"></a>Gradle插件</h3><p>Gradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 apply plugin: ‘java’</p>\n<p>这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task:</p>\n<ul>\n<li>1.gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等</li>\n<li>2.gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试</li>\n<li>3.gradle clean：删除 build 生成的目录和所有生成的文件</li>\n<li>4.gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs</li>\n</ul>\n<p>Gradle各个task的关系图：</p>\n<p><img src=\"/images/blogimages/2016/gradle_task.png\" alt=\"basic task\"></p>\n<p>从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。</p>\n<h4 id=\"外部依赖\"><a href=\"#外部依赖\" class=\"headerlink\" title=\"外部依赖\"></a>外部依赖</h4><p>通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。</p>\n<p>首先，指定maven的仓库地址：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">repositories &#123;</div><div class=\"line\">\tmavenCentral()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>mavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">\tcompile group: <span class=\"string\">'commons-collections'</span>, name: <span class=\"string\">'commons-collections'</span>, version: <span class=\"string\">'3.2'</span></div><div class=\"line\">\t<span class=\"comment\">// 简化写法</span></div><div class=\"line\">\t<span class=\"comment\">// compile 'commons-collections:commons-collections:3.2'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。</p>\n<h4 id=\"本地依赖\"><a href=\"#本地依赖\" class=\"headerlink\" title=\"本地依赖\"></a>本地依赖</h4><p>Gradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">\t<span class=\"function\">compile <span class=\"title\">files</span><span class=\"params\">(<span class=\"string\">'dir/file.jar'</span>)</span></div><div class=\"line\">\tcompile <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: <span class=\"string\">'*.jar'</span>)</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<h4 id=\"项目依赖\"><a href=\"#项目依赖\" class=\"headerlink\" title=\"项目依赖\"></a>项目依赖</h4><p>往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">include <span class=\"string\">'sub-project1'</span>, <span class=\"string\">'sub-project2'</span>, <span class=\"string\">'sub-project3'</span></div></pre></td></tr></table></figure>\n<p>如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">\t<span class=\"function\">compile <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">':sub-project2'</span>)</span></div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<h4 id=\"依赖关系管理\"><a href=\"#依赖关系管理\" class=\"headerlink\" title=\"依赖关系管理\"></a>依赖关系管理</h4><p>从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。</p>\n<p>例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">apply plugin: <span class=\"string\">'java'</span></div><div class=\"line\"></div><div class=\"line\">repositories &#123;</div><div class=\"line\">    mavenCentral()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile group: <span class=\"string\">'org.hibernate'</span>, name: <span class=\"string\">'hibernate-core'</span>, version: <span class=\"string\">'3.6.7.Final'</span></div><div class=\"line\">    testCompile group: <span class=\"string\">'junit'</span>, name: <span class=\"string\">'junit'</span>, version: <span class=\"string\">'4.+'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活</p>\n<p>Java 插件中定义了许多标准的配置，例如如下：</p>\n<blockquote>\n<ul>\n<li>compile<br>  用来编译项目源代码的</li>\n<li>runtime<br>  在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。</li>\n<li>testCompile<br>  编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。</li>\n<li>testRuntime<br>  运行测试所需要的依赖。 默认的, 包含上面三个依赖。</li>\n</ul>\n</blockquote>"},{"layout":"post","title":"gradle 学习2——生成指定文件名的apk","keywords":"Android,gradle","banner":"http://obxk8w81b.bkt.clouddn.com/Cart%20with%20Red%20and%20White%20Ox.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Cart%20with%20Red%20and%20White%20Ox.jpg","_content":"\n上一篇[Gradle学习]()了解了Gradle的基本结构和依赖关系，这篇文章介绍下怎么在Android上使用Gradle生成指定包名的APK\n\n### 需求场景\n在我们Android开发基本进入测试阶段后，会根据后台的不同环境，打包出对应不同环境（如SIT、UAT、PRD等）的APK安装包。\n\n每次去手动修改Java类改变后台环境太麻烦还容易忘记修改。打包成功后，还需要手动将默认的包名app-release.apk改成我们需要的包名，也是非常麻烦，有没有直接指定环境，生成指定文件名的安装包呢？\n\n方法是有的，就是利用gradle的分渠道打包特性，下面上代码分别解释。\n\n> 主要在这两个个地方修改：\n- buildType（构建类型）\n- productFlavors （不同定制的产品）\n\n<!--more-->\n#### buildType（构建类型）介绍\n\n默认情况下，Android Plugin会自动给项目设置同时构建应用程序的debug和release版本。 两个版本之间的不同主要围绕着能否在一个安全设备上调试，以及APK如何签名。\n\n可以创建一个新的构建类型就是简单的在buildType标签下添加一个新的元素，并且可以使用initWith()或者直接使用闭包来配置它。\n\n以下是一些可能使用到的属性和默认值：\n\n|*Property name\t*|*Default values for debug\t*|*Default values for release / other*|\n|:--------:|:-------:|:--------:|\n|debuggable\t            | true\t|false |\n|jniDebugBuild\t        | false\t|false|\n|renderscriptDebugBuild\t| false\t|false|\n|renderscriptOptimLevel\t|   3\t|3|\n|applicationIdSuffix\t|  null\t|null|\n|versionNameSuffix\t    |  null\t|null|\n|signingConfig\t  |android.signingConfigs.debug\t|null|\n|zipAlign\t             |false\t|true|\n|runProguard\t         |false\t|false|\n|proguardFile\t     |N/A (set only)\t|N/A (set only)|\n|proguardFiles\t     |N/A (set only)\t|N/A (set only)|\n\n上面介绍摘选自[Gralde plugin User Guide 中文版](https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/basic_project/build_types.html)\n\n\n#### Product flavors（不同定制的产品）介绍\n一个product flavor定义了从项目中构建了一个应用的自定义版本。一个单一的项目可以同时定义多个不同的flavor来改变应用的输出。\n\n这个新的设计概念是为了解决不同的版本之间的差异非常小的情况。虽然最项目终生成了多个定制的版本，但是它们本质上都是同一个应用，那么这种做法可能是比使用库项目更好的实现方式。\n\nProduct flavor需要在productFlavors这个DSL容器中声明：\n\n~~~ Java\nandroid {\n    ....\n\n    productFlavors {\n        flavor1 {\n            ...\n        }\n\n        flavor2 {\n            ...\n        }\n    }\n}\n~~~\n这里创建了两个flavor，名为flavor1和flavor2。\n\n> 注意：flavor的命名不能与已存在的Build Type或者androidTest这个sourceSet有冲突。\n\n#### Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）\n正如前面章节所提到的，每一个Build Type都会生成一个新的APK。\n\nProduct Flavor同样也会做这些事情：项目的输出将会拼接所有可能的Build Type和Product Flavor（如果有Flavor定义存在的话）的组合。\n\n每一种组合（包含Build Type和Product Flavor）就是一个Build Variant（构建变种版本）。\n\n例如，在上面的Flavor声明例子中与默认的debug和release两个Build Type将会生成4个Build Variant：\n\n- Flavor1 - debug\n- Flavor1 - release\n- Flavor2 - debug\n- Flavor2 - release\n\n项目中如果没有定义flavor同样也会有Build Variant，只是使用的是默认的flavor和配置。default(默认)的flavor/config是没有名字的，所以生成的Build Variant列表看起来就跟Build Type列表一样。\n\n### 具体使用\n我们的需求就要用到**Build Type**和**Product Flavor**\n我在项目中**Build Type**的使用，先看代码：\n\n~~~ Java\nbuildTypes {\n        release {\n            buildConfigField \"boolean\", \"LEO_DEBUG\", \"false\"\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'\n            debuggable false\n            jniDebuggable false\n        }\n        debug {\n            buildConfigField \"int\", \"buildType\", \"2\"\n            buildConfigField \"boolean\", \"LEO_DEBUG\", \"true\"\n        }\n    }\n~~~\n和**Product Flavor**的使用\n\n~~~ Java\nproductFlavors{\n\t\t\t kaifa{\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"1\"\n\t\t\t }\n\t\t\t ceshi {\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"2\"\n\t\t\t }\n\t\t\t SIT {\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"3\"\n\t\t\t }\n\t\t\t UAT {\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"4\"\n\t\t\t }\n\t\t\t PRD {\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"5\"\n\t\t\t }\n\t }\n~~~\n每一个构建过的productFlavors都会在**app->build->generated->source->buildConfig**目录下创建自己对应的一个flavor目录，如下图：\n\n![Gradle build structure](/images/blogimages/2016/gradle_structure2.png)\n\n而，buildConfigField会在指定的目录，**flavor->release/debug->包名**，下生成一个BuildConfig.java文件，我的代码在BuildConfig.java中定义了一个int类型的buildType和boolean类型的LEO_DEBUG。要使用这两个字段只需要:\n\n~~~ Java\nif (BuildConfig.LEO_DEBUG){\n\t\t//用来控制本地Log日志\n}\nif (Environment ==BuildConfig.buildType){\n\t\t//用来控制开发环境\n}\n~~~\n\n#### gradle中修改apk生成名字的方法\n这个方法是定义在productFlavors同一层级的\n\n~~~ Java\nandroid.applicationVariants.all { variant ->\n        variant.outputs.each { output ->\n            def outputFile = output.outputFile\n            if (outputFile != null && outputFile.name.endsWith('.apk')) {\n                //这里修改apk文件名\n                def flavorname =variant.productFlavors[0].name\n                if (flavorname.equals('kaifa'))\n                    flavorname = 'debug'\n                else if (flavorname.equals('ceshi'))\n                    flavorname = 'release'\n\n                def fileName = \"app-${flavorname}-${defaultConfig.versionName}-${releaseTime() }.apk\"\n                output.outputFile = new File(outputFile.parent, fileName)\n            }\n        }\n    }\n~~~\n\n这个方法要定义在最外层\n~~~ Java\ndef releaseTime() {\n    return new Date().format(\"MMdd\", TimeZone.getTimeZone(\"UTC\"))\n}\n~~~\n\n最后生成的apk名字\n","source":"_posts/2016-10-13-gradle-learning2.md","raw":"---\nlayout: post\ntitle:  gradle 学习2——生成指定文件名的apk\ncategory: accumulation\ntags: gradle\nkeywords: Android,gradle\nbanner: http://obxk8w81b.bkt.clouddn.com/Cart%20with%20Red%20and%20White%20Ox.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Cart%20with%20Red%20and%20White%20Ox.jpg\n---\n\n上一篇[Gradle学习]()了解了Gradle的基本结构和依赖关系，这篇文章介绍下怎么在Android上使用Gradle生成指定包名的APK\n\n### 需求场景\n在我们Android开发基本进入测试阶段后，会根据后台的不同环境，打包出对应不同环境（如SIT、UAT、PRD等）的APK安装包。\n\n每次去手动修改Java类改变后台环境太麻烦还容易忘记修改。打包成功后，还需要手动将默认的包名app-release.apk改成我们需要的包名，也是非常麻烦，有没有直接指定环境，生成指定文件名的安装包呢？\n\n方法是有的，就是利用gradle的分渠道打包特性，下面上代码分别解释。\n\n> 主要在这两个个地方修改：\n- buildType（构建类型）\n- productFlavors （不同定制的产品）\n\n<!--more-->\n#### buildType（构建类型）介绍\n\n默认情况下，Android Plugin会自动给项目设置同时构建应用程序的debug和release版本。 两个版本之间的不同主要围绕着能否在一个安全设备上调试，以及APK如何签名。\n\n可以创建一个新的构建类型就是简单的在buildType标签下添加一个新的元素，并且可以使用initWith()或者直接使用闭包来配置它。\n\n以下是一些可能使用到的属性和默认值：\n\n|*Property name\t*|*Default values for debug\t*|*Default values for release / other*|\n|:--------:|:-------:|:--------:|\n|debuggable\t            | true\t|false |\n|jniDebugBuild\t        | false\t|false|\n|renderscriptDebugBuild\t| false\t|false|\n|renderscriptOptimLevel\t|   3\t|3|\n|applicationIdSuffix\t|  null\t|null|\n|versionNameSuffix\t    |  null\t|null|\n|signingConfig\t  |android.signingConfigs.debug\t|null|\n|zipAlign\t             |false\t|true|\n|runProguard\t         |false\t|false|\n|proguardFile\t     |N/A (set only)\t|N/A (set only)|\n|proguardFiles\t     |N/A (set only)\t|N/A (set only)|\n\n上面介绍摘选自[Gralde plugin User Guide 中文版](https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/basic_project/build_types.html)\n\n\n#### Product flavors（不同定制的产品）介绍\n一个product flavor定义了从项目中构建了一个应用的自定义版本。一个单一的项目可以同时定义多个不同的flavor来改变应用的输出。\n\n这个新的设计概念是为了解决不同的版本之间的差异非常小的情况。虽然最项目终生成了多个定制的版本，但是它们本质上都是同一个应用，那么这种做法可能是比使用库项目更好的实现方式。\n\nProduct flavor需要在productFlavors这个DSL容器中声明：\n\n~~~ Java\nandroid {\n    ....\n\n    productFlavors {\n        flavor1 {\n            ...\n        }\n\n        flavor2 {\n            ...\n        }\n    }\n}\n~~~\n这里创建了两个flavor，名为flavor1和flavor2。\n\n> 注意：flavor的命名不能与已存在的Build Type或者androidTest这个sourceSet有冲突。\n\n#### Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）\n正如前面章节所提到的，每一个Build Type都会生成一个新的APK。\n\nProduct Flavor同样也会做这些事情：项目的输出将会拼接所有可能的Build Type和Product Flavor（如果有Flavor定义存在的话）的组合。\n\n每一种组合（包含Build Type和Product Flavor）就是一个Build Variant（构建变种版本）。\n\n例如，在上面的Flavor声明例子中与默认的debug和release两个Build Type将会生成4个Build Variant：\n\n- Flavor1 - debug\n- Flavor1 - release\n- Flavor2 - debug\n- Flavor2 - release\n\n项目中如果没有定义flavor同样也会有Build Variant，只是使用的是默认的flavor和配置。default(默认)的flavor/config是没有名字的，所以生成的Build Variant列表看起来就跟Build Type列表一样。\n\n### 具体使用\n我们的需求就要用到**Build Type**和**Product Flavor**\n我在项目中**Build Type**的使用，先看代码：\n\n~~~ Java\nbuildTypes {\n        release {\n            buildConfigField \"boolean\", \"LEO_DEBUG\", \"false\"\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'\n            debuggable false\n            jniDebuggable false\n        }\n        debug {\n            buildConfigField \"int\", \"buildType\", \"2\"\n            buildConfigField \"boolean\", \"LEO_DEBUG\", \"true\"\n        }\n    }\n~~~\n和**Product Flavor**的使用\n\n~~~ Java\nproductFlavors{\n\t\t\t kaifa{\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"1\"\n\t\t\t }\n\t\t\t ceshi {\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"2\"\n\t\t\t }\n\t\t\t SIT {\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"3\"\n\t\t\t }\n\t\t\t UAT {\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"4\"\n\t\t\t }\n\t\t\t PRD {\n\t\t\t\t\t buildConfigField \"int\", \"buildType\", \"5\"\n\t\t\t }\n\t }\n~~~\n每一个构建过的productFlavors都会在**app->build->generated->source->buildConfig**目录下创建自己对应的一个flavor目录，如下图：\n\n![Gradle build structure](/images/blogimages/2016/gradle_structure2.png)\n\n而，buildConfigField会在指定的目录，**flavor->release/debug->包名**，下生成一个BuildConfig.java文件，我的代码在BuildConfig.java中定义了一个int类型的buildType和boolean类型的LEO_DEBUG。要使用这两个字段只需要:\n\n~~~ Java\nif (BuildConfig.LEO_DEBUG){\n\t\t//用来控制本地Log日志\n}\nif (Environment ==BuildConfig.buildType){\n\t\t//用来控制开发环境\n}\n~~~\n\n#### gradle中修改apk生成名字的方法\n这个方法是定义在productFlavors同一层级的\n\n~~~ Java\nandroid.applicationVariants.all { variant ->\n        variant.outputs.each { output ->\n            def outputFile = output.outputFile\n            if (outputFile != null && outputFile.name.endsWith('.apk')) {\n                //这里修改apk文件名\n                def flavorname =variant.productFlavors[0].name\n                if (flavorname.equals('kaifa'))\n                    flavorname = 'debug'\n                else if (flavorname.equals('ceshi'))\n                    flavorname = 'release'\n\n                def fileName = \"app-${flavorname}-${defaultConfig.versionName}-${releaseTime() }.apk\"\n                output.outputFile = new File(outputFile.parent, fileName)\n            }\n        }\n    }\n~~~\n\n这个方法要定义在最外层\n~~~ Java\ndef releaseTime() {\n    return new Date().format(\"MMdd\", TimeZone.getTimeZone(\"UTC\"))\n}\n~~~\n\n最后生成的apk名字\n","slug":"gradle-learning2","published":1,"date":"2016-10-12T16:00:00.000Z","updated":"2016-12-26T10:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5p0024bxs6bq1p2hhc","content":"<p>上一篇<a href=\"\">Gradle学习</a>了解了Gradle的基本结构和依赖关系，这篇文章介绍下怎么在Android上使用Gradle生成指定包名的APK</p>\n<h3 id=\"需求场景\"><a href=\"#需求场景\" class=\"headerlink\" title=\"需求场景\"></a>需求场景</h3><p>在我们Android开发基本进入测试阶段后，会根据后台的不同环境，打包出对应不同环境（如SIT、UAT、PRD等）的APK安装包。</p>\n<p>每次去手动修改Java类改变后台环境太麻烦还容易忘记修改。打包成功后，还需要手动将默认的包名app-release.apk改成我们需要的包名，也是非常麻烦，有没有直接指定环境，生成指定文件名的安装包呢？</p>\n<p>方法是有的，就是利用gradle的分渠道打包特性，下面上代码分别解释。</p>\n<blockquote>\n<p>主要在这两个个地方修改：</p>\n<ul>\n<li>buildType（构建类型）</li>\n<li>productFlavors （不同定制的产品）</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"buildType（构建类型）介绍\"><a href=\"#buildType（构建类型）介绍\" class=\"headerlink\" title=\"buildType（构建类型）介绍\"></a>buildType（构建类型）介绍</h4><p>默认情况下，Android Plugin会自动给项目设置同时构建应用程序的debug和release版本。 两个版本之间的不同主要围绕着能否在一个安全设备上调试，以及APK如何签名。</p>\n<p>可以创建一个新的构建类型就是简单的在buildType标签下添加一个新的元素，并且可以使用initWith()或者直接使用闭包来配置它。</p>\n<p>以下是一些可能使用到的属性和默认值：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><em>Property name    </em></th>\n<th style=\"text-align:center\"><em>Default values for debug    </em></th>\n<th style=\"text-align:center\"><em>Default values for release / other</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">debuggable</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">jniDebugBuild</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">renderscriptDebugBuild</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">renderscriptOptimLevel</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">applicationIdSuffix</td>\n<td style=\"text-align:center\">null</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">versionNameSuffix</td>\n<td style=\"text-align:center\">null</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">signingConfig</td>\n<td style=\"text-align:center\">android.signingConfigs.debug</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">zipAlign</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">runProguard</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">proguardFile</td>\n<td style=\"text-align:center\">N/A (set only)</td>\n<td style=\"text-align:center\">N/A (set only)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">proguardFiles</td>\n<td style=\"text-align:center\">N/A (set only)</td>\n<td style=\"text-align:center\">N/A (set only)</td>\n</tr>\n</tbody>\n</table>\n<p>上面介绍摘选自<a href=\"https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/basic_project/build_types.html\" target=\"_blank\" rel=\"external\">Gralde plugin User Guide 中文版</a></p>\n<h4 id=\"Product-flavors（不同定制的产品）介绍\"><a href=\"#Product-flavors（不同定制的产品）介绍\" class=\"headerlink\" title=\"Product flavors（不同定制的产品）介绍\"></a>Product flavors（不同定制的产品）介绍</h4><p>一个product flavor定义了从项目中构建了一个应用的自定义版本。一个单一的项目可以同时定义多个不同的flavor来改变应用的输出。</p>\n<p>这个新的设计概念是为了解决不同的版本之间的差异非常小的情况。虽然最项目终生成了多个定制的版本，但是它们本质上都是同一个应用，那么这种做法可能是比使用库项目更好的实现方式。</p>\n<p>Product flavor需要在productFlavors这个DSL容器中声明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ....</div><div class=\"line\"></div><div class=\"line\">    productFlavors &#123;</div><div class=\"line\">        flavor1 &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        flavor2 &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里创建了两个flavor，名为flavor1和flavor2。</p>\n<blockquote>\n<p>注意：flavor的命名不能与已存在的Build Type或者androidTest这个sourceSet有冲突。</p>\n</blockquote>\n<h4 id=\"Build-Type-Product-Flavor-Build-Variant（构建类型-定制产品-构建变种版本）\"><a href=\"#Build-Type-Product-Flavor-Build-Variant（构建类型-定制产品-构建变种版本）\" class=\"headerlink\" title=\"Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）\"></a>Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）</h4><p>正如前面章节所提到的，每一个Build Type都会生成一个新的APK。</p>\n<p>Product Flavor同样也会做这些事情：项目的输出将会拼接所有可能的Build Type和Product Flavor（如果有Flavor定义存在的话）的组合。</p>\n<p>每一种组合（包含Build Type和Product Flavor）就是一个Build Variant（构建变种版本）。</p>\n<p>例如，在上面的Flavor声明例子中与默认的debug和release两个Build Type将会生成4个Build Variant：</p>\n<ul>\n<li>Flavor1 - debug</li>\n<li>Flavor1 - release</li>\n<li>Flavor2 - debug</li>\n<li>Flavor2 - release</li>\n</ul>\n<p>项目中如果没有定义flavor同样也会有Build Variant，只是使用的是默认的flavor和配置。default(默认)的flavor/config是没有名字的，所以生成的Build Variant列表看起来就跟Build Type列表一样。</p>\n<h3 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h3><p>我们的需求就要用到<strong>Build Type</strong>和<strong>Product Flavor</strong><br>我在项目中<strong>Build Type</strong>的使用，先看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">buildTypes &#123;</div><div class=\"line\">        release &#123;</div><div class=\"line\">            buildConfigField <span class=\"string\">\"boolean\"</span>, <span class=\"string\">\"LEO_DEBUG\"</span>, <span class=\"string\">\"false\"</span></div><div class=\"line\">            <span class=\"function\">minifyEnabled <span class=\"keyword\">true</span></span></div><div class=\"line\">            proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">'proguard-android.txt'</span>)</span>, 'proguard-rules.txt'</div><div class=\"line\">            debuggable <span class=\"keyword\">false</span></div><div class=\"line\">            jniDebuggable <span class=\"keyword\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        debug &#123;</div><div class=\"line\">            buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"2\"</span></div><div class=\"line\">            buildConfigField <span class=\"string\">\"boolean\"</span>, <span class=\"string\">\"LEO_DEBUG\"</span>, <span class=\"string\">\"true\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>和<strong>Product Flavor</strong>的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">productFlavors&#123;</div><div class=\"line\">\t\t\t kaifa&#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"1\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t\t\t ceshi &#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"2\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t\t\t SIT &#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"3\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t\t\t UAT &#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"4\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t\t\t PRD &#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"5\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t &#125;</div></pre></td></tr></table></figure>\n<p>每一个构建过的productFlavors都会在<strong>app-&gt;build-&gt;generated-&gt;source-&gt;buildConfig</strong>目录下创建自己对应的一个flavor目录，如下图：</p>\n<p><img src=\"/images/blogimages/2016/gradle_structure2.png\" alt=\"Gradle build structure\"></p>\n<p>而，buildConfigField会在指定的目录，<strong>flavor-&gt;release/debug-&gt;包名</strong>，下生成一个BuildConfig.java文件，我的代码在BuildConfig.java中定义了一个int类型的buildType和boolean类型的LEO_DEBUG。要使用这两个字段只需要:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (BuildConfig.LEO_DEBUG)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//用来控制本地Log日志</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (Environment ==BuildConfig.buildType)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//用来控制开发环境</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"gradle中修改apk生成名字的方法\"><a href=\"#gradle中修改apk生成名字的方法\" class=\"headerlink\" title=\"gradle中修改apk生成名字的方法\"></a>gradle中修改apk生成名字的方法</h4><p>这个方法是定义在productFlavors同一层级的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">android.applicationVariants.all &#123; variant -&gt;</div><div class=\"line\">        variant.outputs.each &#123; output -&gt;</div><div class=\"line\">            def outputFile = output.<span class=\"function\">outputFile</span></div><div class=\"line\">            <span class=\"title\">if</span> <span class=\"params\">(outputFile != <span class=\"keyword\">null</span> &amp;&amp; outputFile.name.endsWith(<span class=\"string\">'.apk'</span>)</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">//这里修改apk文件名</span></div><div class=\"line\">                def flavorname =variant.productFlavors[<span class=\"number\">0</span>].<span class=\"function\">name</span></div><div class=\"line\">                <span class=\"title\">if</span> <span class=\"params\">(flavorname.equals(<span class=\"string\">'kaifa'</span>)</span>)</div><div class=\"line\">                    flavorname = <span class=\"string\">'debug'</span></div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flavorname.equals(<span class=\"string\">'ceshi'</span>))</div><div class=\"line\">                    flavorname = <span class=\"string\">'release'</span></div><div class=\"line\"></div><div class=\"line\">                def fileName = <span class=\"string\">\"app-$&#123;flavorname&#125;-$&#123;defaultConfig.versionName&#125;-$&#123;releaseTime() &#125;.apk\"</span></div><div class=\"line\">                output.outputFile = <span class=\"keyword\">new</span> File(outputFile.parent, fileName)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个方法要定义在最外层<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">def <span class=\"title\">releaseTime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Date().format(<span class=\"string\">\"MMdd\"</span>, TimeZone.getTimeZone(<span class=\"string\">\"UTC\"</span>))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后生成的apk名字</p>\n","excerpt":"<p>上一篇<a href=\"\">Gradle学习</a>了解了Gradle的基本结构和依赖关系，这篇文章介绍下怎么在Android上使用Gradle生成指定包名的APK</p>\n<h3 id=\"需求场景\"><a href=\"#需求场景\" class=\"headerlink\" title=\"需求场景\"></a>需求场景</h3><p>在我们Android开发基本进入测试阶段后，会根据后台的不同环境，打包出对应不同环境（如SIT、UAT、PRD等）的APK安装包。</p>\n<p>每次去手动修改Java类改变后台环境太麻烦还容易忘记修改。打包成功后，还需要手动将默认的包名app-release.apk改成我们需要的包名，也是非常麻烦，有没有直接指定环境，生成指定文件名的安装包呢？</p>\n<p>方法是有的，就是利用gradle的分渠道打包特性，下面上代码分别解释。</p>\n<blockquote>\n<p>主要在这两个个地方修改：</p>\n<ul>\n<li>buildType（构建类型）</li>\n<li>productFlavors （不同定制的产品）</li>\n</ul>\n</blockquote>","more":"<h4 id=\"buildType（构建类型）介绍\"><a href=\"#buildType（构建类型）介绍\" class=\"headerlink\" title=\"buildType（构建类型）介绍\"></a>buildType（构建类型）介绍</h4><p>默认情况下，Android Plugin会自动给项目设置同时构建应用程序的debug和release版本。 两个版本之间的不同主要围绕着能否在一个安全设备上调试，以及APK如何签名。</p>\n<p>可以创建一个新的构建类型就是简单的在buildType标签下添加一个新的元素，并且可以使用initWith()或者直接使用闭包来配置它。</p>\n<p>以下是一些可能使用到的属性和默认值：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><em>Property name    </em></th>\n<th style=\"text-align:center\"><em>Default values for debug    </em></th>\n<th style=\"text-align:center\"><em>Default values for release / other</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">debuggable</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">jniDebugBuild</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">renderscriptDebugBuild</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">renderscriptOptimLevel</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">applicationIdSuffix</td>\n<td style=\"text-align:center\">null</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">versionNameSuffix</td>\n<td style=\"text-align:center\">null</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">signingConfig</td>\n<td style=\"text-align:center\">android.signingConfigs.debug</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">zipAlign</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">runProguard</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">proguardFile</td>\n<td style=\"text-align:center\">N/A (set only)</td>\n<td style=\"text-align:center\">N/A (set only)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">proguardFiles</td>\n<td style=\"text-align:center\">N/A (set only)</td>\n<td style=\"text-align:center\">N/A (set only)</td>\n</tr>\n</tbody>\n</table>\n<p>上面介绍摘选自<a href=\"https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/basic_project/build_types.html\">Gralde plugin User Guide 中文版</a></p>\n<h4 id=\"Product-flavors（不同定制的产品）介绍\"><a href=\"#Product-flavors（不同定制的产品）介绍\" class=\"headerlink\" title=\"Product flavors（不同定制的产品）介绍\"></a>Product flavors（不同定制的产品）介绍</h4><p>一个product flavor定义了从项目中构建了一个应用的自定义版本。一个单一的项目可以同时定义多个不同的flavor来改变应用的输出。</p>\n<p>这个新的设计概念是为了解决不同的版本之间的差异非常小的情况。虽然最项目终生成了多个定制的版本，但是它们本质上都是同一个应用，那么这种做法可能是比使用库项目更好的实现方式。</p>\n<p>Product flavor需要在productFlavors这个DSL容器中声明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ....</div><div class=\"line\"></div><div class=\"line\">    productFlavors &#123;</div><div class=\"line\">        flavor1 &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        flavor2 &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里创建了两个flavor，名为flavor1和flavor2。</p>\n<blockquote>\n<p>注意：flavor的命名不能与已存在的Build Type或者androidTest这个sourceSet有冲突。</p>\n</blockquote>\n<h4 id=\"Build-Type-Product-Flavor-Build-Variant（构建类型-定制产品-构建变种版本）\"><a href=\"#Build-Type-Product-Flavor-Build-Variant（构建类型-定制产品-构建变种版本）\" class=\"headerlink\" title=\"Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）\"></a>Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）</h4><p>正如前面章节所提到的，每一个Build Type都会生成一个新的APK。</p>\n<p>Product Flavor同样也会做这些事情：项目的输出将会拼接所有可能的Build Type和Product Flavor（如果有Flavor定义存在的话）的组合。</p>\n<p>每一种组合（包含Build Type和Product Flavor）就是一个Build Variant（构建变种版本）。</p>\n<p>例如，在上面的Flavor声明例子中与默认的debug和release两个Build Type将会生成4个Build Variant：</p>\n<ul>\n<li>Flavor1 - debug</li>\n<li>Flavor1 - release</li>\n<li>Flavor2 - debug</li>\n<li>Flavor2 - release</li>\n</ul>\n<p>项目中如果没有定义flavor同样也会有Build Variant，只是使用的是默认的flavor和配置。default(默认)的flavor/config是没有名字的，所以生成的Build Variant列表看起来就跟Build Type列表一样。</p>\n<h3 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h3><p>我们的需求就要用到<strong>Build Type</strong>和<strong>Product Flavor</strong><br>我在项目中<strong>Build Type</strong>的使用，先看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">buildTypes &#123;</div><div class=\"line\">        release &#123;</div><div class=\"line\">            buildConfigField <span class=\"string\">\"boolean\"</span>, <span class=\"string\">\"LEO_DEBUG\"</span>, <span class=\"string\">\"false\"</span></div><div class=\"line\">            <span class=\"function\">minifyEnabled <span class=\"keyword\">true</span></div><div class=\"line\">            proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">'proguard-android.txt'</span>)</span>, 'proguard-rules.txt'</div><div class=\"line\">            debuggable <span class=\"keyword\">false</span></div><div class=\"line\">            jniDebuggable <span class=\"keyword\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        debug </span>&#123;</div><div class=\"line\">            buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"2\"</span></div><div class=\"line\">            buildConfigField <span class=\"string\">\"boolean\"</span>, <span class=\"string\">\"LEO_DEBUG\"</span>, <span class=\"string\">\"true\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>和<strong>Product Flavor</strong>的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">productFlavors&#123;</div><div class=\"line\">\t\t\t kaifa&#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"1\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t\t\t ceshi &#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"2\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t\t\t SIT &#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"3\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t\t\t UAT &#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"4\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t\t\t PRD &#123;</div><div class=\"line\">\t\t\t\t\t buildConfigField <span class=\"string\">\"int\"</span>, <span class=\"string\">\"buildType\"</span>, <span class=\"string\">\"5\"</span></div><div class=\"line\">\t\t\t &#125;</div><div class=\"line\">\t &#125;</div></pre></td></tr></table></figure>\n<p>每一个构建过的productFlavors都会在<strong>app-&gt;build-&gt;generated-&gt;source-&gt;buildConfig</strong>目录下创建自己对应的一个flavor目录，如下图：</p>\n<p><img src=\"/images/blogimages/2016/gradle_structure2.png\" alt=\"Gradle build structure\"></p>\n<p>而，buildConfigField会在指定的目录，<strong>flavor-&gt;release/debug-&gt;包名</strong>，下生成一个BuildConfig.java文件，我的代码在BuildConfig.java中定义了一个int类型的buildType和boolean类型的LEO_DEBUG。要使用这两个字段只需要:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (BuildConfig.LEO_DEBUG)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//用来控制本地Log日志</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (Environment ==BuildConfig.buildType)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//用来控制开发环境</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"gradle中修改apk生成名字的方法\"><a href=\"#gradle中修改apk生成名字的方法\" class=\"headerlink\" title=\"gradle中修改apk生成名字的方法\"></a>gradle中修改apk生成名字的方法</h4><p>这个方法是定义在productFlavors同一层级的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">android.applicationVariants.all &#123; variant -&gt;</div><div class=\"line\">        variant.outputs.each &#123; output -&gt;</div><div class=\"line\">            def outputFile = output.<span class=\"function\">outputFile</div><div class=\"line\">            <span class=\"title\">if</span> <span class=\"params\">(outputFile != <span class=\"keyword\">null</span> &amp;&amp; outputFile.name.endsWith(<span class=\"string\">'.apk'</span>)</span>) </span>&#123;</div><div class=\"line\">                <span class=\"comment\">//这里修改apk文件名</span></div><div class=\"line\">                def flavorname =variant.productFlavors[<span class=\"number\">0</span>].<span class=\"function\">name</div><div class=\"line\">                <span class=\"title\">if</span> <span class=\"params\">(flavorname.equals(<span class=\"string\">'kaifa'</span>)</span>)</div><div class=\"line\">                    flavorname </span>= <span class=\"string\">'debug'</span></div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flavorname.equals(<span class=\"string\">'ceshi'</span>))</div><div class=\"line\">                    flavorname = <span class=\"string\">'release'</span></div><div class=\"line\"></div><div class=\"line\">                def fileName = <span class=\"string\">\"app-$&#123;flavorname&#125;-$&#123;defaultConfig.versionName&#125;-$&#123;releaseTime() &#125;.apk\"</span></div><div class=\"line\">                output.outputFile = <span class=\"keyword\">new</span> File(outputFile.parent, fileName)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个方法要定义在最外层<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">def <span class=\"title\">releaseTime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Date().format(<span class=\"string\">\"MMdd\"</span>, TimeZone.getTimeZone(<span class=\"string\">\"UTC\"</span>))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后生成的apk名字</p>"},{"layout":"post","title":"Hexo 出错情况收集","keywords":"Hexo","banner":"http://obxk8w81b.bkt.clouddn.com/Couple%20Out%20for%20a%20Stroll.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Couple%20Out%20for%20a%20Stroll.jpg","_content":"\n#### Error: Cannot find module './build/Release/DTraceProviderBindings'\n\n我在更新hexo，准备安装别的module时，不小心按到了 ctrl+c，结果发现使用hexo命令会报如下错误：\n~~~ Java\n{ [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }    \n{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n~~~\n<!--more-->\n网上一大堆的解决办法都不好用，这里特别记录下我找到的一个解决办法，亲测可用\n\n**1. 重新安装Hexo，需要手动删除隐藏的hexo文件**\n\n- 需要删除 /usr/local/lib/node_modules/ 目录下的**hexo文件夹**\n- /usr/local/bin/ 下的**hexo文件**. 直接删掉就好了.\n> 注意这两个都是隐藏文件，要想在finder中显示隐藏文件，需要在Terminal中执行：\ndefaults write com.apple.finder AppleShowAllFiles -bool true\n\n**2. 重新执行命令：npm install -g hexo --save**\n\n这样就可以了  :)\n","source":"_posts/2016-11-03-hexo-mac-module-not-found.md","raw":"---\nlayout: post\ntitle:  Hexo 出错情况收集\ncategory: accumulation\ntags: Hexo\nkeywords: Hexo\nbanner: http://obxk8w81b.bkt.clouddn.com/Couple%20Out%20for%20a%20Stroll.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Couple%20Out%20for%20a%20Stroll.jpg\n---\n\n#### Error: Cannot find module './build/Release/DTraceProviderBindings'\n\n我在更新hexo，准备安装别的module时，不小心按到了 ctrl+c，结果发现使用hexo命令会报如下错误：\n~~~ Java\n{ [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }    \n{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n~~~\n<!--more-->\n网上一大堆的解决办法都不好用，这里特别记录下我找到的一个解决办法，亲测可用\n\n**1. 重新安装Hexo，需要手动删除隐藏的hexo文件**\n\n- 需要删除 /usr/local/lib/node_modules/ 目录下的**hexo文件夹**\n- /usr/local/bin/ 下的**hexo文件**. 直接删掉就好了.\n> 注意这两个都是隐藏文件，要想在finder中显示隐藏文件，需要在Terminal中执行：\ndefaults write com.apple.finder AppleShowAllFiles -bool true\n\n**2. 重新执行命令：npm install -g hexo --save**\n\n这样就可以了  :)\n","slug":"hexo-mac-module-not-found","published":1,"date":"2016-11-02T16:00:00.000Z","updated":"2016-12-28T03:14:03.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5r0027bxs66mwab3r9","content":"<h4 id=\"Error-Cannot-find-module-‘-build-Release-DTraceProviderBindings’\"><a href=\"#Error-Cannot-find-module-‘-build-Release-DTraceProviderBindings’\" class=\"headerlink\" title=\"Error: Cannot find module ‘./build/Release/DTraceProviderBindings’\"></a>Error: Cannot find module ‘./build/Release/DTraceProviderBindings’</h4><p>我在更新hexo，准备安装别的module时，不小心按到了 ctrl+c，结果发现使用hexo命令会报如下错误：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; [Error: Cannot find <span class=\"keyword\">module</span> <span class=\"string\">'./build/Release/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;    </div><div class=\"line\">&#123; [Error: Cannot find <span class=\"keyword\">module</span> <span class=\"string\">'./build/default/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div><div class=\"line\">&#123; [Error: Cannot find <span class=\"keyword\">module</span> <span class=\"string\">'./build/Debug/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>网上一大堆的解决办法都不好用，这里特别记录下我找到的一个解决办法，亲测可用</p>\n<p><strong>1. 重新安装Hexo，需要手动删除隐藏的hexo文件</strong></p>\n<ul>\n<li>需要删除 /usr/local/lib/node_modules/ 目录下的<strong>hexo文件夹</strong></li>\n<li>/usr/local/bin/ 下的<strong>hexo文件</strong>. 直接删掉就好了.<blockquote>\n<p>注意这两个都是隐藏文件，要想在finder中显示隐藏文件，需要在Terminal中执行：<br>defaults write com.apple.finder AppleShowAllFiles -bool true</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>2. 重新执行命令：npm install -g hexo –save</strong></p>\n<p>这样就可以了  :)</p>\n","excerpt":"<h4 id=\"Error-Cannot-find-module-‘-build-Release-DTraceProviderBindings’\"><a href=\"#Error-Cannot-find-module-‘-build-Release-DTraceProviderBindings’\" class=\"headerlink\" title=\"Error: Cannot find module ‘./build/Release/DTraceProviderBindings’\"></a>Error: Cannot find module ‘./build/Release/DTraceProviderBindings’</h4><p>我在更新hexo，准备安装别的module时，不小心按到了 ctrl+c，结果发现使用hexo命令会报如下错误：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; [Error: Cannot find <span class=\"keyword\">module</span> <span class=\"string\">'./build/Release/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;    </div><div class=\"line\">&#123; [Error: Cannot find <span class=\"keyword\">module</span> <span class=\"string\">'./build/default/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div><div class=\"line\">&#123; [Error: Cannot find <span class=\"keyword\">module</span> <span class=\"string\">'./build/Debug/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div></pre></td></tr></table></figure></p>","more":"<p>网上一大堆的解决办法都不好用，这里特别记录下我找到的一个解决办法，亲测可用</p>\n<p><strong>1. 重新安装Hexo，需要手动删除隐藏的hexo文件</strong></p>\n<ul>\n<li>需要删除 /usr/local/lib/node_modules/ 目录下的<strong>hexo文件夹</strong></li>\n<li>/usr/local/bin/ 下的<strong>hexo文件</strong>. 直接删掉就好了.<blockquote>\n<p>注意这两个都是隐藏文件，要想在finder中显示隐藏文件，需要在Terminal中执行：<br>defaults write com.apple.finder AppleShowAllFiles -bool true</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>2. 重新执行命令：npm install -g hexo –save</strong></p>\n<p>这样就可以了  :)</p>"},{"layout":"post","title":"Hexo 模板学习——Hexo 结构","keywords":"Hexo结构","banner":"http://obxk8w81b.bkt.clouddn.com/Boy%20Cutting%20Grass%20with%20a%20Sickle.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Boy%20Cutting%20Grass%20with%20a%20Sickle.jpg","_content":"\n### 起步\nHexo会读取根目录下的_config.yml里面的theme属性, 从而采用对应的主题。而主题都是放在themes/目录下面的，然后你会发现他里面有个landscape的目录，这个就是默认主题啦。\n\n接着，我们查看themes/landscape/目录，以及根据文档docs-themes，我们很容易得出：一个主题其实由4部分组成。\n\n- _config.yml: 主题的配置文件\n- source/: 放我们的CSS文件以及图片\n- layout/: 模板文件\n- scripts: 放JavaScript文件，他们会自动加载\n\n根据文档[docs-templates](https://hexo.io/docs/templates.html)，下面表格中每个页面都有一个可用的模板，可以没有这些模板，但至少要有一个index模板。\n\n<!--more-->\n\n|Template|Page|\tFallback|\n|:--------:|:-------:|:--------:|\n|index\t|Home page | |\n|post\t|Posts\t|index|\n|page|\tPages |index|\n|archive\t|Archives|\tindex|\n|category\t|Category archives\t|archive|\n|tag\t|Tag archives|\tarchive|\n\n\n\n每次当我们在浏览器访问时，Hexo都会去解析sources目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以EJS为例)\n\n无论URL是什么，Hexo先读取layout.ejs，然后里面的body变量会替换成上面表格里的模板：(Fallback的意思是如果访问/archives时，我们的archives.ejs不存在的话，就会返回index.ejs)\n\n\n### 布局\n#### 编写布局文件(layout.ejs)\n\n模板文件在layout文件夹下，文件名对应Hexo中的模板名，有index,post,page,archive,category,tag几种，对于普通的header + content + footer的页面结构，header和footer往往是可以复用的，因此我们可以使用layout.ejs进行布局，动态的内容使用body变量去动态渲染，所以我的layout.ejs大概长这样:\n\n~~~ JavaScript\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/>\n    <title><%= config.title %></title>\n    <%- css('css/style') %>\n</head>\n<body>\n    <%- partial('_partial/header') %>\n    <div class=\"main\">\n        <%- body %>\n    </div>\n    <%- partial('_partial/footer') %>\n    <%- js('js/index.js') %>\n</body>\n</html>\n~~~\n\npartial,js和css是Hexo提供的辅助函数，后面再说。\n\n#### 其他模板文件\n\n每一个模板文件对应的是一种布局，当你使用hexo new <title>的时候，其实忽略了一个参数，完整的命令是hexo new [layout] <title>，这个layout就决定了文章使用何种方式布局，比如创建一个自己简介的About页面，hexo new page \"about\"其实就是使用了page布局。每种布局对应到我们的模板文件上就是index.ejs(首页),post.ejs(文章),archive.ejs(归档),tag.ejs(标签归档),page.ejs(分页)。\n\n##### index.ejs\n\n首页一般是一些博文的摘要和一个分页器，通过Hexo的page变量拿到页面的数据渲染即可，这里我们不直接在index.ejs中写HTML结构，新建一个_partial/article.ejs，将文章数据传给子模板渲染，然后再额外传入一个参数{index: true}，对后面的post.ejs和page.ejs加以区分，让子模板能正确渲染。最后，index.ejs大致是这样的:\n\n~~~ JavaScript\n//index.ejs\n<% page.posts.each(function(post, index){ %>\n    <%- partial('_partial/article', {index: true, post: post}) %>\n<% }) %>\n<div class=\"pagination\">\n    <%- paginator({ total: Math.ceil(site.posts.length / config.per_page)}) %>\n</div>\n~~~\n##### post.ejs\n\n文章模板和首页差不多，只是对应的是一篇具体的文章，所以就把文章传入，再额外传入{index: false}告诉子模板不要按首页的方式去渲染就好了。就一行代码(因为都在子模板里 XD\n\n~~~ JavaScript\n//post.ejs\n<%- partial('_partial/article', {index: false, post: page}) %>\n~~~\n##### page.ejs\n\n我个人对Page模板其实是有点懵逼的，在我自己的实践中是添加about(hexo new page \"about\")页面后，访问/about会走分页布局，实际上这个页面对应的内容是/source/about里的index.md，也相当于对文章的渲染，因此我把Page模板也写成了和文章模板一样:\n\n~~~ JavaScript\n//page.ejs\n<%- partial('_partial/article', {index: false, post: page}) %>\n_partial/article.ejs\n~~~\n前面一共有三处共用了article模板，另外page和post的一样的，所以实际上只有两种情况:主页(index: true)和非主页(index: false)。对应的_partial/article.ejs里只要判断这个值就可以正确渲染了，基本结构如下：\n\n~~~ JavaScript\n//_partial/article.ejs\n<% if(index){ %>\n    //index logic...\n<% }else{ %>\n    //post or page logic...\n<% } %>\n~~~\n\n##### tag.ejs\n\n标签归档页内容很少，直接用Hexo的辅助函数list_tags生成一个标签的列表就ok了:\n\n~~~ JavaScript\n//tag.ejs\n<%- list_tags() %>\n~~~\n归档页模板和首页差不多，归档页只需要展示文章标题和最后的分页器就好:\n\n~~~ JavaScript\n//archive.ejs\n<div class=\"archive\">\n  <% var lastyear; %>\n  <% page.posts.each(function(post){ %>\n    <% var year = post.date.year() %>\n    <% if(lastyear !== year){ %>\n      <h4 class=\"year\"><%= year %></h4>\n      <% lastyear = year %>\n    <% } %>\n    <div class=\"archive_item\">\n      <a class=\"title\" href=\"<%- url_for(post.path) %>\"><%= post.title %></a>\n      <span class=\"date\"><%= post.date.format('YYYY-MM-DD') %></span>\n    </div>\n  <% }) %>\n  <div class=\"pagination\">\n    <%- paginator({ total: Math.ceil(site.posts.length / config.per_page)}) %>\n  </div>\n</div>\n~~~\n至此，模板文件就写好了，对于category模板就放弃了，感觉比较鸡肋。。。\n\n### 变量\n其实在模板文件中我们已经看到了page.post,site.posts.length,config.per_page等等，页面的内容就是根据这些变量获取的，由Hexo提供，拿来直接用，Hexo提供了很多变量，但不是都很常用，一般就用到以下变量:\n\n- site: 对应整个网站的变量，一般会用到site.posts.length制作分页器\n\n- page: 对应当前页面的信息，例如我在index.ejs中使用page.posts获取了当前页面的所有文章而不是使用site.posts。\n\n- config: 博客的配置信息，博客根目录下的_config.yml。\n\n- theme: 主题的配置信息，对于主题根目录下的_config.yml。\n\n#### 辅助函数(Helper)\n制作一个分页器，我们需要知道文章的总数和每页展示的文章数，然后通过循环生成每个link标签，还要根据当前页面判断link标签的active状态，但是在Hexo中这些都不用我们自己来做了!Hexo提供了**paginator**这一辅助函数帮助我们生成分页器，只需要将文章总数site.posts.length和每页文章数config.per_page传入就可以生成了。\n\n##### 其他的Helper:\n\n- **list_tags([options])**: 快速生成标签列表\n\n- **js(path/to/js), css(path/to/css)** 用来载入静态资源，path可以是字符串或数组(载入多个资源)，默认会去source文件夹下去找。\n\n- **partial(path/to/partial)** 引用字模板，默认会去layout文件夹下找。\n\n### 样式\n知道了Hexo的渲染方式，我们就可以使用HTML标签+CSS样式个性化我们的主题了，推荐大家使用CSS预处理语言的一种来写样式，这样就可以通过预处理语言自身的特点让样式更灵活。\n\n### 其他\n#### 添加对多说和Disqus的支持\n\n评论是很常用的功能，不如就直接在我们的主题里支持了，然后通过配置变量决定是否开启，评论区跟在文章内容下面，对于这种三方的代码块，最好也以partial的方式提取出来，方便移除或是替换。\n\n~~~ JavaScript\n//_partial/article.ejs\n<section class='post-content'>\n    <%- post.content %>\n</section>\n//评论部分，post.comments判断是否开启评论，config.duoshuo_shortname\n和config.disqus_shortname来判断启用那种评论插件，这里优先判断了多说\n<% if(post.comments){ %>\n    <section id=\"comments\">\n    <% if (config.duoshuo_shortname){ %>\n            <%- partial('_partial/duoshuo') %>\n        <% }else if(config.disqus_shortname){ %>\n            <%- partial('_partial/disqus') %>\n        <% } %>\n    </section>\n<% } %>\n~~~\n再将多说和Disqus提供的js脚本代码放在**_partial/duoshuo.ejs和_partial/disqus.ejs**下就ok了~\n\n#### 使用highlight.js提供代码高亮\n\nhighlight.js提供了多种语言的支持和多种皮肤，用法也很简单，载入文件后调用初始化方法，一切都帮你搞定，对于使用那种皮肤，喜好因人而异，我们干脆在主题的配置文件中做成配置项让用户自己选择:\n\n~~~ JavaScript\n//showonne/_config.yml\n\n...other configs\n\n# highlight.js\nhighlight_theme: zenburn\n~~~\n对应的layout.ejs中:\n\n~~~ JavaScript\n<link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/<%= theme.highlight_theme %>.min.css\">\n~~~\n样式文件通过CDN引入，因为不同皮肤对应不同的文件名，所以十分灵活。\n\n### 最后\n当初是对应着landscape照葫芦画瓢写的，最近回头来发现一些不合理的地方，所以就又改了改，也对应着写了这么一篇总结，接下来准备再把样式划分一下，对于颜色这类样式通过变量的方式提取出来，也变得可配置，能让主题更灵活一些。\n\n### 参考资源\n","source":"_posts/2016-12-06-hexo-learning1.md","raw":"---\nlayout: post\ntitle:  Hexo 模板学习——Hexo 结构\ncategory: accumulation\ntags: Hexo\nkeywords: Hexo结构\nbanner: http://obxk8w81b.bkt.clouddn.com/Boy%20Cutting%20Grass%20with%20a%20Sickle.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Boy%20Cutting%20Grass%20with%20a%20Sickle.jpg\n---\n\n### 起步\nHexo会读取根目录下的_config.yml里面的theme属性, 从而采用对应的主题。而主题都是放在themes/目录下面的，然后你会发现他里面有个landscape的目录，这个就是默认主题啦。\n\n接着，我们查看themes/landscape/目录，以及根据文档docs-themes，我们很容易得出：一个主题其实由4部分组成。\n\n- _config.yml: 主题的配置文件\n- source/: 放我们的CSS文件以及图片\n- layout/: 模板文件\n- scripts: 放JavaScript文件，他们会自动加载\n\n根据文档[docs-templates](https://hexo.io/docs/templates.html)，下面表格中每个页面都有一个可用的模板，可以没有这些模板，但至少要有一个index模板。\n\n<!--more-->\n\n|Template|Page|\tFallback|\n|:--------:|:-------:|:--------:|\n|index\t|Home page | |\n|post\t|Posts\t|index|\n|page|\tPages |index|\n|archive\t|Archives|\tindex|\n|category\t|Category archives\t|archive|\n|tag\t|Tag archives|\tarchive|\n\n\n\n每次当我们在浏览器访问时，Hexo都会去解析sources目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以EJS为例)\n\n无论URL是什么，Hexo先读取layout.ejs，然后里面的body变量会替换成上面表格里的模板：(Fallback的意思是如果访问/archives时，我们的archives.ejs不存在的话，就会返回index.ejs)\n\n\n### 布局\n#### 编写布局文件(layout.ejs)\n\n模板文件在layout文件夹下，文件名对应Hexo中的模板名，有index,post,page,archive,category,tag几种，对于普通的header + content + footer的页面结构，header和footer往往是可以复用的，因此我们可以使用layout.ejs进行布局，动态的内容使用body变量去动态渲染，所以我的layout.ejs大概长这样:\n\n~~~ JavaScript\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/>\n    <title><%= config.title %></title>\n    <%- css('css/style') %>\n</head>\n<body>\n    <%- partial('_partial/header') %>\n    <div class=\"main\">\n        <%- body %>\n    </div>\n    <%- partial('_partial/footer') %>\n    <%- js('js/index.js') %>\n</body>\n</html>\n~~~\n\npartial,js和css是Hexo提供的辅助函数，后面再说。\n\n#### 其他模板文件\n\n每一个模板文件对应的是一种布局，当你使用hexo new <title>的时候，其实忽略了一个参数，完整的命令是hexo new [layout] <title>，这个layout就决定了文章使用何种方式布局，比如创建一个自己简介的About页面，hexo new page \"about\"其实就是使用了page布局。每种布局对应到我们的模板文件上就是index.ejs(首页),post.ejs(文章),archive.ejs(归档),tag.ejs(标签归档),page.ejs(分页)。\n\n##### index.ejs\n\n首页一般是一些博文的摘要和一个分页器，通过Hexo的page变量拿到页面的数据渲染即可，这里我们不直接在index.ejs中写HTML结构，新建一个_partial/article.ejs，将文章数据传给子模板渲染，然后再额外传入一个参数{index: true}，对后面的post.ejs和page.ejs加以区分，让子模板能正确渲染。最后，index.ejs大致是这样的:\n\n~~~ JavaScript\n//index.ejs\n<% page.posts.each(function(post, index){ %>\n    <%- partial('_partial/article', {index: true, post: post}) %>\n<% }) %>\n<div class=\"pagination\">\n    <%- paginator({ total: Math.ceil(site.posts.length / config.per_page)}) %>\n</div>\n~~~\n##### post.ejs\n\n文章模板和首页差不多，只是对应的是一篇具体的文章，所以就把文章传入，再额外传入{index: false}告诉子模板不要按首页的方式去渲染就好了。就一行代码(因为都在子模板里 XD\n\n~~~ JavaScript\n//post.ejs\n<%- partial('_partial/article', {index: false, post: page}) %>\n~~~\n##### page.ejs\n\n我个人对Page模板其实是有点懵逼的，在我自己的实践中是添加about(hexo new page \"about\")页面后，访问/about会走分页布局，实际上这个页面对应的内容是/source/about里的index.md，也相当于对文章的渲染，因此我把Page模板也写成了和文章模板一样:\n\n~~~ JavaScript\n//page.ejs\n<%- partial('_partial/article', {index: false, post: page}) %>\n_partial/article.ejs\n~~~\n前面一共有三处共用了article模板，另外page和post的一样的，所以实际上只有两种情况:主页(index: true)和非主页(index: false)。对应的_partial/article.ejs里只要判断这个值就可以正确渲染了，基本结构如下：\n\n~~~ JavaScript\n//_partial/article.ejs\n<% if(index){ %>\n    //index logic...\n<% }else{ %>\n    //post or page logic...\n<% } %>\n~~~\n\n##### tag.ejs\n\n标签归档页内容很少，直接用Hexo的辅助函数list_tags生成一个标签的列表就ok了:\n\n~~~ JavaScript\n//tag.ejs\n<%- list_tags() %>\n~~~\n归档页模板和首页差不多，归档页只需要展示文章标题和最后的分页器就好:\n\n~~~ JavaScript\n//archive.ejs\n<div class=\"archive\">\n  <% var lastyear; %>\n  <% page.posts.each(function(post){ %>\n    <% var year = post.date.year() %>\n    <% if(lastyear !== year){ %>\n      <h4 class=\"year\"><%= year %></h4>\n      <% lastyear = year %>\n    <% } %>\n    <div class=\"archive_item\">\n      <a class=\"title\" href=\"<%- url_for(post.path) %>\"><%= post.title %></a>\n      <span class=\"date\"><%= post.date.format('YYYY-MM-DD') %></span>\n    </div>\n  <% }) %>\n  <div class=\"pagination\">\n    <%- paginator({ total: Math.ceil(site.posts.length / config.per_page)}) %>\n  </div>\n</div>\n~~~\n至此，模板文件就写好了，对于category模板就放弃了，感觉比较鸡肋。。。\n\n### 变量\n其实在模板文件中我们已经看到了page.post,site.posts.length,config.per_page等等，页面的内容就是根据这些变量获取的，由Hexo提供，拿来直接用，Hexo提供了很多变量，但不是都很常用，一般就用到以下变量:\n\n- site: 对应整个网站的变量，一般会用到site.posts.length制作分页器\n\n- page: 对应当前页面的信息，例如我在index.ejs中使用page.posts获取了当前页面的所有文章而不是使用site.posts。\n\n- config: 博客的配置信息，博客根目录下的_config.yml。\n\n- theme: 主题的配置信息，对于主题根目录下的_config.yml。\n\n#### 辅助函数(Helper)\n制作一个分页器，我们需要知道文章的总数和每页展示的文章数，然后通过循环生成每个link标签，还要根据当前页面判断link标签的active状态，但是在Hexo中这些都不用我们自己来做了!Hexo提供了**paginator**这一辅助函数帮助我们生成分页器，只需要将文章总数site.posts.length和每页文章数config.per_page传入就可以生成了。\n\n##### 其他的Helper:\n\n- **list_tags([options])**: 快速生成标签列表\n\n- **js(path/to/js), css(path/to/css)** 用来载入静态资源，path可以是字符串或数组(载入多个资源)，默认会去source文件夹下去找。\n\n- **partial(path/to/partial)** 引用字模板，默认会去layout文件夹下找。\n\n### 样式\n知道了Hexo的渲染方式，我们就可以使用HTML标签+CSS样式个性化我们的主题了，推荐大家使用CSS预处理语言的一种来写样式，这样就可以通过预处理语言自身的特点让样式更灵活。\n\n### 其他\n#### 添加对多说和Disqus的支持\n\n评论是很常用的功能，不如就直接在我们的主题里支持了，然后通过配置变量决定是否开启，评论区跟在文章内容下面，对于这种三方的代码块，最好也以partial的方式提取出来，方便移除或是替换。\n\n~~~ JavaScript\n//_partial/article.ejs\n<section class='post-content'>\n    <%- post.content %>\n</section>\n//评论部分，post.comments判断是否开启评论，config.duoshuo_shortname\n和config.disqus_shortname来判断启用那种评论插件，这里优先判断了多说\n<% if(post.comments){ %>\n    <section id=\"comments\">\n    <% if (config.duoshuo_shortname){ %>\n            <%- partial('_partial/duoshuo') %>\n        <% }else if(config.disqus_shortname){ %>\n            <%- partial('_partial/disqus') %>\n        <% } %>\n    </section>\n<% } %>\n~~~\n再将多说和Disqus提供的js脚本代码放在**_partial/duoshuo.ejs和_partial/disqus.ejs**下就ok了~\n\n#### 使用highlight.js提供代码高亮\n\nhighlight.js提供了多种语言的支持和多种皮肤，用法也很简单，载入文件后调用初始化方法，一切都帮你搞定，对于使用那种皮肤，喜好因人而异，我们干脆在主题的配置文件中做成配置项让用户自己选择:\n\n~~~ JavaScript\n//showonne/_config.yml\n\n...other configs\n\n# highlight.js\nhighlight_theme: zenburn\n~~~\n对应的layout.ejs中:\n\n~~~ JavaScript\n<link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/<%= theme.highlight_theme %>.min.css\">\n~~~\n样式文件通过CDN引入，因为不同皮肤对应不同的文件名，所以十分灵活。\n\n### 最后\n当初是对应着landscape照葫芦画瓢写的，最近回头来发现一些不合理的地方，所以就又改了改，也对应着写了这么一篇总结，接下来准备再把样式划分一下，对于颜色这类样式通过变量的方式提取出来，也变得可配置，能让主题更灵活一些。\n\n### 参考资源\n","slug":"hexo-learning1","published":1,"date":"2016-12-05T16:00:00.000Z","updated":"2016-12-28T03:15:10.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5s002bbxs67cl1fg4u","content":"<h3 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h3><p>Hexo会读取根目录下的_config.yml里面的theme属性, 从而采用对应的主题。而主题都是放在themes/目录下面的，然后你会发现他里面有个landscape的目录，这个就是默认主题啦。</p>\n<p>接着，我们查看themes/landscape/目录，以及根据文档docs-themes，我们很容易得出：一个主题其实由4部分组成。</p>\n<ul>\n<li>_config.yml: 主题的配置文件</li>\n<li>source/: 放我们的CSS文件以及图片</li>\n<li>layout/: 模板文件</li>\n<li>scripts: 放JavaScript文件，他们会自动加载</li>\n</ul>\n<p>根据文档<a href=\"https://hexo.io/docs/templates.html\" target=\"_blank\" rel=\"external\">docs-templates</a>，下面表格中每个页面都有一个可用的模板，可以没有这些模板，但至少要有一个index模板。</p>\n<a id=\"more\"></a>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Template</th>\n<th style=\"text-align:center\">Page</th>\n<th style=\"text-align:center\">Fallback</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">index</td>\n<td style=\"text-align:center\">Home page</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">post</td>\n<td style=\"text-align:center\">Posts</td>\n<td style=\"text-align:center\">index</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">page</td>\n<td style=\"text-align:center\">Pages</td>\n<td style=\"text-align:center\">index</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">archive</td>\n<td style=\"text-align:center\">Archives</td>\n<td style=\"text-align:center\">index</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">category</td>\n<td style=\"text-align:center\">Category archives</td>\n<td style=\"text-align:center\">archive</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tag</td>\n<td style=\"text-align:center\">Tag archives</td>\n<td style=\"text-align:center\">archive</td>\n</tr>\n</tbody>\n</table>\n<p>每次当我们在浏览器访问时，Hexo都会去解析sources目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以EJS为例)</p>\n<p>无论URL是什么，Hexo先读取layout.ejs，然后里面的body变量会替换成上面表格里的模板：(Fallback的意思是如果访问/archives时，我们的archives.ejs不存在的话，就会返回index.ejs)</p>\n<h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><h4 id=\"编写布局文件-layout-ejs\"><a href=\"#编写布局文件-layout-ejs\" class=\"headerlink\" title=\"编写布局文件(layout.ejs)\"></a>编写布局文件(layout.ejs)</h4><p>模板文件在layout文件夹下，文件名对应Hexo中的模板名，有index,post,page,archive,category,tag几种，对于普通的header + content + footer的页面结构，header和footer往往是可以复用的，因此我们可以使用layout.ejs进行布局，动态的内容使用body变量去动态渲染，所以我的layout.ejs大概长这样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!doctype html&gt;</div><div class=\"line\">&lt;html lang=\"en\"&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=\"UTF-8\"&gt;</div><div class=\"line\">    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/&gt;</div><div class=\"line\">    &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt;</div><div class=\"line\">    &lt;%- css('css/style') %&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;%- partial('_partial/header') %&gt;</div><div class=\"line\">    &lt;div class=\"main\"&gt;</div><div class=\"line\">        &lt;%- body %&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">    &lt;%- partial('_partial/footer') %&gt;</div><div class=\"line\">    &lt;%- js('js/index.js') %&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>partial,js和css是Hexo提供的辅助函数，后面再说。</p>\n<h4 id=\"其他模板文件\"><a href=\"#其他模板文件\" class=\"headerlink\" title=\"其他模板文件\"></a>其他模板文件</h4><p>每一个模板文件对应的是一种布局，当你使用hexo new <title>的时候，其实忽略了一个参数，完整的命令是hexo new [layout] <title>，这个layout就决定了文章使用何种方式布局，比如创建一个自己简介的About页面，hexo new page “about”其实就是使用了page布局。每种布局对应到我们的模板文件上就是index.ejs(首页),post.ejs(文章),archive.ejs(归档),tag.ejs(标签归档),page.ejs(分页)。</title></title></p>\n<h5 id=\"index-ejs\"><a href=\"#index-ejs\" class=\"headerlink\" title=\"index.ejs\"></a>index.ejs</h5><p>首页一般是一些博文的摘要和一个分页器，通过Hexo的page变量拿到页面的数据渲染即可，这里我们不直接在index.ejs中写HTML结构，新建一个_partial/article.ejs，将文章数据传给子模板渲染，然后再额外传入一个参数{index: true}，对后面的post.ejs和page.ejs加以区分，让子模板能正确渲染。最后，index.ejs大致是这样的:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//index.ejs</span></div><div class=\"line\">&lt;% page.posts.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post, index</span>)</span>&#123; %&gt;</div><div class=\"line\">    &lt;%- partial('_partial/article', &#123;index: true, post: post&#125;) %&gt;</div><div class=\"line\">&lt;% &#125;) %&gt;</div><div class=\"line\">&lt;div class=\"pagination\"&gt;</div><div class=\"line\">    &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"post-ejs\"><a href=\"#post-ejs\" class=\"headerlink\" title=\"post.ejs\"></a>post.ejs</h5><p>文章模板和首页差不多，只是对应的是一篇具体的文章，所以就把文章传入，再额外传入{index: false}告诉子模板不要按首页的方式去渲染就好了。就一行代码(因为都在子模板里 XD</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//post.ejs</span></div><div class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/article'</span>, &#123;<span class=\"attr\">index</span>: <span class=\"literal\">false</span>, <span class=\"attr\">post</span>: page&#125;) %&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"page-ejs\"><a href=\"#page-ejs\" class=\"headerlink\" title=\"page.ejs\"></a>page.ejs</h5><p>我个人对Page模板其实是有点懵逼的，在我自己的实践中是添加about(hexo new page “about”)页面后，访问/about会走分页布局，实际上这个页面对应的内容是/source/about里的index.md，也相当于对文章的渲染，因此我把Page模板也写成了和文章模板一样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//page.ejs</span></div><div class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/article'</span>, &#123;<span class=\"attr\">index</span>: <span class=\"literal\">false</span>, <span class=\"attr\">post</span>: page&#125;) %&gt;</div><div class=\"line\">_partial/article.ejs</div></pre></td></tr></table></figure>\n<p>前面一共有三处共用了article模板，另外page和post的一样的，所以实际上只有两种情况:主页(index: true)和非主页(index: false)。对应的_partial/article.ejs里只要判断这个值就可以正确渲染了，基本结构如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//_partial/article.ejs</span></div><div class=\"line\">&lt;% <span class=\"keyword\">if</span>(index)&#123; %&gt;</div><div class=\"line\">    <span class=\"comment\">//index logic...</span></div><div class=\"line\">&lt;% &#125;<span class=\"keyword\">else</span>&#123; %&gt;</div><div class=\"line\">    <span class=\"comment\">//post or page logic...</span></div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"tag-ejs\"><a href=\"#tag-ejs\" class=\"headerlink\" title=\"tag.ejs\"></a>tag.ejs</h5><p>标签归档页内容很少，直接用Hexo的辅助函数list_tags生成一个标签的列表就ok了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//tag.ejs</span></div><div class=\"line\">&lt;%- list_tags() %&gt;</div></pre></td></tr></table></figure>\n<p>归档页模板和首页差不多，归档页只需要展示文章标题和最后的分页器就好:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//archive.ejs</span></div><div class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"archive\"</span>&gt;</div><div class=\"line\">  &lt;% var lastyear; %&gt;</div><div class=\"line\">  &lt;% page.posts.each(function(post)&#123; %&gt;</div><div class=\"line\">    &lt;% var year = post.date.year() %&gt;</div><div class=\"line\">    &lt;% if(lastyear !== year)&#123; %&gt;</div><div class=\"line\">      &lt;h4 class=\"year\"&gt;&lt;%= year %&gt;&lt;/h4&gt;</div><div class=\"line\">      &lt;% lastyear = year %&gt;</div><div class=\"line\">    &lt;% &#125; %&gt;</div><div class=\"line\">    &lt;div class=\"archive_item\"&gt;</div><div class=\"line\">      &lt;a class=\"title\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= post.title %&gt;&lt;/a&gt;</div><div class=\"line\">      &lt;span class=\"date\"&gt;&lt;%= post.date.format('YYYY-MM-DD') %&gt;&lt;/span&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">  &lt;% &#125;) %&gt;</div><div class=\"line\">  &lt;div class=\"pagination\"&gt;</div><div class=\"line\">    &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt;</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>至此，模板文件就写好了，对于category模板就放弃了，感觉比较鸡肋。。。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>其实在模板文件中我们已经看到了page.post,site.posts.length,config.per_page等等，页面的内容就是根据这些变量获取的，由Hexo提供，拿来直接用，Hexo提供了很多变量，但不是都很常用，一般就用到以下变量:</p>\n<ul>\n<li><p>site: 对应整个网站的变量，一般会用到site.posts.length制作分页器</p>\n</li>\n<li><p>page: 对应当前页面的信息，例如我在index.ejs中使用page.posts获取了当前页面的所有文章而不是使用site.posts。</p>\n</li>\n<li><p>config: 博客的配置信息，博客根目录下的_config.yml。</p>\n</li>\n<li><p>theme: 主题的配置信息，对于主题根目录下的_config.yml。</p>\n</li>\n</ul>\n<h4 id=\"辅助函数-Helper\"><a href=\"#辅助函数-Helper\" class=\"headerlink\" title=\"辅助函数(Helper)\"></a>辅助函数(Helper)</h4><p>制作一个分页器，我们需要知道文章的总数和每页展示的文章数，然后通过循环生成每个link标签，还要根据当前页面判断link标签的active状态，但是在Hexo中这些都不用我们自己来做了!Hexo提供了<strong>paginator</strong>这一辅助函数帮助我们生成分页器，只需要将文章总数site.posts.length和每页文章数config.per_page传入就可以生成了。</p>\n<h5 id=\"其他的Helper\"><a href=\"#其他的Helper\" class=\"headerlink\" title=\"其他的Helper:\"></a>其他的Helper:</h5><ul>\n<li><p><strong>list_tags([options])</strong>: 快速生成标签列表</p>\n</li>\n<li><p><strong>js(path/to/js), css(path/to/css)</strong> 用来载入静态资源，path可以是字符串或数组(载入多个资源)，默认会去source文件夹下去找。</p>\n</li>\n<li><p><strong>partial(path/to/partial)</strong> 引用字模板，默认会去layout文件夹下找。</p>\n</li>\n</ul>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><p>知道了Hexo的渲染方式，我们就可以使用HTML标签+CSS样式个性化我们的主题了，推荐大家使用CSS预处理语言的一种来写样式，这样就可以通过预处理语言自身的特点让样式更灵活。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"添加对多说和Disqus的支持\"><a href=\"#添加对多说和Disqus的支持\" class=\"headerlink\" title=\"添加对多说和Disqus的支持\"></a>添加对多说和Disqus的支持</h4><p>评论是很常用的功能，不如就直接在我们的主题里支持了，然后通过配置变量决定是否开启，评论区跟在文章内容下面，对于这种三方的代码块，最好也以partial的方式提取出来，方便移除或是替换。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//_partial/article.ejs</span></div><div class=\"line\">&lt;section <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'post-content'</span>&gt;</div><div class=\"line\">    &lt;%- post.content %&gt;</div><div class=\"line\">&lt;/section&gt;</div><div class=\"line\"><span class=\"comment\">//评论部分，post.comments判断是否开启评论，config.duoshuo_shortname</span></div><div class=\"line\">和config.disqus_shortname来判断启用那种评论插件，这里优先判断了多说</div><div class=\"line\">&lt;% <span class=\"keyword\">if</span>(post.comments)&#123; %&gt;</div><div class=\"line\">    &lt;section id=\"comments\"&gt;</div><div class=\"line\">    &lt;% if (config.duoshuo_shortname)&#123; %&gt;</div><div class=\"line\">            &lt;%- partial('_partial/duoshuo') %&gt;</div><div class=\"line\">        &lt;% &#125;else if(config.disqus_shortname)&#123; %&gt;</div><div class=\"line\">            &lt;%- partial('_partial/disqus') %&gt;</div><div class=\"line\">        &lt;% &#125; %&gt;</div><div class=\"line\">    &lt;/section&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<p>再将多说和Disqus提供的js脚本代码放在<strong>_partial/duoshuo.ejs和_partial/disqus.ejs</strong>下就ok了~</p>\n<h4 id=\"使用highlight-js提供代码高亮\"><a href=\"#使用highlight-js提供代码高亮\" class=\"headerlink\" title=\"使用highlight.js提供代码高亮\"></a>使用highlight.js提供代码高亮</h4><p>highlight.js提供了多种语言的支持和多种皮肤，用法也很简单，载入文件后调用初始化方法，一切都帮你搞定，对于使用那种皮肤，喜好因人而异，我们干脆在主题的配置文件中做成配置项让用户自己选择:</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//showonne/_config.yml</div><div class=\"line\"></div><div class=\"line\">...other configs</div><div class=\"line\"></div><div class=\"line\"># highlight.js</div><div class=\"line\">highlight_theme: zenburn</div></pre></td></tr></table></figure>\n<p>对应的layout.ejs中:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/&lt;%= theme.highlight_theme %&gt;.min.css\"</span>&gt;</div></pre></td></tr></table></figure>\n<p>样式文件通过CDN引入，因为不同皮肤对应不同的文件名，所以十分灵活。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>当初是对应着landscape照葫芦画瓢写的，最近回头来发现一些不合理的地方，所以就又改了改，也对应着写了这么一篇总结，接下来准备再把样式划分一下，对于颜色这类样式通过变量的方式提取出来，也变得可配置，能让主题更灵活一些。</p>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h3>","excerpt":"<h3 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h3><p>Hexo会读取根目录下的_config.yml里面的theme属性, 从而采用对应的主题。而主题都是放在themes/目录下面的，然后你会发现他里面有个landscape的目录，这个就是默认主题啦。</p>\n<p>接着，我们查看themes/landscape/目录，以及根据文档docs-themes，我们很容易得出：一个主题其实由4部分组成。</p>\n<ul>\n<li>_config.yml: 主题的配置文件</li>\n<li>source/: 放我们的CSS文件以及图片</li>\n<li>layout/: 模板文件</li>\n<li>scripts: 放JavaScript文件，他们会自动加载</li>\n</ul>\n<p>根据文档<a href=\"https://hexo.io/docs/templates.html\">docs-templates</a>，下面表格中每个页面都有一个可用的模板，可以没有这些模板，但至少要有一个index模板。</p>","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Template</th>\n<th style=\"text-align:center\">Page</th>\n<th style=\"text-align:center\">Fallback</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">index</td>\n<td style=\"text-align:center\">Home page</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">post</td>\n<td style=\"text-align:center\">Posts</td>\n<td style=\"text-align:center\">index</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">page</td>\n<td style=\"text-align:center\">Pages</td>\n<td style=\"text-align:center\">index</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">archive</td>\n<td style=\"text-align:center\">Archives</td>\n<td style=\"text-align:center\">index</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">category</td>\n<td style=\"text-align:center\">Category archives</td>\n<td style=\"text-align:center\">archive</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tag</td>\n<td style=\"text-align:center\">Tag archives</td>\n<td style=\"text-align:center\">archive</td>\n</tr>\n</tbody>\n</table>\n<p>每次当我们在浏览器访问时，Hexo都会去解析sources目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以EJS为例)</p>\n<p>无论URL是什么，Hexo先读取layout.ejs，然后里面的body变量会替换成上面表格里的模板：(Fallback的意思是如果访问/archives时，我们的archives.ejs不存在的话，就会返回index.ejs)</p>\n<h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><h4 id=\"编写布局文件-layout-ejs\"><a href=\"#编写布局文件-layout-ejs\" class=\"headerlink\" title=\"编写布局文件(layout.ejs)\"></a>编写布局文件(layout.ejs)</h4><p>模板文件在layout文件夹下，文件名对应Hexo中的模板名，有index,post,page,archive,category,tag几种，对于普通的header + content + footer的页面结构，header和footer往往是可以复用的，因此我们可以使用layout.ejs进行布局，动态的内容使用body变量去动态渲染，所以我的layout.ejs大概长这样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!doctype html&gt;</div><div class=\"line\">&lt;html lang=\"en\"&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=\"UTF-8\"&gt;</div><div class=\"line\">    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/&gt;</div><div class=\"line\">    &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt;</div><div class=\"line\">    &lt;%- css('css/style') %&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;%- partial('_partial/header') %&gt;</div><div class=\"line\">    &lt;div class=\"main\"&gt;</div><div class=\"line\">        &lt;%- body %&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">    &lt;%- partial('_partial/footer') %&gt;</div><div class=\"line\">    &lt;%- js('js/index.js') %&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>partial,js和css是Hexo提供的辅助函数，后面再说。</p>\n<h4 id=\"其他模板文件\"><a href=\"#其他模板文件\" class=\"headerlink\" title=\"其他模板文件\"></a>其他模板文件</h4><p>每一个模板文件对应的是一种布局，当你使用hexo new <title>的时候，其实忽略了一个参数，完整的命令是hexo new [layout] <title>，这个layout就决定了文章使用何种方式布局，比如创建一个自己简介的About页面，hexo new page “about”其实就是使用了page布局。每种布局对应到我们的模板文件上就是index.ejs(首页),post.ejs(文章),archive.ejs(归档),tag.ejs(标签归档),page.ejs(分页)。</p>\n<h5 id=\"index-ejs\"><a href=\"#index-ejs\" class=\"headerlink\" title=\"index.ejs\"></a>index.ejs</h5><p>首页一般是一些博文的摘要和一个分页器，通过Hexo的page变量拿到页面的数据渲染即可，这里我们不直接在index.ejs中写HTML结构，新建一个_partial/article.ejs，将文章数据传给子模板渲染，然后再额外传入一个参数{index: true}，对后面的post.ejs和page.ejs加以区分，让子模板能正确渲染。最后，index.ejs大致是这样的:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//index.ejs</span></div><div class=\"line\">&lt;% page.posts.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post, index</span>)</span>&#123; %&gt;</div><div class=\"line\">    &lt;%- partial('_partial/article', &#123;index: true, post: post&#125;) %&gt;</div><div class=\"line\">&lt;% &#125;) %&gt;</div><div class=\"line\">&lt;div class=\"pagination\"&gt;</div><div class=\"line\">    &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"post-ejs\"><a href=\"#post-ejs\" class=\"headerlink\" title=\"post.ejs\"></a>post.ejs</h5><p>文章模板和首页差不多，只是对应的是一篇具体的文章，所以就把文章传入，再额外传入{index: false}告诉子模板不要按首页的方式去渲染就好了。就一行代码(因为都在子模板里 XD</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//post.ejs</span></div><div class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/article'</span>, &#123;<span class=\"attr\">index</span>: <span class=\"literal\">false</span>, <span class=\"attr\">post</span>: page&#125;) %&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"page-ejs\"><a href=\"#page-ejs\" class=\"headerlink\" title=\"page.ejs\"></a>page.ejs</h5><p>我个人对Page模板其实是有点懵逼的，在我自己的实践中是添加about(hexo new page “about”)页面后，访问/about会走分页布局，实际上这个页面对应的内容是/source/about里的index.md，也相当于对文章的渲染，因此我把Page模板也写成了和文章模板一样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//page.ejs</span></div><div class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/article'</span>, &#123;<span class=\"attr\">index</span>: <span class=\"literal\">false</span>, <span class=\"attr\">post</span>: page&#125;) %&gt;</div><div class=\"line\">_partial/article.ejs</div></pre></td></tr></table></figure>\n<p>前面一共有三处共用了article模板，另外page和post的一样的，所以实际上只有两种情况:主页(index: true)和非主页(index: false)。对应的_partial/article.ejs里只要判断这个值就可以正确渲染了，基本结构如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//_partial/article.ejs</span></div><div class=\"line\">&lt;% <span class=\"keyword\">if</span>(index)&#123; %&gt;</div><div class=\"line\">    <span class=\"comment\">//index logic...</span></div><div class=\"line\">&lt;% &#125;<span class=\"keyword\">else</span>&#123; %&gt;</div><div class=\"line\">    <span class=\"comment\">//post or page logic...</span></div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"tag-ejs\"><a href=\"#tag-ejs\" class=\"headerlink\" title=\"tag.ejs\"></a>tag.ejs</h5><p>标签归档页内容很少，直接用Hexo的辅助函数list_tags生成一个标签的列表就ok了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//tag.ejs</span></div><div class=\"line\">&lt;%- list_tags() %&gt;</div></pre></td></tr></table></figure>\n<p>归档页模板和首页差不多，归档页只需要展示文章标题和最后的分页器就好:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//archive.ejs</span></div><div class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"archive\"</span>&gt;</div><div class=\"line\">  &lt;% var lastyear; %&gt;</div><div class=\"line\">  &lt;% page.posts.each(function(post)&#123; %&gt;</div><div class=\"line\">    &lt;% var year = post.date.year() %&gt;</div><div class=\"line\">    &lt;% if(lastyear !== year)&#123; %&gt;</div><div class=\"line\">      &lt;h4 class=\"year\"&gt;&lt;%= year %&gt;&lt;/h4&gt;</div><div class=\"line\">      &lt;% lastyear = year %&gt;</div><div class=\"line\">    &lt;% &#125; %&gt;</div><div class=\"line\">    &lt;div class=\"archive_item\"&gt;</div><div class=\"line\">      &lt;a class=\"title\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= post.title %&gt;&lt;/a&gt;</div><div class=\"line\">      &lt;span class=\"date\"&gt;&lt;%= post.date.format('YYYY-MM-DD') %&gt;&lt;/span&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">  &lt;% &#125;) %&gt;</div><div class=\"line\">  &lt;div class=\"pagination\"&gt;</div><div class=\"line\">    &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt;</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>至此，模板文件就写好了，对于category模板就放弃了，感觉比较鸡肋。。。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>其实在模板文件中我们已经看到了page.post,site.posts.length,config.per_page等等，页面的内容就是根据这些变量获取的，由Hexo提供，拿来直接用，Hexo提供了很多变量，但不是都很常用，一般就用到以下变量:</p>\n<ul>\n<li><p>site: 对应整个网站的变量，一般会用到site.posts.length制作分页器</p>\n</li>\n<li><p>page: 对应当前页面的信息，例如我在index.ejs中使用page.posts获取了当前页面的所有文章而不是使用site.posts。</p>\n</li>\n<li><p>config: 博客的配置信息，博客根目录下的_config.yml。</p>\n</li>\n<li><p>theme: 主题的配置信息，对于主题根目录下的_config.yml。</p>\n</li>\n</ul>\n<h4 id=\"辅助函数-Helper\"><a href=\"#辅助函数-Helper\" class=\"headerlink\" title=\"辅助函数(Helper)\"></a>辅助函数(Helper)</h4><p>制作一个分页器，我们需要知道文章的总数和每页展示的文章数，然后通过循环生成每个link标签，还要根据当前页面判断link标签的active状态，但是在Hexo中这些都不用我们自己来做了!Hexo提供了<strong>paginator</strong>这一辅助函数帮助我们生成分页器，只需要将文章总数site.posts.length和每页文章数config.per_page传入就可以生成了。</p>\n<h5 id=\"其他的Helper\"><a href=\"#其他的Helper\" class=\"headerlink\" title=\"其他的Helper:\"></a>其他的Helper:</h5><ul>\n<li><p><strong>list_tags([options])</strong>: 快速生成标签列表</p>\n</li>\n<li><p><strong>js(path/to/js), css(path/to/css)</strong> 用来载入静态资源，path可以是字符串或数组(载入多个资源)，默认会去source文件夹下去找。</p>\n</li>\n<li><p><strong>partial(path/to/partial)</strong> 引用字模板，默认会去layout文件夹下找。</p>\n</li>\n</ul>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><p>知道了Hexo的渲染方式，我们就可以使用HTML标签+CSS样式个性化我们的主题了，推荐大家使用CSS预处理语言的一种来写样式，这样就可以通过预处理语言自身的特点让样式更灵活。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"添加对多说和Disqus的支持\"><a href=\"#添加对多说和Disqus的支持\" class=\"headerlink\" title=\"添加对多说和Disqus的支持\"></a>添加对多说和Disqus的支持</h4><p>评论是很常用的功能，不如就直接在我们的主题里支持了，然后通过配置变量决定是否开启，评论区跟在文章内容下面，对于这种三方的代码块，最好也以partial的方式提取出来，方便移除或是替换。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//_partial/article.ejs</span></div><div class=\"line\">&lt;section <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'post-content'</span>&gt;</div><div class=\"line\">    &lt;%- post.content %&gt;</div><div class=\"line\">&lt;/section&gt;</div><div class=\"line\"><span class=\"comment\">//评论部分，post.comments判断是否开启评论，config.duoshuo_shortname</span></div><div class=\"line\">和config.disqus_shortname来判断启用那种评论插件，这里优先判断了多说</div><div class=\"line\">&lt;% <span class=\"keyword\">if</span>(post.comments)&#123; %&gt;</div><div class=\"line\">    &lt;section id=\"comments\"&gt;</div><div class=\"line\">    &lt;% if (config.duoshuo_shortname)&#123; %&gt;</div><div class=\"line\">            &lt;%- partial('_partial/duoshuo') %&gt;</div><div class=\"line\">        &lt;% &#125;else if(config.disqus_shortname)&#123; %&gt;</div><div class=\"line\">            &lt;%- partial('_partial/disqus') %&gt;</div><div class=\"line\">        &lt;% &#125; %&gt;</div><div class=\"line\">    &lt;/section&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<p>再将多说和Disqus提供的js脚本代码放在<strong>_partial/duoshuo.ejs和_partial/disqus.ejs</strong>下就ok了~</p>\n<h4 id=\"使用highlight-js提供代码高亮\"><a href=\"#使用highlight-js提供代码高亮\" class=\"headerlink\" title=\"使用highlight.js提供代码高亮\"></a>使用highlight.js提供代码高亮</h4><p>highlight.js提供了多种语言的支持和多种皮肤，用法也很简单，载入文件后调用初始化方法，一切都帮你搞定，对于使用那种皮肤，喜好因人而异，我们干脆在主题的配置文件中做成配置项让用户自己选择:</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//showonne/_config.yml</div><div class=\"line\"></div><div class=\"line\">...other configs</div><div class=\"line\"></div><div class=\"line\"># highlight.js</div><div class=\"line\">highlight_theme: zenburn</div></pre></td></tr></table></figure>\n<p>对应的layout.ejs中:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/&lt;%= theme.highlight_theme %&gt;.min.css\"</span>&gt;</div></pre></td></tr></table></figure>\n<p>样式文件通过CDN引入，因为不同皮肤对应不同的文件名，所以十分灵活。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>当初是对应着landscape照葫芦画瓢写的，最近回头来发现一些不合理的地方，所以就又改了改，也对应着写了这么一篇总结，接下来准备再把样式划分一下，对于颜色这类样式通过变量的方式提取出来，也变得可配置，能让主题更灵活一些。</p>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h3>"},{"layout":"post","title":"Hexo 模板学习——EJS介绍","keywords":"EJS介绍","banner":"http://obxk8w81b.bkt.clouddn.com/Bulb%20Fields.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Bulb%20Fields.jpg","_content":"\n### 什么是EJS？\n\nEJS是JavaScript模板库，用来从JSON数据中生成HTML字符串\n\n### EJS的语法和功能：\n#### 1、缓存功能，能够缓存已经解析好的html模版\n\n#### 2、&lt;% code %&gt;用于执行其中javascript代码。\n~~~ javascript\n<% alert('hello world') %>\n~~~\n#### 3、&lt;%= code =%&gt;会对code进行html转义；\n\n<!--more-->\n\n~~~ javascript\n<h1><%=title %></h1>                    注：会把title里面存的值给显示出来在h1中。\n<p><%= 'hello world' %></p>             注：会把hello world显示在h1中。\n<h1><%= '<b>hello world</b>' %></h1>    注：会把hello world变粗，然后显示在h1中。\n~~~ javascript\n#### 4、<%- code %>将不会进行转义；，这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。\n\n~~~ javascript\n<h1><%-title %>asd</h1>          最后显示asd，及显示原网页\n<p><%# 'hello world' %>asd</p>   最后显示asd，及显示原网页\n~~~\n#### 5、支持自定义标签，比如'&lt;%'可以使用'{{'，'%&gt;'用'}}'代替；\n\n    ejs 里，默认的闭合标记是 <%  .. %>，我们也可以定义自己的标签。例如：\n\n~~~ javascript\napp.set(\"view options\",{                                                                                  \n   \"open\":\"{{\",                                                                                  \n   \"close\":\"}}\"\n});\n~~~\n#### 6、提供一些辅助函数，用于模版中使用\n\n- 1)、first，返回数组的第一个元素；\n- 2)、last，返回数组的最后一个元素；\n- 3)、capitalize，返回首字母大写的字符串；\n- 4)、downcase，返回字符串的小写；\n- 5)、upcase，返回字符串的大写；\n- 6)、sort，排序（Object.create(obj).sort()？）；\n- 7)、sort_by:'prop'，按照指定的prop属性进行升序排序；\n- 8)、size，返回长度，即length属性，不一定非是数组才行；\n- 9)、plus:n，加上n，将转化为Number进行运算；\n- 10)、minus:n，减去n，将转化为Number进行运算；\n- 11)、times:n，乘以n，将转化为Number进行运算；\n- 12)、divided_by:n，除以n，将转化为Number进行运算；\n- 13)、join:'val'，将数组用'val'最为分隔符，进行合并成一个字符串；\n- 14)、truncate:n，截取前n个字符，超过长度时，将返回一个副本\n- 15)、truncate_words:n，取得字符串中的前n个word，word以空格进行分割；\n- 16)、replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；\n- 17)、prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；\n- 18)、append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；\n- 19)、map:'prop'，返回对象数组中属性为prop的值组成的数组；\n- 20)、reverse，翻转数组或字符串；\n- 21)、get:'prop'，取得属性为'prop'的值；\n- 22)、json，转化为json格式字符串\n\n**利用&lt;%- include filename %&gt;加载其他页面模版；**\n\n#### ejs我的总结：\n\nejs 写法：\n\n- 1.普通传入并使用变量：\n\n~~~ JavaScript\n<%= title %>\n~~~\n\n- 2.普通for执行js代码（for中间的代码一定可以执行到）：\n\n~~~ JavaScript\n<% for(var i=0; i<headerNavbar.length; i++) {%>\n    <li><a href=\"/reg\"><%= headerNavbar[i].name %></a></li>\n<% } %>\n~~~\n\n- 3.特殊if语句的js代码（if中间的额代码不一定可以执行到）：\n\n~~~ JavaScript\n <% if(active=='index'){%>\nclass=\"active\"\n <% }%>\n~~~\n","source":"_posts/2016-12-04-hexo-learning0.md","raw":"---\nlayout: post\ntitle:  Hexo 模板学习——EJS介绍\ncategory: accumulation\ntags: EJS\nkeywords: EJS介绍\nbanner: http://obxk8w81b.bkt.clouddn.com/Bulb%20Fields.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Bulb%20Fields.jpg\n---\n\n### 什么是EJS？\n\nEJS是JavaScript模板库，用来从JSON数据中生成HTML字符串\n\n### EJS的语法和功能：\n#### 1、缓存功能，能够缓存已经解析好的html模版\n\n#### 2、&lt;% code %&gt;用于执行其中javascript代码。\n~~~ javascript\n<% alert('hello world') %>\n~~~\n#### 3、&lt;%= code =%&gt;会对code进行html转义；\n\n<!--more-->\n\n~~~ javascript\n<h1><%=title %></h1>                    注：会把title里面存的值给显示出来在h1中。\n<p><%= 'hello world' %></p>             注：会把hello world显示在h1中。\n<h1><%= '<b>hello world</b>' %></h1>    注：会把hello world变粗，然后显示在h1中。\n~~~ javascript\n#### 4、<%- code %>将不会进行转义；，这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。\n\n~~~ javascript\n<h1><%-title %>asd</h1>          最后显示asd，及显示原网页\n<p><%# 'hello world' %>asd</p>   最后显示asd，及显示原网页\n~~~\n#### 5、支持自定义标签，比如'&lt;%'可以使用'{{'，'%&gt;'用'}}'代替；\n\n    ejs 里，默认的闭合标记是 <%  .. %>，我们也可以定义自己的标签。例如：\n\n~~~ javascript\napp.set(\"view options\",{                                                                                  \n   \"open\":\"{{\",                                                                                  \n   \"close\":\"}}\"\n});\n~~~\n#### 6、提供一些辅助函数，用于模版中使用\n\n- 1)、first，返回数组的第一个元素；\n- 2)、last，返回数组的最后一个元素；\n- 3)、capitalize，返回首字母大写的字符串；\n- 4)、downcase，返回字符串的小写；\n- 5)、upcase，返回字符串的大写；\n- 6)、sort，排序（Object.create(obj).sort()？）；\n- 7)、sort_by:'prop'，按照指定的prop属性进行升序排序；\n- 8)、size，返回长度，即length属性，不一定非是数组才行；\n- 9)、plus:n，加上n，将转化为Number进行运算；\n- 10)、minus:n，减去n，将转化为Number进行运算；\n- 11)、times:n，乘以n，将转化为Number进行运算；\n- 12)、divided_by:n，除以n，将转化为Number进行运算；\n- 13)、join:'val'，将数组用'val'最为分隔符，进行合并成一个字符串；\n- 14)、truncate:n，截取前n个字符，超过长度时，将返回一个副本\n- 15)、truncate_words:n，取得字符串中的前n个word，word以空格进行分割；\n- 16)、replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；\n- 17)、prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；\n- 18)、append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；\n- 19)、map:'prop'，返回对象数组中属性为prop的值组成的数组；\n- 20)、reverse，翻转数组或字符串；\n- 21)、get:'prop'，取得属性为'prop'的值；\n- 22)、json，转化为json格式字符串\n\n**利用&lt;%- include filename %&gt;加载其他页面模版；**\n\n#### ejs我的总结：\n\nejs 写法：\n\n- 1.普通传入并使用变量：\n\n~~~ JavaScript\n<%= title %>\n~~~\n\n- 2.普通for执行js代码（for中间的代码一定可以执行到）：\n\n~~~ JavaScript\n<% for(var i=0; i<headerNavbar.length; i++) {%>\n    <li><a href=\"/reg\"><%= headerNavbar[i].name %></a></li>\n<% } %>\n~~~\n\n- 3.特殊if语句的js代码（if中间的额代码不一定可以执行到）：\n\n~~~ JavaScript\n <% if(active=='index'){%>\nclass=\"active\"\n <% }%>\n~~~\n","slug":"hexo-learning0","published":1,"date":"2016-12-03T16:00:00.000Z","updated":"2016-12-28T03:08:26.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5t002ebxs6e6v8eh9i","content":"<h3 id=\"什么是EJS？\"><a href=\"#什么是EJS？\" class=\"headerlink\" title=\"什么是EJS？\"></a>什么是EJS？</h3><p>EJS是JavaScript模板库，用来从JSON数据中生成HTML字符串</p>\n<h3 id=\"EJS的语法和功能：\"><a href=\"#EJS的语法和功能：\" class=\"headerlink\" title=\"EJS的语法和功能：\"></a>EJS的语法和功能：</h3><h4 id=\"1、缓存功能，能够缓存已经解析好的html模版\"><a href=\"#1、缓存功能，能够缓存已经解析好的html模版\" class=\"headerlink\" title=\"1、缓存功能，能够缓存已经解析好的html模版\"></a>1、缓存功能，能够缓存已经解析好的html模版</h4><h4 id=\"2、-lt-code-gt-用于执行其中javascript代码。\"><a href=\"#2、-lt-code-gt-用于执行其中javascript代码。\" class=\"headerlink\" title=\"2、&lt;% code %&gt;用于执行其中javascript代码。\"></a>2、&lt;% code %&gt;用于执行其中javascript代码。</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;% alert(<span class=\"string\">'hello world'</span>) %&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"3、-lt-code-gt-会对code进行html转义；\"><a href=\"#3、-lt-code-gt-会对code进行html转义；\" class=\"headerlink\" title=\"3、&lt;%= code =%&gt;会对code进行html转义；\"></a>3、&lt;%= code =%&gt;会对code进行html转义；</h4><a id=\"more\"></a>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&lt;%=title %&gt;&lt;/h1&gt;                    注：会把title里面存的值给显示出来在h1中。</div><div class=\"line\">&lt;p&gt;&lt;%= 'hello world' %&gt;&lt;/p&gt;             注：会把hello world显示在h1中。</div><div class=\"line\">&lt;h1&gt;&lt;%= '&lt;b&gt;hello world&lt;/b&gt;' %&gt;&lt;/h1&gt;    注：会把hello world变粗，然后显示在h1中。</div><div class=\"line\">~~~ javascript</div><div class=\"line\">#### 4、&lt;%- code %&gt;将不会进行转义；，这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。</div><div class=\"line\"></div><div class=\"line\">~~~ javascript</div><div class=\"line\">&lt;h1&gt;&lt;%-title %&gt;asd&lt;/h1&gt;          最后显示asd，及显示原网页</div><div class=\"line\">&lt;p&gt;&lt;%# 'hello world' %&gt;asd&lt;/p&gt;   最后显示asd，及显示原网页</div></pre></td></tr></table></figure>\n<h4 id=\"5、支持自定义标签，比如’-lt-’可以使用’‘代替；\"><a href=\"#5、支持自定义标签，比如’-lt-’可以使用’‘代替；\" class=\"headerlink\" title=\"5、支持自定义标签，比如’&lt;%’可以使用’‘代替；\"></a>5、支持自定义标签，比如’&lt;%’可以使用’NaN‘代替；</h4><pre><code>ejs 里，默认的闭合标记是 &lt;%  .. %&gt;，我们也可以定义自己的标签。例如：\n</code></pre><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.set(<span class=\"string\">\"view options\"</span>,&#123;                                                                                  </div><div class=\"line\">   <span class=\"string\">\"open\"</span>:<span class=\"string\">\"&#123;&#123;\"</span>,                                                                                  </div><div class=\"line\">   <span class=\"string\">\"close\"</span>:<span class=\"string\">\"&#125;&#125;\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"6、提供一些辅助函数，用于模版中使用\"><a href=\"#6、提供一些辅助函数，用于模版中使用\" class=\"headerlink\" title=\"6、提供一些辅助函数，用于模版中使用\"></a>6、提供一些辅助函数，用于模版中使用</h4><ul>\n<li>1)、first，返回数组的第一个元素；</li>\n<li>2)、last，返回数组的最后一个元素；</li>\n<li>3)、capitalize，返回首字母大写的字符串；</li>\n<li>4)、downcase，返回字符串的小写；</li>\n<li>5)、upcase，返回字符串的大写；</li>\n<li>6)、sort，排序（Object.create(obj).sort()？）；</li>\n<li>7)、sort_by:’prop’，按照指定的prop属性进行升序排序；</li>\n<li>8)、size，返回长度，即length属性，不一定非是数组才行；</li>\n<li>9)、plus:n，加上n，将转化为Number进行运算；</li>\n<li>10)、minus:n，减去n，将转化为Number进行运算；</li>\n<li>11)、times:n，乘以n，将转化为Number进行运算；</li>\n<li>12)、divided_by:n，除以n，将转化为Number进行运算；</li>\n<li>13)、join:’val’，将数组用’val’最为分隔符，进行合并成一个字符串；</li>\n<li>14)、truncate:n，截取前n个字符，超过长度时，将返回一个副本</li>\n<li>15)、truncate_words:n，取得字符串中的前n个word，word以空格进行分割；</li>\n<li>16)、replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；</li>\n<li>17)、prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；</li>\n<li>18)、append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；</li>\n<li>19)、map:’prop’，返回对象数组中属性为prop的值组成的数组；</li>\n<li>20)、reverse，翻转数组或字符串；</li>\n<li>21)、get:’prop’，取得属性为’prop’的值；</li>\n<li>22)、json，转化为json格式字符串</li>\n</ul>\n<p><strong>利用&lt;%- include filename %&gt;加载其他页面模版；</strong></p>\n<h4 id=\"ejs我的总结：\"><a href=\"#ejs我的总结：\" class=\"headerlink\" title=\"ejs我的总结：\"></a>ejs我的总结：</h4><p>ejs 写法：</p>\n<ul>\n<li>1.普通传入并使用变量：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;%= title %&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>2.普通for执行js代码（for中间的代码一定可以执行到）：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;% <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;headerNavbar.length; i++) &#123;%&gt;</div><div class=\"line\">    &lt;li&gt;&lt;a href=\"/reg\"&gt;&lt;%= headerNavbar[i].name %&gt;&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>3.特殊if语句的js代码（if中间的额代码不一定可以执行到）：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"> &lt;% <span class=\"keyword\">if</span>(active==<span class=\"string\">'index'</span>)&#123;%&gt;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"active\"</span></div><div class=\"line\"> &lt;% &#125;%&gt;</div></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"什么是EJS？\"><a href=\"#什么是EJS？\" class=\"headerlink\" title=\"什么是EJS？\"></a>什么是EJS？</h3><p>EJS是JavaScript模板库，用来从JSON数据中生成HTML字符串</p>\n<h3 id=\"EJS的语法和功能：\"><a href=\"#EJS的语法和功能：\" class=\"headerlink\" title=\"EJS的语法和功能：\"></a>EJS的语法和功能：</h3><h4 id=\"1、缓存功能，能够缓存已经解析好的html模版\"><a href=\"#1、缓存功能，能够缓存已经解析好的html模版\" class=\"headerlink\" title=\"1、缓存功能，能够缓存已经解析好的html模版\"></a>1、缓存功能，能够缓存已经解析好的html模版</h4><h4 id=\"2、-lt-code-gt-用于执行其中javascript代码。\"><a href=\"#2、-lt-code-gt-用于执行其中javascript代码。\" class=\"headerlink\" title=\"2、&lt;% code %&gt;用于执行其中javascript代码。\"></a>2、&lt;% code %&gt;用于执行其中javascript代码。</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;% alert(<span class=\"string\">'hello world'</span>) %&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"3、-lt-code-gt-会对code进行html转义；\"><a href=\"#3、-lt-code-gt-会对code进行html转义；\" class=\"headerlink\" title=\"3、&lt;%= code =%&gt;会对code进行html转义；\"></a>3、&lt;%= code =%&gt;会对code进行html转义；</h4>","more":"<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&lt;%=title %&gt;&lt;/h1&gt;                    注：会把title里面存的值给显示出来在h1中。</div><div class=\"line\">&lt;p&gt;&lt;%= 'hello world' %&gt;&lt;/p&gt;             注：会把hello world显示在h1中。</div><div class=\"line\">&lt;h1&gt;&lt;%= '&lt;b&gt;hello world&lt;/b&gt;' %&gt;&lt;/h1&gt;    注：会把hello world变粗，然后显示在h1中。</div><div class=\"line\">~~~ javascript</div><div class=\"line\">#### 4、&lt;%- code %&gt;将不会进行转义；，这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。</div><div class=\"line\"></div><div class=\"line\">~~~ javascript</div><div class=\"line\">&lt;h1&gt;&lt;%-title %&gt;asd&lt;/h1&gt;          最后显示asd，及显示原网页</div><div class=\"line\">&lt;p&gt;&lt;%# 'hello world' %&gt;asd&lt;/p&gt;   最后显示asd，及显示原网页</div></pre></td></tr></table></figure>\n<h4 id=\"5、支持自定义标签，比如’-lt-’可以使用’‘代替；\"><a href=\"#5、支持自定义标签，比如’-lt-’可以使用’‘代替；\" class=\"headerlink\" title=\"5、支持自定义标签，比如’&lt;%’可以使用’‘代替；\"></a>5、支持自定义标签，比如’&lt;%’可以使用’NaN‘代替；</h4><pre><code>ejs 里，默认的闭合标记是 &lt;%  .. %&gt;，我们也可以定义自己的标签。例如：\n</code></pre><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.set(<span class=\"string\">\"view options\"</span>,&#123;                                                                                  </div><div class=\"line\">   <span class=\"string\">\"open\"</span>:<span class=\"string\">\"&#123;&#123;\"</span>,                                                                                  </div><div class=\"line\">   <span class=\"string\">\"close\"</span>:<span class=\"string\">\"&#125;&#125;\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"6、提供一些辅助函数，用于模版中使用\"><a href=\"#6、提供一些辅助函数，用于模版中使用\" class=\"headerlink\" title=\"6、提供一些辅助函数，用于模版中使用\"></a>6、提供一些辅助函数，用于模版中使用</h4><ul>\n<li>1)、first，返回数组的第一个元素；</li>\n<li>2)、last，返回数组的最后一个元素；</li>\n<li>3)、capitalize，返回首字母大写的字符串；</li>\n<li>4)、downcase，返回字符串的小写；</li>\n<li>5)、upcase，返回字符串的大写；</li>\n<li>6)、sort，排序（Object.create(obj).sort()？）；</li>\n<li>7)、sort_by:’prop’，按照指定的prop属性进行升序排序；</li>\n<li>8)、size，返回长度，即length属性，不一定非是数组才行；</li>\n<li>9)、plus:n，加上n，将转化为Number进行运算；</li>\n<li>10)、minus:n，减去n，将转化为Number进行运算；</li>\n<li>11)、times:n，乘以n，将转化为Number进行运算；</li>\n<li>12)、divided_by:n，除以n，将转化为Number进行运算；</li>\n<li>13)、join:’val’，将数组用’val’最为分隔符，进行合并成一个字符串；</li>\n<li>14)、truncate:n，截取前n个字符，超过长度时，将返回一个副本</li>\n<li>15)、truncate_words:n，取得字符串中的前n个word，word以空格进行分割；</li>\n<li>16)、replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；</li>\n<li>17)、prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；</li>\n<li>18)、append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；</li>\n<li>19)、map:’prop’，返回对象数组中属性为prop的值组成的数组；</li>\n<li>20)、reverse，翻转数组或字符串；</li>\n<li>21)、get:’prop’，取得属性为’prop’的值；</li>\n<li>22)、json，转化为json格式字符串</li>\n</ul>\n<p><strong>利用&lt;%- include filename %&gt;加载其他页面模版；</strong></p>\n<h4 id=\"ejs我的总结：\"><a href=\"#ejs我的总结：\" class=\"headerlink\" title=\"ejs我的总结：\"></a>ejs我的总结：</h4><p>ejs 写法：</p>\n<ul>\n<li>1.普通传入并使用变量：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;%= title %&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>2.普通for执行js代码（for中间的代码一定可以执行到）：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;% <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;headerNavbar.length; i++) &#123;%&gt;</div><div class=\"line\">    &lt;li&gt;&lt;a href=\"/reg\"&gt;&lt;%= headerNavbar[i].name %&gt;&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>3.特殊if语句的js代码（if中间的额代码不一定可以执行到）：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"> &lt;% <span class=\"keyword\">if</span>(active==<span class=\"string\">'index'</span>)&#123;%&gt;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"active\"</span></div><div class=\"line\"> &lt;% &#125;%&gt;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Android 增量更新整理","keywords":"Android Patch Update","banner":"http://obxk8w81b.bkt.clouddn.com/Cottages%20with%20a%20Woman%20Working%20in%20the%20Foreground.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Cottages%20with%20a%20Woman%20Working%20in%20the%20Foreground.jpg","_content":"\n### 背景\n在前几年，整体移动网络环境相比现在差很多，加之流量费用又相对较高，因此每当我们发布新版本的时候，一些用户升级并不是很积极，这就造成了新版本的升级率并不高。而google为了解决了这个问题，提出了Smart App Update，即增量更新（也叫做差分升级）。\n\n增量更新与热修复完全不是一个东西。增量更新需要重新安装apk，而热修复不需要。热修复也能完成部分增量更新的功能。\n\n\n### 增量更新的流程\n增量更新的具体流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的，当然部分应用市场有root权限你可能感知不到）。\n\n<!--more-->\n\n### 增量更新的原理\n增量更新的原理也很简单，就是将手机上已安装的旧版本apk与服务器端新版本apk进行二进制对比，并得到差分包（patch），用户在升级更新应用时，只需要下载差分包，然后在本地使用差分包与旧版的apk合成新版apk，然后进行安装。差分包文件的大小，那就远比APK小得多了，这样也便于用户进行应用升级。\n\n\n那么增量更新的流程可以细化为几个关键点：\n\n- 1.用户手机上提取当前安装应用的apk\n- 2.如何利用old.apk和new.apk生成增量文件（差分包）\n- 3.增加文件与1.中的old.apk合并，然后安装\n\n旧版的APK可以在**/data/app/%packagename%/**下找到。\n\n也可以参考下面的代码：\n\n~~~ JavaScript\npublic class ApkExtract {\n    public static String extract(Context context) {\n        context = context.getApplicationContext();\n        ApplicationInfo applicationInfo = context.getApplicationInfo();\n        String apkPath = applicationInfo.sourceDir;\n        Log.d(\"hongyang\", apkPath);\n        return apkPath;\n    }\n}\n~~~\n\n#### 关于生成差分包\n制作差分包的工具为[bsdiff](http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz)，\n\n网址：\n\nhttp://www.daemonology.net/bsdiff/\n\n下载地址：\n\nhttp://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz\n\n这是一个非常牛的二进制查分工具，bsdiff源代码在Android的源码目录下 ”\\\\external\\\\bsdiff“”这边也可以找到。另外还需要依赖[bzlib](http://www.bzip.org/downloads.html)来进行打包。在安全性方面，补丁和新旧版APK最好都要进行MD5验证，以免被篡改。\n\n关于这个工具可以使用别人编译好的so库，[这里](https://github.com/hongyangAndroid/BsDiff_And_Patch/tree/master/so-dist)；熟悉NDK开发的也可以自己编译，[请看这里](http://blog.csdn.net/lmj623565791/article/details/52761658)。这里就不在考虑这个工具问题了。\n\n- 生成增量文件\n~~~ JavaScript\n./bsdiff old.apk new.apk old-to-new.patch\n~~~\n这样就生成了一个增量文件old-to-new.patch\n\n#### 关于合并差分包\n生成差分包肯定是在服务端，合并差分包才是Android客户端需要做的：\n\n- 增量文件和old.apk合并成新的apk\n~~~ JavaScript\n./bspatch old.apk new2.apk old-to-new.patch\n~~~\n这样就生成一个new2.apk\n\n生成后，要查看下两个文件的md5值。如果两个文件md5值一致，那么几乎可以肯定两个文件时一模一样的。\n\n\n### 增量更新存在的不足\n- 1、增量升级是以两个应用版本之间的差异来生成补丁的，但是我们无法保证用户每次的及时升级到最新，也就是在更新前，新版和旧版只差一个版本，所以必须对你所发布的每一个版本都和最新的版本作差分，以便使所有版本的用户都可以差分升级，这样相对就比较繁琐了。解决方法也有，可以通过Shell脚本来实现批量生成。\n\n- 2.增量升级能成功的前提是，从手机端能够获得旧版APK，并且与服务端的APK签名是一样的，所以像那些破解的APP就无法实现更新。前面也提到了，为了安全性，防止补丁合成错误，最好在补丁合成前对旧版本的apk进行sha1或者MD5校验，保证基础包的一致性，这样才能顺利的实现增量升级。\n\n想要封装一套增量更新的工具，请看这篇文章：[打造Android万能的软件更新库，修改只要一点点](http://blog.csdn.net/huang_cai_yuan/article/details/52927630)\n","source":"_posts/2016-12-20-Android-patch-update.md","raw":"---\nlayout: post\ntitle:  Android 增量更新整理\ncategory: accumulation\ntags: Android Patch Update\nkeywords: Android Patch Update\nbanner: http://obxk8w81b.bkt.clouddn.com/Cottages%20with%20a%20Woman%20Working%20in%20the%20Foreground.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Cottages%20with%20a%20Woman%20Working%20in%20the%20Foreground.jpg\n---\n\n### 背景\n在前几年，整体移动网络环境相比现在差很多，加之流量费用又相对较高，因此每当我们发布新版本的时候，一些用户升级并不是很积极，这就造成了新版本的升级率并不高。而google为了解决了这个问题，提出了Smart App Update，即增量更新（也叫做差分升级）。\n\n增量更新与热修复完全不是一个东西。增量更新需要重新安装apk，而热修复不需要。热修复也能完成部分增量更新的功能。\n\n\n### 增量更新的流程\n增量更新的具体流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的，当然部分应用市场有root权限你可能感知不到）。\n\n<!--more-->\n\n### 增量更新的原理\n增量更新的原理也很简单，就是将手机上已安装的旧版本apk与服务器端新版本apk进行二进制对比，并得到差分包（patch），用户在升级更新应用时，只需要下载差分包，然后在本地使用差分包与旧版的apk合成新版apk，然后进行安装。差分包文件的大小，那就远比APK小得多了，这样也便于用户进行应用升级。\n\n\n那么增量更新的流程可以细化为几个关键点：\n\n- 1.用户手机上提取当前安装应用的apk\n- 2.如何利用old.apk和new.apk生成增量文件（差分包）\n- 3.增加文件与1.中的old.apk合并，然后安装\n\n旧版的APK可以在**/data/app/%packagename%/**下找到。\n\n也可以参考下面的代码：\n\n~~~ JavaScript\npublic class ApkExtract {\n    public static String extract(Context context) {\n        context = context.getApplicationContext();\n        ApplicationInfo applicationInfo = context.getApplicationInfo();\n        String apkPath = applicationInfo.sourceDir;\n        Log.d(\"hongyang\", apkPath);\n        return apkPath;\n    }\n}\n~~~\n\n#### 关于生成差分包\n制作差分包的工具为[bsdiff](http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz)，\n\n网址：\n\nhttp://www.daemonology.net/bsdiff/\n\n下载地址：\n\nhttp://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz\n\n这是一个非常牛的二进制查分工具，bsdiff源代码在Android的源码目录下 ”\\\\external\\\\bsdiff“”这边也可以找到。另外还需要依赖[bzlib](http://www.bzip.org/downloads.html)来进行打包。在安全性方面，补丁和新旧版APK最好都要进行MD5验证，以免被篡改。\n\n关于这个工具可以使用别人编译好的so库，[这里](https://github.com/hongyangAndroid/BsDiff_And_Patch/tree/master/so-dist)；熟悉NDK开发的也可以自己编译，[请看这里](http://blog.csdn.net/lmj623565791/article/details/52761658)。这里就不在考虑这个工具问题了。\n\n- 生成增量文件\n~~~ JavaScript\n./bsdiff old.apk new.apk old-to-new.patch\n~~~\n这样就生成了一个增量文件old-to-new.patch\n\n#### 关于合并差分包\n生成差分包肯定是在服务端，合并差分包才是Android客户端需要做的：\n\n- 增量文件和old.apk合并成新的apk\n~~~ JavaScript\n./bspatch old.apk new2.apk old-to-new.patch\n~~~\n这样就生成一个new2.apk\n\n生成后，要查看下两个文件的md5值。如果两个文件md5值一致，那么几乎可以肯定两个文件时一模一样的。\n\n\n### 增量更新存在的不足\n- 1、增量升级是以两个应用版本之间的差异来生成补丁的，但是我们无法保证用户每次的及时升级到最新，也就是在更新前，新版和旧版只差一个版本，所以必须对你所发布的每一个版本都和最新的版本作差分，以便使所有版本的用户都可以差分升级，这样相对就比较繁琐了。解决方法也有，可以通过Shell脚本来实现批量生成。\n\n- 2.增量升级能成功的前提是，从手机端能够获得旧版APK，并且与服务端的APK签名是一样的，所以像那些破解的APP就无法实现更新。前面也提到了，为了安全性，防止补丁合成错误，最好在补丁合成前对旧版本的apk进行sha1或者MD5校验，保证基础包的一致性，这样才能顺利的实现增量升级。\n\n想要封装一套增量更新的工具，请看这篇文章：[打造Android万能的软件更新库，修改只要一点点](http://blog.csdn.net/huang_cai_yuan/article/details/52927630)\n","slug":"Android-patch-update","published":1,"date":"2016-12-19T16:00:00.000Z","updated":"2016-12-28T06:28:21.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj5v002hbxs674jtp4x9","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在前几年，整体移动网络环境相比现在差很多，加之流量费用又相对较高，因此每当我们发布新版本的时候，一些用户升级并不是很积极，这就造成了新版本的升级率并不高。而google为了解决了这个问题，提出了Smart App Update，即增量更新（也叫做差分升级）。</p>\n<p>增量更新与热修复完全不是一个东西。增量更新需要重新安装apk，而热修复不需要。热修复也能完成部分增量更新的功能。</p>\n<h3 id=\"增量更新的流程\"><a href=\"#增量更新的流程\" class=\"headerlink\" title=\"增量更新的流程\"></a>增量更新的流程</h3><p>增量更新的具体流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的，当然部分应用市场有root权限你可能感知不到）。</p>\n<a id=\"more\"></a>\n<h3 id=\"增量更新的原理\"><a href=\"#增量更新的原理\" class=\"headerlink\" title=\"增量更新的原理\"></a>增量更新的原理</h3><p>增量更新的原理也很简单，就是将手机上已安装的旧版本apk与服务器端新版本apk进行二进制对比，并得到差分包（patch），用户在升级更新应用时，只需要下载差分包，然后在本地使用差分包与旧版的apk合成新版apk，然后进行安装。差分包文件的大小，那就远比APK小得多了，这样也便于用户进行应用升级。</p>\n<p>那么增量更新的流程可以细化为几个关键点：</p>\n<ul>\n<li>1.用户手机上提取当前安装应用的apk</li>\n<li>2.如何利用old.apk和new.apk生成增量文件（差分包）</li>\n<li>3.增加文件与1.中的old.apk合并，然后安装</li>\n</ul>\n<p>旧版的APK可以在<strong>/data/app/%packagename%/</strong>下找到。</p>\n<p>也可以参考下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApkExtract</span> </span>&#123;</div><div class=\"line\">    public <span class=\"keyword\">static</span> <span class=\"built_in\">String</span> extract(Context context) &#123;</div><div class=\"line\">        context = context.getApplicationContext();</div><div class=\"line\">        ApplicationInfo applicationInfo = context.getApplicationInfo();</div><div class=\"line\">        <span class=\"built_in\">String</span> apkPath = applicationInfo.sourceDir;</div><div class=\"line\">        Log.d(<span class=\"string\">\"hongyang\"</span>, apkPath);</div><div class=\"line\">        <span class=\"keyword\">return</span> apkPath;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"关于生成差分包\"><a href=\"#关于生成差分包\" class=\"headerlink\" title=\"关于生成差分包\"></a>关于生成差分包</h4><p>制作差分包的工具为<a href=\"http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz\" target=\"_blank\" rel=\"external\">bsdiff</a>，</p>\n<p>网址：</p>\n<p><a href=\"http://www.daemonology.net/bsdiff/\" target=\"_blank\" rel=\"external\">http://www.daemonology.net/bsdiff/</a></p>\n<p>下载地址：</p>\n<p><a href=\"http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz\" target=\"_blank\" rel=\"external\">http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz</a></p>\n<p>这是一个非常牛的二进制查分工具，bsdiff源代码在Android的源码目录下 ”\\external\\bsdiff“”这边也可以找到。另外还需要依赖<a href=\"http://www.bzip.org/downloads.html\" target=\"_blank\" rel=\"external\">bzlib</a>来进行打包。在安全性方面，补丁和新旧版APK最好都要进行MD5验证，以免被篡改。</p>\n<p>关于这个工具可以使用别人编译好的so库，<a href=\"https://github.com/hongyangAndroid/BsDiff_And_Patch/tree/master/so-dist\" target=\"_blank\" rel=\"external\">这里</a>；熟悉NDK开发的也可以自己编译，<a href=\"http://blog.csdn.net/lmj623565791/article/details/52761658\" target=\"_blank\" rel=\"external\">请看这里</a>。这里就不在考虑这个工具问题了。</p>\n<ul>\n<li>生成增量文件<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">./bsdiff old.apk <span class=\"keyword\">new</span>.apk old-to-<span class=\"keyword\">new</span>.patch</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样就生成了一个增量文件old-to-new.patch</p>\n<h4 id=\"关于合并差分包\"><a href=\"#关于合并差分包\" class=\"headerlink\" title=\"关于合并差分包\"></a>关于合并差分包</h4><p>生成差分包肯定是在服务端，合并差分包才是Android客户端需要做的：</p>\n<ul>\n<li>增量文件和old.apk合并成新的apk<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">./bspatch old.apk new2.apk old-to-<span class=\"keyword\">new</span>.patch</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样就生成一个new2.apk</p>\n<p>生成后，要查看下两个文件的md5值。如果两个文件md5值一致，那么几乎可以肯定两个文件时一模一样的。</p>\n<h3 id=\"增量更新存在的不足\"><a href=\"#增量更新存在的不足\" class=\"headerlink\" title=\"增量更新存在的不足\"></a>增量更新存在的不足</h3><ul>\n<li><p>1、增量升级是以两个应用版本之间的差异来生成补丁的，但是我们无法保证用户每次的及时升级到最新，也就是在更新前，新版和旧版只差一个版本，所以必须对你所发布的每一个版本都和最新的版本作差分，以便使所有版本的用户都可以差分升级，这样相对就比较繁琐了。解决方法也有，可以通过Shell脚本来实现批量生成。</p>\n</li>\n<li><p>2.增量升级能成功的前提是，从手机端能够获得旧版APK，并且与服务端的APK签名是一样的，所以像那些破解的APP就无法实现更新。前面也提到了，为了安全性，防止补丁合成错误，最好在补丁合成前对旧版本的apk进行sha1或者MD5校验，保证基础包的一致性，这样才能顺利的实现增量升级。</p>\n</li>\n</ul>\n<p>想要封装一套增量更新的工具，请看这篇文章：<a href=\"http://blog.csdn.net/huang_cai_yuan/article/details/52927630\" target=\"_blank\" rel=\"external\">打造Android万能的软件更新库，修改只要一点点</a></p>\n","excerpt":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在前几年，整体移动网络环境相比现在差很多，加之流量费用又相对较高，因此每当我们发布新版本的时候，一些用户升级并不是很积极，这就造成了新版本的升级率并不高。而google为了解决了这个问题，提出了Smart App Update，即增量更新（也叫做差分升级）。</p>\n<p>增量更新与热修复完全不是一个东西。增量更新需要重新安装apk，而热修复不需要。热修复也能完成部分增量更新的功能。</p>\n<h3 id=\"增量更新的流程\"><a href=\"#增量更新的流程\" class=\"headerlink\" title=\"增量更新的流程\"></a>增量更新的流程</h3><p>增量更新的具体流程是：用户手机上安装着某个应用，下载了增量包，手机上的apk和增量包合并形成新的包，然后再次安装（注意这个过程是要重新安装的，当然部分应用市场有root权限你可能感知不到）。</p>","more":"<h3 id=\"增量更新的原理\"><a href=\"#增量更新的原理\" class=\"headerlink\" title=\"增量更新的原理\"></a>增量更新的原理</h3><p>增量更新的原理也很简单，就是将手机上已安装的旧版本apk与服务器端新版本apk进行二进制对比，并得到差分包（patch），用户在升级更新应用时，只需要下载差分包，然后在本地使用差分包与旧版的apk合成新版apk，然后进行安装。差分包文件的大小，那就远比APK小得多了，这样也便于用户进行应用升级。</p>\n<p>那么增量更新的流程可以细化为几个关键点：</p>\n<ul>\n<li>1.用户手机上提取当前安装应用的apk</li>\n<li>2.如何利用old.apk和new.apk生成增量文件（差分包）</li>\n<li>3.增加文件与1.中的old.apk合并，然后安装</li>\n</ul>\n<p>旧版的APK可以在<strong>/data/app/%packagename%/</strong>下找到。</p>\n<p>也可以参考下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApkExtract</span> </span>&#123;</div><div class=\"line\">    public <span class=\"keyword\">static</span> <span class=\"built_in\">String</span> extract(Context context) &#123;</div><div class=\"line\">        context = context.getApplicationContext();</div><div class=\"line\">        ApplicationInfo applicationInfo = context.getApplicationInfo();</div><div class=\"line\">        <span class=\"built_in\">String</span> apkPath = applicationInfo.sourceDir;</div><div class=\"line\">        Log.d(<span class=\"string\">\"hongyang\"</span>, apkPath);</div><div class=\"line\">        <span class=\"keyword\">return</span> apkPath;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"关于生成差分包\"><a href=\"#关于生成差分包\" class=\"headerlink\" title=\"关于生成差分包\"></a>关于生成差分包</h4><p>制作差分包的工具为<a href=\"http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz\">bsdiff</a>，</p>\n<p>网址：</p>\n<p><a href=\"http://www.daemonology.net/bsdiff/\">http://www.daemonology.net/bsdiff/</a></p>\n<p>下载地址：</p>\n<p><a href=\"http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz\">http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz</a></p>\n<p>这是一个非常牛的二进制查分工具，bsdiff源代码在Android的源码目录下 ”\\external\\bsdiff“”这边也可以找到。另外还需要依赖<a href=\"http://www.bzip.org/downloads.html\">bzlib</a>来进行打包。在安全性方面，补丁和新旧版APK最好都要进行MD5验证，以免被篡改。</p>\n<p>关于这个工具可以使用别人编译好的so库，<a href=\"https://github.com/hongyangAndroid/BsDiff_And_Patch/tree/master/so-dist\">这里</a>；熟悉NDK开发的也可以自己编译，<a href=\"http://blog.csdn.net/lmj623565791/article/details/52761658\">请看这里</a>。这里就不在考虑这个工具问题了。</p>\n<ul>\n<li>生成增量文件<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">./bsdiff old.apk <span class=\"keyword\">new</span>.apk old-to-<span class=\"keyword\">new</span>.patch</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样就生成了一个增量文件old-to-new.patch</p>\n<h4 id=\"关于合并差分包\"><a href=\"#关于合并差分包\" class=\"headerlink\" title=\"关于合并差分包\"></a>关于合并差分包</h4><p>生成差分包肯定是在服务端，合并差分包才是Android客户端需要做的：</p>\n<ul>\n<li>增量文件和old.apk合并成新的apk<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">./bspatch old.apk new2.apk old-to-<span class=\"keyword\">new</span>.patch</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样就生成一个new2.apk</p>\n<p>生成后，要查看下两个文件的md5值。如果两个文件md5值一致，那么几乎可以肯定两个文件时一模一样的。</p>\n<h3 id=\"增量更新存在的不足\"><a href=\"#增量更新存在的不足\" class=\"headerlink\" title=\"增量更新存在的不足\"></a>增量更新存在的不足</h3><ul>\n<li><p>1、增量升级是以两个应用版本之间的差异来生成补丁的，但是我们无法保证用户每次的及时升级到最新，也就是在更新前，新版和旧版只差一个版本，所以必须对你所发布的每一个版本都和最新的版本作差分，以便使所有版本的用户都可以差分升级，这样相对就比较繁琐了。解决方法也有，可以通过Shell脚本来实现批量生成。</p>\n</li>\n<li><p>2.增量升级能成功的前提是，从手机端能够获得旧版APK，并且与服务端的APK签名是一样的，所以像那些破解的APP就无法实现更新。前面也提到了，为了安全性，防止补丁合成错误，最好在补丁合成前对旧版本的apk进行sha1或者MD5校验，保证基础包的一致性，这样才能顺利的实现增量升级。</p>\n</li>\n</ul>\n<p>想要封装一套增量更新的工具，请看这篇文章：<a href=\"http://blog.csdn.net/huang_cai_yuan/article/details/52927630\">打造Android万能的软件更新库，修改只要一点点</a></p>"},{"layout":"post","title":"nodejs入门","keywords":"nodejs","banner":"http://obxk8w81b.bkt.clouddn.com/Daubigny%20s%20Garden%202.jpg","thumbnail":"http://obxk8w81b.bkt.clouddn.com/Daubigny%20s%20Garden%202.jpg","_content":"\n> 本文是我自己的学习笔记，整理自[《Node入门》](http://www.nodebeginner.org/index-zh-cn.html)\n\n## Node入门\n\n作者： Manuel Kiessling\n翻译： goddyzhao & GrayZhang & MondayChen\n\n\n本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。\n\n\n### 服务端JavaScript\n\nJavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。\n\nNode.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。\n\n<!--more-->\n\n要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。\n\n除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。\n\n因此，Node.js事实上既是一个运行时环境，同时又是一个库。\n\n要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考[官方的安装指南](https://github.com/joyent/node/wiki/Installation)。安装完成后，继续回来阅读本书下面的内容。\n\n#### “Hello World”\n\n好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。\n\n打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：\n\n~~~ JavaScript\nconsole.log(\"Hello World\");\n~~~\n保存该文件，并通过Node.js来执行：\n~~~ JavaScript\nnode helloworld.js\n~~~\n正常的话，就会在终端输出Hello World 。\n\n好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。\n\n### **一个完整的基于Node.js的web应用**\n\n### 用例\n\n我们来把目标设定得简单点，不过也要够实际才行：\n\n用户可以通过浏览器使用我们的应用。\n当用户请求http://domain/start 时，可以看到一个欢迎页面，页面上有一个文件上传的表单。\n用户可以选择一个图片并提交表单，随后文件将被上传到http://domain/upload  ，该页面完成上传后会把图片显示在页面上。\n差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。\n\n更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。\n\n### 应用不同模块分析\n\n我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？\n\n我们需要提供Web页面，因此需要一个HTTP服务器\n对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（request handler）\n当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序\n路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能\n我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器\n最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节\n我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。\n从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。\n\n不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。\n\n听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。\n\n现在我们就来开始实现之路，先从第一个部分--HTTP服务器着手。\n\n### 构建应用的模块\n\n#### 一个基础的HTTP服务器\n\n当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。\n我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？\n\n实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。\n\n这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。\n\n那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。\n\n在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。\n\n让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(8888);\n~~~\n搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：\n\n~~~ JavaScript\nnode server.js\n~~~\n接下来，打开浏览器访问http://localhost:8888/ ，你会看到一个写着“Hello World”的网页。\n\n这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。\n\n#### 分析HTTP服务器\n\n那么接下来，让我们分析一下这个HTTP服务器的构成。\n\n第一行请求（require）Node.js自带的 http 模块，并且把它赋值给 http 变量。\n\n接下来我们调用http模块提供的函数： createServer 。这个函数会返回一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。\n\n咱们暂时先不管 http.createServer 的括号里的那个函数定义。\n\n我们本来可以用这样的代码来启动服务器并侦听8888端口：\n~~~ JavaScript\nvar http = require(\"http\");\n\nvar server = http.createServer();\nserver.listen(8888);\n~~~\n这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。\n\n最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 createServer() 的第一个参数，一个函数定义。\n\n实际上，这个函数定义是 createServer() 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。\n\n#### 进行函数传递\n\n举例来说，你可以这样做：\n\n~~~ JavaScript\nfunction say(word) {\n  console.log(word);\n}\n\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\nexecute(say, \"Hello\");\n~~~\n请仔细阅读这段代码！在这里，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！\n\n这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。\n\n当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。\n\n我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：\n\n~~~ JavaScript\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\n\nexecute(function(word){ console.log(word) }, \"Hello\");\n~~~\n我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。\n\n用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 匿名函数 。\n\n这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\n\n#### 函数传递是如何让HTTP服务器工作的\n\n带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(8888);\n~~~\n现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。\n\n用这样的代码也可以达到同样的目的：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nfunction onRequest(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}\n\nhttp.createServer(onRequest).listen(8888);\n~~~\n也许现在我们该问这个问题了：我们为什么要用这种方式呢？\n\n#### 基于事件驱动的回调\n\n这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。\n\n你也许会想花点时间读一下Felix Geisendörfer的大作[Understanding node.js](http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb)，它介绍了一些背景知识。\n\n这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。\n\n当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。\n\n问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。\n\n写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。\n\n那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？\n\n嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。\n\n我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。\n\n我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。\n\n这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。\n\n至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。\n\n让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nfunction onRequest(request, response) {\n  console.log(\"Request received.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}\n\nhttp.createServer(onRequest).listen(8888);\n\nconsole.log(\"Server has started.\");\n~~~\n\n> 注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。\n\n当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问http://localhost:8888/ ），“Request received.”这条消息就会在命令行中出现。\n\n这就是事件驱动的异步服务器端JavaScript和它的回调啦！\n\n> （请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分浏览器都会在你访问 http://localhost:8888/ 时尝试读取 http://localhost:8888/favicon.ico )\n\n#### 服务器是如何处理请求的\n\n好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 onRequest() 的主体部分。\n\n当回调启动，我们的 onRequest() 函数被触发的时候，有两个参数被传入： request 和 response 。\n\n它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。\n\n所以我们的代码就是：当收到请求时，使用 response.writeHead() 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 response.write() 函数在HTTP相应主体中发送文本“Hello World\"。\n\n最后，我们调用 response.end() 完成响应。\n\n目前来说，我们对请求的细节并不在意，所以我们没有使用 request 对象。\n\n服务端的模块放在哪里\n\nOK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 server.js 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 index.js 的文件去调用应用的其他模块（比如 server.js 中的HTTP服务器模块）来引导和启动应用。\n\n我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 index.js 主文件使用。\n\n也许你已经注意到，我们已经在代码中使用了模块了。像这样：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\n...\n\nhttp.createServer(...);\n~~~\nNode.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。\n\n这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。\n\n给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：\n\n~~~ JavaScript\nvar foo = require(\"http\");\n\n...\n\nfoo.createServer(...);\n~~~\n很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？\n\n等我们把 server.js 变成一个真正的模块，你就能搞明白了。\n\n事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本。\n\n目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。\n\n我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nfunction start() {\n  function onRequest(request, response) {\n    console.log(\"Request received.\");\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。\n\n创建 index.js 文件并写入以下内容：\n\n~~~ JavaScript\nvar server = require(\"./server\");\n\nserver.start();\n~~~\n正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。\n\n好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：\n\n~~~ JavaScript\nnode index.js\n~~~\n非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。\n\n我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。\n\n对于一个非常简单的应用来说，你可以直接在回调函数 onRequest() 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。\n\n处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做**路由**的模块吧。\n\n#### 如何来进行请求的“路由”\n\n我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。\n\n因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。\n\n我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是**url**和**querystring**模块。\n\n~~~ JavaScript\n                               url.parse(string).query\n                                           |\n           url.parse(string).pathname      |\n                       |                   |\n                       |                   |\n                     ------ -------------------\nhttp://localhost:8888/start?foo=bar&hello=world\n                                ---       -----\n                                 |          |\n                                 |          |\n              querystring(string)[\"foo\"]    |\n                                            |\n                         querystring(string)[\"hello\"]\n~~~\n\n当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。\n\n现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start() {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n好了，我们的应用现在可以通过请求的URL路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。\n\n在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。\n\n现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容：\n\n~~~ JavaScript\nfunction route(pathname) {\n  console.log(\"About to route a request for \" + pathname);\n}\n\nexports.route = route;\n~~~\n如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。\n\n我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读[Martin Fowlers关于依赖注入的大作](http://martinfowler.com/articles/injection.html)来作为背景知识）。\n\n首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    route(pathname);\n\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：\n~~~ JavaScript\nvar server = require(\"./server\");\nvar router = require(\"./router\");\n\nserver.start(router.route);\n~~~\n在这里，我们传递的函数依旧什么也没做。\n\n如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：\n\n~~~ JavaScript\nbash$ node index.js\nRequest for /foo received.\nAbout to route a request for /foo\n~~~\n（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。\n\n#### 行为驱动执行\n\n请允许我再次脱离主题，在这里谈一谈函数式编程。\n\n将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。\n\n就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。\n\n    嗨那个叫路由的东西，能帮我把这个路由一下吗？\n\n但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。\n\n理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。\n\n我是在读了Steve Yegge的大作[名词王国中的死刑](http://steve-yegge.blogspot.jp/2006/03/execution-in-kingdom-of-nouns.html)之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。\n\n#### 路由给真正的请求处理程序\n\n回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。\n\n当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。\n\n在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。\n\n我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。\n\n应用程序需要新的部件，因此加入新的模块 -- 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：\n\n~~~ JavaScript\nfunction start() {\n  console.log(\"Request handler 'start' was called.\");\n}\n\nfunction upload() {\n  console.log(\"Request handler 'upload' was called.\");\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。\n\n在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。\n\n这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。\n\n那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆if request == x then call handler y也使得系统丑陋不堪。\n\n仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎**关联数组（associative array）** 能完美胜任。\n\n不过结果有点令人失望，JavaScript没提供关联数组 -- 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。\n\n在这方面，http://msdn.microsoft.com/en-us/magazine/cc163419.aspx 有一个不错的介绍，我在此摘录一段：\n\n> 在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 -- 你可以把JavaScript的对象想象成一个键为字符串类型的字典。\n\n但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！\n\n好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。\n\n我们先将这个对象引入到主文件index.js中：\n\n~~~ JavaScript\nvar server = require(\"./server\");\nvar router = require(\"./router\");\nvar requestHandlers = require(\"./requestHandlers\");\n\nvar handle = {}\nhandle[\"/\"] = requestHandlers.start;\nhandle[\"/start\"] = requestHandlers.start;\nhandle[\"/upload\"] = requestHandlers.upload;\n\nserver.start(router.route, handle);\n~~~\n虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。\n\n正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为\"/\"的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。\n\n在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    route(handle, pathname);\n\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。\n\n然后我们相应地在route.js文件中修改route()函数：\n\n~~~ JavaScript\nfunction route(handle, pathname) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    handle[pathname]();\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n  }\n}\n\nexports.route = route;\n~~~\n通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle[pathname]();的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。\n\n有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序：\n\n~~~ JavaScript\nServer has started.\nRequest for /start received.\nAbout to route a request for /start\nRequest handler 'start' was called.\n~~~\n并且在浏览器中打开http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了：\n\n~~~ JavaScript\nRequest for / received.\nAbout to route a request for /\nRequest handler 'start' was called.\n~~~\n\n#### 让请求处理程序作出响应\n\n很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。\n\n这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们server.js文件中的onRequest函数。\n\n其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。\n\n#### 不好的实现方式\n\n对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。\n\n这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。\n\n我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。\n\n让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式：\n\n~~~ JavaScript\nfunction start() {\n  console.log(\"Request handler 'start' was called.\");\n  return \"Hello Start\";\n}\n\nfunction upload() {\n  console.log(\"Request handler 'upload' was called.\");\n  return \"Hello Upload\";\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式：\n\n~~~ JavaScript\nfunction route(handle, pathname) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    return handle[pathname]();\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n    return \"404 Not found\";\n  }\n}\n\nexports.route = route;\n~~~\n正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。\n\n最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    var content = route(handle, pathname)\n    response.write(content);\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n如果我们运行重构后的应用，一切都会工作的很好：请求http://localhost:8888/start, 浏览器会输出“Hello Start”，请求http://localhost:8888/upload 会输出“Hello Upload”,而请求http://localhost:8888/foo 会输出“404 Not found”。\n\n好，那么问题在哪里呢？简单的说就是： **当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了**。\n\n没理解？没关系，下面就来详细解释下。\n\n#### 阻塞与非阻塞\n\n正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。\n\n我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。\n\n这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。\n\n让我们将requestHandlers.js修改成如下形式：\n\n~~~ JavaScript\nfunction start() {\n  console.log(\"Request handler 'start' was called.\");\n\n  function sleep(milliSeconds) {\n    var startTime = new Date().getTime();\n    while (new Date().getTime() < startTime + milliSeconds);\n  }\n\n  sleep(10000);\n  return \"Hello Start\";\n}\n\nfunction upload() {\n  console.log(\"Request handler 'upload' was called.\");\n  return \"Hello Upload\";\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。\n\n> （当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）\n\n接下来就让我们来看看，我们的改动带来了哪些变化。\n\n如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入http://localhost:8888/start， 但是先不要打开它！\n\n在第二个浏览器窗口的地址栏中输入http://localhost:8888/upload， 同样的，先不要打开它！\n\n接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。\n\n注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！\n\n这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“**它阻塞了所有其他的处理工作**”。\n\n这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。\n\n这句话的意思是说，**Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理** —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。\n\n然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。\n\n对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”\n\n（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——[理解node.js的事件轮询](http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/)。）\n\n接下来，我们会介绍一种**错误**的使用非阻塞操作的方式。\n\n和上次一样，我们通过修改我们的应用来暴露问题。\n\n这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式：\n\n~~~ JavaScript\nvar exec = require(\"child_process\").exec;\n\nfunction start() {\n  console.log(\"Request handler 'start' was called.\");\n  var content = \"empty\";\n\n  exec(\"ls -lah\", function (error, stdout, stderr) {\n    content = stdout;\n  });\n\n  return content;\n}\n\nfunction upload() {\n  console.log(\"Request handler 'upload' was called.\");\n  return \"Hello Upload\";\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n上述代码中，我们引入了一个新的Node.js模块，**child_process**。之所以用它，是为了实现一个既简单又实用的非阻塞操作：**exec()**。\n\nexec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。\n\n上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。\n\n和往常一样，我们启动服务器，然后访问“http://localhost:8888/start” 。\n\n之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？\n\n这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。\n\n> （如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。\n\n然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？\n\n好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。\n\n问题就在于，为了进行非阻塞工作，exec()使用了回调函数。\n\n在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数：\n\n~~~ JavaScript\nfunction (error, stdout, stderr) {\n  content = stdout;\n}\n~~~\n现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。\n\n我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。\n\n为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。\n\n那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？\n\n好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。\n\n#### 以非阻塞操作进行请求响应\n\n我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。\n\n不过，用Node.js就有这样一种实现方案： **函数传递**。下面就让我们来具体看看如何实现。\n\n到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -> 请求路由 -> 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。\n\n现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用**将服务器“传递”给内容**的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。\n\n原理就是如此，接下来让我们来一步步实现这种方案。\n\n先从server.js开始：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    route(handle, pathname, response);\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。\n\n下面就来看看我们的router.js:\n\n~~~ JavaScript\nfunction route(handle, pathname, response) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    handle[pathname](response);\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n    response.writeHead(404, {\"Content-Type\": \"text/plain\"});\n    response.write(\"404 Not found\");\n    response.end();\n  }\n}\n\nexports.route = route;\n~~~\n同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。\n\n如果没有对应的请求处理器处理，我们就直接返回“404”错误。\n\n最后，我们将requestHandler.js修改为如下形式：\n\n~~~ JavaScript\nvar exec = require(\"child_process\").exec;\n\nfunction start(response) {\n  console.log(\"Request handler 'start' was called.\");\n\n  exec(\"ls -lah\", function (error, stdout, stderr) {\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(stdout);\n    response.end();\n  });\n}\n\nfunction upload(response) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello Upload\");\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。\n\nstart处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。\n\n这时再次我们启动应用（node index.js），一切都会工作的很好。\n\n如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式：\n\n~~~ JavaScript\nvar exec = require(\"child_process\").exec;\n\nfunction start(response) {\n  console.log(\"Request handler 'start' was called.\");\n\n  exec(\"find /\",\n    { timeout: 10000, maxBuffer: 20000*1024 },\n    function (error, stdout, stderr) {\n      response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n      response.write(stdout);\n      response.end();\n    });\n}\n\nfunction upload(response) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello Upload\");\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n这样一来，当请求http://localhost:8888/start 的时候，会花10秒钟的时间才载入，而当请求http://localhost:8888/upload 的时候，会立即响应，纵然这个时候/start响应还在处理中。\n\n#### 更有用的场景\n\n到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。\n\n服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。\n\n好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。\n\n要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。\n\n第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。\n第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。\n\n#### 处理POST请求\n\n考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。\n\n/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：\n\n~~~ JavaScript\nfunction start(response) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" content=\"text/html; '+\n    'charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" method=\"post\">'+\n    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+\n    '<input type=\"submit\" value=\"Submit text\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello Upload\");\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问http://localhost:8888/start 就可以看到简单的表单了，要记得重启服务器哦！\n\n你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。\n\n余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。\n\n现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。\n\n这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。\n\n为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有**data事件（表示新的小数据块到达了）**以及**end事件（表示所有的数据都已经接收完毕）**。\n\n我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上**注册监听器（listener）** 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。\n\n如下所示：\n\n~~~ JavaScript\nrequest.addListener(\"data\", function(chunk) {\n  // called when a new chunk of data was received\n});\n\nrequest.addListener(\"end\", function() {\n  // called when all chunks of data have been received\n});\n~~~\n问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。\n\n在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。\n\n因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。\n\n还等什么，马上来实现。先从server.js开始：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var postData = \"\";\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    request.setEncoding(\"utf8\");\n\n    request.addListener(\"data\", function(postDataChunk) {\n      postData += postDataChunk;\n      console.log(\"Received POST data chunk '\"+\n      postDataChunk + \"'.\");\n    });\n\n    request.addListener(\"end\", function() {\n      route(handle, pathname, response, postData);\n    });\n\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会**当所有数据接收完毕后才触发，并且只触发一次**。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。\n\n上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。\n\n我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。\n\n再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：\n\n~~~ JavaScript\nfunction route(handle, pathname, response, postData) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    handle[pathname](response, postData);\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n    response.writeHead(404, {\"Content-Type\": \"text/plain\"});\n    response.write(\"404 Not found\");\n    response.end();\n  }\n}\n\nexports.route = route;\n~~~\n然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：\n\n~~~ JavaScript\nfunction start(response, postData) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" content=\"text/html; '+\n    'charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" method=\"post\">'+\n    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+\n    '<input type=\"submit\" value=\"Submit text\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, postData) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"You've sent: \" + postData);\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。\n\n我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。\n\n我们可以使用此前介绍过的querystring模块来实现：\n\n~~~ JavaScript\nvar querystring = require(\"querystring\");\n\nfunction start(response, postData) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" content=\"text/html; '+\n    'charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" method=\"post\">'+\n    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+\n    '<input type=\"submit\" value=\"Submit text\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, postData) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"You've sent the text: \"+\n  querystring.parse(postData).text);\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n好了，以上就是关于处理POST数据的全部内容。\n\n#### 处理文件上传\n\n最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。\n\n回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。\n\n这里我们要用到的外部模块是Felix Geisendörfer开发的**node-formidable模块**。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。\n\n使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：\n\n~~~ JavaScript\nnpm install formidable\n~~~\n如果终端输出如下内容：\n\n~~~ JavaScript\nnpm info build Success: formidable@1.0.9\nnpm ok\n~~~\n就说明模块已经安装成功了。\n\n现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可：\n\n~~~ JavaScript\nvar formidable = require(\"formidable\");\n~~~\n这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。\n\nnode-formidable官方的例子展示了这两部分是如何融合在一起工作的：\n\n~~~ JavaScript\nvar formidable = require('formidable'),\n    http = require('http'),\n    util = require('util');\n\nhttp.createServer(function(req, res) {\n  if (req.url == '/upload' && req.method.toLowerCase() == 'post') {\n    // parse a file upload\n    var form = new formidable.IncomingForm();\n    form.parse(req, function(err, fields, files) {\n      res.writeHead(200, {'content-type': 'text/plain'});\n      res.write('received upload:\\n\\n');\n      res.end(util.inspect({fields: fields, files: files}));\n    });\n    return;\n  }\n\n  // show a file upload form\n  res.writeHead(200, {'content-type': 'text/html'});\n  res.end(\n    '<form action=\"/upload\" enctype=\"multipart/form-data\" '+\n    'method=\"post\">'+\n    '<input type=\"text\" name=\"title\"><br>'+\n    '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n    '<input type=\"submit\" value=\"Upload\">'+\n    '</form>'\n  );\n}).listen(8888);\n~~~\n如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示：\n\n~~~ JavaScript\nreceived upload:\n\n{ fields: { title: 'Hello World' },\n  files:\n   { upload:\n      { size: 1558,\n        path: '/tmp/1c747974a27a6292743669e91f29350b',\n        name: 'us-flag.png',\n        type: 'image/png',\n        lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,\n        _writeStream: [Object],\n        length: [Getter],\n        filename: [Getter],\n        mime: [Getter] } } }\n~~~\n为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。\n\n我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？\n\n显然，我们需要将该文件读取到我们的服务器中，使用一个叫**fs**的模块。\n\n我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。\n\n将requestHandlers.js修改为如下形式：\n\n~~~ JavaScript\nvar querystring = require(\"querystring\"),\n    fs = require(\"fs\");\n\nfunction start(response, postData) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" '+\n    'content=\"text/html; charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" method=\"post\">'+\n    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+\n    '<input type=\"submit\" value=\"Submit text\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, postData) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"You've sent the text: \"+\n  querystring.parse(postData).text);\n  response.end();\n}\n\nfunction show(response, postData) {\n  console.log(\"Request handler 'show' was called.\");\n  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {\n    if(error) {\n      response.writeHead(500, {\"Content-Type\": \"text/plain\"});\n      response.write(error + \"\\n\");\n      response.end();\n    } else {\n      response.writeHead(200, {\"Content-Type\": \"image/png\"});\n      response.write(file, \"binary\");\n      response.end();\n    }\n  });\n}\n\nexports.start = start;\nexports.upload = upload;\nexports.show = show;\n~~~\n我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中：\n\n~~~ JavaScript\nvar server = require(\"./server\");\nvar router = require(\"./router\");\nvar requestHandlers = require(\"./requestHandlers\");\n\nvar handle = {}\nhandle[\"/\"] = requestHandlers.start;\nhandle[\"/start\"] = requestHandlers.start;\nhandle[\"/upload\"] = requestHandlers.upload;\nhandle[\"/show\"] = requestHandlers.show;\n\nserver.start(router.route, handle);\n~~~\n重启服务器之后，通过访问http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。\n\n好，最后我们要的就是：\n\n- 在/start表单中添加一个文件上传元素\n- 将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png\n- 将上传的图片内嵌到/uploadURL输出的HTML中\n\n第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示：\n\n~~~ JavaScript\nvar querystring = require(\"querystring\"),\n    fs = require(\"fs\");\n\nfunction start(response, postData) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" '+\n    'content=\"text/html; charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" enctype=\"multipart/form-data\" '+\n    'method=\"post\">'+\n    '<input type=\"file\" name=\"upload\">'+\n    '<input type=\"submit\" value=\"Upload file\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, postData) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"You've sent the text: \"+\n  querystring.parse(postData).text);\n  response.end();\n}\n\nfunction show(response, postData) {\n  console.log(\"Request handler 'show' was called.\");\n  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {\n    if(error) {\n      response.writeHead(500, {\"Content-Type\": \"text/plain\"});\n      response.write(error + \"\\n\");\n      response.end();\n    } else {\n      response.writeHead(200, {\"Content-Type\": \"image/png\"});\n      response.write(file, \"binary\");\n      response.end();\n    }\n  });\n}\n\nexports.start = start;\nexports.upload = upload;\nexports.show = show;\n~~~\n很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。\n\n但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。\n\n到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）\n\n我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n    route(handle, pathname, response, request);\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：\n\n~~~ JavaScript\nfunction route(handle, pathname, response, request) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    handle[pathname](response, request);\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n    response.writeHead(404, {\"Content-Type\": \"text/html\"});\n    response.write(\"404 Not found\");\n    response.end();\n  }\n}\n\nexports.route = route;\n~~~\n现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。\n\n这里采用**fs.renameSync(path1,path2)来实现**。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。\n\n接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：\n\n~~~ JavaScript\nvar querystring = require(\"querystring\"),\n    fs = require(\"fs\"),\n    formidable = require(\"formidable\");\n\nfunction start(response) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" content=\"text/html; '+\n    'charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" enctype=\"multipart/form-data\" '+\n    'method=\"post\">'+\n    '<input type=\"file\" name=\"upload\" multiple=\"multiple\">'+\n    '<input type=\"submit\" value=\"Upload file\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, request) {\n  console.log(\"Request handler 'upload' was called.\");\n\n  var form = new formidable.IncomingForm();\n  console.log(\"about to parse\");\n  form.parse(request, function(error, fields, files) {\n    console.log(\"parsing done\");\n    fs.renameSync(files.upload.path, \"/tmp/test.png\");\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(\"received image:<br/>\");\n    response.write(\"<img src='/show' />\");\n    response.end();\n  });\n}\n\nfunction show(response) {\n  console.log(\"Request handler 'show' was called.\");\n  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {\n    if(error) {\n      response.writeHead(500, {\"Content-Type\": \"text/plain\"});\n      response.write(error + \"\\n\");\n      response.end();\n    } else {\n      response.writeHead(200, {\"Content-Type\": \"image/png\"});\n      response.write(file, \"binary\");\n      response.end();\n    }\n  });\n}\n\nexports.start = start;\nexports.upload = upload;\nexports.show = show;\n~~~\n好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。\n\n### 总结与展望\n\n恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。\n\n当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。\n\n但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。\n","source":"_posts/2016-12-03-nodejs-learning-getting-started.md","raw":"---\nlayout: post\ntitle:  nodejs入门\ncategory: read\ntags: nodejs\nkeywords: nodejs\nbanner: http://obxk8w81b.bkt.clouddn.com/Daubigny%20s%20Garden%202.jpg\nthumbnail: http://obxk8w81b.bkt.clouddn.com/Daubigny%20s%20Garden%202.jpg\n---\n\n> 本文是我自己的学习笔记，整理自[《Node入门》](http://www.nodebeginner.org/index-zh-cn.html)\n\n## Node入门\n\n作者： Manuel Kiessling\n翻译： goddyzhao & GrayZhang & MondayChen\n\n\n本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。\n\n\n### 服务端JavaScript\n\nJavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。\n\nNode.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。\n\n<!--more-->\n\n要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。\n\n除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。\n\n因此，Node.js事实上既是一个运行时环境，同时又是一个库。\n\n要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考[官方的安装指南](https://github.com/joyent/node/wiki/Installation)。安装完成后，继续回来阅读本书下面的内容。\n\n#### “Hello World”\n\n好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。\n\n打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：\n\n~~~ JavaScript\nconsole.log(\"Hello World\");\n~~~\n保存该文件，并通过Node.js来执行：\n~~~ JavaScript\nnode helloworld.js\n~~~\n正常的话，就会在终端输出Hello World 。\n\n好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。\n\n### **一个完整的基于Node.js的web应用**\n\n### 用例\n\n我们来把目标设定得简单点，不过也要够实际才行：\n\n用户可以通过浏览器使用我们的应用。\n当用户请求http://domain/start 时，可以看到一个欢迎页面，页面上有一个文件上传的表单。\n用户可以选择一个图片并提交表单，随后文件将被上传到http://domain/upload  ，该页面完成上传后会把图片显示在页面上。\n差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。\n\n更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。\n\n### 应用不同模块分析\n\n我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？\n\n我们需要提供Web页面，因此需要一个HTTP服务器\n对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（request handler）\n当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序\n路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能\n我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器\n最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节\n我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。\n从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。\n\n不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。\n\n听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。\n\n现在我们就来开始实现之路，先从第一个部分--HTTP服务器着手。\n\n### 构建应用的模块\n\n#### 一个基础的HTTP服务器\n\n当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。\n我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？\n\n实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。\n\n这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。\n\n那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。\n\n在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。\n\n让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(8888);\n~~~\n搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：\n\n~~~ JavaScript\nnode server.js\n~~~\n接下来，打开浏览器访问http://localhost:8888/ ，你会看到一个写着“Hello World”的网页。\n\n这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。\n\n#### 分析HTTP服务器\n\n那么接下来，让我们分析一下这个HTTP服务器的构成。\n\n第一行请求（require）Node.js自带的 http 模块，并且把它赋值给 http 变量。\n\n接下来我们调用http模块提供的函数： createServer 。这个函数会返回一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。\n\n咱们暂时先不管 http.createServer 的括号里的那个函数定义。\n\n我们本来可以用这样的代码来启动服务器并侦听8888端口：\n~~~ JavaScript\nvar http = require(\"http\");\n\nvar server = http.createServer();\nserver.listen(8888);\n~~~\n这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。\n\n最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 createServer() 的第一个参数，一个函数定义。\n\n实际上，这个函数定义是 createServer() 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。\n\n#### 进行函数传递\n\n举例来说，你可以这样做：\n\n~~~ JavaScript\nfunction say(word) {\n  console.log(word);\n}\n\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\nexecute(say, \"Hello\");\n~~~\n请仔细阅读这段代码！在这里，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！\n\n这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。\n\n当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。\n\n我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：\n\n~~~ JavaScript\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\n\nexecute(function(word){ console.log(word) }, \"Hello\");\n~~~\n我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。\n\n用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 匿名函数 。\n\n这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\n\n#### 函数传递是如何让HTTP服务器工作的\n\n带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(8888);\n~~~\n现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。\n\n用这样的代码也可以达到同样的目的：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nfunction onRequest(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}\n\nhttp.createServer(onRequest).listen(8888);\n~~~\n也许现在我们该问这个问题了：我们为什么要用这种方式呢？\n\n#### 基于事件驱动的回调\n\n这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。\n\n你也许会想花点时间读一下Felix Geisendörfer的大作[Understanding node.js](http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb)，它介绍了一些背景知识。\n\n这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。\n\n当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。\n\n问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。\n\n写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。\n\n那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？\n\n嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。\n\n我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。\n\n我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。\n\n这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。\n\n至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。\n\n让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nfunction onRequest(request, response) {\n  console.log(\"Request received.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}\n\nhttp.createServer(onRequest).listen(8888);\n\nconsole.log(\"Server has started.\");\n~~~\n\n> 注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。\n\n当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问http://localhost:8888/ ），“Request received.”这条消息就会在命令行中出现。\n\n这就是事件驱动的异步服务器端JavaScript和它的回调啦！\n\n> （请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分浏览器都会在你访问 http://localhost:8888/ 时尝试读取 http://localhost:8888/favicon.ico )\n\n#### 服务器是如何处理请求的\n\n好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 onRequest() 的主体部分。\n\n当回调启动，我们的 onRequest() 函数被触发的时候，有两个参数被传入： request 和 response 。\n\n它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。\n\n所以我们的代码就是：当收到请求时，使用 response.writeHead() 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 response.write() 函数在HTTP相应主体中发送文本“Hello World\"。\n\n最后，我们调用 response.end() 完成响应。\n\n目前来说，我们对请求的细节并不在意，所以我们没有使用 request 对象。\n\n服务端的模块放在哪里\n\nOK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 server.js 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 index.js 的文件去调用应用的其他模块（比如 server.js 中的HTTP服务器模块）来引导和启动应用。\n\n我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 index.js 主文件使用。\n\n也许你已经注意到，我们已经在代码中使用了模块了。像这样：\n\n~~~ JavaScript\nvar http = require(\"http\");\n\n...\n\nhttp.createServer(...);\n~~~\nNode.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。\n\n这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。\n\n给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：\n\n~~~ JavaScript\nvar foo = require(\"http\");\n\n...\n\nfoo.createServer(...);\n~~~\n很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？\n\n等我们把 server.js 变成一个真正的模块，你就能搞明白了。\n\n事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本。\n\n目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。\n\n我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。\n\n~~~ JavaScript\nvar http = require(\"http\");\n\nfunction start() {\n  function onRequest(request, response) {\n    console.log(\"Request received.\");\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。\n\n创建 index.js 文件并写入以下内容：\n\n~~~ JavaScript\nvar server = require(\"./server\");\n\nserver.start();\n~~~\n正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。\n\n好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：\n\n~~~ JavaScript\nnode index.js\n~~~\n非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。\n\n我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。\n\n对于一个非常简单的应用来说，你可以直接在回调函数 onRequest() 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。\n\n处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做**路由**的模块吧。\n\n#### 如何来进行请求的“路由”\n\n我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。\n\n因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。\n\n我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是**url**和**querystring**模块。\n\n~~~ JavaScript\n                               url.parse(string).query\n                                           |\n           url.parse(string).pathname      |\n                       |                   |\n                       |                   |\n                     ------ -------------------\nhttp://localhost:8888/start?foo=bar&hello=world\n                                ---       -----\n                                 |          |\n                                 |          |\n              querystring(string)[\"foo\"]    |\n                                            |\n                         querystring(string)[\"hello\"]\n~~~\n\n当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。\n\n现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start() {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n好了，我们的应用现在可以通过请求的URL路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。\n\n在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。\n\n现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容：\n\n~~~ JavaScript\nfunction route(pathname) {\n  console.log(\"About to route a request for \" + pathname);\n}\n\nexports.route = route;\n~~~\n如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。\n\n我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读[Martin Fowlers关于依赖注入的大作](http://martinfowler.com/articles/injection.html)来作为背景知识）。\n\n首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    route(pathname);\n\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：\n~~~ JavaScript\nvar server = require(\"./server\");\nvar router = require(\"./router\");\n\nserver.start(router.route);\n~~~\n在这里，我们传递的函数依旧什么也没做。\n\n如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：\n\n~~~ JavaScript\nbash$ node index.js\nRequest for /foo received.\nAbout to route a request for /foo\n~~~\n（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。\n\n#### 行为驱动执行\n\n请允许我再次脱离主题，在这里谈一谈函数式编程。\n\n将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。\n\n就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。\n\n    嗨那个叫路由的东西，能帮我把这个路由一下吗？\n\n但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。\n\n理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。\n\n我是在读了Steve Yegge的大作[名词王国中的死刑](http://steve-yegge.blogspot.jp/2006/03/execution-in-kingdom-of-nouns.html)之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。\n\n#### 路由给真正的请求处理程序\n\n回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。\n\n当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。\n\n在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。\n\n我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。\n\n应用程序需要新的部件，因此加入新的模块 -- 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：\n\n~~~ JavaScript\nfunction start() {\n  console.log(\"Request handler 'start' was called.\");\n}\n\nfunction upload() {\n  console.log(\"Request handler 'upload' was called.\");\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。\n\n在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。\n\n这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。\n\n那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆if request == x then call handler y也使得系统丑陋不堪。\n\n仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎**关联数组（associative array）** 能完美胜任。\n\n不过结果有点令人失望，JavaScript没提供关联数组 -- 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。\n\n在这方面，http://msdn.microsoft.com/en-us/magazine/cc163419.aspx 有一个不错的介绍，我在此摘录一段：\n\n> 在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 -- 你可以把JavaScript的对象想象成一个键为字符串类型的字典。\n\n但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！\n\n好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。\n\n我们先将这个对象引入到主文件index.js中：\n\n~~~ JavaScript\nvar server = require(\"./server\");\nvar router = require(\"./router\");\nvar requestHandlers = require(\"./requestHandlers\");\n\nvar handle = {}\nhandle[\"/\"] = requestHandlers.start;\nhandle[\"/start\"] = requestHandlers.start;\nhandle[\"/upload\"] = requestHandlers.upload;\n\nserver.start(router.route, handle);\n~~~\n虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。\n\n正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为\"/\"的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。\n\n在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    route(handle, pathname);\n\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。\n\n然后我们相应地在route.js文件中修改route()函数：\n\n~~~ JavaScript\nfunction route(handle, pathname) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    handle[pathname]();\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n  }\n}\n\nexports.route = route;\n~~~\n通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle[pathname]();的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。\n\n有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序：\n\n~~~ JavaScript\nServer has started.\nRequest for /start received.\nAbout to route a request for /start\nRequest handler 'start' was called.\n~~~\n并且在浏览器中打开http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了：\n\n~~~ JavaScript\nRequest for / received.\nAbout to route a request for /\nRequest handler 'start' was called.\n~~~\n\n#### 让请求处理程序作出响应\n\n很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。\n\n这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们server.js文件中的onRequest函数。\n\n其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。\n\n#### 不好的实现方式\n\n对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。\n\n这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。\n\n我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。\n\n让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式：\n\n~~~ JavaScript\nfunction start() {\n  console.log(\"Request handler 'start' was called.\");\n  return \"Hello Start\";\n}\n\nfunction upload() {\n  console.log(\"Request handler 'upload' was called.\");\n  return \"Hello Upload\";\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式：\n\n~~~ JavaScript\nfunction route(handle, pathname) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    return handle[pathname]();\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n    return \"404 Not found\";\n  }\n}\n\nexports.route = route;\n~~~\n正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。\n\n最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    var content = route(handle, pathname)\n    response.write(content);\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n如果我们运行重构后的应用，一切都会工作的很好：请求http://localhost:8888/start, 浏览器会输出“Hello Start”，请求http://localhost:8888/upload 会输出“Hello Upload”,而请求http://localhost:8888/foo 会输出“404 Not found”。\n\n好，那么问题在哪里呢？简单的说就是： **当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了**。\n\n没理解？没关系，下面就来详细解释下。\n\n#### 阻塞与非阻塞\n\n正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。\n\n我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。\n\n这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。\n\n让我们将requestHandlers.js修改成如下形式：\n\n~~~ JavaScript\nfunction start() {\n  console.log(\"Request handler 'start' was called.\");\n\n  function sleep(milliSeconds) {\n    var startTime = new Date().getTime();\n    while (new Date().getTime() < startTime + milliSeconds);\n  }\n\n  sleep(10000);\n  return \"Hello Start\";\n}\n\nfunction upload() {\n  console.log(\"Request handler 'upload' was called.\");\n  return \"Hello Upload\";\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。\n\n> （当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）\n\n接下来就让我们来看看，我们的改动带来了哪些变化。\n\n如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入http://localhost:8888/start， 但是先不要打开它！\n\n在第二个浏览器窗口的地址栏中输入http://localhost:8888/upload， 同样的，先不要打开它！\n\n接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。\n\n注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！\n\n这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“**它阻塞了所有其他的处理工作**”。\n\n这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。\n\n这句话的意思是说，**Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理** —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。\n\n然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。\n\n对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”\n\n（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——[理解node.js的事件轮询](http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/)。）\n\n接下来，我们会介绍一种**错误**的使用非阻塞操作的方式。\n\n和上次一样，我们通过修改我们的应用来暴露问题。\n\n这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式：\n\n~~~ JavaScript\nvar exec = require(\"child_process\").exec;\n\nfunction start() {\n  console.log(\"Request handler 'start' was called.\");\n  var content = \"empty\";\n\n  exec(\"ls -lah\", function (error, stdout, stderr) {\n    content = stdout;\n  });\n\n  return content;\n}\n\nfunction upload() {\n  console.log(\"Request handler 'upload' was called.\");\n  return \"Hello Upload\";\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n上述代码中，我们引入了一个新的Node.js模块，**child_process**。之所以用它，是为了实现一个既简单又实用的非阻塞操作：**exec()**。\n\nexec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。\n\n上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。\n\n和往常一样，我们启动服务器，然后访问“http://localhost:8888/start” 。\n\n之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？\n\n这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。\n\n> （如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。\n\n然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？\n\n好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。\n\n问题就在于，为了进行非阻塞工作，exec()使用了回调函数。\n\n在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数：\n\n~~~ JavaScript\nfunction (error, stdout, stderr) {\n  content = stdout;\n}\n~~~\n现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。\n\n我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。\n\n为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。\n\n那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？\n\n好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。\n\n#### 以非阻塞操作进行请求响应\n\n我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。\n\n不过，用Node.js就有这样一种实现方案： **函数传递**。下面就让我们来具体看看如何实现。\n\n到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -> 请求路由 -> 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。\n\n现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用**将服务器“传递”给内容**的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。\n\n原理就是如此，接下来让我们来一步步实现这种方案。\n\n先从server.js开始：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    route(handle, pathname, response);\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。\n\n下面就来看看我们的router.js:\n\n~~~ JavaScript\nfunction route(handle, pathname, response) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    handle[pathname](response);\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n    response.writeHead(404, {\"Content-Type\": \"text/plain\"});\n    response.write(\"404 Not found\");\n    response.end();\n  }\n}\n\nexports.route = route;\n~~~\n同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。\n\n如果没有对应的请求处理器处理，我们就直接返回“404”错误。\n\n最后，我们将requestHandler.js修改为如下形式：\n\n~~~ JavaScript\nvar exec = require(\"child_process\").exec;\n\nfunction start(response) {\n  console.log(\"Request handler 'start' was called.\");\n\n  exec(\"ls -lah\", function (error, stdout, stderr) {\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(stdout);\n    response.end();\n  });\n}\n\nfunction upload(response) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello Upload\");\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。\n\nstart处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。\n\n这时再次我们启动应用（node index.js），一切都会工作的很好。\n\n如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式：\n\n~~~ JavaScript\nvar exec = require(\"child_process\").exec;\n\nfunction start(response) {\n  console.log(\"Request handler 'start' was called.\");\n\n  exec(\"find /\",\n    { timeout: 10000, maxBuffer: 20000*1024 },\n    function (error, stdout, stderr) {\n      response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n      response.write(stdout);\n      response.end();\n    });\n}\n\nfunction upload(response) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello Upload\");\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n这样一来，当请求http://localhost:8888/start 的时候，会花10秒钟的时间才载入，而当请求http://localhost:8888/upload 的时候，会立即响应，纵然这个时候/start响应还在处理中。\n\n#### 更有用的场景\n\n到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。\n\n服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。\n\n好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。\n\n要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。\n\n第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。\n第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。\n\n#### 处理POST请求\n\n考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。\n\n/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：\n\n~~~ JavaScript\nfunction start(response) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" content=\"text/html; '+\n    'charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" method=\"post\">'+\n    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+\n    '<input type=\"submit\" value=\"Submit text\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello Upload\");\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问http://localhost:8888/start 就可以看到简单的表单了，要记得重启服务器哦！\n\n你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。\n\n余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。\n\n现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。\n\n这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。\n\n为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有**data事件（表示新的小数据块到达了）**以及**end事件（表示所有的数据都已经接收完毕）**。\n\n我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上**注册监听器（listener）** 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。\n\n如下所示：\n\n~~~ JavaScript\nrequest.addListener(\"data\", function(chunk) {\n  // called when a new chunk of data was received\n});\n\nrequest.addListener(\"end\", function() {\n  // called when all chunks of data have been received\n});\n~~~\n问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。\n\n在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。\n\n因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。\n\n还等什么，马上来实现。先从server.js开始：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var postData = \"\";\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    request.setEncoding(\"utf8\");\n\n    request.addListener(\"data\", function(postDataChunk) {\n      postData += postDataChunk;\n      console.log(\"Received POST data chunk '\"+\n      postDataChunk + \"'.\");\n    });\n\n    request.addListener(\"end\", function() {\n      route(handle, pathname, response, postData);\n    });\n\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会**当所有数据接收完毕后才触发，并且只触发一次**。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。\n\n上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。\n\n我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。\n\n再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：\n\n~~~ JavaScript\nfunction route(handle, pathname, response, postData) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    handle[pathname](response, postData);\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n    response.writeHead(404, {\"Content-Type\": \"text/plain\"});\n    response.write(\"404 Not found\");\n    response.end();\n  }\n}\n\nexports.route = route;\n~~~\n然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：\n\n~~~ JavaScript\nfunction start(response, postData) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" content=\"text/html; '+\n    'charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" method=\"post\">'+\n    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+\n    '<input type=\"submit\" value=\"Submit text\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, postData) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"You've sent: \" + postData);\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。\n\n我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。\n\n我们可以使用此前介绍过的querystring模块来实现：\n\n~~~ JavaScript\nvar querystring = require(\"querystring\");\n\nfunction start(response, postData) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" content=\"text/html; '+\n    'charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" method=\"post\">'+\n    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+\n    '<input type=\"submit\" value=\"Submit text\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, postData) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"You've sent the text: \"+\n  querystring.parse(postData).text);\n  response.end();\n}\n\nexports.start = start;\nexports.upload = upload;\n~~~\n好了，以上就是关于处理POST数据的全部内容。\n\n#### 处理文件上传\n\n最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。\n\n回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。\n\n这里我们要用到的外部模块是Felix Geisendörfer开发的**node-formidable模块**。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。\n\n使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：\n\n~~~ JavaScript\nnpm install formidable\n~~~\n如果终端输出如下内容：\n\n~~~ JavaScript\nnpm info build Success: formidable@1.0.9\nnpm ok\n~~~\n就说明模块已经安装成功了。\n\n现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可：\n\n~~~ JavaScript\nvar formidable = require(\"formidable\");\n~~~\n这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。\n\nnode-formidable官方的例子展示了这两部分是如何融合在一起工作的：\n\n~~~ JavaScript\nvar formidable = require('formidable'),\n    http = require('http'),\n    util = require('util');\n\nhttp.createServer(function(req, res) {\n  if (req.url == '/upload' && req.method.toLowerCase() == 'post') {\n    // parse a file upload\n    var form = new formidable.IncomingForm();\n    form.parse(req, function(err, fields, files) {\n      res.writeHead(200, {'content-type': 'text/plain'});\n      res.write('received upload:\\n\\n');\n      res.end(util.inspect({fields: fields, files: files}));\n    });\n    return;\n  }\n\n  // show a file upload form\n  res.writeHead(200, {'content-type': 'text/html'});\n  res.end(\n    '<form action=\"/upload\" enctype=\"multipart/form-data\" '+\n    'method=\"post\">'+\n    '<input type=\"text\" name=\"title\"><br>'+\n    '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n    '<input type=\"submit\" value=\"Upload\">'+\n    '</form>'\n  );\n}).listen(8888);\n~~~\n如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示：\n\n~~~ JavaScript\nreceived upload:\n\n{ fields: { title: 'Hello World' },\n  files:\n   { upload:\n      { size: 1558,\n        path: '/tmp/1c747974a27a6292743669e91f29350b',\n        name: 'us-flag.png',\n        type: 'image/png',\n        lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,\n        _writeStream: [Object],\n        length: [Getter],\n        filename: [Getter],\n        mime: [Getter] } } }\n~~~\n为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。\n\n我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？\n\n显然，我们需要将该文件读取到我们的服务器中，使用一个叫**fs**的模块。\n\n我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。\n\n将requestHandlers.js修改为如下形式：\n\n~~~ JavaScript\nvar querystring = require(\"querystring\"),\n    fs = require(\"fs\");\n\nfunction start(response, postData) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" '+\n    'content=\"text/html; charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" method=\"post\">'+\n    '<textarea name=\"text\" rows=\"20\" cols=\"60\"></textarea>'+\n    '<input type=\"submit\" value=\"Submit text\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, postData) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"You've sent the text: \"+\n  querystring.parse(postData).text);\n  response.end();\n}\n\nfunction show(response, postData) {\n  console.log(\"Request handler 'show' was called.\");\n  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {\n    if(error) {\n      response.writeHead(500, {\"Content-Type\": \"text/plain\"});\n      response.write(error + \"\\n\");\n      response.end();\n    } else {\n      response.writeHead(200, {\"Content-Type\": \"image/png\"});\n      response.write(file, \"binary\");\n      response.end();\n    }\n  });\n}\n\nexports.start = start;\nexports.upload = upload;\nexports.show = show;\n~~~\n我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中：\n\n~~~ JavaScript\nvar server = require(\"./server\");\nvar router = require(\"./router\");\nvar requestHandlers = require(\"./requestHandlers\");\n\nvar handle = {}\nhandle[\"/\"] = requestHandlers.start;\nhandle[\"/start\"] = requestHandlers.start;\nhandle[\"/upload\"] = requestHandlers.upload;\nhandle[\"/show\"] = requestHandlers.show;\n\nserver.start(router.route, handle);\n~~~\n重启服务器之后，通过访问http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。\n\n好，最后我们要的就是：\n\n- 在/start表单中添加一个文件上传元素\n- 将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png\n- 将上传的图片内嵌到/uploadURL输出的HTML中\n\n第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示：\n\n~~~ JavaScript\nvar querystring = require(\"querystring\"),\n    fs = require(\"fs\");\n\nfunction start(response, postData) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" '+\n    'content=\"text/html; charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" enctype=\"multipart/form-data\" '+\n    'method=\"post\">'+\n    '<input type=\"file\" name=\"upload\">'+\n    '<input type=\"submit\" value=\"Upload file\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, postData) {\n  console.log(\"Request handler 'upload' was called.\");\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"You've sent the text: \"+\n  querystring.parse(postData).text);\n  response.end();\n}\n\nfunction show(response, postData) {\n  console.log(\"Request handler 'show' was called.\");\n  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {\n    if(error) {\n      response.writeHead(500, {\"Content-Type\": \"text/plain\"});\n      response.write(error + \"\\n\");\n      response.end();\n    } else {\n      response.writeHead(200, {\"Content-Type\": \"image/png\"});\n      response.write(file, \"binary\");\n      response.end();\n    }\n  });\n}\n\nexports.start = start;\nexports.upload = upload;\nexports.show = show;\n~~~\n很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。\n\n但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。\n\n到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）\n\n我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：\n\n~~~ JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route, handle) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n    route(handle, pathname, response, request);\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n~~~\n接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：\n\n~~~ JavaScript\nfunction route(handle, pathname, response, request) {\n  console.log(\"About to route a request for \" + pathname);\n  if (typeof handle[pathname] === 'function') {\n    handle[pathname](response, request);\n  } else {\n    console.log(\"No request handler found for \" + pathname);\n    response.writeHead(404, {\"Content-Type\": \"text/html\"});\n    response.write(\"404 Not found\");\n    response.end();\n  }\n}\n\nexports.route = route;\n~~~\n现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。\n\n这里采用**fs.renameSync(path1,path2)来实现**。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。\n\n接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：\n\n~~~ JavaScript\nvar querystring = require(\"querystring\"),\n    fs = require(\"fs\"),\n    formidable = require(\"formidable\");\n\nfunction start(response) {\n  console.log(\"Request handler 'start' was called.\");\n\n  var body = '<html>'+\n    '<head>'+\n    '<meta http-equiv=\"Content-Type\" content=\"text/html; '+\n    'charset=UTF-8\" />'+\n    '</head>'+\n    '<body>'+\n    '<form action=\"/upload\" enctype=\"multipart/form-data\" '+\n    'method=\"post\">'+\n    '<input type=\"file\" name=\"upload\" multiple=\"multiple\">'+\n    '<input type=\"submit\" value=\"Upload file\" />'+\n    '</form>'+\n    '</body>'+\n    '</html>';\n\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(body);\n    response.end();\n}\n\nfunction upload(response, request) {\n  console.log(\"Request handler 'upload' was called.\");\n\n  var form = new formidable.IncomingForm();\n  console.log(\"about to parse\");\n  form.parse(request, function(error, fields, files) {\n    console.log(\"parsing done\");\n    fs.renameSync(files.upload.path, \"/tmp/test.png\");\n    response.writeHead(200, {\"Content-Type\": \"text/html\"});\n    response.write(\"received image:<br/>\");\n    response.write(\"<img src='/show' />\");\n    response.end();\n  });\n}\n\nfunction show(response) {\n  console.log(\"Request handler 'show' was called.\");\n  fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file) {\n    if(error) {\n      response.writeHead(500, {\"Content-Type\": \"text/plain\"});\n      response.write(error + \"\\n\");\n      response.end();\n    } else {\n      response.writeHead(200, {\"Content-Type\": \"image/png\"});\n      response.write(file, \"binary\");\n      response.end();\n    }\n  });\n}\n\nexports.start = start;\nexports.upload = upload;\nexports.show = show;\n~~~\n好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。\n\n### 总结与展望\n\n恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。\n\n当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。\n\n但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。\n","slug":"nodejs-learning-getting-started","published":1,"date":"2016-12-02T16:00:00.000Z","updated":"2016-12-28T03:07:22.000Z","comments":1,"photos":[],"link":"","_id":"cix8kaj6k0032bxs6byemy14u","content":"<blockquote>\n<p>本文是我自己的学习笔记，整理自<a href=\"http://www.nodebeginner.org/index-zh-cn.html\" target=\"_blank\" rel=\"external\">《Node入门》</a></p>\n</blockquote>\n<h2 id=\"Node入门\"><a href=\"#Node入门\" class=\"headerlink\" title=\"Node入门\"></a>Node入门</h2><p>作者： Manuel Kiessling<br>翻译： goddyzhao &amp; GrayZhang &amp; MondayChen</p>\n<p>本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。</p>\n<h3 id=\"服务端JavaScript\"><a href=\"#服务端JavaScript\" class=\"headerlink\" title=\"服务端JavaScript\"></a>服务端JavaScript</h3><p>JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。</p>\n<p>Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。</p>\n<a id=\"more\"></a>\n<p>要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。</p>\n<p>除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。</p>\n<p>因此，Node.js事实上既是一个运行时环境，同时又是一个库。</p>\n<p>要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考<a href=\"https://github.com/joyent/node/wiki/Installation\" target=\"_blank\" rel=\"external\">官方的安装指南</a>。安装完成后，继续回来阅读本书下面的内容。</p>\n<h4 id=\"“Hello-World”\"><a href=\"#“Hello-World”\" class=\"headerlink\" title=\"“Hello World”\"></a>“Hello World”</h4><p>好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。</p>\n<p>打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello World\"</span>);</div></pre></td></tr></table></figure>\n<p>保存该文件，并通过Node.js来执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">node helloworld.js</div></pre></td></tr></table></figure></p>\n<p>正常的话，就会在终端输出Hello World 。</p>\n<p>好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。</p>\n<h3 id=\"一个完整的基于Node-js的web应用\"><a href=\"#一个完整的基于Node-js的web应用\" class=\"headerlink\" title=\"一个完整的基于Node.js的web应用\"></a><strong>一个完整的基于Node.js的web应用</strong></h3><h3 id=\"用例\"><a href=\"#用例\" class=\"headerlink\" title=\"用例\"></a>用例</h3><p>我们来把目标设定得简单点，不过也要够实际才行：</p>\n<p>用户可以通过浏览器使用我们的应用。<br>当用户请求<a href=\"http://domain/start\" target=\"_blank\" rel=\"external\">http://domain/start</a> 时，可以看到一个欢迎页面，页面上有一个文件上传的表单。<br>用户可以选择一个图片并提交表单，随后文件将被上传到<a href=\"http://domain/upload\" target=\"_blank\" rel=\"external\">http://domain/upload</a>  ，该页面完成上传后会把图片显示在页面上。<br>差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。</p>\n<p>更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。</p>\n<h3 id=\"应用不同模块分析\"><a href=\"#应用不同模块分析\" class=\"headerlink\" title=\"应用不同模块分析\"></a>应用不同模块分析</h3><p>我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？</p>\n<p>我们需要提供Web页面，因此需要一个HTTP服务器<br>对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（request handler）<br>当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序<br>路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能<br>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器<br>最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节<br>我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。<br>从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。</p>\n<p>不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。</p>\n<p>听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。</p>\n<p>现在我们就来开始实现之路，先从第一个部分–HTTP服务器着手。</p>\n<h3 id=\"构建应用的模块\"><a href=\"#构建应用的模块\" class=\"headerlink\" title=\"构建应用的模块\"></a>构建应用的模块</h3><h4 id=\"一个基础的HTTP服务器\"><a href=\"#一个基础的HTTP服务器\" class=\"headerlink\" title=\"一个基础的HTTP服务器\"></a>一个基础的HTTP服务器</h4><p>当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。<br>我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？</p>\n<p>实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。</p>\n<p>这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。</p>\n<p>那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。</p>\n<p>在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。</p>\n<p>让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure>\n<p>搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">node server.js</div></pre></td></tr></table></figure>\n<p>接下来，打开浏览器访问<a href=\"http://localhost:8888/\" target=\"_blank\" rel=\"external\">http://localhost:8888/</a> ，你会看到一个写着“Hello World”的网页。</p>\n<p>这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。</p>\n<h4 id=\"分析HTTP服务器\"><a href=\"#分析HTTP服务器\" class=\"headerlink\" title=\"分析HTTP服务器\"></a>分析HTTP服务器</h4><p>那么接下来，让我们分析一下这个HTTP服务器的构成。</p>\n<p>第一行请求（require）Node.js自带的 http 模块，并且把它赋值给 http 变量。</p>\n<p>接下来我们调用http模块提供的函数： createServer 。这个函数会返回一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。</p>\n<p>咱们暂时先不管 http.createServer 的括号里的那个函数定义。</p>\n<p>我们本来可以用这样的代码来启动服务器并侦听8888端口：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer();</div><div class=\"line\">server.listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure></p>\n<p>这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。</p>\n<p>最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 createServer() 的第一个参数，一个函数定义。</p>\n<p>实际上，这个函数定义是 createServer() 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。</p>\n<h4 id=\"进行函数传递\"><a href=\"#进行函数传递\" class=\"headerlink\" title=\"进行函数传递\"></a>进行函数传递</h4><p>举例来说，你可以这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\">word</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(word);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\">someFunction, value</span>) </span>&#123;</div><div class=\"line\">  someFunction(value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">execute(say, <span class=\"string\">\"Hello\"</span>);</div></pre></td></tr></table></figure>\n<p>请仔细阅读这段代码！在这里，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！</p>\n<p>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。</p>\n<p>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>\n<p>我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\">someFunction, value</span>) </span>&#123;</div><div class=\"line\">  someFunction(value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">execute(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">word</span>)</span>&#123; <span class=\"built_in\">console</span>.log(word) &#125;, <span class=\"string\">\"Hello\"</span>);</div></pre></td></tr></table></figure>\n<p>我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。</p>\n<p>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 匿名函数 。</p>\n<p>这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>\n<h4 id=\"函数传递是如何让HTTP服务器工作的\"><a href=\"#函数传递是如何让HTTP服务器工作的\" class=\"headerlink\" title=\"函数传递是如何让HTTP服务器工作的\"></a>函数传递是如何让HTTP服务器工作的</h4><p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure>\n<p>现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。</p>\n<p>用这样的代码也可以达到同样的目的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure>\n<p>也许现在我们该问这个问题了：我们为什么要用这种方式呢？</p>\n<h4 id=\"基于事件驱动的回调\"><a href=\"#基于事件驱动的回调\" class=\"headerlink\" title=\"基于事件驱动的回调\"></a>基于事件驱动的回调</h4><p>这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。</p>\n<p>你也许会想花点时间读一下Felix Geisendörfer的大作<a href=\"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb\" target=\"_blank\" rel=\"external\">Understanding node.js</a>，它介绍了一些背景知识。</p>\n<p>这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。</p>\n<p>当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。</p>\n<p>问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。</p>\n<p>写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。</p>\n<p>那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？</p>\n<p>嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。</p>\n<p>我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。</p>\n<p>我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。</p>\n<p>这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。</p>\n<p>至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。</p>\n<p>让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request received.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。</p>\n</blockquote>\n<p>当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问<a href=\"http://localhost:8888/\" target=\"_blank\" rel=\"external\">http://localhost:8888/</a> ），“Request received.”这条消息就会在命令行中出现。</p>\n<p>这就是事件驱动的异步服务器端JavaScript和它的回调啦！</p>\n<blockquote>\n<p>（请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分浏览器都会在你访问 <a href=\"http://localhost:8888/\" target=\"_blank\" rel=\"external\">http://localhost:8888/</a> 时尝试读取 <a href=\"http://localhost:8888/favicon.ico\" target=\"_blank\" rel=\"external\">http://localhost:8888/favicon.ico</a> )</p>\n</blockquote>\n<h4 id=\"服务器是如何处理请求的\"><a href=\"#服务器是如何处理请求的\" class=\"headerlink\" title=\"服务器是如何处理请求的\"></a>服务器是如何处理请求的</h4><p>好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 onRequest() 的主体部分。</p>\n<p>当回调启动，我们的 onRequest() 函数被触发的时候，有两个参数被传入： request 和 response 。</p>\n<p>它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。</p>\n<p>所以我们的代码就是：当收到请求时，使用 response.writeHead() 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 response.write() 函数在HTTP相应主体中发送文本“Hello World”。</p>\n<p>最后，我们调用 response.end() 完成响应。</p>\n<p>目前来说，我们对请求的细节并不在意，所以我们没有使用 request 对象。</p>\n<p>服务端的模块放在哪里</p>\n<p>OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 server.js 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 index.js 的文件去调用应用的其他模块（比如 server.js 中的HTTP服务器模块）来引导和启动应用。</p>\n<p>我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 index.js 主文件使用。</p>\n<p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">http.createServer(...);</div></pre></td></tr></table></figure>\n<p>Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。</p>\n<p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p>\n<p>给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">foo.createServer(...);</div></pre></td></tr></table></figure>\n<p>很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？</p>\n<p>等我们把 server.js 变成一个真正的模块，你就能搞明白了。</p>\n<p>事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本。</p>\n<p>目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。</p>\n<p>我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request received.\"</span>);</div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。</p>\n<p>创建 index.js 文件并写入以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">\"./server\"</span>);</div><div class=\"line\"></div><div class=\"line\">server.start();</div></pre></td></tr></table></figure>\n<p>正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。</p>\n<p>好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">node index.js</div></pre></td></tr></table></figure>\n<p>非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。</p>\n<p>我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。</p>\n<p>对于一个非常简单的应用来说，你可以直接在回调函数 onRequest() 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。</p>\n<p>处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做<strong>路由</strong>的模块吧。</p>\n<h4 id=\"如何来进行请求的“路由”\"><a href=\"#如何来进行请求的“路由”\" class=\"headerlink\" title=\"如何来进行请求的“路由”\"></a>如何来进行请求的“路由”</h4><p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>\n<p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>\n<p>我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是<strong>url</strong>和<strong>querystring</strong>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">                               url.parse(string).query</div><div class=\"line\">                                           |</div><div class=\"line\">           url.parse(string).pathname      |</div><div class=\"line\">                       |                   |</div><div class=\"line\">                       |                   |</div><div class=\"line\">                     ------ -------------------</div><div class=\"line\">http:<span class=\"comment\">//localhost:8888/start?foo=bar&amp;hello=world</span></div><div class=\"line\">                                ---       -----</div><div class=\"line\">                                 |          |</div><div class=\"line\">                                 |          |</div><div class=\"line\">              querystring(string)[<span class=\"string\">\"foo\"</span>]    |</div><div class=\"line\">                                            |</div><div class=\"line\">                         querystring(string)[<span class=\"string\">\"hello\"</span>]</div></pre></td></tr></table></figure>\n<p>当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。</p>\n<p>现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</p>\n<p>在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>\n<p>现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">pathname</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>\n<p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读<a href=\"http://martinfowler.com/articles/injection.html\" target=\"_blank\" rel=\"external\">Martin Fowlers关于依赖注入的大作</a>来作为背景知识）。</p>\n<p>首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    route(pathname);</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">\"./server\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">\"./router\"</span>);</div><div class=\"line\"></div><div class=\"line\">server.start(router.route);</div></pre></td></tr></table></figure></p>\n<p>在这里，我们传递的函数依旧什么也没做。</p>\n<p>如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">bash$ node index.js</div><div class=\"line\">Request <span class=\"keyword\">for</span> /foo received.</div><div class=\"line\">About to route a request <span class=\"keyword\">for</span> /foo</div></pre></td></tr></table></figure>\n<p>（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。</p>\n<h4 id=\"行为驱动执行\"><a href=\"#行为驱动执行\" class=\"headerlink\" title=\"行为驱动执行\"></a>行为驱动执行</h4><p>请允许我再次脱离主题，在这里谈一谈函数式编程。</p>\n<p>将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。</p>\n<p>就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。</p>\n<pre><code>嗨那个叫路由的东西，能帮我把这个路由一下吗？\n</code></pre><p>但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。</p>\n<p>理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。</p>\n<p>我是在读了Steve Yegge的大作<a href=\"http://steve-yegge.blogspot.jp/2006/03/execution-in-kingdom-of-nouns.html\" target=\"_blank\" rel=\"external\">名词王国中的死刑</a>之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。</p>\n<h4 id=\"路由给真正的请求处理程序\"><a href=\"#路由给真正的请求处理程序\" class=\"headerlink\" title=\"路由给真正的请求处理程序\"></a>路由给真正的请求处理程序</h4><p>回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。</p>\n<p>当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。</p>\n<p>在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。</p>\n<p>我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。</p>\n<p>应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。</p>\n<p>在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。</p>\n<p>这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。</p>\n<p>那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆if request == x then call handler y也使得系统丑陋不堪。</p>\n<p>仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎<strong>关联数组（associative array）</strong> 能完美胜任。</p>\n<p>不过结果有点令人失望，JavaScript没提供关联数组 – 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。</p>\n<p>在这方面，<a href=\"http://msdn.microsoft.com/en-us/magazine/cc163419.aspx\" target=\"_blank\" rel=\"external\">http://msdn.microsoft.com/en-us/magazine/cc163419.aspx</a> 有一个不错的介绍，我在此摘录一段：</p>\n<blockquote>\n<p>在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 – 你可以把JavaScript的对象想象成一个键为字符串类型的字典。</p>\n</blockquote>\n<p>但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！</p>\n<p>好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。</p>\n<p>我们先将这个对象引入到主文件index.js中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">\"./server\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">\"./router\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> requestHandlers = <span class=\"built_in\">require</span>(<span class=\"string\">\"./requestHandlers\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> handle = &#123;&#125;</div><div class=\"line\">handle[<span class=\"string\">\"/\"</span>] = requestHandlers.start;</div><div class=\"line\">handle[<span class=\"string\">\"/start\"</span>] = requestHandlers.start;</div><div class=\"line\">handle[<span class=\"string\">\"/upload\"</span>] = requestHandlers.upload;</div><div class=\"line\"></div><div class=\"line\">server.start(router.route, handle);</div></pre></td></tr></table></figure>\n<p>虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。</p>\n<p>正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为”/“的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。</p>\n<p>在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    route(handle, pathname);</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。</p>\n<p>然后我们相应地在route.js文件中修改route()函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    handle[pathname]();</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle<a href=\"\">pathname</a>;的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。</p>\n<p>有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问<a href=\"http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序：\" target=\"_blank\" rel=\"external\">http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序：</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">Server has started.</div><div class=\"line\">Request <span class=\"keyword\">for</span> /start received.</div><div class=\"line\">About to route a request <span class=\"keyword\">for</span> /start</div><div class=\"line\">Request handler <span class=\"string\">'start'</span> was called.</div></pre></td></tr></table></figure>\n<p>并且在浏览器中打开<a href=\"http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了：\" target=\"_blank\" rel=\"external\">http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了：</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">Request <span class=\"keyword\">for</span> / received.</div><div class=\"line\">About to route a request <span class=\"keyword\">for</span> /</div><div class=\"line\">Request handler <span class=\"string\">'start'</span> was called.</div></pre></td></tr></table></figure>\n<h4 id=\"让请求处理程序作出响应\"><a href=\"#让请求处理程序作出响应\" class=\"headerlink\" title=\"让请求处理程序作出响应\"></a>让请求处理程序作出响应</h4><p>很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。</p>\n<p>这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们server.js文件中的onRequest函数。</p>\n<p>其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。</p>\n<h4 id=\"不好的实现方式\"><a href=\"#不好的实现方式\" class=\"headerlink\" title=\"不好的实现方式\"></a>不好的实现方式</h4><p>对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。</p>\n<p>这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。</p>\n<p>我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。</p>\n<p>让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Start\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Upload\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> handle[pathname]();</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"404 Not found\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。</p>\n<p>最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    <span class=\"keyword\">var</span> content = route(handle, pathname)</div><div class=\"line\">    response.write(content);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>如果我们运行重构后的应用，一切都会工作的很好：请求<a href=\"http://localhost:8888/start\" target=\"_blank\" rel=\"external\">http://localhost:8888/start</a>, 浏览器会输出“Hello Start”，请求<a href=\"http://localhost:8888/upload\" target=\"_blank\" rel=\"external\">http://localhost:8888/upload</a> 会输出“Hello Upload”,而请求<a href=\"http://localhost:8888/foo\" target=\"_blank\" rel=\"external\">http://localhost:8888/foo</a> 会输出“404 Not found”。</p>\n<p>好，那么问题在哪里呢？简单的说就是： <strong>当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了</strong>。</p>\n<p>没理解？没关系，下面就来详细解释下。</p>\n<h4 id=\"阻塞与非阻塞\"><a href=\"#阻塞与非阻塞\" class=\"headerlink\" title=\"阻塞与非阻塞\"></a>阻塞与非阻塞</h4><p>正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。</p>\n<p>我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。</p>\n<p>这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。</p>\n<p>让我们将requestHandlers.js修改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">milliSeconds</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime() &lt; startTime + milliSeconds);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  sleep(<span class=\"number\">10000</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Start\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Upload\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。</p>\n<blockquote>\n<p>（当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）</p>\n</blockquote>\n<p>接下来就让我们来看看，我们的改动带来了哪些变化。</p>\n<p>如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href=\"http://localhost:8888/start，\" target=\"_blank\" rel=\"external\">http://localhost:8888/start，</a> 但是先不要打开它！</p>\n<p>在第二个浏览器窗口的地址栏中输入<a href=\"http://localhost:8888/upload，\" target=\"_blank\" rel=\"external\">http://localhost:8888/upload，</a> 同样的，先不要打开它！</p>\n<p>接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。</p>\n<p>注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！</p>\n<p>这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“<strong>它阻塞了所有其他的处理工作</strong>”。</p>\n<p>这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。</p>\n<p>这句话的意思是说，<strong>Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理</strong> —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。</p>\n<p>然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。</p>\n<p>对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</p>\n<p>（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——<a href=\"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\" target=\"_blank\" rel=\"external\">理解node.js的事件轮询</a>。）</p>\n<p>接下来，我们会介绍一种<strong>错误</strong>的使用非阻塞操作的方式。</p>\n<p>和上次一样，我们通过修改我们的应用来暴露问题。</p>\n<p>这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">\"child_process\"</span>).exec;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> content = <span class=\"string\">\"empty\"</span>;</div><div class=\"line\"></div><div class=\"line\">  exec(<span class=\"string\">\"ls -lah\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, stdout, stderr</span>) </span>&#123;</div><div class=\"line\">    content = stdout;</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> content;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Upload\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>上述代码中，我们引入了一个新的Node.js模块，<strong>child_process</strong>。之所以用它，是为了实现一个既简单又实用的非阻塞操作：<strong>exec()</strong>。</p>\n<p>exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。</p>\n<p>上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。</p>\n<p>和往常一样，我们启动服务器，然后访问“<a href=\"http://localhost:8888/start”\" target=\"_blank\" rel=\"external\">http://localhost:8888/start”</a> 。</p>\n<p>之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？</p>\n<p>这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。</p>\n<blockquote>\n<p>（如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。</p>\n</blockquote>\n<p>然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？</p>\n<p>好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。</p>\n<p>问题就在于，为了进行非阻塞工作，exec()使用了回调函数。</p>\n<p>在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, stdout, stderr</span>) </span>&#123;</div><div class=\"line\">  content = stdout;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。</p>\n<p>我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。</p>\n<p>为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。</p>\n<p>那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？</p>\n<p>好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。</p>\n<h4 id=\"以非阻塞操作进行请求响应\"><a href=\"#以非阻塞操作进行请求响应\" class=\"headerlink\" title=\"以非阻塞操作进行请求响应\"></a>以非阻塞操作进行请求响应</h4><p>我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。</p>\n<p>不过，用Node.js就有这样一种实现方案： <strong>函数传递</strong>。下面就让我们来具体看看如何实现。</p>\n<p>到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</p>\n<p>现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用<strong>将服务器“传递”给内容</strong>的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。</p>\n<p>原理就是如此，接下来让我们来一步步实现这种方案。</p>\n<p>先从server.js开始：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    route(handle, pathname, response);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。</p>\n<p>下面就来看看我们的router.js:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname, response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    handle[pathname](response);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">    response.writeHead(<span class=\"number\">404</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"404 Not found\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。</p>\n<p>如果没有对应的请求处理器处理，我们就直接返回“404”错误。</p>\n<p>最后，我们将requestHandler.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">\"child_process\"</span>).exec;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  exec(<span class=\"string\">\"ls -lah\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, stdout, stderr</span>) </span>&#123;</div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(stdout);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello Upload\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。</p>\n<p>start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。</p>\n<p>这时再次我们启动应用（node index.js），一切都会工作的很好。</p>\n<p>如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">\"child_process\"</span>).exec;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  exec(<span class=\"string\">\"find /\"</span>,</div><div class=\"line\">    &#123; <span class=\"attr\">timeout</span>: <span class=\"number\">10000</span>, <span class=\"attr\">maxBuffer</span>: <span class=\"number\">20000</span>*<span class=\"number\">1024</span> &#125;,</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, stdout, stderr</span>) </span>&#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">      response.write(stdout);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello Upload\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>这样一来，当请求<a href=\"http://localhost:8888/start\" target=\"_blank\" rel=\"external\">http://localhost:8888/start</a> 的时候，会花10秒钟的时间才载入，而当请求<a href=\"http://localhost:8888/upload\" target=\"_blank\" rel=\"external\">http://localhost:8888/upload</a> 的时候，会立即响应，纵然这个时候/start响应还在处理中。</p>\n<h4 id=\"更有用的场景\"><a href=\"#更有用的场景\" class=\"headerlink\" title=\"更有用的场景\"></a>更有用的场景</h4><p>到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。</p>\n<p>服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。</p>\n<p>好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。</p>\n<p>要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。</p>\n<p>第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。<br>第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。</p>\n<h4 id=\"处理POST请求\"><a href=\"#处理POST请求\" class=\"headerlink\" title=\"处理POST请求\"></a>处理POST请求</h4><p>考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。</p>\n<p>/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '</span>+</div><div class=\"line\">    <span class=\"string\">'charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Submit text\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello Upload\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问<a href=\"http://localhost:8888/start\" target=\"_blank\" rel=\"external\">http://localhost:8888/start</a> 就可以看到简单的表单了，要记得重启服务器哦！</p>\n<p>你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。</p>\n<p>余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。</p>\n<p>现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。</p>\n<p>这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。</p>\n<p>为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有<strong>data事件（表示新的小数据块到达了）</strong>以及<strong>end事件（表示所有的数据都已经接收完毕）</strong>。</p>\n<p>我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上<strong>注册监听器（listener）</strong> 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。</p>\n<p>如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">request.addListener(<span class=\"string\">\"data\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// called when a new chunk of data was received</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">request.addListener(<span class=\"string\">\"end\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// called when all chunks of data have been received</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。</p>\n<p>在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。</p>\n<p>因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。</p>\n<p>还等什么，马上来实现。先从server.js开始：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> postData = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    request.setEncoding(<span class=\"string\">\"utf8\"</span>);</div><div class=\"line\"></div><div class=\"line\">    request.addListener(<span class=\"string\">\"data\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">postDataChunk</span>) </span>&#123;</div><div class=\"line\">      postData += postDataChunk;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Received POST data chunk '\"</span>+</div><div class=\"line\">      postDataChunk + <span class=\"string\">\"'.\"</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    request.addListener(<span class=\"string\">\"end\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      route(handle, pathname, response, postData);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会<strong>当所有数据接收完毕后才触发，并且只触发一次</strong>。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。</p>\n<p>上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。</p>\n<p>我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。</p>\n<p>再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname, response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    handle[pathname](response, postData);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">    response.writeHead(<span class=\"number\">404</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"404 Not found\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '</span>+</div><div class=\"line\">    <span class=\"string\">'charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Submit text\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"You've sent: \"</span> + postData);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。</p>\n<p>我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。</p>\n<p>我们可以使用此前介绍过的querystring模块来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">\"querystring\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '</span>+</div><div class=\"line\">    <span class=\"string\">'charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Submit text\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"You've sent the text: \"</span>+</div><div class=\"line\">  querystring.parse(postData).text);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>好了，以上就是关于处理POST数据的全部内容。</p>\n<h4 id=\"处理文件上传\"><a href=\"#处理文件上传\" class=\"headerlink\" title=\"处理文件上传\"></a>处理文件上传</h4><p>最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。</p>\n<p>回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。</p>\n<p>这里我们要用到的外部模块是Felix Geisendörfer开发的<strong>node-formidable模块</strong>。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。</p>\n<p>使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm install formidable</div></pre></td></tr></table></figure>\n<p>如果终端输出如下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm info build Success: formidable@<span class=\"number\">1.0</span><span class=\"number\">.9</span></div><div class=\"line\">npm ok</div></pre></td></tr></table></figure>\n<p>就说明模块已经安装成功了。</p>\n<p>现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> formidable = <span class=\"built_in\">require</span>(<span class=\"string\">\"formidable\"</span>);</div></pre></td></tr></table></figure>\n<p>这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。</p>\n<p>node-formidable官方的例子展示了这两部分是如何融合在一起工作的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> formidable = <span class=\"built_in\">require</span>(<span class=\"string\">'formidable'</span>),</div><div class=\"line\">    http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>),</div><div class=\"line\">    util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (req.url == <span class=\"string\">'/upload'</span> &amp;&amp; req.method.toLowerCase() == <span class=\"string\">'post'</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// parse a file upload</span></div><div class=\"line\">    <span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> formidable.IncomingForm();</div><div class=\"line\">    form.parse(req, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, fields, files</span>) </span>&#123;</div><div class=\"line\">      res.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'content-type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</div><div class=\"line\">      res.write(<span class=\"string\">'received upload:\\n\\n'</span>);</div><div class=\"line\">      res.end(util.inspect(&#123;<span class=\"attr\">fields</span>: fields, <span class=\"attr\">files</span>: files&#125;));</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// show a file upload form</span></div><div class=\"line\">  res.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'content-type'</span>: <span class=\"string\">'text/html'</span>&#125;);</div><div class=\"line\">  res.end(</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '</span>+</div><div class=\"line\">    <span class=\"string\">'method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"text\" name=\"title\"&gt;&lt;br&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;&lt;br&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Upload\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure>\n<p>如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">received upload:</div><div class=\"line\"></div><div class=\"line\">&#123; <span class=\"attr\">fields</span>: &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Hello World'</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">files</span>:</div><div class=\"line\">   &#123; <span class=\"attr\">upload</span>:</div><div class=\"line\">      &#123; <span class=\"attr\">size</span>: <span class=\"number\">1558</span>,</div><div class=\"line\">        <span class=\"attr\">path</span>: <span class=\"string\">'/tmp/1c747974a27a6292743669e91f29350b'</span>,</div><div class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">'us-flag.png'</span>,</div><div class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">'image/png'</span>,</div><div class=\"line\">        <span class=\"attr\">lastModifiedDate</span>: Tue, <span class=\"number\">21</span> Jun <span class=\"number\">2011</span> <span class=\"number\">07</span>:<span class=\"number\">02</span>:<span class=\"number\">41</span> GMT,</div><div class=\"line\">        <span class=\"attr\">_writeStream</span>: [<span class=\"built_in\">Object</span>],</div><div class=\"line\">        <span class=\"attr\">length</span>: [Getter],</div><div class=\"line\">        <span class=\"attr\">filename</span>: [Getter],</div><div class=\"line\">        <span class=\"attr\">mime</span>: [Getter] &#125; &#125; &#125;</div></pre></td></tr></table></figure>\n<p>为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。</p>\n<p>我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？</p>\n<p>显然，我们需要将该文件读取到我们的服务器中，使用一个叫<strong>fs</strong>的模块。</p>\n<p>我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。</p>\n<p>将requestHandlers.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">\"querystring\"</span>),</div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" '</span>+</div><div class=\"line\">    <span class=\"string\">'content=\"text/html; charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Submit text\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"You've sent the text: \"</span>+</div><div class=\"line\">  querystring.parse(postData).text);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'show' was called.\"</span>);</div><div class=\"line\">  fs.readFile(<span class=\"string\">\"/tmp/test.png\"</span>, <span class=\"string\">\"binary\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, file</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">500</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">      response.write(error + <span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"image/png\"</span>&#125;);</div><div class=\"line\">      response.write(file, <span class=\"string\">\"binary\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div><div class=\"line\">exports.show = show;</div></pre></td></tr></table></figure>\n<p>我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">\"./server\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">\"./router\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> requestHandlers = <span class=\"built_in\">require</span>(<span class=\"string\">\"./requestHandlers\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> handle = &#123;&#125;</div><div class=\"line\">handle[<span class=\"string\">\"/\"</span>] = requestHandlers.start;</div><div class=\"line\">handle[<span class=\"string\">\"/start\"</span>] = requestHandlers.start;</div><div class=\"line\">handle[<span class=\"string\">\"/upload\"</span>] = requestHandlers.upload;</div><div class=\"line\">handle[<span class=\"string\">\"/show\"</span>] = requestHandlers.show;</div><div class=\"line\"></div><div class=\"line\">server.start(router.route, handle);</div></pre></td></tr></table></figure>\n<p>重启服务器之后，通过访问<a href=\"http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。\" target=\"_blank\" rel=\"external\">http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。</a></p>\n<p>好，最后我们要的就是：</p>\n<ul>\n<li>在/start表单中添加一个文件上传元素</li>\n<li>将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png</li>\n<li>将上传的图片内嵌到/uploadURL输出的HTML中</li>\n</ul>\n<p>第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">\"querystring\"</span>),</div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" '</span>+</div><div class=\"line\">    <span class=\"string\">'content=\"text/html; charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '</span>+</div><div class=\"line\">    <span class=\"string\">'method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"file\" name=\"upload\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Upload file\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"You've sent the text: \"</span>+</div><div class=\"line\">  querystring.parse(postData).text);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'show' was called.\"</span>);</div><div class=\"line\">  fs.readFile(<span class=\"string\">\"/tmp/test.png\"</span>, <span class=\"string\">\"binary\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, file</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">500</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">      response.write(error + <span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"image/png\"</span>&#125;);</div><div class=\"line\">      response.write(file, <span class=\"string\">\"binary\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div><div class=\"line\">exports.show = show;</div></pre></td></tr></table></figure>\n<p>很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。</p>\n<p>但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。</p>\n<p>到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）</p>\n<p>我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\">    route(handle, pathname, response, request);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname, response, request</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    handle[pathname](response, request);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">    response.writeHead(<span class=\"number\">404</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"404 Not found\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。</p>\n<p>这里采用<strong>fs.renameSync(path1,path2)来实现</strong>。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。</p>\n<p>接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">\"querystring\"</span>),</div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>),</div><div class=\"line\">    formidable = <span class=\"built_in\">require</span>(<span class=\"string\">\"formidable\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '</span>+</div><div class=\"line\">    <span class=\"string\">'charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '</span>+</div><div class=\"line\">    <span class=\"string\">'method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Upload file\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, request</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> formidable.IncomingForm();</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"about to parse\"</span>);</div><div class=\"line\">  form.parse(request, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, fields, files</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"parsing done\"</span>);</div><div class=\"line\">    fs.renameSync(files.upload.path, <span class=\"string\">\"/tmp/test.png\"</span>);</div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"received image:&lt;br/&gt;\"</span>);</div><div class=\"line\">    response.write(<span class=\"string\">\"&lt;img src='/show' /&gt;\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'show' was called.\"</span>);</div><div class=\"line\">  fs.readFile(<span class=\"string\">\"/tmp/test.png\"</span>, <span class=\"string\">\"binary\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, file</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">500</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">      response.write(error + <span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"image/png\"</span>&#125;);</div><div class=\"line\">      response.write(file, <span class=\"string\">\"binary\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div><div class=\"line\">exports.show = show;</div></pre></td></tr></table></figure>\n<p>好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。</p>\n<h3 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h3><p>恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。</p>\n<p>当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。</p>\n<p>但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。</p>\n","excerpt":"<blockquote>\n<p>本文是我自己的学习笔记，整理自<a href=\"http://www.nodebeginner.org/index-zh-cn.html\">《Node入门》</a></p>\n</blockquote>\n<h2 id=\"Node入门\"><a href=\"#Node入门\" class=\"headerlink\" title=\"Node入门\"></a>Node入门</h2><p>作者： Manuel Kiessling<br>翻译： goddyzhao &amp; GrayZhang &amp; MondayChen</p>\n<p>本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。</p>\n<h3 id=\"服务端JavaScript\"><a href=\"#服务端JavaScript\" class=\"headerlink\" title=\"服务端JavaScript\"></a>服务端JavaScript</h3><p>JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。</p>\n<p>Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。</p>","more":"<p>要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。</p>\n<p>除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。</p>\n<p>因此，Node.js事实上既是一个运行时环境，同时又是一个库。</p>\n<p>要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考<a href=\"https://github.com/joyent/node/wiki/Installation\">官方的安装指南</a>。安装完成后，继续回来阅读本书下面的内容。</p>\n<h4 id=\"“Hello-World”\"><a href=\"#“Hello-World”\" class=\"headerlink\" title=\"“Hello World”\"></a>“Hello World”</h4><p>好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。</p>\n<p>打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello World\"</span>);</div></pre></td></tr></table></figure>\n<p>保存该文件，并通过Node.js来执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">node helloworld.js</div></pre></td></tr></table></figure></p>\n<p>正常的话，就会在终端输出Hello World 。</p>\n<p>好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。</p>\n<h3 id=\"一个完整的基于Node-js的web应用\"><a href=\"#一个完整的基于Node-js的web应用\" class=\"headerlink\" title=\"一个完整的基于Node.js的web应用\"></a><strong>一个完整的基于Node.js的web应用</strong></h3><h3 id=\"用例\"><a href=\"#用例\" class=\"headerlink\" title=\"用例\"></a>用例</h3><p>我们来把目标设定得简单点，不过也要够实际才行：</p>\n<p>用户可以通过浏览器使用我们的应用。<br>当用户请求<a href=\"http://domain/start\">http://domain/start</a> 时，可以看到一个欢迎页面，页面上有一个文件上传的表单。<br>用户可以选择一个图片并提交表单，随后文件将被上传到<a href=\"http://domain/upload\">http://domain/upload</a>  ，该页面完成上传后会把图片显示在页面上。<br>差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。</p>\n<p>更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。</p>\n<h3 id=\"应用不同模块分析\"><a href=\"#应用不同模块分析\" class=\"headerlink\" title=\"应用不同模块分析\"></a>应用不同模块分析</h3><p>我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？</p>\n<p>我们需要提供Web页面，因此需要一个HTTP服务器<br>对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（request handler）<br>当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序<br>路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能<br>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器<br>最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节<br>我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。<br>从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。</p>\n<p>不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。</p>\n<p>听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。</p>\n<p>现在我们就来开始实现之路，先从第一个部分–HTTP服务器着手。</p>\n<h3 id=\"构建应用的模块\"><a href=\"#构建应用的模块\" class=\"headerlink\" title=\"构建应用的模块\"></a>构建应用的模块</h3><h4 id=\"一个基础的HTTP服务器\"><a href=\"#一个基础的HTTP服务器\" class=\"headerlink\" title=\"一个基础的HTTP服务器\"></a>一个基础的HTTP服务器</h4><p>当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。<br>我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？</p>\n<p>实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。</p>\n<p>这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。</p>\n<p>那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。</p>\n<p>在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。</p>\n<p>让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure>\n<p>搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">node server.js</div></pre></td></tr></table></figure>\n<p>接下来，打开浏览器访问<a href=\"http://localhost:8888/\">http://localhost:8888/</a> ，你会看到一个写着“Hello World”的网页。</p>\n<p>这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。</p>\n<h4 id=\"分析HTTP服务器\"><a href=\"#分析HTTP服务器\" class=\"headerlink\" title=\"分析HTTP服务器\"></a>分析HTTP服务器</h4><p>那么接下来，让我们分析一下这个HTTP服务器的构成。</p>\n<p>第一行请求（require）Node.js自带的 http 模块，并且把它赋值给 http 变量。</p>\n<p>接下来我们调用http模块提供的函数： createServer 。这个函数会返回一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。</p>\n<p>咱们暂时先不管 http.createServer 的括号里的那个函数定义。</p>\n<p>我们本来可以用这样的代码来启动服务器并侦听8888端口：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer();</div><div class=\"line\">server.listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure></p>\n<p>这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。</p>\n<p>最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 createServer() 的第一个参数，一个函数定义。</p>\n<p>实际上，这个函数定义是 createServer() 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。</p>\n<h4 id=\"进行函数传递\"><a href=\"#进行函数传递\" class=\"headerlink\" title=\"进行函数传递\"></a>进行函数传递</h4><p>举例来说，你可以这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\">word</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(word);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\">someFunction, value</span>) </span>&#123;</div><div class=\"line\">  someFunction(value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">execute(say, <span class=\"string\">\"Hello\"</span>);</div></pre></td></tr></table></figure>\n<p>请仔细阅读这段代码！在这里，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！</p>\n<p>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。</p>\n<p>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>\n<p>我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\">someFunction, value</span>) </span>&#123;</div><div class=\"line\">  someFunction(value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">execute(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">word</span>)</span>&#123; <span class=\"built_in\">console</span>.log(word) &#125;, <span class=\"string\">\"Hello\"</span>);</div></pre></td></tr></table></figure>\n<p>我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。</p>\n<p>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 匿名函数 。</p>\n<p>这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>\n<h4 id=\"函数传递是如何让HTTP服务器工作的\"><a href=\"#函数传递是如何让HTTP服务器工作的\" class=\"headerlink\" title=\"函数传递是如何让HTTP服务器工作的\"></a>函数传递是如何让HTTP服务器工作的</h4><p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure>\n<p>现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。</p>\n<p>用这样的代码也可以达到同样的目的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure>\n<p>也许现在我们该问这个问题了：我们为什么要用这种方式呢？</p>\n<h4 id=\"基于事件驱动的回调\"><a href=\"#基于事件驱动的回调\" class=\"headerlink\" title=\"基于事件驱动的回调\"></a>基于事件驱动的回调</h4><p>这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。</p>\n<p>你也许会想花点时间读一下Felix Geisendörfer的大作<a href=\"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb\">Understanding node.js</a>，它介绍了一些背景知识。</p>\n<p>这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。</p>\n<p>当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。</p>\n<p>问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。</p>\n<p>写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。</p>\n<p>那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？</p>\n<p>嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。</p>\n<p>我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。</p>\n<p>我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。</p>\n<p>这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。</p>\n<p>至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。</p>\n<p>让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request received.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。</p>\n</blockquote>\n<p>当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问<a href=\"http://localhost:8888/\">http://localhost:8888/</a> ），“Request received.”这条消息就会在命令行中出现。</p>\n<p>这就是事件驱动的异步服务器端JavaScript和它的回调啦！</p>\n<blockquote>\n<p>（请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分浏览器都会在你访问 <a href=\"http://localhost:8888/\">http://localhost:8888/</a> 时尝试读取 <a href=\"http://localhost:8888/favicon.ico\">http://localhost:8888/favicon.ico</a> )</p>\n</blockquote>\n<h4 id=\"服务器是如何处理请求的\"><a href=\"#服务器是如何处理请求的\" class=\"headerlink\" title=\"服务器是如何处理请求的\"></a>服务器是如何处理请求的</h4><p>好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 onRequest() 的主体部分。</p>\n<p>当回调启动，我们的 onRequest() 函数被触发的时候，有两个参数被传入： request 和 response 。</p>\n<p>它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。</p>\n<p>所以我们的代码就是：当收到请求时，使用 response.writeHead() 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 response.write() 函数在HTTP相应主体中发送文本“Hello World”。</p>\n<p>最后，我们调用 response.end() 完成响应。</p>\n<p>目前来说，我们对请求的细节并不在意，所以我们没有使用 request 对象。</p>\n<p>服务端的模块放在哪里</p>\n<p>OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 server.js 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 index.js 的文件去调用应用的其他模块（比如 server.js 中的HTTP服务器模块）来引导和启动应用。</p>\n<p>我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 index.js 主文件使用。</p>\n<p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">http.createServer(...);</div></pre></td></tr></table></figure>\n<p>Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。</p>\n<p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p>\n<p>给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">foo.createServer(...);</div></pre></td></tr></table></figure>\n<p>很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？</p>\n<p>等我们把 server.js 变成一个真正的模块，你就能搞明白了。</p>\n<p>事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本。</p>\n<p>目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。</p>\n<p>我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request received.\"</span>);</div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。</p>\n<p>创建 index.js 文件并写入以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">\"./server\"</span>);</div><div class=\"line\"></div><div class=\"line\">server.start();</div></pre></td></tr></table></figure>\n<p>正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。</p>\n<p>好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">node index.js</div></pre></td></tr></table></figure>\n<p>非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。</p>\n<p>我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。</p>\n<p>对于一个非常简单的应用来说，你可以直接在回调函数 onRequest() 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。</p>\n<p>处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做<strong>路由</strong>的模块吧。</p>\n<h4 id=\"如何来进行请求的“路由”\"><a href=\"#如何来进行请求的“路由”\" class=\"headerlink\" title=\"如何来进行请求的“路由”\"></a>如何来进行请求的“路由”</h4><p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>\n<p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>\n<p>我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是<strong>url</strong>和<strong>querystring</strong>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">                               url.parse(string).query</div><div class=\"line\">                                           |</div><div class=\"line\">           url.parse(string).pathname      |</div><div class=\"line\">                       |                   |</div><div class=\"line\">                       |                   |</div><div class=\"line\">                     ------ -------------------</div><div class=\"line\">http:<span class=\"comment\">//localhost:8888/start?foo=bar&amp;hello=world</span></div><div class=\"line\">                                ---       -----</div><div class=\"line\">                                 |          |</div><div class=\"line\">                                 |          |</div><div class=\"line\">              querystring(string)[<span class=\"string\">\"foo\"</span>]    |</div><div class=\"line\">                                            |</div><div class=\"line\">                         querystring(string)[<span class=\"string\">\"hello\"</span>]</div></pre></td></tr></table></figure>\n<p>当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。</p>\n<p>现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。</p>\n<p>在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>\n<p>现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">pathname</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>\n<p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读<a href=\"http://martinfowler.com/articles/injection.html\">Martin Fowlers关于依赖注入的大作</a>来作为背景知识）。</p>\n<p>首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    route(pathname);</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">\"./server\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">\"./router\"</span>);</div><div class=\"line\"></div><div class=\"line\">server.start(router.route);</div></pre></td></tr></table></figure></p>\n<p>在这里，我们传递的函数依旧什么也没做。</p>\n<p>如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">bash$ node index.js</div><div class=\"line\">Request <span class=\"keyword\">for</span> /foo received.</div><div class=\"line\">About to route a request <span class=\"keyword\">for</span> /foo</div></pre></td></tr></table></figure>\n<p>（以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。</p>\n<h4 id=\"行为驱动执行\"><a href=\"#行为驱动执行\" class=\"headerlink\" title=\"行为驱动执行\"></a>行为驱动执行</h4><p>请允许我再次脱离主题，在这里谈一谈函数式编程。</p>\n<p>将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。</p>\n<p>就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。</p>\n<pre><code>嗨那个叫路由的东西，能帮我把这个路由一下吗？\n</code></pre><p>但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。</p>\n<p>理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。</p>\n<p>我是在读了Steve Yegge的大作<a href=\"http://steve-yegge.blogspot.jp/2006/03/execution-in-kingdom-of-nouns.html\">名词王国中的死刑</a>之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。</p>\n<h4 id=\"路由给真正的请求处理程序\"><a href=\"#路由给真正的请求处理程序\" class=\"headerlink\" title=\"路由给真正的请求处理程序\"></a>路由给真正的请求处理程序</h4><p>回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。</p>\n<p>当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。</p>\n<p>在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。</p>\n<p>我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。</p>\n<p>应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。</p>\n<p>在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。</p>\n<p>这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。</p>\n<p>那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆if request == x then call handler y也使得系统丑陋不堪。</p>\n<p>仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎<strong>关联数组（associative array）</strong> 能完美胜任。</p>\n<p>不过结果有点令人失望，JavaScript没提供关联数组 – 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。</p>\n<p>在这方面，<a href=\"http://msdn.microsoft.com/en-us/magazine/cc163419.aspx\">http://msdn.microsoft.com/en-us/magazine/cc163419.aspx</a> 有一个不错的介绍，我在此摘录一段：</p>\n<blockquote>\n<p>在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 – 你可以把JavaScript的对象想象成一个键为字符串类型的字典。</p>\n</blockquote>\n<p>但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！</p>\n<p>好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。</p>\n<p>我们先将这个对象引入到主文件index.js中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">\"./server\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">\"./router\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> requestHandlers = <span class=\"built_in\">require</span>(<span class=\"string\">\"./requestHandlers\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> handle = &#123;&#125;</div><div class=\"line\">handle[<span class=\"string\">\"/\"</span>] = requestHandlers.start;</div><div class=\"line\">handle[<span class=\"string\">\"/start\"</span>] = requestHandlers.start;</div><div class=\"line\">handle[<span class=\"string\">\"/upload\"</span>] = requestHandlers.upload;</div><div class=\"line\"></div><div class=\"line\">server.start(router.route, handle);</div></pre></td></tr></table></figure>\n<p>虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。</p>\n<p>正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为”/“的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。</p>\n<p>在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    route(handle, pathname);</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"Hello World\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。</p>\n<p>然后我们相应地在route.js文件中修改route()函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    handle[pathname]();</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle<a href=\"\">pathname</a>;的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。</p>\n<p>有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问<a href=\"http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序：\">http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序：</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">Server has started.</div><div class=\"line\">Request <span class=\"keyword\">for</span> /start received.</div><div class=\"line\">About to route a request <span class=\"keyword\">for</span> /start</div><div class=\"line\">Request handler <span class=\"string\">'start'</span> was called.</div></pre></td></tr></table></figure>\n<p>并且在浏览器中打开<a href=\"http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了：\">http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了：</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">Request <span class=\"keyword\">for</span> / received.</div><div class=\"line\">About to route a request <span class=\"keyword\">for</span> /</div><div class=\"line\">Request handler <span class=\"string\">'start'</span> was called.</div></pre></td></tr></table></figure>\n<h4 id=\"让请求处理程序作出响应\"><a href=\"#让请求处理程序作出响应\" class=\"headerlink\" title=\"让请求处理程序作出响应\"></a>让请求处理程序作出响应</h4><p>很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。</p>\n<p>这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们server.js文件中的onRequest函数。</p>\n<p>其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。</p>\n<h4 id=\"不好的实现方式\"><a href=\"#不好的实现方式\" class=\"headerlink\" title=\"不好的实现方式\"></a>不好的实现方式</h4><p>对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。</p>\n<p>这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。</p>\n<p>我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。</p>\n<p>让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Start\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Upload\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> handle[pathname]();</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"404 Not found\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。</p>\n<p>最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    <span class=\"keyword\">var</span> content = route(handle, pathname)</div><div class=\"line\">    response.write(content);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>如果我们运行重构后的应用，一切都会工作的很好：请求<a href=\"http://localhost:8888/start\">http://localhost:8888/start</a>, 浏览器会输出“Hello Start”，请求<a href=\"http://localhost:8888/upload\">http://localhost:8888/upload</a> 会输出“Hello Upload”,而请求<a href=\"http://localhost:8888/foo\">http://localhost:8888/foo</a> 会输出“404 Not found”。</p>\n<p>好，那么问题在哪里呢？简单的说就是： <strong>当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了</strong>。</p>\n<p>没理解？没关系，下面就来详细解释下。</p>\n<h4 id=\"阻塞与非阻塞\"><a href=\"#阻塞与非阻塞\" class=\"headerlink\" title=\"阻塞与非阻塞\"></a>阻塞与非阻塞</h4><p>正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。</p>\n<p>我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。</p>\n<p>这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。</p>\n<p>让我们将requestHandlers.js修改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">milliSeconds</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime() &lt; startTime + milliSeconds);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  sleep(<span class=\"number\">10000</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Start\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Upload\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。</p>\n<blockquote>\n<p>（当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）</p>\n</blockquote>\n<p>接下来就让我们来看看，我们的改动带来了哪些变化。</p>\n<p>如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href=\"http://localhost:8888/start，\">http://localhost:8888/start，</a> 但是先不要打开它！</p>\n<p>在第二个浏览器窗口的地址栏中输入<a href=\"http://localhost:8888/upload，\">http://localhost:8888/upload，</a> 同样的，先不要打开它！</p>\n<p>接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。</p>\n<p>注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！</p>\n<p>这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“<strong>它阻塞了所有其他的处理工作</strong>”。</p>\n<p>这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。</p>\n<p>这句话的意思是说，<strong>Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理</strong> —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。</p>\n<p>然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。</p>\n<p>对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</p>\n<p>（如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——<a href=\"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\">理解node.js的事件轮询</a>。）</p>\n<p>接下来，我们会介绍一种<strong>错误</strong>的使用非阻塞操作的方式。</p>\n<p>和上次一样，我们通过修改我们的应用来暴露问题。</p>\n<p>这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">\"child_process\"</span>).exec;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> content = <span class=\"string\">\"empty\"</span>;</div><div class=\"line\"></div><div class=\"line\">  exec(<span class=\"string\">\"ls -lah\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, stdout, stderr</span>) </span>&#123;</div><div class=\"line\">    content = stdout;</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> content;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Upload\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>上述代码中，我们引入了一个新的Node.js模块，<strong>child_process</strong>。之所以用它，是为了实现一个既简单又实用的非阻塞操作：<strong>exec()</strong>。</p>\n<p>exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。</p>\n<p>上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。</p>\n<p>和往常一样，我们启动服务器，然后访问“<a href=\"http://localhost:8888/start”\">http://localhost:8888/start”</a> 。</p>\n<p>之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？</p>\n<p>这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。</p>\n<blockquote>\n<p>（如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。</p>\n</blockquote>\n<p>然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？</p>\n<p>好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。</p>\n<p>问题就在于，为了进行非阻塞工作，exec()使用了回调函数。</p>\n<p>在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, stdout, stderr</span>) </span>&#123;</div><div class=\"line\">  content = stdout;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。</p>\n<p>我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。</p>\n<p>为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。</p>\n<p>那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？</p>\n<p>好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。</p>\n<h4 id=\"以非阻塞操作进行请求响应\"><a href=\"#以非阻塞操作进行请求响应\" class=\"headerlink\" title=\"以非阻塞操作进行请求响应\"></a>以非阻塞操作进行请求响应</h4><p>我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。</p>\n<p>不过，用Node.js就有这样一种实现方案： <strong>函数传递</strong>。下面就让我们来具体看看如何实现。</p>\n<p>到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</p>\n<p>现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用<strong>将服务器“传递”给内容</strong>的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。</p>\n<p>原理就是如此，接下来让我们来一步步实现这种方案。</p>\n<p>先从server.js开始：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    route(handle, pathname, response);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。</p>\n<p>下面就来看看我们的router.js:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname, response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    handle[pathname](response);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">    response.writeHead(<span class=\"number\">404</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"404 Not found\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。</p>\n<p>如果没有对应的请求处理器处理，我们就直接返回“404”错误。</p>\n<p>最后，我们将requestHandler.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">\"child_process\"</span>).exec;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  exec(<span class=\"string\">\"ls -lah\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, stdout, stderr</span>) </span>&#123;</div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(stdout);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello Upload\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。</p>\n<p>start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。</p>\n<p>这时再次我们启动应用（node index.js），一切都会工作的很好。</p>\n<p>如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">\"child_process\"</span>).exec;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  exec(<span class=\"string\">\"find /\"</span>,</div><div class=\"line\">    &#123; <span class=\"attr\">timeout</span>: <span class=\"number\">10000</span>, <span class=\"attr\">maxBuffer</span>: <span class=\"number\">20000</span>*<span class=\"number\">1024</span> &#125;,</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, stdout, stderr</span>) </span>&#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">      response.write(stdout);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello Upload\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>这样一来，当请求<a href=\"http://localhost:8888/start\">http://localhost:8888/start</a> 的时候，会花10秒钟的时间才载入，而当请求<a href=\"http://localhost:8888/upload\">http://localhost:8888/upload</a> 的时候，会立即响应，纵然这个时候/start响应还在处理中。</p>\n<h4 id=\"更有用的场景\"><a href=\"#更有用的场景\" class=\"headerlink\" title=\"更有用的场景\"></a>更有用的场景</h4><p>到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。</p>\n<p>服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。</p>\n<p>好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。</p>\n<p>要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。</p>\n<p>第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。<br>第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。</p>\n<h4 id=\"处理POST请求\"><a href=\"#处理POST请求\" class=\"headerlink\" title=\"处理POST请求\"></a>处理POST请求</h4><p>考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。</p>\n<p>/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '</span>+</div><div class=\"line\">    <span class=\"string\">'charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Submit text\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"Hello Upload\"</span>);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问<a href=\"http://localhost:8888/start\">http://localhost:8888/start</a> 就可以看到简单的表单了，要记得重启服务器哦！</p>\n<p>你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。</p>\n<p>余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。</p>\n<p>现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。</p>\n<p>这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。</p>\n<p>为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有<strong>data事件（表示新的小数据块到达了）</strong>以及<strong>end事件（表示所有的数据都已经接收完毕）</strong>。</p>\n<p>我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上<strong>注册监听器（listener）</strong> 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。</p>\n<p>如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">request.addListener(<span class=\"string\">\"data\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// called when a new chunk of data was received</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">request.addListener(<span class=\"string\">\"end\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// called when all chunks of data have been received</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。</p>\n<p>在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。</p>\n<p>因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。</p>\n<p>还等什么，马上来实现。先从server.js开始：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> postData = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\"></div><div class=\"line\">    request.setEncoding(<span class=\"string\">\"utf8\"</span>);</div><div class=\"line\"></div><div class=\"line\">    request.addListener(<span class=\"string\">\"data\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">postDataChunk</span>) </span>&#123;</div><div class=\"line\">      postData += postDataChunk;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Received POST data chunk '\"</span>+</div><div class=\"line\">      postDataChunk + <span class=\"string\">\"'.\"</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    request.addListener(<span class=\"string\">\"end\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      route(handle, pathname, response, postData);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会<strong>当所有数据接收完毕后才触发，并且只触发一次</strong>。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。</p>\n<p>上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。</p>\n<p>我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。</p>\n<p>再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname, response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    handle[pathname](response, postData);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">    response.writeHead(<span class=\"number\">404</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"404 Not found\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '</span>+</div><div class=\"line\">    <span class=\"string\">'charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Submit text\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"You've sent: \"</span> + postData);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。</p>\n<p>我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。</p>\n<p>我们可以使用此前介绍过的querystring模块来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">\"querystring\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '</span>+</div><div class=\"line\">    <span class=\"string\">'charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Submit text\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"You've sent the text: \"</span>+</div><div class=\"line\">  querystring.parse(postData).text);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div></pre></td></tr></table></figure>\n<p>好了，以上就是关于处理POST数据的全部内容。</p>\n<h4 id=\"处理文件上传\"><a href=\"#处理文件上传\" class=\"headerlink\" title=\"处理文件上传\"></a>处理文件上传</h4><p>最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。</p>\n<p>回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。</p>\n<p>这里我们要用到的外部模块是Felix Geisendörfer开发的<strong>node-formidable模块</strong>。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。</p>\n<p>使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm install formidable</div></pre></td></tr></table></figure>\n<p>如果终端输出如下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm info build Success: formidable@<span class=\"number\">1.0</span><span class=\"number\">.9</span></div><div class=\"line\">npm ok</div></pre></td></tr></table></figure>\n<p>就说明模块已经安装成功了。</p>\n<p>现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> formidable = <span class=\"built_in\">require</span>(<span class=\"string\">\"formidable\"</span>);</div></pre></td></tr></table></figure>\n<p>这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。</p>\n<p>node-formidable官方的例子展示了这两部分是如何融合在一起工作的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> formidable = <span class=\"built_in\">require</span>(<span class=\"string\">'formidable'</span>),</div><div class=\"line\">    http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>),</div><div class=\"line\">    util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (req.url == <span class=\"string\">'/upload'</span> &amp;&amp; req.method.toLowerCase() == <span class=\"string\">'post'</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// parse a file upload</span></div><div class=\"line\">    <span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> formidable.IncomingForm();</div><div class=\"line\">    form.parse(req, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, fields, files</span>) </span>&#123;</div><div class=\"line\">      res.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'content-type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</div><div class=\"line\">      res.write(<span class=\"string\">'received upload:\\n\\n'</span>);</div><div class=\"line\">      res.end(util.inspect(&#123;<span class=\"attr\">fields</span>: fields, <span class=\"attr\">files</span>: files&#125;));</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// show a file upload form</span></div><div class=\"line\">  res.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'content-type'</span>: <span class=\"string\">'text/html'</span>&#125;);</div><div class=\"line\">  res.end(</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '</span>+</div><div class=\"line\">    <span class=\"string\">'method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"text\" name=\"title\"&gt;&lt;br&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;&lt;br&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Upload\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</div></pre></td></tr></table></figure>\n<p>如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">received upload:</div><div class=\"line\"></div><div class=\"line\">&#123; <span class=\"attr\">fields</span>: &#123; <span class=\"attr\">title</span>: <span class=\"string\">'Hello World'</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">files</span>:</div><div class=\"line\">   &#123; <span class=\"attr\">upload</span>:</div><div class=\"line\">      &#123; <span class=\"attr\">size</span>: <span class=\"number\">1558</span>,</div><div class=\"line\">        <span class=\"attr\">path</span>: <span class=\"string\">'/tmp/1c747974a27a6292743669e91f29350b'</span>,</div><div class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">'us-flag.png'</span>,</div><div class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">'image/png'</span>,</div><div class=\"line\">        <span class=\"attr\">lastModifiedDate</span>: Tue, <span class=\"number\">21</span> Jun <span class=\"number\">2011</span> <span class=\"number\">07</span>:<span class=\"number\">02</span>:<span class=\"number\">41</span> GMT,</div><div class=\"line\">        <span class=\"attr\">_writeStream</span>: [<span class=\"built_in\">Object</span>],</div><div class=\"line\">        <span class=\"attr\">length</span>: [Getter],</div><div class=\"line\">        <span class=\"attr\">filename</span>: [Getter],</div><div class=\"line\">        <span class=\"attr\">mime</span>: [Getter] &#125; &#125; &#125;</div></pre></td></tr></table></figure>\n<p>为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。</p>\n<p>我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？</p>\n<p>显然，我们需要将该文件读取到我们的服务器中，使用一个叫<strong>fs</strong>的模块。</p>\n<p>我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。</p>\n<p>将requestHandlers.js修改为如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">\"querystring\"</span>),</div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" '</span>+</div><div class=\"line\">    <span class=\"string\">'content=\"text/html; charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;textarea name=\"text\" rows=\"20\" cols=\"60\"&gt;&lt;/textarea&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Submit text\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"You've sent the text: \"</span>+</div><div class=\"line\">  querystring.parse(postData).text);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'show' was called.\"</span>);</div><div class=\"line\">  fs.readFile(<span class=\"string\">\"/tmp/test.png\"</span>, <span class=\"string\">\"binary\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, file</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">500</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">      response.write(error + <span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"image/png\"</span>&#125;);</div><div class=\"line\">      response.write(file, <span class=\"string\">\"binary\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div><div class=\"line\">exports.show = show;</div></pre></td></tr></table></figure>\n<p>我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">\"./server\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">\"./router\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> requestHandlers = <span class=\"built_in\">require</span>(<span class=\"string\">\"./requestHandlers\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> handle = &#123;&#125;</div><div class=\"line\">handle[<span class=\"string\">\"/\"</span>] = requestHandlers.start;</div><div class=\"line\">handle[<span class=\"string\">\"/start\"</span>] = requestHandlers.start;</div><div class=\"line\">handle[<span class=\"string\">\"/upload\"</span>] = requestHandlers.upload;</div><div class=\"line\">handle[<span class=\"string\">\"/show\"</span>] = requestHandlers.show;</div><div class=\"line\"></div><div class=\"line\">server.start(router.route, handle);</div></pre></td></tr></table></figure>\n<p>重启服务器之后，通过访问<a href=\"http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。\">http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。</a></p>\n<p>好，最后我们要的就是：</p>\n<ul>\n<li>在/start表单中添加一个文件上传元素</li>\n<li>将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png</li>\n<li>将上传的图片内嵌到/uploadURL输出的HTML中</li>\n</ul>\n<p>第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">\"querystring\"</span>),</div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" '</span>+</div><div class=\"line\">    <span class=\"string\">'content=\"text/html; charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '</span>+</div><div class=\"line\">    <span class=\"string\">'method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"file\" name=\"upload\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Upload file\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\">  response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">  response.write(<span class=\"string\">\"You've sent the text: \"</span>+</div><div class=\"line\">  querystring.parse(postData).text);</div><div class=\"line\">  response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">response, postData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'show' was called.\"</span>);</div><div class=\"line\">  fs.readFile(<span class=\"string\">\"/tmp/test.png\"</span>, <span class=\"string\">\"binary\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, file</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">500</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">      response.write(error + <span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"image/png\"</span>&#125;);</div><div class=\"line\">      response.write(file, <span class=\"string\">\"binary\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div><div class=\"line\">exports.show = show;</div></pre></td></tr></table></figure>\n<p>很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。</p>\n<p>但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。</p>\n<p>到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）</p>\n<p>我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">\"http\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">route, handle</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRequest</span>(<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request for \"</span> + pathname + <span class=\"string\">\" received.\"</span>);</div><div class=\"line\">    route(handle, pathname, response, request);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  http.createServer(onRequest).listen(<span class=\"number\">8888</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server has started.\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div></pre></td></tr></table></figure>\n<p>接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">handle, pathname, response, request</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"About to route a request for \"</span> + pathname);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handle[pathname] === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    handle[pathname](response, request);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No request handler found for \"</span> + pathname);</div><div class=\"line\">    response.writeHead(<span class=\"number\">404</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"404 Not found\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.route = route;</div></pre></td></tr></table></figure>\n<p>现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。</p>\n<p>这里采用<strong>fs.renameSync(path1,path2)来实现</strong>。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。</p>\n<p>接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">\"querystring\"</span>),</div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>),</div><div class=\"line\">    formidable = <span class=\"built_in\">require</span>(<span class=\"string\">\"formidable\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'start' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">'&lt;html&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;meta http-equiv=\"Content-Type\" content=\"text/html; '</span>+</div><div class=\"line\">    <span class=\"string\">'charset=UTF-8\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/head&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '</span>+</div><div class=\"line\">    <span class=\"string\">'method=\"post\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"submit\" value=\"Upload file\" /&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/body&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/html&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(body);</div><div class=\"line\">    response.end();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">response, request</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'upload' was called.\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> formidable.IncomingForm();</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"about to parse\"</span>);</div><div class=\"line\">  form.parse(request, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, fields, files</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"parsing done\"</span>);</div><div class=\"line\">    fs.renameSync(files.upload.path, <span class=\"string\">\"/tmp/test.png\"</span>);</div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/html\"</span>&#125;);</div><div class=\"line\">    response.write(<span class=\"string\">\"received image:&lt;br/&gt;\"</span>);</div><div class=\"line\">    response.write(<span class=\"string\">\"&lt;img src='/show' /&gt;\"</span>);</div><div class=\"line\">    response.end();</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Request handler 'show' was called.\"</span>);</div><div class=\"line\">  fs.readFile(<span class=\"string\">\"/tmp/test.png\"</span>, <span class=\"string\">\"binary\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, file</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">500</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>&#125;);</div><div class=\"line\">      response.write(error + <span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"image/png\"</span>&#125;);</div><div class=\"line\">      response.write(file, <span class=\"string\">\"binary\"</span>);</div><div class=\"line\">      response.end();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.start = start;</div><div class=\"line\">exports.upload = upload;</div><div class=\"line\">exports.show = show;</div></pre></td></tr></table></figure>\n<p>好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。</p>\n<h3 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h3><p>恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。</p>\n<p>当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。</p>\n<p>但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cix8kaj3h0002bxs6dxgppuzo","category_id":"cix8kaj3w0006bxs6bzk63kra","_id":"cix8kaj4d000fbxs6rv7iogcn"},{"post_id":"cix8kaj3l0004bxs6wizadlw9","category_id":"cix8kaj48000bbxs6hw928tpv","_id":"cix8kaj4p000nbxs6w39vmen1"},{"post_id":"cix8kaj4h000kbxs6tiyvg0sh","category_id":"cix8kaj3w0006bxs6bzk63kra","_id":"cix8kaj4u000sbxs60ez6fj4x"},{"post_id":"cix8kaj410008bxs6j8x0dglc","category_id":"cix8kaj48000bbxs6hw928tpv","_id":"cix8kaj4w000xbxs62bn88n5l"},{"post_id":"cix8kaj4s000rbxs6n717ql5g","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj4y0010bxs632su8hji"},{"post_id":"cix8kaj420009bxs6au58dxam","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj500015bxs6l06gvm9f"},{"post_id":"cix8kaj4u000ubxs6w1vak2f1","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj510018bxs69m4o2tay"},{"post_id":"cix8kaj4x000zbxs6vij8wit7","category_id":"cix8kaj48000bbxs6hw928tpv","_id":"cix8kaj55001dbxs699lo4l91"},{"post_id":"cix8kaj46000abxs60x3e3xyj","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj59001gbxs6tvre9yym"},{"post_id":"cix8kaj4z0012bxs68t759qya","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5d001lbxs620nbtcon"},{"post_id":"cix8kaj500017bxs6rrenl4zl","category_id":"cix8kaj48000bbxs6hw928tpv","_id":"cix8kaj5e001obxs68i7vrkzz"},{"post_id":"cix8kaj4a000ebxs6gh4ldmv9","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5g001rbxs6mt1rdpl3"},{"post_id":"cix8kaj52001abxs625fljjiq","category_id":"cix8kaj48000bbxs6hw928tpv","_id":"cix8kaj5i001vbxs6seef4fgw"},{"post_id":"cix8kaj56001fbxs6k185lj0f","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5m001ybxs6jtlw6dus"},{"post_id":"cix8kaj4d000gbxs667ak3zb7","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5p0022bxs6flt7epd5"},{"post_id":"cix8kaj59001ibxs622pi4num","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5r0025bxs6zum4g8k5"},{"post_id":"cix8kaj5d001nbxs6s1m2yhg0","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5s0029bxs6mpbbm88a"},{"post_id":"cix8kaj4k000mbxs6ltqfvndk","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5t002cbxs6d5ppifbg"},{"post_id":"cix8kaj5f001qbxs670lmwfes","category_id":"cix8kaj48000bbxs6hw928tpv","_id":"cix8kaj5v002gbxs60wwg1ewv"},{"post_id":"cix8kaj5h001ubxs6eflf9zga","category_id":"cix8kaj48000bbxs6hw928tpv","_id":"cix8kaj5x002jbxs6dpyiyabn"},{"post_id":"cix8kaj5i001xbxs6o2vmlkf1","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5x002lbxs6kxw42o23"},{"post_id":"cix8kaj5m0021bxs6vcvynsxr","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5x002nbxs6ehk5j4pr"},{"post_id":"cix8kaj5p0024bxs6bq1p2hhc","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5y002pbxs67qbmd7rb"},{"post_id":"cix8kaj5r0027bxs66mwab3r9","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5y002rbxs6a5kr26gt"},{"post_id":"cix8kaj5s002bbxs67cl1fg4u","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5y002sbxs6a4nriy5t"},{"post_id":"cix8kaj5t002ebxs6e6v8eh9i","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5y002vbxs68givw29q"},{"post_id":"cix8kaj5v002hbxs674jtp4x9","category_id":"cix8kaj4r000obxs63x5xzzwk","_id":"cix8kaj5y002wbxs6tvofbesk"},{"post_id":"cix8kaj6k0032bxs6byemy14u","category_id":"cix8kaj3w0006bxs6bzk63kra","_id":"cix8kaj6o0034bxs6fy05zevu"}],"PostTag":[{"post_id":"cix8kaj3h0002bxs6dxgppuzo","tag_id":"cix8kaj400007bxs6fk0ka63v","_id":"cix8kaj49000dbxs6hbckheku"},{"post_id":"cix8kaj4a000ebxs6gh4ldmv9","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj4g000jbxs6wjwydzki"},{"post_id":"cix8kaj3l0004bxs6wizadlw9","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj4k000lbxs69tufnd12"},{"post_id":"cix8kaj4d000gbxs667ak3zb7","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj4s000qbxs6z48d2wpy"},{"post_id":"cix8kaj4h000kbxs6tiyvg0sh","tag_id":"cix8kaj400007bxs6fk0ka63v","_id":"cix8kaj4u000tbxs63805qsbc"},{"post_id":"cix8kaj410008bxs6j8x0dglc","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj4w000ybxs6zofonyus"},{"post_id":"cix8kaj420009bxs6au58dxam","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj4y0011bxs6vzhhozkx"},{"post_id":"cix8kaj4u000ubxs6w1vak2f1","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj500016bxs6im3ufqkx"},{"post_id":"cix8kaj46000abxs60x3e3xyj","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj510019bxs6gci1idi0"},{"post_id":"cix8kaj4z0012bxs68t759qya","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj55001ebxs6foy8qt7o"},{"post_id":"cix8kaj4k000mbxs6ltqfvndk","tag_id":"cix8kaj500013bxs6r9rdi56c","_id":"cix8kaj59001hbxs6bxb94dxw"},{"post_id":"cix8kaj56001fbxs6k185lj0f","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj5d001mbxs6kr88al9a"},{"post_id":"cix8kaj4s000rbxs6n717ql5g","tag_id":"cix8kaj500013bxs6r9rdi56c","_id":"cix8kaj5e001pbxs6fl5abyvw"},{"post_id":"cix8kaj59001ibxs622pi4num","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj5g001sbxs6y067k0me"},{"post_id":"cix8kaj4x000zbxs6vij8wit7","tag_id":"cix8kaj5c001kbxs68d9kgs78","_id":"cix8kaj5i001wbxs6iqv6sgd4"},{"post_id":"cix8kaj5f001qbxs670lmwfes","tag_id":"cix8kaj500013bxs6r9rdi56c","_id":"cix8kaj5m001zbxs6actrr0vp"},{"post_id":"cix8kaj5h001ubxs6eflf9zga","tag_id":"cix8kaj5c001kbxs68d9kgs78","_id":"cix8kaj5p0023bxs68z3c03uk"},{"post_id":"cix8kaj500017bxs6rrenl4zl","tag_id":"cix8kaj5c001kbxs68d9kgs78","_id":"cix8kaj5r0026bxs69enm3wfg"},{"post_id":"cix8kaj5i001xbxs6o2vmlkf1","tag_id":"cix8kaj49000cbxs6k4ci0min","_id":"cix8kaj5s002abxs6xevxnz38"},{"post_id":"cix8kaj52001abxs625fljjiq","tag_id":"cix8kaj5m0020bxs6zb1e83hv","_id":"cix8kaj5t002dbxs67uiyr5v4"},{"post_id":"cix8kaj5d001nbxs6s1m2yhg0","tag_id":"cix8kaj5s0028bxs61r5eba6h","_id":"cix8kaj5w002ibxs6omfpqdiz"},{"post_id":"cix8kaj5m0021bxs6vcvynsxr","tag_id":"cix8kaj5v002fbxs6rs28henp","_id":"cix8kaj5x002mbxs6lgl4x4lz"},{"post_id":"cix8kaj5p0024bxs6bq1p2hhc","tag_id":"cix8kaj5v002fbxs6rs28henp","_id":"cix8kaj5y002qbxs694ibvn7s"},{"post_id":"cix8kaj5r0027bxs66mwab3r9","tag_id":"cix8kaj5x002obxs6zwzosoyc","_id":"cix8kaj5y002ubxs68o2zvtgx"},{"post_id":"cix8kaj5s002bbxs67cl1fg4u","tag_id":"cix8kaj5x002obxs6zwzosoyc","_id":"cix8kaj5y002ybxs6bpimili4"},{"post_id":"cix8kaj5t002ebxs6e6v8eh9i","tag_id":"cix8kaj5y002xbxs6doc70set","_id":"cix8kaj5z0030bxs64ekosxev"},{"post_id":"cix8kaj5v002hbxs674jtp4x9","tag_id":"cix8kaj5y002zbxs6rm3t2bm3","_id":"cix8kaj5z0031bxs6nszur2xr"},{"post_id":"cix8kaj6k0032bxs6byemy14u","tag_id":"cix8kaj6m0033bxs606w6kut8","_id":"cix8kaj6p0035bxs6ty8fxpxu"}],"Tag":[{"name":"read","_id":"cix8kaj400007bxs6fk0ka63v"},{"name":"accumulation","_id":"cix8kaj49000cbxs6k4ci0min"},{"name":"Android JNI","_id":"cix8kaj500013bxs6r9rdi56c"},{"name":"technology","_id":"cix8kaj5c001kbxs68d9kgs78"},{"name":"RxJava","_id":"cix8kaj5m0020bxs6zb1e83hv"},{"name":"Android design pattern","_id":"cix8kaj5s0028bxs61r5eba6h"},{"name":"gradle","_id":"cix8kaj5v002fbxs6rs28henp"},{"name":"Hexo","_id":"cix8kaj5x002obxs6zwzosoyc"},{"name":"EJS","_id":"cix8kaj5y002xbxs6doc70set"},{"name":"Android Patch Update","_id":"cix8kaj5y002zbxs6rm3t2bm3"},{"name":"nodejs","_id":"cix8kaj6m0033bxs606w6kut8"}]}}